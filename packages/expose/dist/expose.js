/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/memoize */ "./node_modules/@emotion/memoize/dist/memoize.esm.js");


var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class)|(on[A-Z].*)|((data|aria|x)-.*))$/i;
var index = Object(_emotion_memoize__WEBPACK_IMPORTED_MODULE_0__["default"])(reactPropsRegex.test.bind(reactPropsRegex));

/* harmony default export */ __webpack_exports__["default"] = (index);


/***/ }),

/***/ "./node_modules/@emotion/memoize/dist/memoize.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/@emotion/memoize/dist/memoize.esm.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function memoize(fn) {
  var cache = {};
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (memoize);
//# sourceMappingURL=memoize.esm.js.map


/***/ }),

/***/ "./node_modules/@popmotion/easing/dist/easing.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/@popmotion/easing/dist/easing.es.js ***!
  \**********************************************************/
/*! exports provided: reversed, mirrored, createReversedEasing, createMirroredEasing, createExpoIn, createBackIn, createAnticipateEasing, linear, easeIn, easeOut, easeInOut, circIn, circOut, circInOut, backIn, backOut, backInOut, anticipate, cubicBezier */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reversed", function() { return reversed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mirrored", function() { return mirrored; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReversedEasing", function() { return createReversedEasing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMirroredEasing", function() { return createMirroredEasing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createExpoIn", function() { return createExpoIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBackIn", function() { return createBackIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAnticipateEasing", function() { return createAnticipateEasing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeIn", function() { return easeIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOut", function() { return easeOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeInOut", function() { return easeInOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circIn", function() { return circIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circOut", function() { return circOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circInOut", function() { return circInOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "anticipate", function() { return anticipate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicBezier", function() { return cubicBezier; });
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var reversed = function (easing) {
    return function (p) {
        return 1 - easing(1 - p);
    };
};
var mirrored = function (easing) {
    return function (p) {
        return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
    };
};
var createReversedEasing = reversed;
var createMirroredEasing = mirrored;
var createExpoIn = function (power) {
    return function (p) {
        return Math.pow(p, power);
    };
};
var createBackIn = function (power) {
    return function (p) {
        return p * p * ((power + 1) * p - power);
    };
};
var createAnticipateEasing = function (power) {
    var backEasing = createBackIn(power);
    return function (p) {
        return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
    };
};
var linear = function (p) {
    return p;
};
var easeIn = /*#__PURE__*/createExpoIn(2);
var easeOut = /*#__PURE__*/reversed(easeIn);
var easeInOut = /*#__PURE__*/mirrored(easeIn);
var circIn = function (p) {
    return 1 - Math.sin(Math.acos(p));
};
var circOut = /*#__PURE__*/reversed(circIn);
var circInOut = /*#__PURE__*/mirrored(circOut);
var backIn = /*#__PURE__*/createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = /*#__PURE__*/reversed(backIn);
var backInOut = /*#__PURE__*/mirrored(backIn);
var anticipate = /*#__PURE__*/createAnticipateEasing(DEFAULT_OVERSHOOT_STRENGTH);
var NEWTON_ITERATIONS = 8;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var K_SPLINE_TABLE_SIZE = 11;
var K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);
var FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';
var a = function (a1, a2) {
    return 1.0 - 3.0 * a2 + 3.0 * a1;
};
var b = function (a1, a2) {
    return 3.0 * a2 - 6.0 * a1;
};
var c = function (a1) {
    return 3.0 * a1;
};
var getSlope = function (t, a1, a2) {
    return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);
};
var calcBezier = function (t, a1, a2) {
    return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
};
function cubicBezier(mX1, mY1, mX2, mY2) {
    var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);
    var binarySubdivide = function (aX, aA, aB) {
        var i = 0;
        var currentX;
        var currentT;
        do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0.0) {
                aB = currentT;
            } else {
                aA = currentT;
            }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
    };
    var newtonRaphsonIterate = function (aX, aGuessT) {
        var i = 0;
        var currentSlope = 0;
        var currentX;
        for (; i < NEWTON_ITERATIONS; ++i) {
            currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0.0) {
                return aGuessT;
            }
            currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
    };
    var calcSampleValues = function () {
        for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {
            sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);
        }
    };
    var getTForX = function (aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = K_SPLINE_TABLE_SIZE - 1;
        var dist = 0.0;
        var guessForT = 0.0;
        var initialSlope = 0.0;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += K_SAMPLE_STEP_SIZE;
        }
        --currentSample;
        dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;
        initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT);
        } else if (initialSlope === 0.0) {
            return guessForT;
        } else {
            return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);
        }
    };
    calcSampleValues();
    var resolver = function (aX) {
        var returnValue;
        if (mX1 === mY1 && mX2 === mY2) {
            returnValue = aX;
        } else if (aX === 0) {
            returnValue = 0;
        } else if (aX === 1) {
            returnValue = 1;
        } else {
            returnValue = calcBezier(getTForX(aX), mY1, mY2);
        }
        return returnValue;
    };
    return resolver;
}




/***/ }),

/***/ "./node_modules/@reach/router/es/index.js":
/*!************************************************!*\
  !*** ./node_modules/@reach/router/es/index.js ***!
  \************************************************/
/*! exports provided: Link, Location, LocationProvider, Match, Redirect, Router, ServerLocation, createHistory, createMemorySource, isRedirect, navigate, redirectTo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return Link; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Location", function() { return Location; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocationProvider", function() { return LocationProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Match", function() { return Match; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Redirect", function() { return Redirect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return Router; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ServerLocation", function() { return ServerLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRedirect", function() { return isRedirect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "redirectTo", function() { return redirectTo; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! warning */ "./node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var create_react_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! create-react-context */ "./node_modules/create-react-context/lib/index.js");
/* harmony import */ var create_react_context__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(create_react_context__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-lifecycles-compat */ "./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/utils */ "./node_modules/@reach/router/es/lib/utils.js");
/* harmony import */ var _lib_history__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/history */ "./node_modules/@reach/router/es/lib/history.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createHistory", function() { return _lib_history__WEBPACK_IMPORTED_MODULE_8__["createHistory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createMemorySource", function() { return _lib_history__WEBPACK_IMPORTED_MODULE_8__["createMemorySource"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "navigate", function() { return _lib_history__WEBPACK_IMPORTED_MODULE_8__["navigate"]; });

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* eslint-disable jsx-a11y/anchor-has-content */










////////////////////////////////////////////////////////////////////////////////
// React polyfill
var unstable_deferredUpdates = react_dom__WEBPACK_IMPORTED_MODULE_6___default.a.unstable_deferredUpdates;

if (unstable_deferredUpdates === undefined) {
  unstable_deferredUpdates = function unstable_deferredUpdates(fn) {
    return fn();
  };
}

var createNamedContext = function createNamedContext(name, defaultValue) {
  var Ctx = create_react_context__WEBPACK_IMPORTED_MODULE_4___default()(defaultValue);
  Ctx.Consumer.displayName = name + ".Consumer";
  Ctx.Provider.displayName = name + ".Provider";
  return Ctx;
};

////////////////////////////////////////////////////////////////////////////////
// Location Context/Provider
var LocationContext = createNamedContext("Location");

// sets up a listener if there isn't one already so apps don't need to be
// wrapped in some top level provider
var Location = function Location(_ref) {
  var children = _ref.children;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    LocationContext.Consumer,
    null,
    function (context) {
      return context ? children(context) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        LocationProvider,
        null,
        children
      );
    }
  );
};

var LocationProvider = function (_React$Component) {
  _inherits(LocationProvider, _React$Component);

  function LocationProvider() {
    var _temp, _this, _ret;

    _classCallCheck(this, LocationProvider);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      context: _this.getContext(),
      refs: { unlisten: null }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  LocationProvider.prototype.getContext = function getContext() {
    var _props$history = this.props.history,
        navigate = _props$history.navigate,
        location = _props$history.location;

    return { navigate: navigate, location: location };
  };

  LocationProvider.prototype.componentDidCatch = function componentDidCatch(error, info) {
    if (isRedirect(error)) {
      var _navigate = this.props.history.navigate;

      _navigate(error.uri, { replace: true });
    } else {
      throw error;
    }
  };

  LocationProvider.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevState.context.location !== this.state.context.location) {
      this.props.history._onTransitionComplete();
    }
  };

  LocationProvider.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var refs = this.state.refs,
        history = this.props.history;

    refs.unlisten = history.listen(function () {
      Promise.resolve().then(function () {
        unstable_deferredUpdates(function () {
          if (!_this2.unmounted) {
            _this2.setState(function () {
              return { context: _this2.getContext() };
            });
          }
        });
      });
    });
  };

  LocationProvider.prototype.componentWillUnmount = function componentWillUnmount() {
    var refs = this.state.refs;

    this.unmounted = true;
    refs.unlisten();
  };

  LocationProvider.prototype.render = function render() {
    var context = this.state.context,
        children = this.props.children;

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
      LocationContext.Provider,
      { value: context },
      typeof children === "function" ? children(context) : children || null
    );
  };

  return LocationProvider;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

////////////////////////////////////////////////////////////////////////////////


LocationProvider.defaultProps = {
  history: _lib_history__WEBPACK_IMPORTED_MODULE_8__["globalHistory"]
};
 true ? LocationProvider.propTypes = {
  history: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object.isRequired
} : undefined;
var ServerLocation = function ServerLocation(_ref2) {
  var url = _ref2.url,
      children = _ref2.children;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    LocationContext.Provider,
    {
      value: {
        location: { pathname: url },
        navigate: function navigate() {
          throw new Error("You can't call navigate on the server.");
        }
      }
    },
    children
  );
};

////////////////////////////////////////////////////////////////////////////////
// Sets baseuri and basepath for nested routers and links
var BaseContext = createNamedContext("Base", { baseuri: "/", basepath: "/" });

////////////////////////////////////////////////////////////////////////////////
// The main event, welcome to the show everybody.
var Router = function Router(props) {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    BaseContext.Consumer,
    null,
    function (baseContext) {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        Location,
        null,
        function (locationContext) {
          return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(RouterImpl, _extends({}, baseContext, locationContext, props));
        }
      );
    }
  );
};

var RouterImpl = function (_React$PureComponent) {
  _inherits(RouterImpl, _React$PureComponent);

  function RouterImpl() {
    _classCallCheck(this, RouterImpl);

    return _possibleConstructorReturn(this, _React$PureComponent.apply(this, arguments));
  }

  RouterImpl.prototype.render = function render() {
    var _props = this.props,
        location = _props.location,
        _navigate2 = _props.navigate,
        basepath = _props.basepath,
        primary = _props.primary,
        children = _props.children,
        baseuri = _props.baseuri,
        _props$component = _props.component,
        component = _props$component === undefined ? "div" : _props$component,
        domProps = _objectWithoutProperties(_props, ["location", "navigate", "basepath", "primary", "children", "baseuri", "component"]);

    var routes = react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.map(children, createRoute(basepath));
    var pathname = location.pathname;


    var match = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__["pick"])(routes, pathname);

    if (match) {
      var params = match.params,
          uri = match.uri,
          route = match.route,
          element = match.route.value;

      // remove the /* from the end for child routes relative paths

      basepath = route.default ? basepath : route.path.replace(/\*$/, "");

      var props = _extends({}, params, {
        uri: uri,
        location: location,
        navigate: function navigate(to, options) {
          return _navigate2(Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__["resolve"])(to, uri), options);
        }
      });

      var clone = react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(element, props, element.props.children ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        Router,
        { primary: primary },
        element.props.children
      ) : undefined);

      // using 'div' for < 16.3 support
      var FocusWrapper = primary ? FocusHandler : component;
      // don't pass any props to 'div'
      var wrapperProps = primary ? _extends({ uri: uri, location: location, component: component }, domProps) : domProps;

      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        BaseContext.Provider,
        { value: { baseuri: uri, basepath: basepath } },
        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
          FocusWrapper,
          wrapperProps,
          clone
        )
      );
    } else {
      // Not sure if we want this, would require index routes at every level
      // warning(
      //   false,
      //   `<Router basepath="${basepath}">\n\nNothing matched:\n\t${
      //     location.pathname
      //   }\n\nPaths checked: \n\t${routes
      //     .map(route => route.path)
      //     .join(
      //       "\n\t"
      //     )}\n\nTo get rid of this warning, add a default NotFound component as child of Router:
      //   \n\tlet NotFound = () => <div>Not Found!</div>
      //   \n\t<Router>\n\t  <NotFound default/>\n\t  {/* ... */}\n\t</Router>`
      // );
      return null;
    }
  };

  return RouterImpl;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.PureComponent);

RouterImpl.defaultProps = {
  primary: true
};


var FocusContext = createNamedContext("Focus");

var FocusHandler = function FocusHandler(_ref3) {
  var uri = _ref3.uri,
      location = _ref3.location,
      component = _ref3.component,
      domProps = _objectWithoutProperties(_ref3, ["uri", "location", "component"]);

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    FocusContext.Consumer,
    null,
    function (requestFocus) {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(FocusHandlerImpl, _extends({}, domProps, {
        component: component,
        requestFocus: requestFocus,
        uri: uri,
        location: location
      }));
    }
  );
};

// don't focus on initial render
var initialRender = true;
var focusHandlerCount = 0;

var FocusHandlerImpl = function (_React$Component2) {
  _inherits(FocusHandlerImpl, _React$Component2);

  function FocusHandlerImpl() {
    var _temp2, _this4, _ret2;

    _classCallCheck(this, FocusHandlerImpl);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return _ret2 = (_temp2 = (_this4 = _possibleConstructorReturn(this, _React$Component2.call.apply(_React$Component2, [this].concat(args))), _this4), _this4.state = {}, _this4.requestFocus = function (node) {
      if (!_this4.state.shouldFocus) {
        node.focus();
      }
    }, _temp2), _possibleConstructorReturn(_this4, _ret2);
  }

  FocusHandlerImpl.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    var initial = prevState.uri == null;
    if (initial) {
      return _extends({
        shouldFocus: true
      }, nextProps);
    } else {
      var myURIChanged = nextProps.uri !== prevState.uri;
      var navigatedUpToMe = prevState.location.pathname !== nextProps.location.pathname && nextProps.location.pathname === nextProps.uri;
      return _extends({
        shouldFocus: myURIChanged || navigatedUpToMe
      }, nextProps);
    }
  };

  FocusHandlerImpl.prototype.componentDidMount = function componentDidMount() {
    focusHandlerCount++;
    this.focus();
  };

  FocusHandlerImpl.prototype.componentWillUnmount = function componentWillUnmount() {
    focusHandlerCount--;
    if (focusHandlerCount === 0) {
      initialRender = true;
    }
  };

  FocusHandlerImpl.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    if (prevProps.location !== this.props.location && this.state.shouldFocus) {
      this.focus();
    }
  };

  FocusHandlerImpl.prototype.focus = function focus() {
    if (false) {}

    var requestFocus = this.props.requestFocus;


    if (requestFocus) {
      requestFocus(this.node);
    } else {
      if (initialRender) {
        initialRender = false;
      } else {
        this.node.focus();
      }
    }
  };

  FocusHandlerImpl.prototype.render = function render() {
    var _this5 = this;

    var _props2 = this.props,
        children = _props2.children,
        style = _props2.style,
        requestFocus = _props2.requestFocus,
        _props2$role = _props2.role,
        role = _props2$role === undefined ? "group" : _props2$role,
        _props2$component = _props2.component,
        Comp = _props2$component === undefined ? "div" : _props2$component,
        uri = _props2.uri,
        location = _props2.location,
        domProps = _objectWithoutProperties(_props2, ["children", "style", "requestFocus", "role", "component", "uri", "location"]);

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
      Comp,
      _extends({
        style: _extends({ outline: "none" }, style),
        tabIndex: "-1",
        role: role,
        ref: function ref(n) {
          return _this5.node = n;
        }
      }, domProps),
      react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        FocusContext.Provider,
        { value: this.requestFocus },
        this.props.children
      )
    );
  };

  return FocusHandlerImpl;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

Object(react_lifecycles_compat__WEBPACK_IMPORTED_MODULE_5__["polyfill"])(FocusHandlerImpl);

var k = function k() {};

////////////////////////////////////////////////////////////////////////////////
var forwardRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.forwardRef;

if (typeof forwardRef === "undefined") {
  forwardRef = function forwardRef(C) {
    return C;
  };
}

var Link = forwardRef(function (_ref4, ref) {
  var innerRef = _ref4.innerRef,
      props = _objectWithoutProperties(_ref4, ["innerRef"]);

  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    BaseContext.Consumer,
    null,
    function (_ref5) {
      var basepath = _ref5.basepath,
          baseuri = _ref5.baseuri;
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        Location,
        null,
        function (_ref6) {
          var location = _ref6.location,
              navigate = _ref6.navigate;

          var to = props.to,
              state = props.state,
              replace = props.replace,
              _props$getProps = props.getProps,
              getProps = _props$getProps === undefined ? k : _props$getProps,
              anchorProps = _objectWithoutProperties(props, ["to", "state", "replace", "getProps"]);

          var href = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__["resolve"])(to, baseuri);
          var isCurrent = location.pathname === href;
          var isPartiallyCurrent = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__["startsWith"])(location.pathname, href);

          return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", _extends({
            ref: ref || innerRef,
            "aria-current": isCurrent ? "page" : undefined
          }, anchorProps, getProps({ isCurrent: isCurrent, isPartiallyCurrent: isPartiallyCurrent, href: href, location: location }), {
            href: href,
            onClick: function onClick(event) {
              if (anchorProps.onClick) anchorProps.onClick(event);
              if (shouldNavigate(event)) {
                event.preventDefault();
                navigate(href, { state: state, replace: replace });
              }
            }
          }));
        }
      );
    }
  );
});

////////////////////////////////////////////////////////////////////////////////
function RedirectRequest(uri) {
  this.uri = uri;
}

var isRedirect = function isRedirect(o) {
  return o instanceof RedirectRequest;
};

var redirectTo = function redirectTo(to) {
  throw new RedirectRequest(to);
};

var RedirectImpl = function (_React$Component3) {
  _inherits(RedirectImpl, _React$Component3);

  function RedirectImpl() {
    _classCallCheck(this, RedirectImpl);

    return _possibleConstructorReturn(this, _React$Component3.apply(this, arguments));
  }

  // Support React < 16 with this hook
  RedirectImpl.prototype.componentDidMount = function componentDidMount() {
    var _props3 = this.props,
        navigate = _props3.navigate,
        to = _props3.to,
        from = _props3.from,
        _props3$replace = _props3.replace,
        replace = _props3$replace === undefined ? true : _props3$replace,
        state = _props3.state,
        noThrow = _props3.noThrow,
        props = _objectWithoutProperties(_props3, ["navigate", "to", "from", "replace", "state", "noThrow"]);

    Promise.resolve().then(function () {
      navigate(Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__["insertParams"])(to, props), { replace: replace, state: state });
    });
  };

  RedirectImpl.prototype.render = function render() {
    var _props4 = this.props,
        navigate = _props4.navigate,
        to = _props4.to,
        from = _props4.from,
        replace = _props4.replace,
        state = _props4.state,
        noThrow = _props4.noThrow,
        props = _objectWithoutProperties(_props4, ["navigate", "to", "from", "replace", "state", "noThrow"]);

    if (!noThrow) redirectTo(Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__["insertParams"])(to, props));
    return null;
  };

  return RedirectImpl;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

var Redirect = function Redirect(props) {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    Location,
    null,
    function (locationContext) {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(RedirectImpl, _extends({}, locationContext, props));
    }
  );
};

 true ? Redirect.propTypes = {
  from: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
  to: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string.isRequired
} : undefined;

////////////////////////////////////////////////////////////////////////////////
var Match = function Match(_ref7) {
  var path = _ref7.path,
      children = _ref7.children;
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    BaseContext.Consumer,
    null,
    function (_ref8) {
      var baseuri = _ref8.baseuri;
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        Location,
        null,
        function (_ref9) {
          var navigate = _ref9.navigate,
              location = _ref9.location;

          var resolvedPath = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__["resolve"])(path, baseuri);
          var result = Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__["match"])(resolvedPath, location.pathname);
          return children({
            navigate: navigate,
            location: location,
            match: result ? _extends({}, result.params, {
              uri: result.uri,
              path: path
            }) : null
          });
        }
      );
    }
  );
};

////////////////////////////////////////////////////////////////////////////////
// Junk
var stripSlashes = function stripSlashes(str) {
  return str.replace(/(^\/+|\/+$)/g, "");
};

var createRoute = function createRoute(basepath) {
  return function (element) {
    !(element.props.path || element.props.default || element.type === Redirect) ?  true ? invariant__WEBPACK_IMPORTED_MODULE_3___default()(false, "<Router>: Children of <Router> must have a `path` or `default` prop, or be a `<Redirect>`. None found on element type `" + element.type + "`") : undefined : void 0;

    !!(element.type === Redirect && (!element.props.from || !element.props.to)) ?  true ? invariant__WEBPACK_IMPORTED_MODULE_3___default()(false, "<Redirect from=\"" + element.props.from + " to=\"" + element.props.to + "\"/> requires both \"from\" and \"to\" props when inside a <Router>.") : undefined : void 0;

    !!(element.type === Redirect && !Object(_lib_utils__WEBPACK_IMPORTED_MODULE_7__["validateRedirect"])(element.props.from, element.props.to)) ?  true ? invariant__WEBPACK_IMPORTED_MODULE_3___default()(false, "<Redirect from=\"" + element.props.from + " to=\"" + element.props.to + "\"/> has mismatched dynamic segments, ensure both paths have the exact same dynamic segments.") : undefined : void 0;

    if (element.props.default) {
      return { value: element, default: true };
    }

    var elementPath = element.type === Redirect ? element.props.from : element.props.path;

    var path = elementPath === "/" ? basepath : stripSlashes(basepath) + "/" + stripSlashes(elementPath);

    return {
      value: element,
      default: element.props.default,
      path: element.props.children ? stripSlashes(path) + "/*" : path
    };
  };
};

var shouldNavigate = function shouldNavigate(event) {
  return !event.defaultPrevented && event.button === 0 && !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

////////////////////////////////////////////////////////////////////////


/***/ }),

/***/ "./node_modules/@reach/router/es/lib/history.js":
/*!******************************************************!*\
  !*** ./node_modules/@reach/router/es/lib/history.js ***!
  \******************************************************/
/*! exports provided: globalHistory, navigate, createHistory, createMemorySource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalHistory", function() { return globalHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "navigate", function() { return navigate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHistory", function() { return createHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMemorySource", function() { return createMemorySource; });
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

////////////////////////////////////////////////////////////////////////////////
// createHistory(source) - wraps a history source
var getLocation = function getLocation(source) {
  return _extends({}, source.location, {
    state: source.history.state,
    key: source.history.state && source.history.state.key || "initial"
  });
};

var createHistory = function createHistory(source, options) {
  var listeners = [];
  var location = getLocation(source);
  var transitioning = false;
  var resolveTransition = function resolveTransition() {};

  return {
    get location() {
      return location;
    },

    get transitioning() {
      return transitioning;
    },

    _onTransitionComplete: function _onTransitionComplete() {
      transitioning = false;
      resolveTransition();
    },
    listen: function listen(listener) {
      listeners.push(listener);

      var popstateListener = function popstateListener() {
        location = getLocation(source);
        listener();
      };

      source.addEventListener("popstate", popstateListener);

      return function () {
        source.removeEventListener("popstate", popstateListener);
        listeners = listeners.filter(function (fn) {
          return fn !== listener;
        });
      };
    },
    navigate: function navigate(to) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          state = _ref.state,
          _ref$replace = _ref.replace,
          replace = _ref$replace === undefined ? false : _ref$replace;

      state = _extends({}, state, { key: Date.now() + "" });
      // try...catch iOS Safari limits to 100 pushState calls
      try {
        if (transitioning || replace) {
          source.history.replaceState(state, null, to);
        } else {
          source.history.pushState(state, null, to);
        }
      } catch (e) {
        source.location[replace ? "replace" : "assign"](to);
      }

      location = getLocation(source);
      transitioning = true;
      var transition = new Promise(function (res) {
        return resolveTransition = res;
      });
      listeners.forEach(function (fn) {
        return fn();
      });
      return transition;
    }
  };
};

////////////////////////////////////////////////////////////////////////////////
// Stores history entries in memory for testing or other platforms like Native
var createMemorySource = function createMemorySource() {
  var initialPathname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "/";

  var index = 0;
  var stack = [{ pathname: initialPathname, search: "" }];
  var states = [];

  return {
    get location() {
      return stack[index];
    },
    addEventListener: function addEventListener(name, fn) {},
    removeEventListener: function removeEventListener(name, fn) {},

    history: {
      get entries() {
        return stack;
      },
      get index() {
        return index;
      },
      get state() {
        return states[index];
      },
      pushState: function pushState(state, _, uri) {
        var _uri$split = uri.split("?"),
            pathname = _uri$split[0],
            _uri$split$ = _uri$split[1],
            search = _uri$split$ === undefined ? "" : _uri$split$;

        index++;
        stack.push({ pathname: pathname, search: search });
        states.push(state);
      },
      replaceState: function replaceState(state, _, uri) {
        var _uri$split2 = uri.split("?"),
            pathname = _uri$split2[0],
            _uri$split2$ = _uri$split2[1],
            search = _uri$split2$ === undefined ? "" : _uri$split2$;

        stack[index] = { pathname: pathname, search: search };
        states[index] = state;
      }
    }
  };
};

////////////////////////////////////////////////////////////////////////////////
// global history - uses window.history as the source if available, otherwise a
// memory history
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var getSource = function getSource() {
  return canUseDOM ? window : createMemorySource();
};

var globalHistory = createHistory(getSource());
var navigate = globalHistory.navigate;

////////////////////////////////////////////////////////////////////////////////



/***/ }),

/***/ "./node_modules/@reach/router/es/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/@reach/router/es/lib/utils.js ***!
  \****************************************************/
/*! exports provided: startsWith, pick, match, resolve, insertParams, validateRedirect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startsWith", function() { return startsWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return pick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "match", function() { return match; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolve", function() { return resolve; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertParams", function() { return insertParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateRedirect", function() { return validateRedirect; });
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_0__);


////////////////////////////////////////////////////////////////////////////////
// startsWith(string, search) - Check if `string` starts with `search`
var startsWith = function startsWith(string, search) {
  return string.substr(0, search.length) === search;
};

////////////////////////////////////////////////////////////////////////////////
// pick(routes, uri)
//
// Ranks and picks the best route to match. Each segment gets the highest
// amount of points, then the type of segment gets an additional amount of
// points where
//
//     static > dynamic > splat > root
//
// This way we don't have to worry about the order of our routes, let the
// computers do it.
//
// A route looks like this
//
//     { path, default, value }
//
// And a returned match looks like:
//
//     { route, params, uri }
//
// I know, I should use TypeScript not comments for these types.
var pick = function pick(routes, uri) {
  var match = void 0;
  var default_ = void 0;

  var _uri$split = uri.split("?"),
      uriPathname = _uri$split[0];

  var uriSegments = segmentize(uriPathname);
  var isRootUri = uriSegments[0] === "";
  var ranked = rankRoutes(routes);

  for (var i = 0, l = ranked.length; i < l; i++) {
    var missed = false;
    var route = ranked[i].route;

    if (route.default) {
      default_ = {
        route: route,
        params: {},
        uri: uri
      };
      continue;
    }

    var routeSegments = segmentize(route.path);
    var params = {};
    var max = Math.max(uriSegments.length, routeSegments.length);
    var index = 0;

    for (; index < max; index++) {
      var routeSegment = routeSegments[index];
      var uriSegment = uriSegments[index];

      var _isSplat = routeSegment === "*";
      if (_isSplat) {
        // Hit a splat, just grab the rest, and return a match
        // uri:   /files/documents/work
        // route: /files/*
        params["*"] = uriSegments.slice(index).map(decodeURIComponent).join("/");
        break;
      }

      if (uriSegment === undefined) {
        // URI is shorter than the route, no match
        // uri:   /users
        // route: /users/:userId
        missed = true;
        break;
      }

      var dynamicMatch = paramRe.exec(routeSegment);

      if (dynamicMatch && !isRootUri) {
        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;
        !matchIsNotReserved ?  true ? invariant__WEBPACK_IMPORTED_MODULE_0___default()(false, "<Router> dynamic segment \"" + dynamicMatch[1] + "\" is a reserved name. Please use a different name in path \"" + route.path + "\".") : undefined : void 0;
        var value = decodeURIComponent(uriSegment);
        params[dynamicMatch[1]] = value;
      } else if (routeSegment !== uriSegment) {
        // Current segments don't match, not dynamic, not splat, so no match
        // uri:   /users/123/settings
        // route: /users/:id/profile
        missed = true;
        break;
      }
    }

    if (!missed) {
      match = {
        route: route,
        params: params,
        uri: "/" + uriSegments.slice(0, index).join("/")
      };
      break;
    }
  }

  return match || default_ || null;
};

////////////////////////////////////////////////////////////////////////////////
// match(path, uri) - Matches just one path to a uri, also lol
var match = function match(path, uri) {
  return pick([{ path: path }], uri);
};

////////////////////////////////////////////////////////////////////////////////
// resolve(to, basepath)
//
// Resolves URIs as though every path is a directory, no files.  Relative URIs
// in the browser can feel awkward because not only can you be "in a directory"
// you can be "at a file", too. For example
//
//     browserSpecResolve('foo', '/bar/') => /bar/foo
//     browserSpecResolve('foo', '/bar') => /foo
//
// But on the command line of a file system, it's not as complicated, you can't
// `cd` from a file, only directories.  This way, links have to know less about
// their current path. To go deeper you can do this:
//
//     <Link to="deeper"/>
//     // instead of
//     <Link to=`{${props.uri}/deeper}`/>
//
// Just like `cd`, if you want to go deeper from the command line, you do this:
//
//     cd deeper
//     # not
//     cd $(pwd)/deeper
//
// By treating every path as a directory, linking to relative paths should
// require less contextual information and (fingers crossed) be more intuitive.
var resolve = function resolve(to, base) {
  // /foo/bar, /baz/qux => /foo/bar
  if (startsWith(to, "/")) {
    return to;
  }

  var _to$split = to.split("?"),
      toPathname = _to$split[0],
      toQuery = _to$split[1];

  var _base$split = base.split("?"),
      basePathname = _base$split[0];

  var toSegments = segmentize(toPathname);
  var baseSegments = segmentize(basePathname);

  // ?a=b, /users?b=c => /users?a=b
  if (toSegments[0] === "") {
    return addQuery(basePathname, toQuery);
  }

  // profile, /users/789 => /users/789/profile
  if (!startsWith(toSegments[0], ".")) {
    var pathname = baseSegments.concat(toSegments).join("/");
    return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
  }

  // ./         /users/123  =>  /users/123
  // ../        /users/123  =>  /users
  // ../..      /users/123  =>  /
  // ../../one  /a/b/c/d    =>  /a/b/one
  // .././one   /a/b/c/d    =>  /a/b/c/one
  var allSegments = baseSegments.concat(toSegments);
  var segments = [];
  for (var i = 0, l = allSegments.length; i < l; i++) {
    var segment = allSegments[i];
    if (segment === "..") segments.pop();else if (segment !== ".") segments.push(segment);
  }

  return addQuery("/" + segments.join("/"), toQuery);
};

////////////////////////////////////////////////////////////////////////////////
// insertParams(path, params)
var insertParams = function insertParams(path, params) {
  var segments = segmentize(path);
  return "/" + segments.map(function (segment) {
    var match = paramRe.exec(segment);
    return match ? params[match[1]] : segment;
  }).join("/");
};

var validateRedirect = function validateRedirect(from, to) {
  var filter = function filter(segment) {
    return isDynamic(segment);
  };
  var fromString = segmentize(from).filter(filter).sort().join("/");
  var toString = segmentize(to).filter(filter).sort().join("/");
  return fromString === toString;
};

////////////////////////////////////////////////////////////////////////////////
// Junk
var paramRe = /^:(.+)/;

var SEGMENT_POINTS = 4;
var STATIC_POINTS = 3;
var DYNAMIC_POINTS = 2;
var SPLAT_PENALTY = 1;
var ROOT_POINTS = 1;

var isRootSegment = function isRootSegment(segment) {
  return segment === "";
};
var isDynamic = function isDynamic(segment) {
  return paramRe.test(segment);
};
var isSplat = function isSplat(segment) {
  return segment === "*";
};

var rankRoute = function rankRoute(route, index) {
  var score = route.default ? 0 : segmentize(route.path).reduce(function (score, segment) {
    score += SEGMENT_POINTS;
    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;
    return score;
  }, 0);
  return { route: route, score: score, index: index };
};

var rankRoutes = function rankRoutes(routes) {
  return routes.map(rankRoute).sort(function (a, b) {
    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;
  });
};

var segmentize = function segmentize(uri) {
  return uri
  // strip starting/ending slashes
  .replace(/(^\/+|\/+$)/g, "").split("/");
};

var addQuery = function addQuery(pathname, query) {
  return pathname + (query ? "?" + query : "");
};

var reservedNames = ["uri", "path"];

////////////////////////////////////////////////////////////////////////////////


/***/ }),

/***/ "./node_modules/create-react-context/lib/implementation.js":
/*!*****************************************************************!*\
  !*** ./node_modules/create-react-context/lib/implementation.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _gud = __webpack_require__(/*! gud */ "./node_modules/gud/index.js");

var _gud2 = _interopRequireDefault(_gud);

var _warning = __webpack_require__(/*! fbjs/lib/warning */ "./node_modules/fbjs/lib/warning.js");

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MAX_SIGNED_31_BIT_INT = 1073741823;

// Inlined Object.is polyfill.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + (0, _gud2.default)() + '__';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    function Provider() {
      var _temp, _this, _ret;

      _classCallCheck(this, Provider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);
    }

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits = void 0;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0; // No change
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          if (true) {
            (0, _warning2.default)((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits);
          }

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    Provider.prototype.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(_react.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);

  var Consumer = function (_Component2) {
    _inherits(Consumer, _Component2);

    function Consumer() {
      var _temp2, _this2, _ret2;

      _classCallCheck(this, Consumer);

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
        value: _this2.getValue()
      }, _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({ value: _this2.getValue() });
        }
      }, _temp2), _possibleConstructorReturn(_this2, _ret2);
    }

    Consumer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;

      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    Consumer.prototype.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;

      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    Consumer.prototype.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    Consumer.prototype.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    Consumer.prototype.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(_react.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);


  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

exports.default = createReactContext;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/create-react-context/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/create-react-context/lib/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _react2 = _interopRequireDefault(_react);

var _implementation = __webpack_require__(/*! ./implementation */ "./node_modules/create-react-context/lib/implementation.js");

var _implementation2 = _interopRequireDefault(_implementation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _react2.default.createContext || _implementation2.default;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js!./src/css/main.css":
/*!************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--5-1!./node_modules/postcss-loader/src!./src/css/main.css ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in\n *    IE on Windows Phone and in iOS.\n */\n\nhtml {\n  line-height: 1.15; /* 1 */\n      -ms-text-size-adjust: 100%; /* 2 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n\n/**\n * Remove the margin in all browsers (opinionated).\n */\n\nbody {\n  margin: 0;\n}\n\n/**\n * Add the correct display in IE 9-.\n */\n\narticle,\naside,\nfooter,\nheader,\nnav,\nsection {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: .67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n * 1. Add the correct display in IE.\n */\n\nfigcaption,\nfigure,\nmain {\n  /* 1 */\n  display: block;\n}\n\n/**\n * Add the correct margin in IE 8.\n */\n\nfigure {\n  margin: 1em 40px;\n}\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * 1. Remove the gray background on active links in IE 10.\n * 2. Remove gaps in links underline in iOS 8+ and Safari 8+.\n */\n\na {\n  background-color: transparent; /* 1 */\n  -webkit-text-decoration-skip: objects; /* 2 */\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57- and Firefox 39-.\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Prevent the duplicate application of `bolder` by the next rule in Safari 6.\n */\n\nb,\nstrong {\n  font-weight: inherit;\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font style in Android 4.3-.\n */\n\ndfn {\n  font-style: italic;\n}\n\n/**\n * Add the correct background and color in IE 9-.\n */\n\nmark {\n  background-color: #ff0;\n  color: #000;\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n */\n\naudio,\nvideo {\n  display: inline-block;\n}\n\n/**\n * Add the correct display in iOS 4-7.\n */\n\naudio:not([controls]) {\n  display: none;\n  height: 0;\n}\n\n/**\n * Remove the border on images inside links in IE 10-.\n */\n\nimg {\n  border-style: none;\n}\n\n/**\n * Hide the overflow in IE.\n */\n\nsvg:not(:root) {\n  overflow: hidden;\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers (opinionated).\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: sans-serif; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput {\n  /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect {\n  /* 1 */\n  text-transform: none;\n}\n\n/**\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\n *    controls in Android 4.\n * 2. Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\nhtml [type=\"button\"],\n/* 1 */\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; /* 2 */\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\n\nfieldset {\n  padding: .35em .75em .625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * 1. Add the correct display in IE 9-.\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  display: inline-block; /* 1 */\n  vertical-align: baseline; /* 2 */\n}\n\n/**\n * Remove the default vertical scrollbar in IE.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10-.\n * 2. Remove the padding in IE 10-.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n\n/*\n * Add the correct display in IE 9-.\n * 1. Add the correct display in Edge, IE, and Firefox.\n */\n\ndetails,\n/* 1 */\nmenu {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\n\nsummary {\n  display: list-item;\n}\n\n/* Scripting\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n */\n\ncanvas {\n  display: inline-block;\n}\n\n/**\n * Add the correct display in IE.\n */\n\ntemplate {\n  display: none;\n}\n\n/* Hidden\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 10-.\n */\n\n[hidden] {\n  display: none;\n}\n\n/**\n * Manually forked from SUIT CSS Base: https://github.com/suitcss/base\n * A thin layer on top of normalize.css that provides a starting point more\n * suitable for web applications.\n */\n\n/**\n * 1. Prevent padding and border from affecting element width\n * https://goo.gl/pYtbK7\n * 2. Change the default font family in all browsers (opinionated)\n */\n\nhtml {\n  box-sizing: border-box; /* 1 */\n  font-family: sans-serif; /* 2 */\n}\n\n*,\n*::before,\n*::after {\n  box-sizing: inherit;\n}\n\n/**\n * Removes the default spacing and border for appropriate elements.\n */\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nbutton {\n  background: transparent;\n  padding: 0;\n}\n\n/**\n * Work around a Firefox/IE bug where the transparent `button` background\n * results in a loss of the default `button` focus styles.\n */\n\nbutton:focus {\n  outline: 1px dotted;\n  outline: 5px auto -webkit-focus-ring-color;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nol,\nul {\n  margin: 0;\n}\n\n/**\n * Tailwind custom reset styles\n */\n\n/**\n * Allow adding a border to an element by just adding a border-width.\n *\n * By default, the way the browser specifies that an element should have no\n * border is by setting it's border-style to `none` in the user-agent\n * stylesheet.\n *\n * In order to easily add borders to elements by just setting the `border-width`\n * property, we change the default border-style for all elements to `solid`, and\n * use border-width to hide them instead. This way our `border` utilities only\n * need to set the `border-width` property instead of the entire `border`\n * shorthand, making our border utilities much more straightforward to compose.\n *\n * https://github.com/tailwindcss/tailwindcss/pull/116\n */\n\n*,\n*::before,\n*::after {\n  border-width: 0;\n  border-style: solid;\n  border-color: #e7e7ec;\n}\n\n/**\n * Undo the `border-style: none` reset that Normalize applies to images so that\n * our `border-{width}` utilities have the expected effect.\n *\n * The Normalize reset is unnecessary for us since we default the border-width\n * to 0 on all elements.\n *\n * https://github.com/tailwindcss/tailwindcss/issues/362\n */\n\nimg {\n  border-style: solid;\n}\n\n/**\n * Temporary reset for a change introduced in Chrome 62 but now reverted.\n *\n * We can remove this when the reversion is in a normal Chrome release.\n */\n\nbutton,\n[type=\"button\"],\n[type=\"reset\"],\n[type=\"submit\"] {\n  border-radius: 0;\n}\n\ntextarea {\n  resize: vertical;\n}\n\nimg {\n  max-width: 100%;\n  height: auto;\n}\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit;\n}\n\ninput::placeholder,\ntextarea::placeholder {\n  color: inherit;\n  opacity: .5;\n}\n\nbutton,\n[role=button] {\n  cursor: pointer;\n}\n\ntable {\n  border-collapse: collapse;\n}\n\n/*\n@font-face {\n  font-family: 'Karla';\n  src: url('./fonts/karla-regular.woff2') format('woff2'),\n    url('./fonts/karla-regular.woff') format('woff');\n  font-weight: normal;\n  font-style: normal;\n}\n\n@font-face {\n  font-family: 'Karla';\n  src: url('./fonts/karla-regular-italic.woff2') format('woff2'),\n    url('./fonts/karla-regular-italic.woff') format('woff');\n  font-weight: normal;\n  font-style: italic;\n}\n\n@font-face {\n  font-family: 'Karla';\n  src: url('./fonts/karla-bold.woff2') format('woff2'),\n    url('./fonts/karla-bold.woff') format('woff');\n  font-weight: bold;\n  font-style: normal;\n}\n\n@font-face {\n  font-family: 'Karla';\n  src: url('./fonts/karla-bold-italic.woff2') format('woff2'),\n    url('./fonts/karla-bold-italic.woff') format('woff');\n  font-weight: bold;\n  font-style: italic;\n}\n*/\n\nhtml {\n  font-size: 62.5%;\n}\n\nbody {\n  background: #fff;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n  font-size: 1.6rem;\n  color: #453f56;\n}\n\n.outline-0 {\n  outline: 0;\n}\n\n.focus\\:outline-0:focus {\n  outline: 0;\n}\n\n.sr-only,\n.sr-only-focusable:not(:focus):not(:active) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  margin: -1px;\n  border: 0;\n  padding: 0;\n  white-space: nowrap;\n  clip-path: inset(100%);\n  clip: rect(0 0 0 0);\n  overflow: hidden;\n}\n\n:focus + .checkbox {\n  background: #fff;\n}\n\n:checked + .checkbox {\n  background: #8360d6 url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 24 24'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z'/%3E%3C/svg%3E\") center center no-repeat;\n  background-size: 16px 16px;\n  border-color: transparent;\n}\n\ntable tbody td:first-child:focus-within ~ td,\ntable tbody tr:hover td:not(:first-child) {\n  background: #ccc2e9;\n  color: #4c29b0;\n}\n\n.actions::before,\n.actions::after {\n  content: '';\n  display: block;\n  position: absolute;\n  top: 50%;\n  margin-top: -6px;\n  width: 0;\n  height: 0;\n  border-style: solid;\n}\n\n.actions::before {\n  right: 100%;\n  border-width: 6px 6px 6px 0;\n  border-color: transparent #453f56 transparent transparent;\n}\n\n.actions::after {\n  left: 100%;\n  border-width: 6px 0 6px 6px;\n  border-color: transparent transparent transparent #453f56;\n}\n\n.toolbar > button:not(:first-child) {\n  width: 33px;\n  border-left: 1px solid #453f56;\n}\n\n.toolbar > button:not(:first-child)::before {\n  content: '';\n  display: block;\n  position: absolute;\n  left: -1px;\n  top: 50%;\n  height: 20px;\n  margin-top: -10px;\n  width: 1px;\n  background: #87809b;\n}\n\n.toolbar--above::after,\n.toolbar--below::before {\n  content: '';\n  display: block;\n  position: absolute;\n  left: 50%;\n  margin-left: -6px;\n  width: 0;\n  height: 0;\n  border-style: solid;\n}\n\n.toolbar--above::after {\n  top: 100%;\n  border-width: 6px 6px 0;\n  border-color: #453f56 transparent transparent;\n}\n\n.toolbar--below::before {\n  bottom: 100%;\n  border-width: 0 6px 6px;\n  border-color: transparent transparent #453f56;\n}\n\n.logo-container {\n  background: linear-gradient(hsl(240, 20%, 96%) 0%, hsla(240, 20%, 96%, .738) 19%, hsla(240, 20%, 96%, .541) 34%, hsla(240, 20%, 96%, .382) 47%, hsla(240, 20%, 96%, .278) 56.5%, hsla(240, 20%, 96%, .194) 65%, hsla(240, 20%, 96%, .126) 73%, hsla(240, 20%, 96%, .075) 80.2%, hsla(240, 20%, 96%, .042) 86.1%, hsla(240, 20%, 96%, .021) 91%, hsla(240, 20%, 96%, .008) 95.2%, hsla(240, 20%, 96%, .002) 98.2%, hsla(240, 20%, 96%, 0) 100%);\n}\n\n.logo-container::before {\n  content: '';\n  display: block;\n  position: absolute;\n  pointer-events: auto;\n  bottom: 100%;\n  left: 0;\n  width: 100%;\n  background: #f3f3f7;\n  height: 100px;\n}\n\n.button-group {\n  display: inline-flex;\n  display: inline-grid;\n  grid-template-columns: 1fr 1fr;\n}\n\n:checked + .checked\\:bg-purple-dark-10 {\n  background-color: rgba(69, 63, 86, .1);\n}\n\n.btn-group button:first-child {\n  margin-left: 0;\n}\n\n.btn-group button:first-child::before {\n  content: none;\n}\n\n.btn-group button::before,\n.btn-group button::after {\n  content: '';\n  display: block;\n  position: absolute;\n}\n\n.btn-group button::before {\n  top: 5px;\n  bottom: 5px;\n  left: 0;\n  width: 1px;\n  background: #212a38;\n  opacity: .2;\n}\n\n.btn-group button::after {\n  top: 2px;\n  right: 2px;\n  bottom: 2px;\n  left: 3px;\n  background: #8360d6;\n  border-radius: 2px;\n}\n\n.list-reset {\n  list-style: none;\n  padding: 0;\n}\n\n.appearance-none {\n  appearance: none;\n}\n\n.bg-fixed {\n  background-attachment: fixed;\n}\n\n.bg-local {\n  background-attachment: local;\n}\n\n.bg-scroll {\n  background-attachment: scroll;\n}\n\n.bg-inherit {\n  background-color: inherit;\n}\n\n.bg-transparent {\n  background-color: transparent;\n}\n\n.bg-black {\n  background-color: #282828;\n}\n\n.bg-white {\n  background-color: #fff;\n}\n\n.bg-grey-lighter {\n  background-color: #f3f3f7;\n}\n\n.bg-grey-light {\n  background-color: #e7e7ec;\n}\n\n.bg-grey {\n  background-color: #c2c2c6;\n}\n\n.bg-purple-lighter {\n  background-color: #ccc2e9;\n}\n\n.bg-purple-light {\n  background-color: #87809b;\n}\n\n.bg-purple {\n  background-color: #8360d6;\n}\n\n.bg-purple-bright {\n  background-color: #4c29b0;\n}\n\n.bg-purple-dark {\n  background-color: #453f56;\n}\n\n.bg-purple-dark-10 {\n  background-color: rgba(69, 63, 86, .1);\n}\n\n.bg-purple-darker {\n  background-color: #2a2538;\n}\n\n.hover\\:bg-inherit:hover {\n  background-color: inherit;\n}\n\n.hover\\:bg-transparent:hover {\n  background-color: transparent;\n}\n\n.hover\\:bg-black:hover {\n  background-color: #282828;\n}\n\n.hover\\:bg-white:hover {\n  background-color: #fff;\n}\n\n.hover\\:bg-grey-lighter:hover {\n  background-color: #f3f3f7;\n}\n\n.hover\\:bg-grey-light:hover {\n  background-color: #e7e7ec;\n}\n\n.hover\\:bg-grey:hover {\n  background-color: #c2c2c6;\n}\n\n.hover\\:bg-purple-lighter:hover {\n  background-color: #ccc2e9;\n}\n\n.hover\\:bg-purple-light:hover {\n  background-color: #87809b;\n}\n\n.hover\\:bg-purple:hover {\n  background-color: #8360d6;\n}\n\n.hover\\:bg-purple-bright:hover {\n  background-color: #4c29b0;\n}\n\n.hover\\:bg-purple-dark:hover {\n  background-color: #453f56;\n}\n\n.hover\\:bg-purple-dark-10:hover {\n  background-color: rgba(69, 63, 86, .1);\n}\n\n.hover\\:bg-purple-darker:hover {\n  background-color: #2a2538;\n}\n\n.focus\\:bg-inherit:focus {\n  background-color: inherit;\n}\n\n.focus\\:bg-transparent:focus {\n  background-color: transparent;\n}\n\n.focus\\:bg-black:focus {\n  background-color: #282828;\n}\n\n.focus\\:bg-white:focus {\n  background-color: #fff;\n}\n\n.focus\\:bg-grey-lighter:focus {\n  background-color: #f3f3f7;\n}\n\n.focus\\:bg-grey-light:focus {\n  background-color: #e7e7ec;\n}\n\n.focus\\:bg-grey:focus {\n  background-color: #c2c2c6;\n}\n\n.focus\\:bg-purple-lighter:focus {\n  background-color: #ccc2e9;\n}\n\n.focus\\:bg-purple-light:focus {\n  background-color: #87809b;\n}\n\n.focus\\:bg-purple:focus {\n  background-color: #8360d6;\n}\n\n.focus\\:bg-purple-bright:focus {\n  background-color: #4c29b0;\n}\n\n.focus\\:bg-purple-dark:focus {\n  background-color: #453f56;\n}\n\n.focus\\:bg-purple-dark-10:focus {\n  background-color: rgba(69, 63, 86, .1);\n}\n\n.focus\\:bg-purple-darker:focus {\n  background-color: #2a2538;\n}\n\n.bg-bottom {\n  background-position: bottom;\n}\n\n.bg-center {\n  background-position: center;\n}\n\n.bg-left {\n  background-position: left;\n}\n\n.bg-left-bottom {\n  background-position: left bottom;\n}\n\n.bg-left-top {\n  background-position: left top;\n}\n\n.bg-right {\n  background-position: right;\n}\n\n.bg-right-bottom {\n  background-position: right bottom;\n}\n\n.bg-right-top {\n  background-position: right top;\n}\n\n.bg-top {\n  background-position: top;\n}\n\n.bg-repeat {\n  background-repeat: repeat;\n}\n\n.bg-no-repeat {\n  background-repeat: no-repeat;\n}\n\n.bg-repeat-x {\n  background-repeat: repeat-x;\n}\n\n.bg-repeat-y {\n  background-repeat: repeat-y;\n}\n\n.bg-auto {\n  background-size: auto;\n}\n\n.bg-cover {\n  background-size: cover;\n}\n\n.bg-contain {\n  background-size: contain;\n}\n\n.border-collapse {\n  border-collapse: collapse;\n}\n\n.border-separate {\n  border-collapse: separate;\n}\n\n.border-inherit {\n  border-color: inherit;\n}\n\n.border-transparent {\n  border-color: transparent;\n}\n\n.border-black {\n  border-color: #282828;\n}\n\n.border-white {\n  border-color: #fff;\n}\n\n.border-grey-lighter {\n  border-color: #f3f3f7;\n}\n\n.border-grey-light {\n  border-color: #e7e7ec;\n}\n\n.border-grey {\n  border-color: #c2c2c6;\n}\n\n.border-purple-lighter {\n  border-color: #ccc2e9;\n}\n\n.border-purple-light {\n  border-color: #87809b;\n}\n\n.border-purple {\n  border-color: #8360d6;\n}\n\n.border-purple-bright {\n  border-color: #4c29b0;\n}\n\n.border-purple-dark {\n  border-color: #453f56;\n}\n\n.border-purple-dark-10 {\n  border-color: rgba(69, 63, 86, .1);\n}\n\n.border-purple-darker {\n  border-color: #2a2538;\n}\n\n.hover\\:border-inherit:hover {\n  border-color: inherit;\n}\n\n.hover\\:border-transparent:hover {\n  border-color: transparent;\n}\n\n.hover\\:border-black:hover {\n  border-color: #282828;\n}\n\n.hover\\:border-white:hover {\n  border-color: #fff;\n}\n\n.hover\\:border-grey-lighter:hover {\n  border-color: #f3f3f7;\n}\n\n.hover\\:border-grey-light:hover {\n  border-color: #e7e7ec;\n}\n\n.hover\\:border-grey:hover {\n  border-color: #c2c2c6;\n}\n\n.hover\\:border-purple-lighter:hover {\n  border-color: #ccc2e9;\n}\n\n.hover\\:border-purple-light:hover {\n  border-color: #87809b;\n}\n\n.hover\\:border-purple:hover {\n  border-color: #8360d6;\n}\n\n.hover\\:border-purple-bright:hover {\n  border-color: #4c29b0;\n}\n\n.hover\\:border-purple-dark:hover {\n  border-color: #453f56;\n}\n\n.hover\\:border-purple-dark-10:hover {\n  border-color: rgba(69, 63, 86, .1);\n}\n\n.hover\\:border-purple-darker:hover {\n  border-color: #2a2538;\n}\n\n.rounded-none {\n  border-radius: 0;\n}\n\n.rounded-sm {\n  border-radius: 2px;\n}\n\n.rounded {\n  border-radius: 4px;\n}\n\n.rounded-full {\n  border-radius: 9999px;\n}\n\n.rounded-t-none {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.rounded-r-none {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n\n.rounded-b-none {\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.rounded-l-none {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n\n.rounded-t-sm {\n  border-top-left-radius: 2px;\n  border-top-right-radius: 2px;\n}\n\n.rounded-r-sm {\n  border-top-right-radius: 2px;\n  border-bottom-right-radius: 2px;\n}\n\n.rounded-b-sm {\n  border-bottom-right-radius: 2px;\n  border-bottom-left-radius: 2px;\n}\n\n.rounded-l-sm {\n  border-top-left-radius: 2px;\n  border-bottom-left-radius: 2px;\n}\n\n.rounded-t {\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n}\n\n.rounded-r {\n  border-top-right-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n\n.rounded-b {\n  border-bottom-right-radius: 4px;\n  border-bottom-left-radius: 4px;\n}\n\n.rounded-l {\n  border-top-left-radius: 4px;\n  border-bottom-left-radius: 4px;\n}\n\n.rounded-t-full {\n  border-top-left-radius: 9999px;\n  border-top-right-radius: 9999px;\n}\n\n.rounded-r-full {\n  border-top-right-radius: 9999px;\n  border-bottom-right-radius: 9999px;\n}\n\n.rounded-b-full {\n  border-bottom-right-radius: 9999px;\n  border-bottom-left-radius: 9999px;\n}\n\n.rounded-l-full {\n  border-top-left-radius: 9999px;\n  border-bottom-left-radius: 9999px;\n}\n\n.rounded-tl-none {\n  border-top-left-radius: 0;\n}\n\n.rounded-tr-none {\n  border-top-right-radius: 0;\n}\n\n.rounded-br-none {\n  border-bottom-right-radius: 0;\n}\n\n.rounded-bl-none {\n  border-bottom-left-radius: 0;\n}\n\n.rounded-tl-sm {\n  border-top-left-radius: 2px;\n}\n\n.rounded-tr-sm {\n  border-top-right-radius: 2px;\n}\n\n.rounded-br-sm {\n  border-bottom-right-radius: 2px;\n}\n\n.rounded-bl-sm {\n  border-bottom-left-radius: 2px;\n}\n\n.rounded-tl {\n  border-top-left-radius: 4px;\n}\n\n.rounded-tr {\n  border-top-right-radius: 4px;\n}\n\n.rounded-br {\n  border-bottom-right-radius: 4px;\n}\n\n.rounded-bl {\n  border-bottom-left-radius: 4px;\n}\n\n.rounded-tl-full {\n  border-top-left-radius: 9999px;\n}\n\n.rounded-tr-full {\n  border-top-right-radius: 9999px;\n}\n\n.rounded-br-full {\n  border-bottom-right-radius: 9999px;\n}\n\n.rounded-bl-full {\n  border-bottom-left-radius: 9999px;\n}\n\n.border-solid {\n  border-style: solid;\n}\n\n.border-dashed {\n  border-style: dashed;\n}\n\n.border-dotted {\n  border-style: dotted;\n}\n\n.border-none {\n  border-style: none;\n}\n\n.border-0 {\n  border-width: 0;\n}\n\n.border-2 {\n  border-width: 2px;\n}\n\n.border-4 {\n  border-width: 4px;\n}\n\n.border-8 {\n  border-width: 8px;\n}\n\n.border {\n  border-width: 1px;\n}\n\n.border-t-0 {\n  border-top-width: 0;\n}\n\n.border-r-0 {\n  border-right-width: 0;\n}\n\n.border-b-0 {\n  border-bottom-width: 0;\n}\n\n.border-l-0 {\n  border-left-width: 0;\n}\n\n.border-t-2 {\n  border-top-width: 2px;\n}\n\n.border-r-2 {\n  border-right-width: 2px;\n}\n\n.border-b-2 {\n  border-bottom-width: 2px;\n}\n\n.border-l-2 {\n  border-left-width: 2px;\n}\n\n.border-t-4 {\n  border-top-width: 4px;\n}\n\n.border-r-4 {\n  border-right-width: 4px;\n}\n\n.border-b-4 {\n  border-bottom-width: 4px;\n}\n\n.border-l-4 {\n  border-left-width: 4px;\n}\n\n.border-t-8 {\n  border-top-width: 8px;\n}\n\n.border-r-8 {\n  border-right-width: 8px;\n}\n\n.border-b-8 {\n  border-bottom-width: 8px;\n}\n\n.border-l-8 {\n  border-left-width: 8px;\n}\n\n.border-t {\n  border-top-width: 1px;\n}\n\n.border-r {\n  border-right-width: 1px;\n}\n\n.border-b {\n  border-bottom-width: 1px;\n}\n\n.border-l {\n  border-left-width: 1px;\n}\n\n.cursor-auto {\n  cursor: auto;\n}\n\n.cursor-default {\n  cursor: default;\n}\n\n.cursor-pointer {\n  cursor: pointer;\n}\n\n.cursor-wait {\n  cursor: wait;\n}\n\n.cursor-move {\n  cursor: move;\n}\n\n.cursor-not-allowed {\n  cursor: not-allowed;\n}\n\n.block {\n  display: block;\n}\n\n.inline-block {\n  display: inline-block;\n}\n\n.inline {\n  display: inline;\n}\n\n.table {\n  display: table;\n}\n\n.table-row {\n  display: table-row;\n}\n\n.table-cell {\n  display: table-cell;\n}\n\n.hidden {\n  display: none;\n}\n\n.flex {\n  display: flex;\n}\n\n.inline-flex {\n  display: inline-flex;\n}\n\n.flex-row {\n  flex-direction: row;\n}\n\n.flex-row-reverse {\n  flex-direction: row-reverse;\n}\n\n.flex-col {\n  flex-direction: column;\n}\n\n.flex-col-reverse {\n  flex-direction: column-reverse;\n}\n\n.flex-wrap {\n  flex-wrap: wrap;\n}\n\n.flex-wrap-reverse {\n  flex-wrap: wrap-reverse;\n}\n\n.flex-no-wrap {\n  flex-wrap: nowrap;\n}\n\n.items-start {\n  align-items: flex-start;\n}\n\n.items-end {\n  align-items: flex-end;\n}\n\n.items-center {\n  align-items: center;\n}\n\n.items-baseline {\n  align-items: baseline;\n}\n\n.items-stretch {\n  align-items: stretch;\n}\n\n.self-auto {\n  align-self: auto;\n}\n\n.self-start {\n  align-self: flex-start;\n}\n\n.self-end {\n  align-self: flex-end;\n}\n\n.self-center {\n  align-self: center;\n}\n\n.self-stretch {\n  align-self: stretch;\n}\n\n.justify-start {\n  justify-content: flex-start;\n}\n\n.justify-end {\n  justify-content: flex-end;\n}\n\n.justify-center {\n  justify-content: center;\n}\n\n.justify-between {\n  justify-content: space-between;\n}\n\n.justify-around {\n  justify-content: space-around;\n}\n\n.content-center {\n  align-content: center;\n}\n\n.content-start {\n  align-content: flex-start;\n}\n\n.content-end {\n  align-content: flex-end;\n}\n\n.content-between {\n  align-content: space-between;\n}\n\n.content-around {\n  align-content: space-around;\n}\n\n.flex-1 {\n  flex: 1;\n}\n\n.flex-auto {\n  flex: auto;\n}\n\n.flex-initial {\n  flex: initial;\n}\n\n.flex-none {\n  flex: none;\n}\n\n.flex-grow {\n  flex-grow: 1;\n}\n\n.flex-shrink {\n  flex-shrink: 1;\n}\n\n.flex-no-grow {\n  flex-grow: 0;\n}\n\n.flex-no-shrink {\n  flex-shrink: 0;\n}\n\n.float-right {\n  float: right;\n}\n\n.float-left {\n  float: left;\n}\n\n.float-none {\n  float: none;\n}\n\n.clearfix:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n\n.font-sans {\n  font-family: system-ui, BlinkMacSystemFont, -apple-system, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n}\n\n.font-serif {\n  font-family: Constantia, Lucida Bright, Lucidabright, Lucida Serif, Lucida, DejaVu Serif, Bitstream Vera Serif, Liberation Serif, Georgia, serif;\n}\n\n.font-mono {\n  font-family: Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;\n}\n\n.font-hairline {\n  font-weight: 100;\n}\n\n.font-thin {\n  font-weight: 200;\n}\n\n.font-light {\n  font-weight: 300;\n}\n\n.font-normal {\n  font-weight: 400;\n}\n\n.font-medium {\n  font-weight: 500;\n}\n\n.font-semibold {\n  font-weight: 600;\n}\n\n.font-bold {\n  font-weight: 700;\n}\n\n.font-extrabold {\n  font-weight: 800;\n}\n\n.font-black {\n  font-weight: 900;\n}\n\n.hover\\:font-hairline:hover {\n  font-weight: 100;\n}\n\n.hover\\:font-thin:hover {\n  font-weight: 200;\n}\n\n.hover\\:font-light:hover {\n  font-weight: 300;\n}\n\n.hover\\:font-normal:hover {\n  font-weight: 400;\n}\n\n.hover\\:font-medium:hover {\n  font-weight: 500;\n}\n\n.hover\\:font-semibold:hover {\n  font-weight: 600;\n}\n\n.hover\\:font-bold:hover {\n  font-weight: 700;\n}\n\n.hover\\:font-extrabold:hover {\n  font-weight: 800;\n}\n\n.hover\\:font-black:hover {\n  font-weight: 900;\n}\n\n.h-0 {\n  height: 0;\n}\n\n.h-1 {\n  height: 2px;\n}\n\n.h-2 {\n  height: 4px;\n}\n\n.h-3 {\n  height: 8px;\n}\n\n.h-4 {\n  height: 16px;\n}\n\n.h-5 {\n  height: 24px;\n}\n\n.h-6 {\n  height: 32px;\n}\n\n.h-7 {\n  height: 36px;\n}\n\n.h-8 {\n  height: 48px;\n}\n\n.h-9 {\n  height: 64px;\n}\n\n.h-10 {\n  height: 96px;\n}\n\n.h-screen {\n  height: 100vh;\n}\n\n.h-auto {\n  height: auto;\n}\n\n.h-full {\n  height: 100%;\n}\n\n.h-px {\n  height: 1px;\n}\n\n.h-1\\/6 {\n  height: 16.666666667%;\n}\n\n.leading-none {\n  line-height: 1;\n}\n\n.leading-tight {\n  line-height: 1.25;\n}\n\n.leading-normal {\n  line-height: 1.5;\n}\n\n.leading-loose {\n  line-height: 2;\n}\n\n.m-0 {\n  margin: 0;\n}\n\n.m-1 {\n  margin: 2px;\n}\n\n.m-2 {\n  margin: 4px;\n}\n\n.m-3 {\n  margin: 8px;\n}\n\n.m-4 {\n  margin: 16px;\n}\n\n.m-5 {\n  margin: 24px;\n}\n\n.m-6 {\n  margin: 32px;\n}\n\n.m-7 {\n  margin: 36px;\n}\n\n.m-8 {\n  margin: 48px;\n}\n\n.m-9 {\n  margin: 64px;\n}\n\n.m-10 {\n  margin: 96px;\n}\n\n.m-auto {\n  margin: auto;\n}\n\n.m-full {\n  margin: 100%;\n}\n\n.m-px {\n  margin: 1px;\n}\n\n.m-1\\/6 {\n  margin: 16.666666667%;\n}\n\n.my-0 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.mx-0 {\n  margin-left: 0;\n  margin-right: 0;\n}\n\n.my-1 {\n  margin-top: 2px;\n  margin-bottom: 2px;\n}\n\n.mx-1 {\n  margin-left: 2px;\n  margin-right: 2px;\n}\n\n.my-2 {\n  margin-top: 4px;\n  margin-bottom: 4px;\n}\n\n.mx-2 {\n  margin-left: 4px;\n  margin-right: 4px;\n}\n\n.my-3 {\n  margin-top: 8px;\n  margin-bottom: 8px;\n}\n\n.mx-3 {\n  margin-left: 8px;\n  margin-right: 8px;\n}\n\n.my-4 {\n  margin-top: 16px;\n  margin-bottom: 16px;\n}\n\n.mx-4 {\n  margin-left: 16px;\n  margin-right: 16px;\n}\n\n.my-5 {\n  margin-top: 24px;\n  margin-bottom: 24px;\n}\n\n.mx-5 {\n  margin-left: 24px;\n  margin-right: 24px;\n}\n\n.my-6 {\n  margin-top: 32px;\n  margin-bottom: 32px;\n}\n\n.mx-6 {\n  margin-left: 32px;\n  margin-right: 32px;\n}\n\n.my-7 {\n  margin-top: 36px;\n  margin-bottom: 36px;\n}\n\n.mx-7 {\n  margin-left: 36px;\n  margin-right: 36px;\n}\n\n.my-8 {\n  margin-top: 48px;\n  margin-bottom: 48px;\n}\n\n.mx-8 {\n  margin-left: 48px;\n  margin-right: 48px;\n}\n\n.my-9 {\n  margin-top: 64px;\n  margin-bottom: 64px;\n}\n\n.mx-9 {\n  margin-left: 64px;\n  margin-right: 64px;\n}\n\n.my-10 {\n  margin-top: 96px;\n  margin-bottom: 96px;\n}\n\n.mx-10 {\n  margin-left: 96px;\n  margin-right: 96px;\n}\n\n.my-auto {\n  margin-top: auto;\n  margin-bottom: auto;\n}\n\n.mx-auto {\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.my-full {\n  margin-top: 100%;\n  margin-bottom: 100%;\n}\n\n.mx-full {\n  margin-left: 100%;\n  margin-right: 100%;\n}\n\n.my-px {\n  margin-top: 1px;\n  margin-bottom: 1px;\n}\n\n.mx-px {\n  margin-left: 1px;\n  margin-right: 1px;\n}\n\n.my-1\\/6 {\n  margin-top: 16.666666667%;\n  margin-bottom: 16.666666667%;\n}\n\n.mx-1\\/6 {\n  margin-left: 16.666666667%;\n  margin-right: 16.666666667%;\n}\n\n.mt-0 {\n  margin-top: 0;\n}\n\n.mr-0 {\n  margin-right: 0;\n}\n\n.mb-0 {\n  margin-bottom: 0;\n}\n\n.ml-0 {\n  margin-left: 0;\n}\n\n.mt-1 {\n  margin-top: 2px;\n}\n\n.mr-1 {\n  margin-right: 2px;\n}\n\n.mb-1 {\n  margin-bottom: 2px;\n}\n\n.ml-1 {\n  margin-left: 2px;\n}\n\n.mt-2 {\n  margin-top: 4px;\n}\n\n.mr-2 {\n  margin-right: 4px;\n}\n\n.mb-2 {\n  margin-bottom: 4px;\n}\n\n.ml-2 {\n  margin-left: 4px;\n}\n\n.mt-3 {\n  margin-top: 8px;\n}\n\n.mr-3 {\n  margin-right: 8px;\n}\n\n.mb-3 {\n  margin-bottom: 8px;\n}\n\n.ml-3 {\n  margin-left: 8px;\n}\n\n.mt-4 {\n  margin-top: 16px;\n}\n\n.mr-4 {\n  margin-right: 16px;\n}\n\n.mb-4 {\n  margin-bottom: 16px;\n}\n\n.ml-4 {\n  margin-left: 16px;\n}\n\n.mt-5 {\n  margin-top: 24px;\n}\n\n.mr-5 {\n  margin-right: 24px;\n}\n\n.mb-5 {\n  margin-bottom: 24px;\n}\n\n.ml-5 {\n  margin-left: 24px;\n}\n\n.mt-6 {\n  margin-top: 32px;\n}\n\n.mr-6 {\n  margin-right: 32px;\n}\n\n.mb-6 {\n  margin-bottom: 32px;\n}\n\n.ml-6 {\n  margin-left: 32px;\n}\n\n.mt-7 {\n  margin-top: 36px;\n}\n\n.mr-7 {\n  margin-right: 36px;\n}\n\n.mb-7 {\n  margin-bottom: 36px;\n}\n\n.ml-7 {\n  margin-left: 36px;\n}\n\n.mt-8 {\n  margin-top: 48px;\n}\n\n.mr-8 {\n  margin-right: 48px;\n}\n\n.mb-8 {\n  margin-bottom: 48px;\n}\n\n.ml-8 {\n  margin-left: 48px;\n}\n\n.mt-9 {\n  margin-top: 64px;\n}\n\n.mr-9 {\n  margin-right: 64px;\n}\n\n.mb-9 {\n  margin-bottom: 64px;\n}\n\n.ml-9 {\n  margin-left: 64px;\n}\n\n.mt-10 {\n  margin-top: 96px;\n}\n\n.mr-10 {\n  margin-right: 96px;\n}\n\n.mb-10 {\n  margin-bottom: 96px;\n}\n\n.ml-10 {\n  margin-left: 96px;\n}\n\n.mt-auto {\n  margin-top: auto;\n}\n\n.mr-auto {\n  margin-right: auto;\n}\n\n.mb-auto {\n  margin-bottom: auto;\n}\n\n.ml-auto {\n  margin-left: auto;\n}\n\n.mt-full {\n  margin-top: 100%;\n}\n\n.mr-full {\n  margin-right: 100%;\n}\n\n.mb-full {\n  margin-bottom: 100%;\n}\n\n.ml-full {\n  margin-left: 100%;\n}\n\n.mt-px {\n  margin-top: 1px;\n}\n\n.mr-px {\n  margin-right: 1px;\n}\n\n.mb-px {\n  margin-bottom: 1px;\n}\n\n.ml-px {\n  margin-left: 1px;\n}\n\n.mt-1\\/6 {\n  margin-top: 16.666666667%;\n}\n\n.mr-1\\/6 {\n  margin-right: 16.666666667%;\n}\n\n.mb-1\\/6 {\n  margin-bottom: 16.666666667%;\n}\n\n.ml-1\\/6 {\n  margin-left: 16.666666667%;\n}\n\n.max-h-0 {\n  max-height: 0;\n}\n\n.max-h-1 {\n  max-height: 2px;\n}\n\n.max-h-2 {\n  max-height: 4px;\n}\n\n.max-h-3 {\n  max-height: 8px;\n}\n\n.max-h-4 {\n  max-height: 16px;\n}\n\n.max-h-5 {\n  max-height: 24px;\n}\n\n.max-h-6 {\n  max-height: 32px;\n}\n\n.max-h-7 {\n  max-height: 36px;\n}\n\n.max-h-8 {\n  max-height: 48px;\n}\n\n.max-h-9 {\n  max-height: 64px;\n}\n\n.max-h-10 {\n  max-height: 96px;\n}\n\n.max-h-screen {\n  max-height: 100vh;\n}\n\n.max-h-auto {\n  max-height: auto;\n}\n\n.max-h-full {\n  max-height: 100%;\n}\n\n.max-h-px {\n  max-height: 1px;\n}\n\n.max-h-1\\/6 {\n  max-height: 16.666666667%;\n}\n\n.max-w-0 {\n  max-width: 0;\n}\n\n.max-w-1 {\n  max-width: 2px;\n}\n\n.max-w-2 {\n  max-width: 4px;\n}\n\n.max-w-3 {\n  max-width: 8px;\n}\n\n.max-w-4 {\n  max-width: 16px;\n}\n\n.max-w-5 {\n  max-width: 24px;\n}\n\n.max-w-6 {\n  max-width: 32px;\n}\n\n.max-w-7 {\n  max-width: 36px;\n}\n\n.max-w-8 {\n  max-width: 48px;\n}\n\n.max-w-9 {\n  max-width: 64px;\n}\n\n.max-w-10 {\n  max-width: 96px;\n}\n\n.max-w-auto {\n  max-width: auto;\n}\n\n.max-w-full {\n  max-width: 100%;\n}\n\n.max-w-px {\n  max-width: 1px;\n}\n\n.max-w-1\\/6 {\n  max-width: 16.666666667%;\n}\n\n.min-h-0 {\n  min-height: 0;\n}\n\n.min-h-1 {\n  min-height: 2px;\n}\n\n.min-h-2 {\n  min-height: 4px;\n}\n\n.min-h-3 {\n  min-height: 8px;\n}\n\n.min-h-4 {\n  min-height: 16px;\n}\n\n.min-h-5 {\n  min-height: 24px;\n}\n\n.min-h-6 {\n  min-height: 32px;\n}\n\n.min-h-7 {\n  min-height: 36px;\n}\n\n.min-h-8 {\n  min-height: 48px;\n}\n\n.min-h-9 {\n  min-height: 64px;\n}\n\n.min-h-10 {\n  min-height: 96px;\n}\n\n.min-h-screen {\n  min-height: 100vh;\n}\n\n.min-h-auto {\n  min-height: auto;\n}\n\n.min-h-full {\n  min-height: 100%;\n}\n\n.min-h-px {\n  min-height: 1px;\n}\n\n.min-h-1\\/6 {\n  min-height: 16.666666667%;\n}\n\n.min-w-0 {\n  min-width: 0;\n}\n\n.min-w-1 {\n  min-width: 2px;\n}\n\n.min-w-2 {\n  min-width: 4px;\n}\n\n.min-w-3 {\n  min-width: 8px;\n}\n\n.min-w-4 {\n  min-width: 16px;\n}\n\n.min-w-5 {\n  min-width: 24px;\n}\n\n.min-w-6 {\n  min-width: 32px;\n}\n\n.min-w-7 {\n  min-width: 36px;\n}\n\n.min-w-8 {\n  min-width: 48px;\n}\n\n.min-w-9 {\n  min-width: 64px;\n}\n\n.min-w-10 {\n  min-width: 96px;\n}\n\n.min-w-auto {\n  min-width: auto;\n}\n\n.min-w-full {\n  min-width: 100%;\n}\n\n.min-w-px {\n  min-width: 1px;\n}\n\n.min-w-1\\/6 {\n  min-width: 16.666666667%;\n}\n\n.-m-0 {\n  margin: 0;\n}\n\n.-m-1 {\n  margin: -2px;\n}\n\n.-m-2 {\n  margin: -4px;\n}\n\n.-m-3 {\n  margin: -8px;\n}\n\n.-m-4 {\n  margin: -16px;\n}\n\n.-m-5 {\n  margin: -24px;\n}\n\n.-m-6 {\n  margin: -32px;\n}\n\n.-m-7 {\n  margin: -36px;\n}\n\n.-m-8 {\n  margin: -48px;\n}\n\n.-m-9 {\n  margin: -64px;\n}\n\n.-m-10 {\n  margin: -96px;\n}\n\n.-m-auto {\n  margin: -auto;\n}\n\n.-m-full {\n  margin: -100%;\n}\n\n.-m-px {\n  margin: -1px;\n}\n\n.-m-1\\/6 {\n  margin: -16.666666667%;\n}\n\n.-my-0 {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n\n.-mx-0 {\n  margin-left: 0;\n  margin-right: 0;\n}\n\n.-my-1 {\n  margin-top: -2px;\n  margin-bottom: -2px;\n}\n\n.-mx-1 {\n  margin-left: -2px;\n  margin-right: -2px;\n}\n\n.-my-2 {\n  margin-top: -4px;\n  margin-bottom: -4px;\n}\n\n.-mx-2 {\n  margin-left: -4px;\n  margin-right: -4px;\n}\n\n.-my-3 {\n  margin-top: -8px;\n  margin-bottom: -8px;\n}\n\n.-mx-3 {\n  margin-left: -8px;\n  margin-right: -8px;\n}\n\n.-my-4 {\n  margin-top: -16px;\n  margin-bottom: -16px;\n}\n\n.-mx-4 {\n  margin-left: -16px;\n  margin-right: -16px;\n}\n\n.-my-5 {\n  margin-top: -24px;\n  margin-bottom: -24px;\n}\n\n.-mx-5 {\n  margin-left: -24px;\n  margin-right: -24px;\n}\n\n.-my-6 {\n  margin-top: -32px;\n  margin-bottom: -32px;\n}\n\n.-mx-6 {\n  margin-left: -32px;\n  margin-right: -32px;\n}\n\n.-my-7 {\n  margin-top: -36px;\n  margin-bottom: -36px;\n}\n\n.-mx-7 {\n  margin-left: -36px;\n  margin-right: -36px;\n}\n\n.-my-8 {\n  margin-top: -48px;\n  margin-bottom: -48px;\n}\n\n.-mx-8 {\n  margin-left: -48px;\n  margin-right: -48px;\n}\n\n.-my-9 {\n  margin-top: -64px;\n  margin-bottom: -64px;\n}\n\n.-mx-9 {\n  margin-left: -64px;\n  margin-right: -64px;\n}\n\n.-my-10 {\n  margin-top: -96px;\n  margin-bottom: -96px;\n}\n\n.-mx-10 {\n  margin-left: -96px;\n  margin-right: -96px;\n}\n\n.-my-auto {\n  margin-top: -auto;\n  margin-bottom: -auto;\n}\n\n.-mx-auto {\n  margin-left: -auto;\n  margin-right: -auto;\n}\n\n.-my-full {\n  margin-top: -100%;\n  margin-bottom: -100%;\n}\n\n.-mx-full {\n  margin-left: -100%;\n  margin-right: -100%;\n}\n\n.-my-px {\n  margin-top: -1px;\n  margin-bottom: -1px;\n}\n\n.-mx-px {\n  margin-left: -1px;\n  margin-right: -1px;\n}\n\n.-my-1\\/6 {\n  margin-top: -16.666666667%;\n  margin-bottom: -16.666666667%;\n}\n\n.-mx-1\\/6 {\n  margin-left: -16.666666667%;\n  margin-right: -16.666666667%;\n}\n\n.-mt-0 {\n  margin-top: 0;\n}\n\n.-mr-0 {\n  margin-right: 0;\n}\n\n.-mb-0 {\n  margin-bottom: 0;\n}\n\n.-ml-0 {\n  margin-left: 0;\n}\n\n.-mt-1 {\n  margin-top: -2px;\n}\n\n.-mr-1 {\n  margin-right: -2px;\n}\n\n.-mb-1 {\n  margin-bottom: -2px;\n}\n\n.-ml-1 {\n  margin-left: -2px;\n}\n\n.-mt-2 {\n  margin-top: -4px;\n}\n\n.-mr-2 {\n  margin-right: -4px;\n}\n\n.-mb-2 {\n  margin-bottom: -4px;\n}\n\n.-ml-2 {\n  margin-left: -4px;\n}\n\n.-mt-3 {\n  margin-top: -8px;\n}\n\n.-mr-3 {\n  margin-right: -8px;\n}\n\n.-mb-3 {\n  margin-bottom: -8px;\n}\n\n.-ml-3 {\n  margin-left: -8px;\n}\n\n.-mt-4 {\n  margin-top: -16px;\n}\n\n.-mr-4 {\n  margin-right: -16px;\n}\n\n.-mb-4 {\n  margin-bottom: -16px;\n}\n\n.-ml-4 {\n  margin-left: -16px;\n}\n\n.-mt-5 {\n  margin-top: -24px;\n}\n\n.-mr-5 {\n  margin-right: -24px;\n}\n\n.-mb-5 {\n  margin-bottom: -24px;\n}\n\n.-ml-5 {\n  margin-left: -24px;\n}\n\n.-mt-6 {\n  margin-top: -32px;\n}\n\n.-mr-6 {\n  margin-right: -32px;\n}\n\n.-mb-6 {\n  margin-bottom: -32px;\n}\n\n.-ml-6 {\n  margin-left: -32px;\n}\n\n.-mt-7 {\n  margin-top: -36px;\n}\n\n.-mr-7 {\n  margin-right: -36px;\n}\n\n.-mb-7 {\n  margin-bottom: -36px;\n}\n\n.-ml-7 {\n  margin-left: -36px;\n}\n\n.-mt-8 {\n  margin-top: -48px;\n}\n\n.-mr-8 {\n  margin-right: -48px;\n}\n\n.-mb-8 {\n  margin-bottom: -48px;\n}\n\n.-ml-8 {\n  margin-left: -48px;\n}\n\n.-mt-9 {\n  margin-top: -64px;\n}\n\n.-mr-9 {\n  margin-right: -64px;\n}\n\n.-mb-9 {\n  margin-bottom: -64px;\n}\n\n.-ml-9 {\n  margin-left: -64px;\n}\n\n.-mt-10 {\n  margin-top: -96px;\n}\n\n.-mr-10 {\n  margin-right: -96px;\n}\n\n.-mb-10 {\n  margin-bottom: -96px;\n}\n\n.-ml-10 {\n  margin-left: -96px;\n}\n\n.-mt-auto {\n  margin-top: -auto;\n}\n\n.-mr-auto {\n  margin-right: -auto;\n}\n\n.-mb-auto {\n  margin-bottom: -auto;\n}\n\n.-ml-auto {\n  margin-left: -auto;\n}\n\n.-mt-full {\n  margin-top: -100%;\n}\n\n.-mr-full {\n  margin-right: -100%;\n}\n\n.-mb-full {\n  margin-bottom: -100%;\n}\n\n.-ml-full {\n  margin-left: -100%;\n}\n\n.-mt-px {\n  margin-top: -1px;\n}\n\n.-mr-px {\n  margin-right: -1px;\n}\n\n.-mb-px {\n  margin-bottom: -1px;\n}\n\n.-ml-px {\n  margin-left: -1px;\n}\n\n.-mt-1\\/6 {\n  margin-top: -16.666666667%;\n}\n\n.-mr-1\\/6 {\n  margin-right: -16.666666667%;\n}\n\n.-mb-1\\/6 {\n  margin-bottom: -16.666666667%;\n}\n\n.-ml-1\\/6 {\n  margin-left: -16.666666667%;\n}\n\n.opacity-0 {\n  opacity: 0;\n}\n\n.opacity-25 {\n  opacity: .25;\n}\n\n.opacity-50 {\n  opacity: .5;\n}\n\n.opacity-75 {\n  opacity: .75;\n}\n\n.opacity-100 {\n  opacity: 1;\n}\n\n.outline-none {\n  outline: 0;\n}\n\n.focus\\:outline-none:focus {\n  outline: 0;\n}\n\n.overflow-auto {\n  overflow: auto;\n}\n\n.overflow-hidden {\n  overflow: hidden;\n}\n\n.overflow-visible {\n  overflow: visible;\n}\n\n.overflow-scroll {\n  overflow: scroll;\n}\n\n.overflow-x-auto {\n  overflow-x: auto;\n}\n\n.overflow-y-auto {\n  overflow-y: auto;\n}\n\n.overflow-x-hidden {\n  overflow-x: hidden;\n}\n\n.overflow-y-hidden {\n  overflow-y: hidden;\n}\n\n.overflow-x-visible {\n  overflow-x: visible;\n}\n\n.overflow-y-visible {\n  overflow-y: visible;\n}\n\n.overflow-x-scroll {\n  overflow-x: scroll;\n}\n\n.overflow-y-scroll {\n  overflow-y: scroll;\n}\n\n.scrolling-touch {\n  -webkit-overflow-scrolling: touch;\n}\n\n.scrolling-auto {\n  -webkit-overflow-scrolling: auto;\n}\n\n.p-0 {\n  padding: 0;\n}\n\n.p-1 {\n  padding: 2px;\n}\n\n.p-2 {\n  padding: 4px;\n}\n\n.p-3 {\n  padding: 8px;\n}\n\n.p-4 {\n  padding: 16px;\n}\n\n.p-5 {\n  padding: 24px;\n}\n\n.p-6 {\n  padding: 32px;\n}\n\n.p-7 {\n  padding: 36px;\n}\n\n.p-8 {\n  padding: 48px;\n}\n\n.p-9 {\n  padding: 64px;\n}\n\n.p-10 {\n  padding: 96px;\n}\n\n.p-auto {\n  padding: auto;\n}\n\n.p-full {\n  padding: 100%;\n}\n\n.p-px {\n  padding: 1px;\n}\n\n.p-1\\/6 {\n  padding: 16.666666667%;\n}\n\n.py-0 {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n\n.px-0 {\n  padding-left: 0;\n  padding-right: 0;\n}\n\n.py-1 {\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n\n.px-1 {\n  padding-left: 2px;\n  padding-right: 2px;\n}\n\n.py-2 {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n.px-2 {\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n.py-3 {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n\n.px-3 {\n  padding-left: 8px;\n  padding-right: 8px;\n}\n\n.py-4 {\n  padding-top: 16px;\n  padding-bottom: 16px;\n}\n\n.px-4 {\n  padding-left: 16px;\n  padding-right: 16px;\n}\n\n.py-5 {\n  padding-top: 24px;\n  padding-bottom: 24px;\n}\n\n.px-5 {\n  padding-left: 24px;\n  padding-right: 24px;\n}\n\n.py-6 {\n  padding-top: 32px;\n  padding-bottom: 32px;\n}\n\n.px-6 {\n  padding-left: 32px;\n  padding-right: 32px;\n}\n\n.py-7 {\n  padding-top: 36px;\n  padding-bottom: 36px;\n}\n\n.px-7 {\n  padding-left: 36px;\n  padding-right: 36px;\n}\n\n.py-8 {\n  padding-top: 48px;\n  padding-bottom: 48px;\n}\n\n.px-8 {\n  padding-left: 48px;\n  padding-right: 48px;\n}\n\n.py-9 {\n  padding-top: 64px;\n  padding-bottom: 64px;\n}\n\n.px-9 {\n  padding-left: 64px;\n  padding-right: 64px;\n}\n\n.py-10 {\n  padding-top: 96px;\n  padding-bottom: 96px;\n}\n\n.px-10 {\n  padding-left: 96px;\n  padding-right: 96px;\n}\n\n.py-auto {\n  padding-top: auto;\n  padding-bottom: auto;\n}\n\n.px-auto {\n  padding-left: auto;\n  padding-right: auto;\n}\n\n.py-full {\n  padding-top: 100%;\n  padding-bottom: 100%;\n}\n\n.px-full {\n  padding-left: 100%;\n  padding-right: 100%;\n}\n\n.py-px {\n  padding-top: 1px;\n  padding-bottom: 1px;\n}\n\n.px-px {\n  padding-left: 1px;\n  padding-right: 1px;\n}\n\n.py-1\\/6 {\n  padding-top: 16.666666667%;\n  padding-bottom: 16.666666667%;\n}\n\n.px-1\\/6 {\n  padding-left: 16.666666667%;\n  padding-right: 16.666666667%;\n}\n\n.pt-0 {\n  padding-top: 0;\n}\n\n.pr-0 {\n  padding-right: 0;\n}\n\n.pb-0 {\n  padding-bottom: 0;\n}\n\n.pl-0 {\n  padding-left: 0;\n}\n\n.pt-1 {\n  padding-top: 2px;\n}\n\n.pr-1 {\n  padding-right: 2px;\n}\n\n.pb-1 {\n  padding-bottom: 2px;\n}\n\n.pl-1 {\n  padding-left: 2px;\n}\n\n.pt-2 {\n  padding-top: 4px;\n}\n\n.pr-2 {\n  padding-right: 4px;\n}\n\n.pb-2 {\n  padding-bottom: 4px;\n}\n\n.pl-2 {\n  padding-left: 4px;\n}\n\n.pt-3 {\n  padding-top: 8px;\n}\n\n.pr-3 {\n  padding-right: 8px;\n}\n\n.pb-3 {\n  padding-bottom: 8px;\n}\n\n.pl-3 {\n  padding-left: 8px;\n}\n\n.pt-4 {\n  padding-top: 16px;\n}\n\n.pr-4 {\n  padding-right: 16px;\n}\n\n.pb-4 {\n  padding-bottom: 16px;\n}\n\n.pl-4 {\n  padding-left: 16px;\n}\n\n.pt-5 {\n  padding-top: 24px;\n}\n\n.pr-5 {\n  padding-right: 24px;\n}\n\n.pb-5 {\n  padding-bottom: 24px;\n}\n\n.pl-5 {\n  padding-left: 24px;\n}\n\n.pt-6 {\n  padding-top: 32px;\n}\n\n.pr-6 {\n  padding-right: 32px;\n}\n\n.pb-6 {\n  padding-bottom: 32px;\n}\n\n.pl-6 {\n  padding-left: 32px;\n}\n\n.pt-7 {\n  padding-top: 36px;\n}\n\n.pr-7 {\n  padding-right: 36px;\n}\n\n.pb-7 {\n  padding-bottom: 36px;\n}\n\n.pl-7 {\n  padding-left: 36px;\n}\n\n.pt-8 {\n  padding-top: 48px;\n}\n\n.pr-8 {\n  padding-right: 48px;\n}\n\n.pb-8 {\n  padding-bottom: 48px;\n}\n\n.pl-8 {\n  padding-left: 48px;\n}\n\n.pt-9 {\n  padding-top: 64px;\n}\n\n.pr-9 {\n  padding-right: 64px;\n}\n\n.pb-9 {\n  padding-bottom: 64px;\n}\n\n.pl-9 {\n  padding-left: 64px;\n}\n\n.pt-10 {\n  padding-top: 96px;\n}\n\n.pr-10 {\n  padding-right: 96px;\n}\n\n.pb-10 {\n  padding-bottom: 96px;\n}\n\n.pl-10 {\n  padding-left: 96px;\n}\n\n.pt-auto {\n  padding-top: auto;\n}\n\n.pr-auto {\n  padding-right: auto;\n}\n\n.pb-auto {\n  padding-bottom: auto;\n}\n\n.pl-auto {\n  padding-left: auto;\n}\n\n.pt-full {\n  padding-top: 100%;\n}\n\n.pr-full {\n  padding-right: 100%;\n}\n\n.pb-full {\n  padding-bottom: 100%;\n}\n\n.pl-full {\n  padding-left: 100%;\n}\n\n.pt-px {\n  padding-top: 1px;\n}\n\n.pr-px {\n  padding-right: 1px;\n}\n\n.pb-px {\n  padding-bottom: 1px;\n}\n\n.pl-px {\n  padding-left: 1px;\n}\n\n.pt-1\\/6 {\n  padding-top: 16.666666667%;\n}\n\n.pr-1\\/6 {\n  padding-right: 16.666666667%;\n}\n\n.pb-1\\/6 {\n  padding-bottom: 16.666666667%;\n}\n\n.pl-1\\/6 {\n  padding-left: 16.666666667%;\n}\n\n.pointer-events-none {\n  pointer-events: none;\n}\n\n.pointer-events-auto {\n  pointer-events: auto;\n}\n\n.static {\n  position: static;\n}\n\n.fixed {\n  position: fixed;\n}\n\n.absolute {\n  position: absolute;\n}\n\n.relative {\n  position: relative;\n}\n\n.sticky {\n  position: sticky;\n}\n\n.pin-none {\n  top: auto;\n  right: auto;\n  bottom: auto;\n  left: auto;\n}\n\n.pin {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n\n.pin-y {\n  top: 0;\n  bottom: 0;\n}\n\n.pin-x {\n  right: 0;\n  left: 0;\n}\n\n.pin-t {\n  top: 0;\n}\n\n.pin-r {\n  right: 0;\n}\n\n.pin-b {\n  bottom: 0;\n}\n\n.pin-l {\n  left: 0;\n}\n\n.resize-none {\n  resize: none;\n}\n\n.resize-y {\n  resize: vertical;\n}\n\n.resize-x {\n  resize: horizontal;\n}\n\n.resize {\n  resize: both;\n}\n\n.shadow {\n  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .1);\n}\n\n.shadow-md {\n  box-shadow:  0 8px 20px 0 rgba(0, 0, 0, .42);\n}\n\n.shadow-none {\n  box-shadow: none;\n}\n\n.fill-current {\n  fill: currentColor;\n}\n\n.stroke-current {\n  stroke: currentColor;\n}\n\n.table-auto {\n  table-layout: auto;\n}\n\n.table-fixed {\n  table-layout: fixed;\n}\n\n.text-left {\n  text-align: left;\n}\n\n.text-center {\n  text-align: center;\n}\n\n.text-right {\n  text-align: right;\n}\n\n.text-justify {\n  text-align: justify;\n}\n\n.text-inherit {\n  color: inherit;\n}\n\n.text-transparent {\n  color: transparent;\n}\n\n.text-black {\n  color: #282828;\n}\n\n.text-white {\n  color: #fff;\n}\n\n.text-grey-lighter {\n  color: #f3f3f7;\n}\n\n.text-grey-light {\n  color: #e7e7ec;\n}\n\n.text-grey {\n  color: #c2c2c6;\n}\n\n.text-purple-lighter {\n  color: #ccc2e9;\n}\n\n.text-purple-light {\n  color: #87809b;\n}\n\n.text-purple {\n  color: #8360d6;\n}\n\n.text-purple-bright {\n  color: #4c29b0;\n}\n\n.text-purple-dark {\n  color: #453f56;\n}\n\n.text-purple-dark-10 {\n  color: rgba(69, 63, 86, .1);\n}\n\n.text-purple-darker {\n  color: #2a2538;\n}\n\n.hover\\:text-inherit:hover {\n  color: inherit;\n}\n\n.hover\\:text-transparent:hover {\n  color: transparent;\n}\n\n.hover\\:text-black:hover {\n  color: #282828;\n}\n\n.hover\\:text-white:hover {\n  color: #fff;\n}\n\n.hover\\:text-grey-lighter:hover {\n  color: #f3f3f7;\n}\n\n.hover\\:text-grey-light:hover {\n  color: #e7e7ec;\n}\n\n.hover\\:text-grey:hover {\n  color: #c2c2c6;\n}\n\n.hover\\:text-purple-lighter:hover {\n  color: #ccc2e9;\n}\n\n.hover\\:text-purple-light:hover {\n  color: #87809b;\n}\n\n.hover\\:text-purple:hover {\n  color: #8360d6;\n}\n\n.hover\\:text-purple-bright:hover {\n  color: #4c29b0;\n}\n\n.hover\\:text-purple-dark:hover {\n  color: #453f56;\n}\n\n.hover\\:text-purple-dark-10:hover {\n  color: rgba(69, 63, 86, .1);\n}\n\n.hover\\:text-purple-darker:hover {\n  color: #2a2538;\n}\n\n.text-sm {\n  font-size: 1.4rem;\n}\n\n.text-base {\n  font-size: 1.6rem;\n}\n\n.italic {\n  font-style: italic;\n}\n\n.roman {\n  font-style: normal;\n}\n\n.uppercase {\n  text-transform: uppercase;\n}\n\n.lowercase {\n  text-transform: lowercase;\n}\n\n.capitalize {\n  text-transform: capitalize;\n}\n\n.normal-case {\n  text-transform: none;\n}\n\n.underline {\n  text-decoration: underline;\n}\n\n.line-through {\n  text-decoration: line-through;\n}\n\n.no-underline {\n  text-decoration: none;\n}\n\n.antialiased {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.subpixel-antialiased {\n  -webkit-font-smoothing: auto;\n  -moz-osx-font-smoothing: auto;\n}\n\n.hover\\:italic:hover {\n  font-style: italic;\n}\n\n.hover\\:roman:hover {\n  font-style: normal;\n}\n\n.hover\\:uppercase:hover {\n  text-transform: uppercase;\n}\n\n.hover\\:lowercase:hover {\n  text-transform: lowercase;\n}\n\n.hover\\:capitalize:hover {\n  text-transform: capitalize;\n}\n\n.hover\\:normal-case:hover {\n  text-transform: none;\n}\n\n.hover\\:underline:hover {\n  text-decoration: underline;\n}\n\n.hover\\:line-through:hover {\n  text-decoration: line-through;\n}\n\n.hover\\:no-underline:hover {\n  text-decoration: none;\n}\n\n.hover\\:antialiased:hover {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.hover\\:subpixel-antialiased:hover {\n  -webkit-font-smoothing: auto;\n  -moz-osx-font-smoothing: auto;\n}\n\n.tracking-tight {\n  letter-spacing: -0.05em;\n}\n\n.tracking-normal {\n  letter-spacing: 0;\n}\n\n.tracking-wide {\n  letter-spacing: .05em;\n}\n\n.select-none {\n  user-select: none;\n}\n\n.select-text {\n  user-select: text;\n}\n\n.align-baseline {\n  vertical-align: baseline;\n}\n\n.align-top {\n  vertical-align: top;\n}\n\n.align-middle {\n  vertical-align: middle;\n}\n\n.align-bottom {\n  vertical-align: bottom;\n}\n\n.align-text-top {\n  vertical-align: text-top;\n}\n\n.align-text-bottom {\n  vertical-align: text-bottom;\n}\n\n.visible {\n  visibility: visible;\n}\n\n.invisible {\n  visibility: hidden;\n}\n\n.whitespace-normal {\n  white-space: normal;\n}\n\n.whitespace-no-wrap {\n  white-space: nowrap;\n}\n\n.whitespace-pre {\n  white-space: pre;\n}\n\n.whitespace-pre-line {\n  white-space: pre-line;\n}\n\n.whitespace-pre-wrap {\n  white-space: pre-wrap;\n}\n\n.break-words {\n  word-wrap: break-word;\n}\n\n.break-normal {\n  word-wrap: normal;\n}\n\n.truncate {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n\n.w-0 {\n  width: 0;\n}\n\n.w-1 {\n  width: 2px;\n}\n\n.w-2 {\n  width: 4px;\n}\n\n.w-3 {\n  width: 8px;\n}\n\n.w-4 {\n  width: 16px;\n}\n\n.w-5 {\n  width: 24px;\n}\n\n.w-6 {\n  width: 32px;\n}\n\n.w-7 {\n  width: 36px;\n}\n\n.w-8 {\n  width: 48px;\n}\n\n.w-9 {\n  width: 64px;\n}\n\n.w-10 {\n  width: 96px;\n}\n\n.w-screen {\n  width: 100vw;\n}\n\n.w-auto {\n  width: auto;\n}\n\n.w-full {\n  width: 100%;\n}\n\n.w-px {\n  width: 1px;\n}\n\n.w-1\\/6 {\n  width: 16.666666667%;\n}\n\n.z-0 {\n  z-index: 0;\n}\n\n.z-10 {\n  z-index: 10;\n}\n\n.z-20 {\n  z-index: 20;\n}\n\n.z-30 {\n  z-index: 30;\n}\n\n.z-40 {\n  z-index: 40;\n}\n\n.z-50 {\n  z-index: 50;\n}\n\n.z-auto {\n  z-index: auto;\n}\n\n.bg-black-10 {\n  background-color: rgba(40, 40, 40, .1);\n}\n\n.bg-white-10 {\n  background-color: rgba(255, 255, 255, .1);\n}\n\n.bg-grey-lighter-10 {\n  background-color: rgba(243, 243, 247, .1);\n}\n\n.bg-grey-light-10 {\n  background-color: rgba(231, 231, 236, .1);\n}\n\n.bg-grey-10 {\n  background-color: rgba(194, 194, 198, .1);\n}\n\n.bg-purple-lighter-10 {\n  background-color: rgba(204, 194, 233, .1);\n}\n\n.bg-purple-light-10 {\n  background-color: rgba(135, 128, 155, .1);\n}\n\n.bg-purple-10 {\n  background-color: rgba(131, 96, 214, .1);\n}\n\n.bg-purple-bright-10 {\n  background-color: rgba(76, 41, 176, .1);\n}\n\n.bg-purple-dark-10 {\n  background-color: rgba(69, 63, 86, .1);\n}\n\n.bg-purple-darker-10 {\n  background-color: rgba(42, 37, 56, .1);\n}\n\n.hover\\:bg-black-10:hover {\n  background-color: rgba(40, 40, 40, .1);\n}\n\n.hover\\:bg-white-10:hover {\n  background-color: rgba(255, 255, 255, .1);\n}\n\n.hover\\:bg-grey-lighter-10:hover {\n  background-color: rgba(243, 243, 247, .1);\n}\n\n.hover\\:bg-grey-light-10:hover {\n  background-color: rgba(231, 231, 236, .1);\n}\n\n.hover\\:bg-grey-10:hover {\n  background-color: rgba(194, 194, 198, .1);\n}\n\n.hover\\:bg-purple-lighter-10:hover {\n  background-color: rgba(204, 194, 233, .1);\n}\n\n.hover\\:bg-purple-light-10:hover {\n  background-color: rgba(135, 128, 155, .1);\n}\n\n.hover\\:bg-purple-10:hover {\n  background-color: rgba(131, 96, 214, .1);\n}\n\n.hover\\:bg-purple-bright-10:hover {\n  background-color: rgba(76, 41, 176, .1);\n}\n\n.hover\\:bg-purple-dark-10:hover {\n  background-color: rgba(69, 63, 86, .1);\n}\n\n.hover\\:bg-purple-darker-10:hover {\n  background-color: rgba(42, 37, 56, .1);\n}\n\n.focus\\:bg-black-10:focus {\n  background-color: rgba(40, 40, 40, .1);\n}\n\n.focus\\:bg-white-10:focus {\n  background-color: rgba(255, 255, 255, .1);\n}\n\n.focus\\:bg-grey-lighter-10:focus {\n  background-color: rgba(243, 243, 247, .1);\n}\n\n.focus\\:bg-grey-light-10:focus {\n  background-color: rgba(231, 231, 236, .1);\n}\n\n.focus\\:bg-grey-10:focus {\n  background-color: rgba(194, 194, 198, .1);\n}\n\n.focus\\:bg-purple-lighter-10:focus {\n  background-color: rgba(204, 194, 233, .1);\n}\n\n.focus\\:bg-purple-light-10:focus {\n  background-color: rgba(135, 128, 155, .1);\n}\n\n.focus\\:bg-purple-10:focus {\n  background-color: rgba(131, 96, 214, .1);\n}\n\n.focus\\:bg-purple-bright-10:focus {\n  background-color: rgba(76, 41, 176, .1);\n}\n\n.focus\\:bg-purple-dark-10:focus {\n  background-color: rgba(69, 63, 86, .1);\n}\n\n.focus\\:bg-purple-darker-10:focus {\n  background-color: rgba(42, 37, 56, .1);\n}\n\n.bg-black-30 {\n  background-color: rgba(40, 40, 40, .3);\n}\n\n.bg-white-30 {\n  background-color: rgba(255, 255, 255, .3);\n}\n\n.bg-grey-lighter-30 {\n  background-color: rgba(243, 243, 247, .3);\n}\n\n.bg-grey-light-30 {\n  background-color: rgba(231, 231, 236, .3);\n}\n\n.bg-grey-30 {\n  background-color: rgba(194, 194, 198, .3);\n}\n\n.bg-purple-lighter-30 {\n  background-color: rgba(204, 194, 233, .3);\n}\n\n.bg-purple-light-30 {\n  background-color: rgba(135, 128, 155, .3);\n}\n\n.bg-purple-30 {\n  background-color: rgba(131, 96, 214, .3);\n}\n\n.bg-purple-bright-30 {\n  background-color: rgba(76, 41, 176, .3);\n}\n\n.bg-purple-dark-30 {\n  background-color: rgba(69, 63, 86, .3);\n}\n\n.bg-purple-darker-30 {\n  background-color: rgba(42, 37, 56, .3);\n}\n\n.hover\\:bg-black-30:hover {\n  background-color: rgba(40, 40, 40, .3);\n}\n\n.hover\\:bg-white-30:hover {\n  background-color: rgba(255, 255, 255, .3);\n}\n\n.hover\\:bg-grey-lighter-30:hover {\n  background-color: rgba(243, 243, 247, .3);\n}\n\n.hover\\:bg-grey-light-30:hover {\n  background-color: rgba(231, 231, 236, .3);\n}\n\n.hover\\:bg-grey-30:hover {\n  background-color: rgba(194, 194, 198, .3);\n}\n\n.hover\\:bg-purple-lighter-30:hover {\n  background-color: rgba(204, 194, 233, .3);\n}\n\n.hover\\:bg-purple-light-30:hover {\n  background-color: rgba(135, 128, 155, .3);\n}\n\n.hover\\:bg-purple-30:hover {\n  background-color: rgba(131, 96, 214, .3);\n}\n\n.hover\\:bg-purple-bright-30:hover {\n  background-color: rgba(76, 41, 176, .3);\n}\n\n.hover\\:bg-purple-dark-30:hover {\n  background-color: rgba(69, 63, 86, .3);\n}\n\n.hover\\:bg-purple-darker-30:hover {\n  background-color: rgba(42, 37, 56, .3);\n}\n\n.focus\\:bg-black-30:focus {\n  background-color: rgba(40, 40, 40, .3);\n}\n\n.focus\\:bg-white-30:focus {\n  background-color: rgba(255, 255, 255, .3);\n}\n\n.focus\\:bg-grey-lighter-30:focus {\n  background-color: rgba(243, 243, 247, .3);\n}\n\n.focus\\:bg-grey-light-30:focus {\n  background-color: rgba(231, 231, 236, .3);\n}\n\n.focus\\:bg-grey-30:focus {\n  background-color: rgba(194, 194, 198, .3);\n}\n\n.focus\\:bg-purple-lighter-30:focus {\n  background-color: rgba(204, 194, 233, .3);\n}\n\n.focus\\:bg-purple-light-30:focus {\n  background-color: rgba(135, 128, 155, .3);\n}\n\n.focus\\:bg-purple-30:focus {\n  background-color: rgba(131, 96, 214, .3);\n}\n\n.focus\\:bg-purple-bright-30:focus {\n  background-color: rgba(76, 41, 176, .3);\n}\n\n.focus\\:bg-purple-dark-30:focus {\n  background-color: rgba(69, 63, 86, .3);\n}\n\n.focus\\:bg-purple-darker-30:focus {\n  background-color: rgba(42, 37, 56, .3);\n}\n\n.aspect-ratio-square {\n  padding-top: 100%;\n}\n\n.aspect-ratio-logo {\n  padding-top: 24.11%;\n}\n\n@media (min-width: 576px) {\n  .sm\\:list-reset {\n    list-style: none;\n    padding: 0;\n  }\n\n  .sm\\:appearance-none {\n    appearance: none;\n  }\n\n  .sm\\:bg-fixed {\n    background-attachment: fixed;\n  }\n\n  .sm\\:bg-local {\n    background-attachment: local;\n  }\n\n  .sm\\:bg-scroll {\n    background-attachment: scroll;\n  }\n\n  .sm\\:bg-inherit {\n    background-color: inherit;\n  }\n\n  .sm\\:bg-transparent {\n    background-color: transparent;\n  }\n\n  .sm\\:bg-black {\n    background-color: #282828;\n  }\n\n  .sm\\:bg-white {\n    background-color: #fff;\n  }\n\n  .sm\\:bg-grey-lighter {\n    background-color: #f3f3f7;\n  }\n\n  .sm\\:bg-grey-light {\n    background-color: #e7e7ec;\n  }\n\n  .sm\\:bg-grey {\n    background-color: #c2c2c6;\n  }\n\n  .sm\\:bg-purple-lighter {\n    background-color: #ccc2e9;\n  }\n\n  .sm\\:bg-purple-light {\n    background-color: #87809b;\n  }\n\n  .sm\\:bg-purple {\n    background-color: #8360d6;\n  }\n\n  .sm\\:bg-purple-bright {\n    background-color: #4c29b0;\n  }\n\n  .sm\\:bg-purple-dark {\n    background-color: #453f56;\n  }\n\n  .sm\\:bg-purple-dark-10 {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:bg-purple-darker {\n    background-color: #2a2538;\n  }\n\n  .sm\\:hover\\:bg-inherit:hover {\n    background-color: inherit;\n  }\n\n  .sm\\:hover\\:bg-transparent:hover {\n    background-color: transparent;\n  }\n\n  .sm\\:hover\\:bg-black:hover {\n    background-color: #282828;\n  }\n\n  .sm\\:hover\\:bg-white:hover {\n    background-color: #fff;\n  }\n\n  .sm\\:hover\\:bg-grey-lighter:hover {\n    background-color: #f3f3f7;\n  }\n\n  .sm\\:hover\\:bg-grey-light:hover {\n    background-color: #e7e7ec;\n  }\n\n  .sm\\:hover\\:bg-grey:hover {\n    background-color: #c2c2c6;\n  }\n\n  .sm\\:hover\\:bg-purple-lighter:hover {\n    background-color: #ccc2e9;\n  }\n\n  .sm\\:hover\\:bg-purple-light:hover {\n    background-color: #87809b;\n  }\n\n  .sm\\:hover\\:bg-purple:hover {\n    background-color: #8360d6;\n  }\n\n  .sm\\:hover\\:bg-purple-bright:hover {\n    background-color: #4c29b0;\n  }\n\n  .sm\\:hover\\:bg-purple-dark:hover {\n    background-color: #453f56;\n  }\n\n  .sm\\:hover\\:bg-purple-dark-10:hover {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:hover\\:bg-purple-darker:hover {\n    background-color: #2a2538;\n  }\n\n  .sm\\:focus\\:bg-inherit:focus {\n    background-color: inherit;\n  }\n\n  .sm\\:focus\\:bg-transparent:focus {\n    background-color: transparent;\n  }\n\n  .sm\\:focus\\:bg-black:focus {\n    background-color: #282828;\n  }\n\n  .sm\\:focus\\:bg-white:focus {\n    background-color: #fff;\n  }\n\n  .sm\\:focus\\:bg-grey-lighter:focus {\n    background-color: #f3f3f7;\n  }\n\n  .sm\\:focus\\:bg-grey-light:focus {\n    background-color: #e7e7ec;\n  }\n\n  .sm\\:focus\\:bg-grey:focus {\n    background-color: #c2c2c6;\n  }\n\n  .sm\\:focus\\:bg-purple-lighter:focus {\n    background-color: #ccc2e9;\n  }\n\n  .sm\\:focus\\:bg-purple-light:focus {\n    background-color: #87809b;\n  }\n\n  .sm\\:focus\\:bg-purple:focus {\n    background-color: #8360d6;\n  }\n\n  .sm\\:focus\\:bg-purple-bright:focus {\n    background-color: #4c29b0;\n  }\n\n  .sm\\:focus\\:bg-purple-dark:focus {\n    background-color: #453f56;\n  }\n\n  .sm\\:focus\\:bg-purple-dark-10:focus {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:focus\\:bg-purple-darker:focus {\n    background-color: #2a2538;\n  }\n\n  .sm\\:bg-bottom {\n    background-position: bottom;\n  }\n\n  .sm\\:bg-center {\n    background-position: center;\n  }\n\n  .sm\\:bg-left {\n    background-position: left;\n  }\n\n  .sm\\:bg-left-bottom {\n    background-position: left bottom;\n  }\n\n  .sm\\:bg-left-top {\n    background-position: left top;\n  }\n\n  .sm\\:bg-right {\n    background-position: right;\n  }\n\n  .sm\\:bg-right-bottom {\n    background-position: right bottom;\n  }\n\n  .sm\\:bg-right-top {\n    background-position: right top;\n  }\n\n  .sm\\:bg-top {\n    background-position: top;\n  }\n\n  .sm\\:bg-repeat {\n    background-repeat: repeat;\n  }\n\n  .sm\\:bg-no-repeat {\n    background-repeat: no-repeat;\n  }\n\n  .sm\\:bg-repeat-x {\n    background-repeat: repeat-x;\n  }\n\n  .sm\\:bg-repeat-y {\n    background-repeat: repeat-y;\n  }\n\n  .sm\\:bg-auto {\n    background-size: auto;\n  }\n\n  .sm\\:bg-cover {\n    background-size: cover;\n  }\n\n  .sm\\:bg-contain {\n    background-size: contain;\n  }\n\n  .sm\\:border-inherit {\n    border-color: inherit;\n  }\n\n  .sm\\:border-transparent {\n    border-color: transparent;\n  }\n\n  .sm\\:border-black {\n    border-color: #282828;\n  }\n\n  .sm\\:border-white {\n    border-color: #fff;\n  }\n\n  .sm\\:border-grey-lighter {\n    border-color: #f3f3f7;\n  }\n\n  .sm\\:border-grey-light {\n    border-color: #e7e7ec;\n  }\n\n  .sm\\:border-grey {\n    border-color: #c2c2c6;\n  }\n\n  .sm\\:border-purple-lighter {\n    border-color: #ccc2e9;\n  }\n\n  .sm\\:border-purple-light {\n    border-color: #87809b;\n  }\n\n  .sm\\:border-purple {\n    border-color: #8360d6;\n  }\n\n  .sm\\:border-purple-bright {\n    border-color: #4c29b0;\n  }\n\n  .sm\\:border-purple-dark {\n    border-color: #453f56;\n  }\n\n  .sm\\:border-purple-dark-10 {\n    border-color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:border-purple-darker {\n    border-color: #2a2538;\n  }\n\n  .sm\\:hover\\:border-inherit:hover {\n    border-color: inherit;\n  }\n\n  .sm\\:hover\\:border-transparent:hover {\n    border-color: transparent;\n  }\n\n  .sm\\:hover\\:border-black:hover {\n    border-color: #282828;\n  }\n\n  .sm\\:hover\\:border-white:hover {\n    border-color: #fff;\n  }\n\n  .sm\\:hover\\:border-grey-lighter:hover {\n    border-color: #f3f3f7;\n  }\n\n  .sm\\:hover\\:border-grey-light:hover {\n    border-color: #e7e7ec;\n  }\n\n  .sm\\:hover\\:border-grey:hover {\n    border-color: #c2c2c6;\n  }\n\n  .sm\\:hover\\:border-purple-lighter:hover {\n    border-color: #ccc2e9;\n  }\n\n  .sm\\:hover\\:border-purple-light:hover {\n    border-color: #87809b;\n  }\n\n  .sm\\:hover\\:border-purple:hover {\n    border-color: #8360d6;\n  }\n\n  .sm\\:hover\\:border-purple-bright:hover {\n    border-color: #4c29b0;\n  }\n\n  .sm\\:hover\\:border-purple-dark:hover {\n    border-color: #453f56;\n  }\n\n  .sm\\:hover\\:border-purple-dark-10:hover {\n    border-color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:hover\\:border-purple-darker:hover {\n    border-color: #2a2538;\n  }\n\n  .sm\\:rounded-none {\n    border-radius: 0;\n  }\n\n  .sm\\:rounded-sm {\n    border-radius: 2px;\n  }\n\n  .sm\\:rounded {\n    border-radius: 4px;\n  }\n\n  .sm\\:rounded-full {\n    border-radius: 9999px;\n  }\n\n  .sm\\:rounded-t-none {\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n  }\n\n  .sm\\:rounded-r-none {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n\n  .sm\\:rounded-b-none {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  .sm\\:rounded-l-none {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  .sm\\:rounded-t-sm {\n    border-top-left-radius: 2px;\n    border-top-right-radius: 2px;\n  }\n\n  .sm\\:rounded-r-sm {\n    border-top-right-radius: 2px;\n    border-bottom-right-radius: 2px;\n  }\n\n  .sm\\:rounded-b-sm {\n    border-bottom-right-radius: 2px;\n    border-bottom-left-radius: 2px;\n  }\n\n  .sm\\:rounded-l-sm {\n    border-top-left-radius: 2px;\n    border-bottom-left-radius: 2px;\n  }\n\n  .sm\\:rounded-t {\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n  }\n\n  .sm\\:rounded-r {\n    border-top-right-radius: 4px;\n    border-bottom-right-radius: 4px;\n  }\n\n  .sm\\:rounded-b {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n\n  .sm\\:rounded-l {\n    border-top-left-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n\n  .sm\\:rounded-t-full {\n    border-top-left-radius: 9999px;\n    border-top-right-radius: 9999px;\n  }\n\n  .sm\\:rounded-r-full {\n    border-top-right-radius: 9999px;\n    border-bottom-right-radius: 9999px;\n  }\n\n  .sm\\:rounded-b-full {\n    border-bottom-right-radius: 9999px;\n    border-bottom-left-radius: 9999px;\n  }\n\n  .sm\\:rounded-l-full {\n    border-top-left-radius: 9999px;\n    border-bottom-left-radius: 9999px;\n  }\n\n  .sm\\:rounded-tl-none {\n    border-top-left-radius: 0;\n  }\n\n  .sm\\:rounded-tr-none {\n    border-top-right-radius: 0;\n  }\n\n  .sm\\:rounded-br-none {\n    border-bottom-right-radius: 0;\n  }\n\n  .sm\\:rounded-bl-none {\n    border-bottom-left-radius: 0;\n  }\n\n  .sm\\:rounded-tl-sm {\n    border-top-left-radius: 2px;\n  }\n\n  .sm\\:rounded-tr-sm {\n    border-top-right-radius: 2px;\n  }\n\n  .sm\\:rounded-br-sm {\n    border-bottom-right-radius: 2px;\n  }\n\n  .sm\\:rounded-bl-sm {\n    border-bottom-left-radius: 2px;\n  }\n\n  .sm\\:rounded-tl {\n    border-top-left-radius: 4px;\n  }\n\n  .sm\\:rounded-tr {\n    border-top-right-radius: 4px;\n  }\n\n  .sm\\:rounded-br {\n    border-bottom-right-radius: 4px;\n  }\n\n  .sm\\:rounded-bl {\n    border-bottom-left-radius: 4px;\n  }\n\n  .sm\\:rounded-tl-full {\n    border-top-left-radius: 9999px;\n  }\n\n  .sm\\:rounded-tr-full {\n    border-top-right-radius: 9999px;\n  }\n\n  .sm\\:rounded-br-full {\n    border-bottom-right-radius: 9999px;\n  }\n\n  .sm\\:rounded-bl-full {\n    border-bottom-left-radius: 9999px;\n  }\n\n  .sm\\:border-solid {\n    border-style: solid;\n  }\n\n  .sm\\:border-dashed {\n    border-style: dashed;\n  }\n\n  .sm\\:border-dotted {\n    border-style: dotted;\n  }\n\n  .sm\\:border-none {\n    border-style: none;\n  }\n\n  .sm\\:border-0 {\n    border-width: 0;\n  }\n\n  .sm\\:border-2 {\n    border-width: 2px;\n  }\n\n  .sm\\:border-4 {\n    border-width: 4px;\n  }\n\n  .sm\\:border-8 {\n    border-width: 8px;\n  }\n\n  .sm\\:border {\n    border-width: 1px;\n  }\n\n  .sm\\:border-t-0 {\n    border-top-width: 0;\n  }\n\n  .sm\\:border-r-0 {\n    border-right-width: 0;\n  }\n\n  .sm\\:border-b-0 {\n    border-bottom-width: 0;\n  }\n\n  .sm\\:border-l-0 {\n    border-left-width: 0;\n  }\n\n  .sm\\:border-t-2 {\n    border-top-width: 2px;\n  }\n\n  .sm\\:border-r-2 {\n    border-right-width: 2px;\n  }\n\n  .sm\\:border-b-2 {\n    border-bottom-width: 2px;\n  }\n\n  .sm\\:border-l-2 {\n    border-left-width: 2px;\n  }\n\n  .sm\\:border-t-4 {\n    border-top-width: 4px;\n  }\n\n  .sm\\:border-r-4 {\n    border-right-width: 4px;\n  }\n\n  .sm\\:border-b-4 {\n    border-bottom-width: 4px;\n  }\n\n  .sm\\:border-l-4 {\n    border-left-width: 4px;\n  }\n\n  .sm\\:border-t-8 {\n    border-top-width: 8px;\n  }\n\n  .sm\\:border-r-8 {\n    border-right-width: 8px;\n  }\n\n  .sm\\:border-b-8 {\n    border-bottom-width: 8px;\n  }\n\n  .sm\\:border-l-8 {\n    border-left-width: 8px;\n  }\n\n  .sm\\:border-t {\n    border-top-width: 1px;\n  }\n\n  .sm\\:border-r {\n    border-right-width: 1px;\n  }\n\n  .sm\\:border-b {\n    border-bottom-width: 1px;\n  }\n\n  .sm\\:border-l {\n    border-left-width: 1px;\n  }\n\n  .sm\\:cursor-auto {\n    cursor: auto;\n  }\n\n  .sm\\:cursor-default {\n    cursor: default;\n  }\n\n  .sm\\:cursor-pointer {\n    cursor: pointer;\n  }\n\n  .sm\\:cursor-wait {\n    cursor: wait;\n  }\n\n  .sm\\:cursor-move {\n    cursor: move;\n  }\n\n  .sm\\:cursor-not-allowed {\n    cursor: not-allowed;\n  }\n\n  .sm\\:block {\n    display: block;\n  }\n\n  .sm\\:inline-block {\n    display: inline-block;\n  }\n\n  .sm\\:inline {\n    display: inline;\n  }\n\n  .sm\\:table {\n    display: table;\n  }\n\n  .sm\\:table-row {\n    display: table-row;\n  }\n\n  .sm\\:table-cell {\n    display: table-cell;\n  }\n\n  .sm\\:hidden {\n    display: none;\n  }\n\n  .sm\\:flex {\n    display: flex;\n  }\n\n  .sm\\:inline-flex {\n    display: inline-flex;\n  }\n\n  .sm\\:flex-row {\n    flex-direction: row;\n  }\n\n  .sm\\:flex-row-reverse {\n    flex-direction: row-reverse;\n  }\n\n  .sm\\:flex-col {\n    flex-direction: column;\n  }\n\n  .sm\\:flex-col-reverse {\n    flex-direction: column-reverse;\n  }\n\n  .sm\\:flex-wrap {\n    flex-wrap: wrap;\n  }\n\n  .sm\\:flex-wrap-reverse {\n    flex-wrap: wrap-reverse;\n  }\n\n  .sm\\:flex-no-wrap {\n    flex-wrap: nowrap;\n  }\n\n  .sm\\:items-start {\n    align-items: flex-start;\n  }\n\n  .sm\\:items-end {\n    align-items: flex-end;\n  }\n\n  .sm\\:items-center {\n    align-items: center;\n  }\n\n  .sm\\:items-baseline {\n    align-items: baseline;\n  }\n\n  .sm\\:items-stretch {\n    align-items: stretch;\n  }\n\n  .sm\\:self-auto {\n    align-self: auto;\n  }\n\n  .sm\\:self-start {\n    align-self: flex-start;\n  }\n\n  .sm\\:self-end {\n    align-self: flex-end;\n  }\n\n  .sm\\:self-center {\n    align-self: center;\n  }\n\n  .sm\\:self-stretch {\n    align-self: stretch;\n  }\n\n  .sm\\:justify-start {\n    justify-content: flex-start;\n  }\n\n  .sm\\:justify-end {\n    justify-content: flex-end;\n  }\n\n  .sm\\:justify-center {\n    justify-content: center;\n  }\n\n  .sm\\:justify-between {\n    justify-content: space-between;\n  }\n\n  .sm\\:justify-around {\n    justify-content: space-around;\n  }\n\n  .sm\\:content-center {\n    align-content: center;\n  }\n\n  .sm\\:content-start {\n    align-content: flex-start;\n  }\n\n  .sm\\:content-end {\n    align-content: flex-end;\n  }\n\n  .sm\\:content-between {\n    align-content: space-between;\n  }\n\n  .sm\\:content-around {\n    align-content: space-around;\n  }\n\n  .sm\\:flex-1 {\n    flex: 1;\n  }\n\n  .sm\\:flex-auto {\n    flex: auto;\n  }\n\n  .sm\\:flex-initial {\n    flex: initial;\n  }\n\n  .sm\\:flex-none {\n    flex: none;\n  }\n\n  .sm\\:flex-grow {\n    flex-grow: 1;\n  }\n\n  .sm\\:flex-shrink {\n    flex-shrink: 1;\n  }\n\n  .sm\\:flex-no-grow {\n    flex-grow: 0;\n  }\n\n  .sm\\:flex-no-shrink {\n    flex-shrink: 0;\n  }\n\n  .sm\\:float-right {\n    float: right;\n  }\n\n  .sm\\:float-left {\n    float: left;\n  }\n\n  .sm\\:float-none {\n    float: none;\n  }\n\n  .sm\\:clearfix:after {\n    content: \"\";\n    display: table;\n    clear: both;\n  }\n\n  .sm\\:font-sans {\n    font-family: system-ui, BlinkMacSystemFont, -apple-system, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  }\n\n  .sm\\:font-serif {\n    font-family: Constantia, Lucida Bright, Lucidabright, Lucida Serif, Lucida, DejaVu Serif, Bitstream Vera Serif, Liberation Serif, Georgia, serif;\n  }\n\n  .sm\\:font-mono {\n    font-family: Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;\n  }\n\n  .sm\\:font-hairline {\n    font-weight: 100;\n  }\n\n  .sm\\:font-thin {\n    font-weight: 200;\n  }\n\n  .sm\\:font-light {\n    font-weight: 300;\n  }\n\n  .sm\\:font-normal {\n    font-weight: 400;\n  }\n\n  .sm\\:font-medium {\n    font-weight: 500;\n  }\n\n  .sm\\:font-semibold {\n    font-weight: 600;\n  }\n\n  .sm\\:font-bold {\n    font-weight: 700;\n  }\n\n  .sm\\:font-extrabold {\n    font-weight: 800;\n  }\n\n  .sm\\:font-black {\n    font-weight: 900;\n  }\n\n  .sm\\:hover\\:font-hairline:hover {\n    font-weight: 100;\n  }\n\n  .sm\\:hover\\:font-thin:hover {\n    font-weight: 200;\n  }\n\n  .sm\\:hover\\:font-light:hover {\n    font-weight: 300;\n  }\n\n  .sm\\:hover\\:font-normal:hover {\n    font-weight: 400;\n  }\n\n  .sm\\:hover\\:font-medium:hover {\n    font-weight: 500;\n  }\n\n  .sm\\:hover\\:font-semibold:hover {\n    font-weight: 600;\n  }\n\n  .sm\\:hover\\:font-bold:hover {\n    font-weight: 700;\n  }\n\n  .sm\\:hover\\:font-extrabold:hover {\n    font-weight: 800;\n  }\n\n  .sm\\:hover\\:font-black:hover {\n    font-weight: 900;\n  }\n\n  .sm\\:h-0 {\n    height: 0;\n  }\n\n  .sm\\:h-1 {\n    height: 2px;\n  }\n\n  .sm\\:h-2 {\n    height: 4px;\n  }\n\n  .sm\\:h-3 {\n    height: 8px;\n  }\n\n  .sm\\:h-4 {\n    height: 16px;\n  }\n\n  .sm\\:h-5 {\n    height: 24px;\n  }\n\n  .sm\\:h-6 {\n    height: 32px;\n  }\n\n  .sm\\:h-7 {\n    height: 36px;\n  }\n\n  .sm\\:h-8 {\n    height: 48px;\n  }\n\n  .sm\\:h-9 {\n    height: 64px;\n  }\n\n  .sm\\:h-10 {\n    height: 96px;\n  }\n\n  .sm\\:h-screen {\n    height: 100vh;\n  }\n\n  .sm\\:h-auto {\n    height: auto;\n  }\n\n  .sm\\:h-full {\n    height: 100%;\n  }\n\n  .sm\\:h-px {\n    height: 1px;\n  }\n\n  .sm\\:h-1\\/6 {\n    height: 16.666666667%;\n  }\n\n  .sm\\:leading-none {\n    line-height: 1;\n  }\n\n  .sm\\:leading-tight {\n    line-height: 1.25;\n  }\n\n  .sm\\:leading-normal {\n    line-height: 1.5;\n  }\n\n  .sm\\:leading-loose {\n    line-height: 2;\n  }\n\n  .sm\\:m-0 {\n    margin: 0;\n  }\n\n  .sm\\:m-1 {\n    margin: 2px;\n  }\n\n  .sm\\:m-2 {\n    margin: 4px;\n  }\n\n  .sm\\:m-3 {\n    margin: 8px;\n  }\n\n  .sm\\:m-4 {\n    margin: 16px;\n  }\n\n  .sm\\:m-5 {\n    margin: 24px;\n  }\n\n  .sm\\:m-6 {\n    margin: 32px;\n  }\n\n  .sm\\:m-7 {\n    margin: 36px;\n  }\n\n  .sm\\:m-8 {\n    margin: 48px;\n  }\n\n  .sm\\:m-9 {\n    margin: 64px;\n  }\n\n  .sm\\:m-10 {\n    margin: 96px;\n  }\n\n  .sm\\:m-auto {\n    margin: auto;\n  }\n\n  .sm\\:m-full {\n    margin: 100%;\n  }\n\n  .sm\\:m-px {\n    margin: 1px;\n  }\n\n  .sm\\:m-1\\/6 {\n    margin: 16.666666667%;\n  }\n\n  .sm\\:my-0 {\n    margin-top: 0;\n    margin-bottom: 0;\n  }\n\n  .sm\\:mx-0 {\n    margin-left: 0;\n    margin-right: 0;\n  }\n\n  .sm\\:my-1 {\n    margin-top: 2px;\n    margin-bottom: 2px;\n  }\n\n  .sm\\:mx-1 {\n    margin-left: 2px;\n    margin-right: 2px;\n  }\n\n  .sm\\:my-2 {\n    margin-top: 4px;\n    margin-bottom: 4px;\n  }\n\n  .sm\\:mx-2 {\n    margin-left: 4px;\n    margin-right: 4px;\n  }\n\n  .sm\\:my-3 {\n    margin-top: 8px;\n    margin-bottom: 8px;\n  }\n\n  .sm\\:mx-3 {\n    margin-left: 8px;\n    margin-right: 8px;\n  }\n\n  .sm\\:my-4 {\n    margin-top: 16px;\n    margin-bottom: 16px;\n  }\n\n  .sm\\:mx-4 {\n    margin-left: 16px;\n    margin-right: 16px;\n  }\n\n  .sm\\:my-5 {\n    margin-top: 24px;\n    margin-bottom: 24px;\n  }\n\n  .sm\\:mx-5 {\n    margin-left: 24px;\n    margin-right: 24px;\n  }\n\n  .sm\\:my-6 {\n    margin-top: 32px;\n    margin-bottom: 32px;\n  }\n\n  .sm\\:mx-6 {\n    margin-left: 32px;\n    margin-right: 32px;\n  }\n\n  .sm\\:my-7 {\n    margin-top: 36px;\n    margin-bottom: 36px;\n  }\n\n  .sm\\:mx-7 {\n    margin-left: 36px;\n    margin-right: 36px;\n  }\n\n  .sm\\:my-8 {\n    margin-top: 48px;\n    margin-bottom: 48px;\n  }\n\n  .sm\\:mx-8 {\n    margin-left: 48px;\n    margin-right: 48px;\n  }\n\n  .sm\\:my-9 {\n    margin-top: 64px;\n    margin-bottom: 64px;\n  }\n\n  .sm\\:mx-9 {\n    margin-left: 64px;\n    margin-right: 64px;\n  }\n\n  .sm\\:my-10 {\n    margin-top: 96px;\n    margin-bottom: 96px;\n  }\n\n  .sm\\:mx-10 {\n    margin-left: 96px;\n    margin-right: 96px;\n  }\n\n  .sm\\:my-auto {\n    margin-top: auto;\n    margin-bottom: auto;\n  }\n\n  .sm\\:mx-auto {\n    margin-left: auto;\n    margin-right: auto;\n  }\n\n  .sm\\:my-full {\n    margin-top: 100%;\n    margin-bottom: 100%;\n  }\n\n  .sm\\:mx-full {\n    margin-left: 100%;\n    margin-right: 100%;\n  }\n\n  .sm\\:my-px {\n    margin-top: 1px;\n    margin-bottom: 1px;\n  }\n\n  .sm\\:mx-px {\n    margin-left: 1px;\n    margin-right: 1px;\n  }\n\n  .sm\\:my-1\\/6 {\n    margin-top: 16.666666667%;\n    margin-bottom: 16.666666667%;\n  }\n\n  .sm\\:mx-1\\/6 {\n    margin-left: 16.666666667%;\n    margin-right: 16.666666667%;\n  }\n\n  .sm\\:mt-0 {\n    margin-top: 0;\n  }\n\n  .sm\\:mr-0 {\n    margin-right: 0;\n  }\n\n  .sm\\:mb-0 {\n    margin-bottom: 0;\n  }\n\n  .sm\\:ml-0 {\n    margin-left: 0;\n  }\n\n  .sm\\:mt-1 {\n    margin-top: 2px;\n  }\n\n  .sm\\:mr-1 {\n    margin-right: 2px;\n  }\n\n  .sm\\:mb-1 {\n    margin-bottom: 2px;\n  }\n\n  .sm\\:ml-1 {\n    margin-left: 2px;\n  }\n\n  .sm\\:mt-2 {\n    margin-top: 4px;\n  }\n\n  .sm\\:mr-2 {\n    margin-right: 4px;\n  }\n\n  .sm\\:mb-2 {\n    margin-bottom: 4px;\n  }\n\n  .sm\\:ml-2 {\n    margin-left: 4px;\n  }\n\n  .sm\\:mt-3 {\n    margin-top: 8px;\n  }\n\n  .sm\\:mr-3 {\n    margin-right: 8px;\n  }\n\n  .sm\\:mb-3 {\n    margin-bottom: 8px;\n  }\n\n  .sm\\:ml-3 {\n    margin-left: 8px;\n  }\n\n  .sm\\:mt-4 {\n    margin-top: 16px;\n  }\n\n  .sm\\:mr-4 {\n    margin-right: 16px;\n  }\n\n  .sm\\:mb-4 {\n    margin-bottom: 16px;\n  }\n\n  .sm\\:ml-4 {\n    margin-left: 16px;\n  }\n\n  .sm\\:mt-5 {\n    margin-top: 24px;\n  }\n\n  .sm\\:mr-5 {\n    margin-right: 24px;\n  }\n\n  .sm\\:mb-5 {\n    margin-bottom: 24px;\n  }\n\n  .sm\\:ml-5 {\n    margin-left: 24px;\n  }\n\n  .sm\\:mt-6 {\n    margin-top: 32px;\n  }\n\n  .sm\\:mr-6 {\n    margin-right: 32px;\n  }\n\n  .sm\\:mb-6 {\n    margin-bottom: 32px;\n  }\n\n  .sm\\:ml-6 {\n    margin-left: 32px;\n  }\n\n  .sm\\:mt-7 {\n    margin-top: 36px;\n  }\n\n  .sm\\:mr-7 {\n    margin-right: 36px;\n  }\n\n  .sm\\:mb-7 {\n    margin-bottom: 36px;\n  }\n\n  .sm\\:ml-7 {\n    margin-left: 36px;\n  }\n\n  .sm\\:mt-8 {\n    margin-top: 48px;\n  }\n\n  .sm\\:mr-8 {\n    margin-right: 48px;\n  }\n\n  .sm\\:mb-8 {\n    margin-bottom: 48px;\n  }\n\n  .sm\\:ml-8 {\n    margin-left: 48px;\n  }\n\n  .sm\\:mt-9 {\n    margin-top: 64px;\n  }\n\n  .sm\\:mr-9 {\n    margin-right: 64px;\n  }\n\n  .sm\\:mb-9 {\n    margin-bottom: 64px;\n  }\n\n  .sm\\:ml-9 {\n    margin-left: 64px;\n  }\n\n  .sm\\:mt-10 {\n    margin-top: 96px;\n  }\n\n  .sm\\:mr-10 {\n    margin-right: 96px;\n  }\n\n  .sm\\:mb-10 {\n    margin-bottom: 96px;\n  }\n\n  .sm\\:ml-10 {\n    margin-left: 96px;\n  }\n\n  .sm\\:mt-auto {\n    margin-top: auto;\n  }\n\n  .sm\\:mr-auto {\n    margin-right: auto;\n  }\n\n  .sm\\:mb-auto {\n    margin-bottom: auto;\n  }\n\n  .sm\\:ml-auto {\n    margin-left: auto;\n  }\n\n  .sm\\:mt-full {\n    margin-top: 100%;\n  }\n\n  .sm\\:mr-full {\n    margin-right: 100%;\n  }\n\n  .sm\\:mb-full {\n    margin-bottom: 100%;\n  }\n\n  .sm\\:ml-full {\n    margin-left: 100%;\n  }\n\n  .sm\\:mt-px {\n    margin-top: 1px;\n  }\n\n  .sm\\:mr-px {\n    margin-right: 1px;\n  }\n\n  .sm\\:mb-px {\n    margin-bottom: 1px;\n  }\n\n  .sm\\:ml-px {\n    margin-left: 1px;\n  }\n\n  .sm\\:mt-1\\/6 {\n    margin-top: 16.666666667%;\n  }\n\n  .sm\\:mr-1\\/6 {\n    margin-right: 16.666666667%;\n  }\n\n  .sm\\:mb-1\\/6 {\n    margin-bottom: 16.666666667%;\n  }\n\n  .sm\\:ml-1\\/6 {\n    margin-left: 16.666666667%;\n  }\n\n  .sm\\:max-h-0 {\n    max-height: 0;\n  }\n\n  .sm\\:max-h-1 {\n    max-height: 2px;\n  }\n\n  .sm\\:max-h-2 {\n    max-height: 4px;\n  }\n\n  .sm\\:max-h-3 {\n    max-height: 8px;\n  }\n\n  .sm\\:max-h-4 {\n    max-height: 16px;\n  }\n\n  .sm\\:max-h-5 {\n    max-height: 24px;\n  }\n\n  .sm\\:max-h-6 {\n    max-height: 32px;\n  }\n\n  .sm\\:max-h-7 {\n    max-height: 36px;\n  }\n\n  .sm\\:max-h-8 {\n    max-height: 48px;\n  }\n\n  .sm\\:max-h-9 {\n    max-height: 64px;\n  }\n\n  .sm\\:max-h-10 {\n    max-height: 96px;\n  }\n\n  .sm\\:max-h-screen {\n    max-height: 100vh;\n  }\n\n  .sm\\:max-h-auto {\n    max-height: auto;\n  }\n\n  .sm\\:max-h-full {\n    max-height: 100%;\n  }\n\n  .sm\\:max-h-px {\n    max-height: 1px;\n  }\n\n  .sm\\:max-h-1\\/6 {\n    max-height: 16.666666667%;\n  }\n\n  .sm\\:max-w-0 {\n    max-width: 0;\n  }\n\n  .sm\\:max-w-1 {\n    max-width: 2px;\n  }\n\n  .sm\\:max-w-2 {\n    max-width: 4px;\n  }\n\n  .sm\\:max-w-3 {\n    max-width: 8px;\n  }\n\n  .sm\\:max-w-4 {\n    max-width: 16px;\n  }\n\n  .sm\\:max-w-5 {\n    max-width: 24px;\n  }\n\n  .sm\\:max-w-6 {\n    max-width: 32px;\n  }\n\n  .sm\\:max-w-7 {\n    max-width: 36px;\n  }\n\n  .sm\\:max-w-8 {\n    max-width: 48px;\n  }\n\n  .sm\\:max-w-9 {\n    max-width: 64px;\n  }\n\n  .sm\\:max-w-10 {\n    max-width: 96px;\n  }\n\n  .sm\\:max-w-auto {\n    max-width: auto;\n  }\n\n  .sm\\:max-w-full {\n    max-width: 100%;\n  }\n\n  .sm\\:max-w-px {\n    max-width: 1px;\n  }\n\n  .sm\\:max-w-1\\/6 {\n    max-width: 16.666666667%;\n  }\n\n  .sm\\:min-h-0 {\n    min-height: 0;\n  }\n\n  .sm\\:min-h-1 {\n    min-height: 2px;\n  }\n\n  .sm\\:min-h-2 {\n    min-height: 4px;\n  }\n\n  .sm\\:min-h-3 {\n    min-height: 8px;\n  }\n\n  .sm\\:min-h-4 {\n    min-height: 16px;\n  }\n\n  .sm\\:min-h-5 {\n    min-height: 24px;\n  }\n\n  .sm\\:min-h-6 {\n    min-height: 32px;\n  }\n\n  .sm\\:min-h-7 {\n    min-height: 36px;\n  }\n\n  .sm\\:min-h-8 {\n    min-height: 48px;\n  }\n\n  .sm\\:min-h-9 {\n    min-height: 64px;\n  }\n\n  .sm\\:min-h-10 {\n    min-height: 96px;\n  }\n\n  .sm\\:min-h-screen {\n    min-height: 100vh;\n  }\n\n  .sm\\:min-h-auto {\n    min-height: auto;\n  }\n\n  .sm\\:min-h-full {\n    min-height: 100%;\n  }\n\n  .sm\\:min-h-px {\n    min-height: 1px;\n  }\n\n  .sm\\:min-h-1\\/6 {\n    min-height: 16.666666667%;\n  }\n\n  .sm\\:min-w-0 {\n    min-width: 0;\n  }\n\n  .sm\\:min-w-1 {\n    min-width: 2px;\n  }\n\n  .sm\\:min-w-2 {\n    min-width: 4px;\n  }\n\n  .sm\\:min-w-3 {\n    min-width: 8px;\n  }\n\n  .sm\\:min-w-4 {\n    min-width: 16px;\n  }\n\n  .sm\\:min-w-5 {\n    min-width: 24px;\n  }\n\n  .sm\\:min-w-6 {\n    min-width: 32px;\n  }\n\n  .sm\\:min-w-7 {\n    min-width: 36px;\n  }\n\n  .sm\\:min-w-8 {\n    min-width: 48px;\n  }\n\n  .sm\\:min-w-9 {\n    min-width: 64px;\n  }\n\n  .sm\\:min-w-10 {\n    min-width: 96px;\n  }\n\n  .sm\\:min-w-auto {\n    min-width: auto;\n  }\n\n  .sm\\:min-w-full {\n    min-width: 100%;\n  }\n\n  .sm\\:min-w-px {\n    min-width: 1px;\n  }\n\n  .sm\\:min-w-1\\/6 {\n    min-width: 16.666666667%;\n  }\n\n  .sm\\:-m-0 {\n    margin: 0;\n  }\n\n  .sm\\:-m-1 {\n    margin: -2px;\n  }\n\n  .sm\\:-m-2 {\n    margin: -4px;\n  }\n\n  .sm\\:-m-3 {\n    margin: -8px;\n  }\n\n  .sm\\:-m-4 {\n    margin: -16px;\n  }\n\n  .sm\\:-m-5 {\n    margin: -24px;\n  }\n\n  .sm\\:-m-6 {\n    margin: -32px;\n  }\n\n  .sm\\:-m-7 {\n    margin: -36px;\n  }\n\n  .sm\\:-m-8 {\n    margin: -48px;\n  }\n\n  .sm\\:-m-9 {\n    margin: -64px;\n  }\n\n  .sm\\:-m-10 {\n    margin: -96px;\n  }\n\n  .sm\\:-m-auto {\n    margin: -auto;\n  }\n\n  .sm\\:-m-full {\n    margin: -100%;\n  }\n\n  .sm\\:-m-px {\n    margin: -1px;\n  }\n\n  .sm\\:-m-1\\/6 {\n    margin: -16.666666667%;\n  }\n\n  .sm\\:-my-0 {\n    margin-top: 0;\n    margin-bottom: 0;\n  }\n\n  .sm\\:-mx-0 {\n    margin-left: 0;\n    margin-right: 0;\n  }\n\n  .sm\\:-my-1 {\n    margin-top: -2px;\n    margin-bottom: -2px;\n  }\n\n  .sm\\:-mx-1 {\n    margin-left: -2px;\n    margin-right: -2px;\n  }\n\n  .sm\\:-my-2 {\n    margin-top: -4px;\n    margin-bottom: -4px;\n  }\n\n  .sm\\:-mx-2 {\n    margin-left: -4px;\n    margin-right: -4px;\n  }\n\n  .sm\\:-my-3 {\n    margin-top: -8px;\n    margin-bottom: -8px;\n  }\n\n  .sm\\:-mx-3 {\n    margin-left: -8px;\n    margin-right: -8px;\n  }\n\n  .sm\\:-my-4 {\n    margin-top: -16px;\n    margin-bottom: -16px;\n  }\n\n  .sm\\:-mx-4 {\n    margin-left: -16px;\n    margin-right: -16px;\n  }\n\n  .sm\\:-my-5 {\n    margin-top: -24px;\n    margin-bottom: -24px;\n  }\n\n  .sm\\:-mx-5 {\n    margin-left: -24px;\n    margin-right: -24px;\n  }\n\n  .sm\\:-my-6 {\n    margin-top: -32px;\n    margin-bottom: -32px;\n  }\n\n  .sm\\:-mx-6 {\n    margin-left: -32px;\n    margin-right: -32px;\n  }\n\n  .sm\\:-my-7 {\n    margin-top: -36px;\n    margin-bottom: -36px;\n  }\n\n  .sm\\:-mx-7 {\n    margin-left: -36px;\n    margin-right: -36px;\n  }\n\n  .sm\\:-my-8 {\n    margin-top: -48px;\n    margin-bottom: -48px;\n  }\n\n  .sm\\:-mx-8 {\n    margin-left: -48px;\n    margin-right: -48px;\n  }\n\n  .sm\\:-my-9 {\n    margin-top: -64px;\n    margin-bottom: -64px;\n  }\n\n  .sm\\:-mx-9 {\n    margin-left: -64px;\n    margin-right: -64px;\n  }\n\n  .sm\\:-my-10 {\n    margin-top: -96px;\n    margin-bottom: -96px;\n  }\n\n  .sm\\:-mx-10 {\n    margin-left: -96px;\n    margin-right: -96px;\n  }\n\n  .sm\\:-my-auto {\n    margin-top: -auto;\n    margin-bottom: -auto;\n  }\n\n  .sm\\:-mx-auto {\n    margin-left: -auto;\n    margin-right: -auto;\n  }\n\n  .sm\\:-my-full {\n    margin-top: -100%;\n    margin-bottom: -100%;\n  }\n\n  .sm\\:-mx-full {\n    margin-left: -100%;\n    margin-right: -100%;\n  }\n\n  .sm\\:-my-px {\n    margin-top: -1px;\n    margin-bottom: -1px;\n  }\n\n  .sm\\:-mx-px {\n    margin-left: -1px;\n    margin-right: -1px;\n  }\n\n  .sm\\:-my-1\\/6 {\n    margin-top: -16.666666667%;\n    margin-bottom: -16.666666667%;\n  }\n\n  .sm\\:-mx-1\\/6 {\n    margin-left: -16.666666667%;\n    margin-right: -16.666666667%;\n  }\n\n  .sm\\:-mt-0 {\n    margin-top: 0;\n  }\n\n  .sm\\:-mr-0 {\n    margin-right: 0;\n  }\n\n  .sm\\:-mb-0 {\n    margin-bottom: 0;\n  }\n\n  .sm\\:-ml-0 {\n    margin-left: 0;\n  }\n\n  .sm\\:-mt-1 {\n    margin-top: -2px;\n  }\n\n  .sm\\:-mr-1 {\n    margin-right: -2px;\n  }\n\n  .sm\\:-mb-1 {\n    margin-bottom: -2px;\n  }\n\n  .sm\\:-ml-1 {\n    margin-left: -2px;\n  }\n\n  .sm\\:-mt-2 {\n    margin-top: -4px;\n  }\n\n  .sm\\:-mr-2 {\n    margin-right: -4px;\n  }\n\n  .sm\\:-mb-2 {\n    margin-bottom: -4px;\n  }\n\n  .sm\\:-ml-2 {\n    margin-left: -4px;\n  }\n\n  .sm\\:-mt-3 {\n    margin-top: -8px;\n  }\n\n  .sm\\:-mr-3 {\n    margin-right: -8px;\n  }\n\n  .sm\\:-mb-3 {\n    margin-bottom: -8px;\n  }\n\n  .sm\\:-ml-3 {\n    margin-left: -8px;\n  }\n\n  .sm\\:-mt-4 {\n    margin-top: -16px;\n  }\n\n  .sm\\:-mr-4 {\n    margin-right: -16px;\n  }\n\n  .sm\\:-mb-4 {\n    margin-bottom: -16px;\n  }\n\n  .sm\\:-ml-4 {\n    margin-left: -16px;\n  }\n\n  .sm\\:-mt-5 {\n    margin-top: -24px;\n  }\n\n  .sm\\:-mr-5 {\n    margin-right: -24px;\n  }\n\n  .sm\\:-mb-5 {\n    margin-bottom: -24px;\n  }\n\n  .sm\\:-ml-5 {\n    margin-left: -24px;\n  }\n\n  .sm\\:-mt-6 {\n    margin-top: -32px;\n  }\n\n  .sm\\:-mr-6 {\n    margin-right: -32px;\n  }\n\n  .sm\\:-mb-6 {\n    margin-bottom: -32px;\n  }\n\n  .sm\\:-ml-6 {\n    margin-left: -32px;\n  }\n\n  .sm\\:-mt-7 {\n    margin-top: -36px;\n  }\n\n  .sm\\:-mr-7 {\n    margin-right: -36px;\n  }\n\n  .sm\\:-mb-7 {\n    margin-bottom: -36px;\n  }\n\n  .sm\\:-ml-7 {\n    margin-left: -36px;\n  }\n\n  .sm\\:-mt-8 {\n    margin-top: -48px;\n  }\n\n  .sm\\:-mr-8 {\n    margin-right: -48px;\n  }\n\n  .sm\\:-mb-8 {\n    margin-bottom: -48px;\n  }\n\n  .sm\\:-ml-8 {\n    margin-left: -48px;\n  }\n\n  .sm\\:-mt-9 {\n    margin-top: -64px;\n  }\n\n  .sm\\:-mr-9 {\n    margin-right: -64px;\n  }\n\n  .sm\\:-mb-9 {\n    margin-bottom: -64px;\n  }\n\n  .sm\\:-ml-9 {\n    margin-left: -64px;\n  }\n\n  .sm\\:-mt-10 {\n    margin-top: -96px;\n  }\n\n  .sm\\:-mr-10 {\n    margin-right: -96px;\n  }\n\n  .sm\\:-mb-10 {\n    margin-bottom: -96px;\n  }\n\n  .sm\\:-ml-10 {\n    margin-left: -96px;\n  }\n\n  .sm\\:-mt-auto {\n    margin-top: -auto;\n  }\n\n  .sm\\:-mr-auto {\n    margin-right: -auto;\n  }\n\n  .sm\\:-mb-auto {\n    margin-bottom: -auto;\n  }\n\n  .sm\\:-ml-auto {\n    margin-left: -auto;\n  }\n\n  .sm\\:-mt-full {\n    margin-top: -100%;\n  }\n\n  .sm\\:-mr-full {\n    margin-right: -100%;\n  }\n\n  .sm\\:-mb-full {\n    margin-bottom: -100%;\n  }\n\n  .sm\\:-ml-full {\n    margin-left: -100%;\n  }\n\n  .sm\\:-mt-px {\n    margin-top: -1px;\n  }\n\n  .sm\\:-mr-px {\n    margin-right: -1px;\n  }\n\n  .sm\\:-mb-px {\n    margin-bottom: -1px;\n  }\n\n  .sm\\:-ml-px {\n    margin-left: -1px;\n  }\n\n  .sm\\:-mt-1\\/6 {\n    margin-top: -16.666666667%;\n  }\n\n  .sm\\:-mr-1\\/6 {\n    margin-right: -16.666666667%;\n  }\n\n  .sm\\:-mb-1\\/6 {\n    margin-bottom: -16.666666667%;\n  }\n\n  .sm\\:-ml-1\\/6 {\n    margin-left: -16.666666667%;\n  }\n\n  .sm\\:opacity-0 {\n    opacity: 0;\n  }\n\n  .sm\\:opacity-25 {\n    opacity: .25;\n  }\n\n  .sm\\:opacity-50 {\n    opacity: .5;\n  }\n\n  .sm\\:opacity-75 {\n    opacity: .75;\n  }\n\n  .sm\\:opacity-100 {\n    opacity: 1;\n  }\n\n  .sm\\:overflow-auto {\n    overflow: auto;\n  }\n\n  .sm\\:overflow-hidden {\n    overflow: hidden;\n  }\n\n  .sm\\:overflow-visible {\n    overflow: visible;\n  }\n\n  .sm\\:overflow-scroll {\n    overflow: scroll;\n  }\n\n  .sm\\:overflow-x-auto {\n    overflow-x: auto;\n  }\n\n  .sm\\:overflow-y-auto {\n    overflow-y: auto;\n  }\n\n  .sm\\:overflow-x-hidden {\n    overflow-x: hidden;\n  }\n\n  .sm\\:overflow-y-hidden {\n    overflow-y: hidden;\n  }\n\n  .sm\\:overflow-x-visible {\n    overflow-x: visible;\n  }\n\n  .sm\\:overflow-y-visible {\n    overflow-y: visible;\n  }\n\n  .sm\\:overflow-x-scroll {\n    overflow-x: scroll;\n  }\n\n  .sm\\:overflow-y-scroll {\n    overflow-y: scroll;\n  }\n\n  .sm\\:scrolling-touch {\n    -webkit-overflow-scrolling: touch;\n  }\n\n  .sm\\:scrolling-auto {\n    -webkit-overflow-scrolling: auto;\n  }\n\n  .sm\\:p-0 {\n    padding: 0;\n  }\n\n  .sm\\:p-1 {\n    padding: 2px;\n  }\n\n  .sm\\:p-2 {\n    padding: 4px;\n  }\n\n  .sm\\:p-3 {\n    padding: 8px;\n  }\n\n  .sm\\:p-4 {\n    padding: 16px;\n  }\n\n  .sm\\:p-5 {\n    padding: 24px;\n  }\n\n  .sm\\:p-6 {\n    padding: 32px;\n  }\n\n  .sm\\:p-7 {\n    padding: 36px;\n  }\n\n  .sm\\:p-8 {\n    padding: 48px;\n  }\n\n  .sm\\:p-9 {\n    padding: 64px;\n  }\n\n  .sm\\:p-10 {\n    padding: 96px;\n  }\n\n  .sm\\:p-auto {\n    padding: auto;\n  }\n\n  .sm\\:p-full {\n    padding: 100%;\n  }\n\n  .sm\\:p-px {\n    padding: 1px;\n  }\n\n  .sm\\:p-1\\/6 {\n    padding: 16.666666667%;\n  }\n\n  .sm\\:py-0 {\n    padding-top: 0;\n    padding-bottom: 0;\n  }\n\n  .sm\\:px-0 {\n    padding-left: 0;\n    padding-right: 0;\n  }\n\n  .sm\\:py-1 {\n    padding-top: 2px;\n    padding-bottom: 2px;\n  }\n\n  .sm\\:px-1 {\n    padding-left: 2px;\n    padding-right: 2px;\n  }\n\n  .sm\\:py-2 {\n    padding-top: 4px;\n    padding-bottom: 4px;\n  }\n\n  .sm\\:px-2 {\n    padding-left: 4px;\n    padding-right: 4px;\n  }\n\n  .sm\\:py-3 {\n    padding-top: 8px;\n    padding-bottom: 8px;\n  }\n\n  .sm\\:px-3 {\n    padding-left: 8px;\n    padding-right: 8px;\n  }\n\n  .sm\\:py-4 {\n    padding-top: 16px;\n    padding-bottom: 16px;\n  }\n\n  .sm\\:px-4 {\n    padding-left: 16px;\n    padding-right: 16px;\n  }\n\n  .sm\\:py-5 {\n    padding-top: 24px;\n    padding-bottom: 24px;\n  }\n\n  .sm\\:px-5 {\n    padding-left: 24px;\n    padding-right: 24px;\n  }\n\n  .sm\\:py-6 {\n    padding-top: 32px;\n    padding-bottom: 32px;\n  }\n\n  .sm\\:px-6 {\n    padding-left: 32px;\n    padding-right: 32px;\n  }\n\n  .sm\\:py-7 {\n    padding-top: 36px;\n    padding-bottom: 36px;\n  }\n\n  .sm\\:px-7 {\n    padding-left: 36px;\n    padding-right: 36px;\n  }\n\n  .sm\\:py-8 {\n    padding-top: 48px;\n    padding-bottom: 48px;\n  }\n\n  .sm\\:px-8 {\n    padding-left: 48px;\n    padding-right: 48px;\n  }\n\n  .sm\\:py-9 {\n    padding-top: 64px;\n    padding-bottom: 64px;\n  }\n\n  .sm\\:px-9 {\n    padding-left: 64px;\n    padding-right: 64px;\n  }\n\n  .sm\\:py-10 {\n    padding-top: 96px;\n    padding-bottom: 96px;\n  }\n\n  .sm\\:px-10 {\n    padding-left: 96px;\n    padding-right: 96px;\n  }\n\n  .sm\\:py-auto {\n    padding-top: auto;\n    padding-bottom: auto;\n  }\n\n  .sm\\:px-auto {\n    padding-left: auto;\n    padding-right: auto;\n  }\n\n  .sm\\:py-full {\n    padding-top: 100%;\n    padding-bottom: 100%;\n  }\n\n  .sm\\:px-full {\n    padding-left: 100%;\n    padding-right: 100%;\n  }\n\n  .sm\\:py-px {\n    padding-top: 1px;\n    padding-bottom: 1px;\n  }\n\n  .sm\\:px-px {\n    padding-left: 1px;\n    padding-right: 1px;\n  }\n\n  .sm\\:py-1\\/6 {\n    padding-top: 16.666666667%;\n    padding-bottom: 16.666666667%;\n  }\n\n  .sm\\:px-1\\/6 {\n    padding-left: 16.666666667%;\n    padding-right: 16.666666667%;\n  }\n\n  .sm\\:pt-0 {\n    padding-top: 0;\n  }\n\n  .sm\\:pr-0 {\n    padding-right: 0;\n  }\n\n  .sm\\:pb-0 {\n    padding-bottom: 0;\n  }\n\n  .sm\\:pl-0 {\n    padding-left: 0;\n  }\n\n  .sm\\:pt-1 {\n    padding-top: 2px;\n  }\n\n  .sm\\:pr-1 {\n    padding-right: 2px;\n  }\n\n  .sm\\:pb-1 {\n    padding-bottom: 2px;\n  }\n\n  .sm\\:pl-1 {\n    padding-left: 2px;\n  }\n\n  .sm\\:pt-2 {\n    padding-top: 4px;\n  }\n\n  .sm\\:pr-2 {\n    padding-right: 4px;\n  }\n\n  .sm\\:pb-2 {\n    padding-bottom: 4px;\n  }\n\n  .sm\\:pl-2 {\n    padding-left: 4px;\n  }\n\n  .sm\\:pt-3 {\n    padding-top: 8px;\n  }\n\n  .sm\\:pr-3 {\n    padding-right: 8px;\n  }\n\n  .sm\\:pb-3 {\n    padding-bottom: 8px;\n  }\n\n  .sm\\:pl-3 {\n    padding-left: 8px;\n  }\n\n  .sm\\:pt-4 {\n    padding-top: 16px;\n  }\n\n  .sm\\:pr-4 {\n    padding-right: 16px;\n  }\n\n  .sm\\:pb-4 {\n    padding-bottom: 16px;\n  }\n\n  .sm\\:pl-4 {\n    padding-left: 16px;\n  }\n\n  .sm\\:pt-5 {\n    padding-top: 24px;\n  }\n\n  .sm\\:pr-5 {\n    padding-right: 24px;\n  }\n\n  .sm\\:pb-5 {\n    padding-bottom: 24px;\n  }\n\n  .sm\\:pl-5 {\n    padding-left: 24px;\n  }\n\n  .sm\\:pt-6 {\n    padding-top: 32px;\n  }\n\n  .sm\\:pr-6 {\n    padding-right: 32px;\n  }\n\n  .sm\\:pb-6 {\n    padding-bottom: 32px;\n  }\n\n  .sm\\:pl-6 {\n    padding-left: 32px;\n  }\n\n  .sm\\:pt-7 {\n    padding-top: 36px;\n  }\n\n  .sm\\:pr-7 {\n    padding-right: 36px;\n  }\n\n  .sm\\:pb-7 {\n    padding-bottom: 36px;\n  }\n\n  .sm\\:pl-7 {\n    padding-left: 36px;\n  }\n\n  .sm\\:pt-8 {\n    padding-top: 48px;\n  }\n\n  .sm\\:pr-8 {\n    padding-right: 48px;\n  }\n\n  .sm\\:pb-8 {\n    padding-bottom: 48px;\n  }\n\n  .sm\\:pl-8 {\n    padding-left: 48px;\n  }\n\n  .sm\\:pt-9 {\n    padding-top: 64px;\n  }\n\n  .sm\\:pr-9 {\n    padding-right: 64px;\n  }\n\n  .sm\\:pb-9 {\n    padding-bottom: 64px;\n  }\n\n  .sm\\:pl-9 {\n    padding-left: 64px;\n  }\n\n  .sm\\:pt-10 {\n    padding-top: 96px;\n  }\n\n  .sm\\:pr-10 {\n    padding-right: 96px;\n  }\n\n  .sm\\:pb-10 {\n    padding-bottom: 96px;\n  }\n\n  .sm\\:pl-10 {\n    padding-left: 96px;\n  }\n\n  .sm\\:pt-auto {\n    padding-top: auto;\n  }\n\n  .sm\\:pr-auto {\n    padding-right: auto;\n  }\n\n  .sm\\:pb-auto {\n    padding-bottom: auto;\n  }\n\n  .sm\\:pl-auto {\n    padding-left: auto;\n  }\n\n  .sm\\:pt-full {\n    padding-top: 100%;\n  }\n\n  .sm\\:pr-full {\n    padding-right: 100%;\n  }\n\n  .sm\\:pb-full {\n    padding-bottom: 100%;\n  }\n\n  .sm\\:pl-full {\n    padding-left: 100%;\n  }\n\n  .sm\\:pt-px {\n    padding-top: 1px;\n  }\n\n  .sm\\:pr-px {\n    padding-right: 1px;\n  }\n\n  .sm\\:pb-px {\n    padding-bottom: 1px;\n  }\n\n  .sm\\:pl-px {\n    padding-left: 1px;\n  }\n\n  .sm\\:pt-1\\/6 {\n    padding-top: 16.666666667%;\n  }\n\n  .sm\\:pr-1\\/6 {\n    padding-right: 16.666666667%;\n  }\n\n  .sm\\:pb-1\\/6 {\n    padding-bottom: 16.666666667%;\n  }\n\n  .sm\\:pl-1\\/6 {\n    padding-left: 16.666666667%;\n  }\n\n  .sm\\:pointer-events-none {\n    pointer-events: none;\n  }\n\n  .sm\\:pointer-events-auto {\n    pointer-events: auto;\n  }\n\n  .sm\\:static {\n    position: static;\n  }\n\n  .sm\\:fixed {\n    position: fixed;\n  }\n\n  .sm\\:absolute {\n    position: absolute;\n  }\n\n  .sm\\:relative {\n    position: relative;\n  }\n\n  .sm\\:sticky {\n    position: sticky;\n  }\n\n  .sm\\:pin-none {\n    top: auto;\n    right: auto;\n    bottom: auto;\n    left: auto;\n  }\n\n  .sm\\:pin {\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n\n  .sm\\:pin-y {\n    top: 0;\n    bottom: 0;\n  }\n\n  .sm\\:pin-x {\n    right: 0;\n    left: 0;\n  }\n\n  .sm\\:pin-t {\n    top: 0;\n  }\n\n  .sm\\:pin-r {\n    right: 0;\n  }\n\n  .sm\\:pin-b {\n    bottom: 0;\n  }\n\n  .sm\\:pin-l {\n    left: 0;\n  }\n\n  .sm\\:resize-none {\n    resize: none;\n  }\n\n  .sm\\:resize-y {\n    resize: vertical;\n  }\n\n  .sm\\:resize-x {\n    resize: horizontal;\n  }\n\n  .sm\\:resize {\n    resize: both;\n  }\n\n  .sm\\:shadow {\n    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .1);\n  }\n\n  .sm\\:shadow-md {\n    box-shadow:  0 8px 20px 0 rgba(0, 0, 0, .42);\n  }\n\n  .sm\\:shadow-none {\n    box-shadow: none;\n  }\n\n  .sm\\:table-auto {\n    table-layout: auto;\n  }\n\n  .sm\\:table-fixed {\n    table-layout: fixed;\n  }\n\n  .sm\\:text-left {\n    text-align: left;\n  }\n\n  .sm\\:text-center {\n    text-align: center;\n  }\n\n  .sm\\:text-right {\n    text-align: right;\n  }\n\n  .sm\\:text-justify {\n    text-align: justify;\n  }\n\n  .sm\\:text-inherit {\n    color: inherit;\n  }\n\n  .sm\\:text-transparent {\n    color: transparent;\n  }\n\n  .sm\\:text-black {\n    color: #282828;\n  }\n\n  .sm\\:text-white {\n    color: #fff;\n  }\n\n  .sm\\:text-grey-lighter {\n    color: #f3f3f7;\n  }\n\n  .sm\\:text-grey-light {\n    color: #e7e7ec;\n  }\n\n  .sm\\:text-grey {\n    color: #c2c2c6;\n  }\n\n  .sm\\:text-purple-lighter {\n    color: #ccc2e9;\n  }\n\n  .sm\\:text-purple-light {\n    color: #87809b;\n  }\n\n  .sm\\:text-purple {\n    color: #8360d6;\n  }\n\n  .sm\\:text-purple-bright {\n    color: #4c29b0;\n  }\n\n  .sm\\:text-purple-dark {\n    color: #453f56;\n  }\n\n  .sm\\:text-purple-dark-10 {\n    color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:text-purple-darker {\n    color: #2a2538;\n  }\n\n  .sm\\:hover\\:text-inherit:hover {\n    color: inherit;\n  }\n\n  .sm\\:hover\\:text-transparent:hover {\n    color: transparent;\n  }\n\n  .sm\\:hover\\:text-black:hover {\n    color: #282828;\n  }\n\n  .sm\\:hover\\:text-white:hover {\n    color: #fff;\n  }\n\n  .sm\\:hover\\:text-grey-lighter:hover {\n    color: #f3f3f7;\n  }\n\n  .sm\\:hover\\:text-grey-light:hover {\n    color: #e7e7ec;\n  }\n\n  .sm\\:hover\\:text-grey:hover {\n    color: #c2c2c6;\n  }\n\n  .sm\\:hover\\:text-purple-lighter:hover {\n    color: #ccc2e9;\n  }\n\n  .sm\\:hover\\:text-purple-light:hover {\n    color: #87809b;\n  }\n\n  .sm\\:hover\\:text-purple:hover {\n    color: #8360d6;\n  }\n\n  .sm\\:hover\\:text-purple-bright:hover {\n    color: #4c29b0;\n  }\n\n  .sm\\:hover\\:text-purple-dark:hover {\n    color: #453f56;\n  }\n\n  .sm\\:hover\\:text-purple-dark-10:hover {\n    color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:hover\\:text-purple-darker:hover {\n    color: #2a2538;\n  }\n\n  .sm\\:text-sm {\n    font-size: 1.4rem;\n  }\n\n  .sm\\:text-base {\n    font-size: 1.6rem;\n  }\n\n  .sm\\:italic {\n    font-style: italic;\n  }\n\n  .sm\\:roman {\n    font-style: normal;\n  }\n\n  .sm\\:uppercase {\n    text-transform: uppercase;\n  }\n\n  .sm\\:lowercase {\n    text-transform: lowercase;\n  }\n\n  .sm\\:capitalize {\n    text-transform: capitalize;\n  }\n\n  .sm\\:normal-case {\n    text-transform: none;\n  }\n\n  .sm\\:underline {\n    text-decoration: underline;\n  }\n\n  .sm\\:line-through {\n    text-decoration: line-through;\n  }\n\n  .sm\\:no-underline {\n    text-decoration: none;\n  }\n\n  .sm\\:antialiased {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  .sm\\:subpixel-antialiased {\n    -webkit-font-smoothing: auto;\n    -moz-osx-font-smoothing: auto;\n  }\n\n  .sm\\:hover\\:italic:hover {\n    font-style: italic;\n  }\n\n  .sm\\:hover\\:roman:hover {\n    font-style: normal;\n  }\n\n  .sm\\:hover\\:uppercase:hover {\n    text-transform: uppercase;\n  }\n\n  .sm\\:hover\\:lowercase:hover {\n    text-transform: lowercase;\n  }\n\n  .sm\\:hover\\:capitalize:hover {\n    text-transform: capitalize;\n  }\n\n  .sm\\:hover\\:normal-case:hover {\n    text-transform: none;\n  }\n\n  .sm\\:hover\\:underline:hover {\n    text-decoration: underline;\n  }\n\n  .sm\\:hover\\:line-through:hover {\n    text-decoration: line-through;\n  }\n\n  .sm\\:hover\\:no-underline:hover {\n    text-decoration: none;\n  }\n\n  .sm\\:hover\\:antialiased:hover {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  .sm\\:hover\\:subpixel-antialiased:hover {\n    -webkit-font-smoothing: auto;\n    -moz-osx-font-smoothing: auto;\n  }\n\n  .sm\\:tracking-tight {\n    letter-spacing: -0.05em;\n  }\n\n  .sm\\:tracking-normal {\n    letter-spacing: 0;\n  }\n\n  .sm\\:tracking-wide {\n    letter-spacing: .05em;\n  }\n\n  .sm\\:select-none {\n    user-select: none;\n  }\n\n  .sm\\:select-text {\n    user-select: text;\n  }\n\n  .sm\\:align-baseline {\n    vertical-align: baseline;\n  }\n\n  .sm\\:align-top {\n    vertical-align: top;\n  }\n\n  .sm\\:align-middle {\n    vertical-align: middle;\n  }\n\n  .sm\\:align-bottom {\n    vertical-align: bottom;\n  }\n\n  .sm\\:align-text-top {\n    vertical-align: text-top;\n  }\n\n  .sm\\:align-text-bottom {\n    vertical-align: text-bottom;\n  }\n\n  .sm\\:visible {\n    visibility: visible;\n  }\n\n  .sm\\:invisible {\n    visibility: hidden;\n  }\n\n  .sm\\:whitespace-normal {\n    white-space: normal;\n  }\n\n  .sm\\:whitespace-no-wrap {\n    white-space: nowrap;\n  }\n\n  .sm\\:whitespace-pre {\n    white-space: pre;\n  }\n\n  .sm\\:whitespace-pre-line {\n    white-space: pre-line;\n  }\n\n  .sm\\:whitespace-pre-wrap {\n    white-space: pre-wrap;\n  }\n\n  .sm\\:break-words {\n    word-wrap: break-word;\n  }\n\n  .sm\\:break-normal {\n    word-wrap: normal;\n  }\n\n  .sm\\:truncate {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .sm\\:w-0 {\n    width: 0;\n  }\n\n  .sm\\:w-1 {\n    width: 2px;\n  }\n\n  .sm\\:w-2 {\n    width: 4px;\n  }\n\n  .sm\\:w-3 {\n    width: 8px;\n  }\n\n  .sm\\:w-4 {\n    width: 16px;\n  }\n\n  .sm\\:w-5 {\n    width: 24px;\n  }\n\n  .sm\\:w-6 {\n    width: 32px;\n  }\n\n  .sm\\:w-7 {\n    width: 36px;\n  }\n\n  .sm\\:w-8 {\n    width: 48px;\n  }\n\n  .sm\\:w-9 {\n    width: 64px;\n  }\n\n  .sm\\:w-10 {\n    width: 96px;\n  }\n\n  .sm\\:w-screen {\n    width: 100vw;\n  }\n\n  .sm\\:w-auto {\n    width: auto;\n  }\n\n  .sm\\:w-full {\n    width: 100%;\n  }\n\n  .sm\\:w-px {\n    width: 1px;\n  }\n\n  .sm\\:w-1\\/6 {\n    width: 16.666666667%;\n  }\n\n  .sm\\:z-0 {\n    z-index: 0;\n  }\n\n  .sm\\:z-10 {\n    z-index: 10;\n  }\n\n  .sm\\:z-20 {\n    z-index: 20;\n  }\n\n  .sm\\:z-30 {\n    z-index: 30;\n  }\n\n  .sm\\:z-40 {\n    z-index: 40;\n  }\n\n  .sm\\:z-50 {\n    z-index: 50;\n  }\n\n  .sm\\:z-auto {\n    z-index: auto;\n  }\n\n  .sm\\:bg-black-10 {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .sm\\:bg-white-10 {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .sm\\:bg-grey-lighter-10 {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .sm\\:bg-grey-light-10 {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .sm\\:bg-grey-10 {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .sm\\:bg-purple-lighter-10 {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .sm\\:bg-purple-light-10 {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .sm\\:bg-purple-10 {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .sm\\:bg-purple-bright-10 {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .sm\\:bg-purple-dark-10 {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:bg-purple-darker-10 {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .sm\\:hover\\:bg-black-10:hover {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .sm\\:hover\\:bg-white-10:hover {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .sm\\:hover\\:bg-grey-lighter-10:hover {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .sm\\:hover\\:bg-grey-light-10:hover {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .sm\\:hover\\:bg-grey-10:hover {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .sm\\:hover\\:bg-purple-lighter-10:hover {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .sm\\:hover\\:bg-purple-light-10:hover {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .sm\\:hover\\:bg-purple-10:hover {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .sm\\:hover\\:bg-purple-bright-10:hover {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .sm\\:hover\\:bg-purple-dark-10:hover {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:hover\\:bg-purple-darker-10:hover {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .sm\\:focus\\:bg-black-10:focus {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .sm\\:focus\\:bg-white-10:focus {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .sm\\:focus\\:bg-grey-lighter-10:focus {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .sm\\:focus\\:bg-grey-light-10:focus {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .sm\\:focus\\:bg-grey-10:focus {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .sm\\:focus\\:bg-purple-lighter-10:focus {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .sm\\:focus\\:bg-purple-light-10:focus {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .sm\\:focus\\:bg-purple-10:focus {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .sm\\:focus\\:bg-purple-bright-10:focus {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .sm\\:focus\\:bg-purple-dark-10:focus {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .sm\\:focus\\:bg-purple-darker-10:focus {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .sm\\:bg-black-30 {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .sm\\:bg-white-30 {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .sm\\:bg-grey-lighter-30 {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .sm\\:bg-grey-light-30 {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .sm\\:bg-grey-30 {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .sm\\:bg-purple-lighter-30 {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .sm\\:bg-purple-light-30 {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .sm\\:bg-purple-30 {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .sm\\:bg-purple-bright-30 {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .sm\\:bg-purple-dark-30 {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .sm\\:bg-purple-darker-30 {\n    background-color: rgba(42, 37, 56, .3);\n  }\n\n  .sm\\:hover\\:bg-black-30:hover {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .sm\\:hover\\:bg-white-30:hover {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .sm\\:hover\\:bg-grey-lighter-30:hover {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .sm\\:hover\\:bg-grey-light-30:hover {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .sm\\:hover\\:bg-grey-30:hover {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .sm\\:hover\\:bg-purple-lighter-30:hover {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .sm\\:hover\\:bg-purple-light-30:hover {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .sm\\:hover\\:bg-purple-30:hover {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .sm\\:hover\\:bg-purple-bright-30:hover {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .sm\\:hover\\:bg-purple-dark-30:hover {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .sm\\:hover\\:bg-purple-darker-30:hover {\n    background-color: rgba(42, 37, 56, .3);\n  }\n\n  .sm\\:focus\\:bg-black-30:focus {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .sm\\:focus\\:bg-white-30:focus {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .sm\\:focus\\:bg-grey-lighter-30:focus {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .sm\\:focus\\:bg-grey-light-30:focus {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .sm\\:focus\\:bg-grey-30:focus {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .sm\\:focus\\:bg-purple-lighter-30:focus {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .sm\\:focus\\:bg-purple-light-30:focus {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .sm\\:focus\\:bg-purple-30:focus {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .sm\\:focus\\:bg-purple-bright-30:focus {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .sm\\:focus\\:bg-purple-dark-30:focus {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .sm\\:focus\\:bg-purple-darker-30:focus {\n    background-color: rgba(42, 37, 56, .3);\n  }\n}\n\n@media (min-width: 768px) {\n  .md\\:list-reset {\n    list-style: none;\n    padding: 0;\n  }\n\n  .md\\:appearance-none {\n    appearance: none;\n  }\n\n  .md\\:bg-fixed {\n    background-attachment: fixed;\n  }\n\n  .md\\:bg-local {\n    background-attachment: local;\n  }\n\n  .md\\:bg-scroll {\n    background-attachment: scroll;\n  }\n\n  .md\\:bg-inherit {\n    background-color: inherit;\n  }\n\n  .md\\:bg-transparent {\n    background-color: transparent;\n  }\n\n  .md\\:bg-black {\n    background-color: #282828;\n  }\n\n  .md\\:bg-white {\n    background-color: #fff;\n  }\n\n  .md\\:bg-grey-lighter {\n    background-color: #f3f3f7;\n  }\n\n  .md\\:bg-grey-light {\n    background-color: #e7e7ec;\n  }\n\n  .md\\:bg-grey {\n    background-color: #c2c2c6;\n  }\n\n  .md\\:bg-purple-lighter {\n    background-color: #ccc2e9;\n  }\n\n  .md\\:bg-purple-light {\n    background-color: #87809b;\n  }\n\n  .md\\:bg-purple {\n    background-color: #8360d6;\n  }\n\n  .md\\:bg-purple-bright {\n    background-color: #4c29b0;\n  }\n\n  .md\\:bg-purple-dark {\n    background-color: #453f56;\n  }\n\n  .md\\:bg-purple-dark-10 {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:bg-purple-darker {\n    background-color: #2a2538;\n  }\n\n  .md\\:hover\\:bg-inherit:hover {\n    background-color: inherit;\n  }\n\n  .md\\:hover\\:bg-transparent:hover {\n    background-color: transparent;\n  }\n\n  .md\\:hover\\:bg-black:hover {\n    background-color: #282828;\n  }\n\n  .md\\:hover\\:bg-white:hover {\n    background-color: #fff;\n  }\n\n  .md\\:hover\\:bg-grey-lighter:hover {\n    background-color: #f3f3f7;\n  }\n\n  .md\\:hover\\:bg-grey-light:hover {\n    background-color: #e7e7ec;\n  }\n\n  .md\\:hover\\:bg-grey:hover {\n    background-color: #c2c2c6;\n  }\n\n  .md\\:hover\\:bg-purple-lighter:hover {\n    background-color: #ccc2e9;\n  }\n\n  .md\\:hover\\:bg-purple-light:hover {\n    background-color: #87809b;\n  }\n\n  .md\\:hover\\:bg-purple:hover {\n    background-color: #8360d6;\n  }\n\n  .md\\:hover\\:bg-purple-bright:hover {\n    background-color: #4c29b0;\n  }\n\n  .md\\:hover\\:bg-purple-dark:hover {\n    background-color: #453f56;\n  }\n\n  .md\\:hover\\:bg-purple-dark-10:hover {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:hover\\:bg-purple-darker:hover {\n    background-color: #2a2538;\n  }\n\n  .md\\:focus\\:bg-inherit:focus {\n    background-color: inherit;\n  }\n\n  .md\\:focus\\:bg-transparent:focus {\n    background-color: transparent;\n  }\n\n  .md\\:focus\\:bg-black:focus {\n    background-color: #282828;\n  }\n\n  .md\\:focus\\:bg-white:focus {\n    background-color: #fff;\n  }\n\n  .md\\:focus\\:bg-grey-lighter:focus {\n    background-color: #f3f3f7;\n  }\n\n  .md\\:focus\\:bg-grey-light:focus {\n    background-color: #e7e7ec;\n  }\n\n  .md\\:focus\\:bg-grey:focus {\n    background-color: #c2c2c6;\n  }\n\n  .md\\:focus\\:bg-purple-lighter:focus {\n    background-color: #ccc2e9;\n  }\n\n  .md\\:focus\\:bg-purple-light:focus {\n    background-color: #87809b;\n  }\n\n  .md\\:focus\\:bg-purple:focus {\n    background-color: #8360d6;\n  }\n\n  .md\\:focus\\:bg-purple-bright:focus {\n    background-color: #4c29b0;\n  }\n\n  .md\\:focus\\:bg-purple-dark:focus {\n    background-color: #453f56;\n  }\n\n  .md\\:focus\\:bg-purple-dark-10:focus {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:focus\\:bg-purple-darker:focus {\n    background-color: #2a2538;\n  }\n\n  .md\\:bg-bottom {\n    background-position: bottom;\n  }\n\n  .md\\:bg-center {\n    background-position: center;\n  }\n\n  .md\\:bg-left {\n    background-position: left;\n  }\n\n  .md\\:bg-left-bottom {\n    background-position: left bottom;\n  }\n\n  .md\\:bg-left-top {\n    background-position: left top;\n  }\n\n  .md\\:bg-right {\n    background-position: right;\n  }\n\n  .md\\:bg-right-bottom {\n    background-position: right bottom;\n  }\n\n  .md\\:bg-right-top {\n    background-position: right top;\n  }\n\n  .md\\:bg-top {\n    background-position: top;\n  }\n\n  .md\\:bg-repeat {\n    background-repeat: repeat;\n  }\n\n  .md\\:bg-no-repeat {\n    background-repeat: no-repeat;\n  }\n\n  .md\\:bg-repeat-x {\n    background-repeat: repeat-x;\n  }\n\n  .md\\:bg-repeat-y {\n    background-repeat: repeat-y;\n  }\n\n  .md\\:bg-auto {\n    background-size: auto;\n  }\n\n  .md\\:bg-cover {\n    background-size: cover;\n  }\n\n  .md\\:bg-contain {\n    background-size: contain;\n  }\n\n  .md\\:border-inherit {\n    border-color: inherit;\n  }\n\n  .md\\:border-transparent {\n    border-color: transparent;\n  }\n\n  .md\\:border-black {\n    border-color: #282828;\n  }\n\n  .md\\:border-white {\n    border-color: #fff;\n  }\n\n  .md\\:border-grey-lighter {\n    border-color: #f3f3f7;\n  }\n\n  .md\\:border-grey-light {\n    border-color: #e7e7ec;\n  }\n\n  .md\\:border-grey {\n    border-color: #c2c2c6;\n  }\n\n  .md\\:border-purple-lighter {\n    border-color: #ccc2e9;\n  }\n\n  .md\\:border-purple-light {\n    border-color: #87809b;\n  }\n\n  .md\\:border-purple {\n    border-color: #8360d6;\n  }\n\n  .md\\:border-purple-bright {\n    border-color: #4c29b0;\n  }\n\n  .md\\:border-purple-dark {\n    border-color: #453f56;\n  }\n\n  .md\\:border-purple-dark-10 {\n    border-color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:border-purple-darker {\n    border-color: #2a2538;\n  }\n\n  .md\\:hover\\:border-inherit:hover {\n    border-color: inherit;\n  }\n\n  .md\\:hover\\:border-transparent:hover {\n    border-color: transparent;\n  }\n\n  .md\\:hover\\:border-black:hover {\n    border-color: #282828;\n  }\n\n  .md\\:hover\\:border-white:hover {\n    border-color: #fff;\n  }\n\n  .md\\:hover\\:border-grey-lighter:hover {\n    border-color: #f3f3f7;\n  }\n\n  .md\\:hover\\:border-grey-light:hover {\n    border-color: #e7e7ec;\n  }\n\n  .md\\:hover\\:border-grey:hover {\n    border-color: #c2c2c6;\n  }\n\n  .md\\:hover\\:border-purple-lighter:hover {\n    border-color: #ccc2e9;\n  }\n\n  .md\\:hover\\:border-purple-light:hover {\n    border-color: #87809b;\n  }\n\n  .md\\:hover\\:border-purple:hover {\n    border-color: #8360d6;\n  }\n\n  .md\\:hover\\:border-purple-bright:hover {\n    border-color: #4c29b0;\n  }\n\n  .md\\:hover\\:border-purple-dark:hover {\n    border-color: #453f56;\n  }\n\n  .md\\:hover\\:border-purple-dark-10:hover {\n    border-color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:hover\\:border-purple-darker:hover {\n    border-color: #2a2538;\n  }\n\n  .md\\:rounded-none {\n    border-radius: 0;\n  }\n\n  .md\\:rounded-sm {\n    border-radius: 2px;\n  }\n\n  .md\\:rounded {\n    border-radius: 4px;\n  }\n\n  .md\\:rounded-full {\n    border-radius: 9999px;\n  }\n\n  .md\\:rounded-t-none {\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n  }\n\n  .md\\:rounded-r-none {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n\n  .md\\:rounded-b-none {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  .md\\:rounded-l-none {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  .md\\:rounded-t-sm {\n    border-top-left-radius: 2px;\n    border-top-right-radius: 2px;\n  }\n\n  .md\\:rounded-r-sm {\n    border-top-right-radius: 2px;\n    border-bottom-right-radius: 2px;\n  }\n\n  .md\\:rounded-b-sm {\n    border-bottom-right-radius: 2px;\n    border-bottom-left-radius: 2px;\n  }\n\n  .md\\:rounded-l-sm {\n    border-top-left-radius: 2px;\n    border-bottom-left-radius: 2px;\n  }\n\n  .md\\:rounded-t {\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n  }\n\n  .md\\:rounded-r {\n    border-top-right-radius: 4px;\n    border-bottom-right-radius: 4px;\n  }\n\n  .md\\:rounded-b {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n\n  .md\\:rounded-l {\n    border-top-left-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n\n  .md\\:rounded-t-full {\n    border-top-left-radius: 9999px;\n    border-top-right-radius: 9999px;\n  }\n\n  .md\\:rounded-r-full {\n    border-top-right-radius: 9999px;\n    border-bottom-right-radius: 9999px;\n  }\n\n  .md\\:rounded-b-full {\n    border-bottom-right-radius: 9999px;\n    border-bottom-left-radius: 9999px;\n  }\n\n  .md\\:rounded-l-full {\n    border-top-left-radius: 9999px;\n    border-bottom-left-radius: 9999px;\n  }\n\n  .md\\:rounded-tl-none {\n    border-top-left-radius: 0;\n  }\n\n  .md\\:rounded-tr-none {\n    border-top-right-radius: 0;\n  }\n\n  .md\\:rounded-br-none {\n    border-bottom-right-radius: 0;\n  }\n\n  .md\\:rounded-bl-none {\n    border-bottom-left-radius: 0;\n  }\n\n  .md\\:rounded-tl-sm {\n    border-top-left-radius: 2px;\n  }\n\n  .md\\:rounded-tr-sm {\n    border-top-right-radius: 2px;\n  }\n\n  .md\\:rounded-br-sm {\n    border-bottom-right-radius: 2px;\n  }\n\n  .md\\:rounded-bl-sm {\n    border-bottom-left-radius: 2px;\n  }\n\n  .md\\:rounded-tl {\n    border-top-left-radius: 4px;\n  }\n\n  .md\\:rounded-tr {\n    border-top-right-radius: 4px;\n  }\n\n  .md\\:rounded-br {\n    border-bottom-right-radius: 4px;\n  }\n\n  .md\\:rounded-bl {\n    border-bottom-left-radius: 4px;\n  }\n\n  .md\\:rounded-tl-full {\n    border-top-left-radius: 9999px;\n  }\n\n  .md\\:rounded-tr-full {\n    border-top-right-radius: 9999px;\n  }\n\n  .md\\:rounded-br-full {\n    border-bottom-right-radius: 9999px;\n  }\n\n  .md\\:rounded-bl-full {\n    border-bottom-left-radius: 9999px;\n  }\n\n  .md\\:border-solid {\n    border-style: solid;\n  }\n\n  .md\\:border-dashed {\n    border-style: dashed;\n  }\n\n  .md\\:border-dotted {\n    border-style: dotted;\n  }\n\n  .md\\:border-none {\n    border-style: none;\n  }\n\n  .md\\:border-0 {\n    border-width: 0;\n  }\n\n  .md\\:border-2 {\n    border-width: 2px;\n  }\n\n  .md\\:border-4 {\n    border-width: 4px;\n  }\n\n  .md\\:border-8 {\n    border-width: 8px;\n  }\n\n  .md\\:border {\n    border-width: 1px;\n  }\n\n  .md\\:border-t-0 {\n    border-top-width: 0;\n  }\n\n  .md\\:border-r-0 {\n    border-right-width: 0;\n  }\n\n  .md\\:border-b-0 {\n    border-bottom-width: 0;\n  }\n\n  .md\\:border-l-0 {\n    border-left-width: 0;\n  }\n\n  .md\\:border-t-2 {\n    border-top-width: 2px;\n  }\n\n  .md\\:border-r-2 {\n    border-right-width: 2px;\n  }\n\n  .md\\:border-b-2 {\n    border-bottom-width: 2px;\n  }\n\n  .md\\:border-l-2 {\n    border-left-width: 2px;\n  }\n\n  .md\\:border-t-4 {\n    border-top-width: 4px;\n  }\n\n  .md\\:border-r-4 {\n    border-right-width: 4px;\n  }\n\n  .md\\:border-b-4 {\n    border-bottom-width: 4px;\n  }\n\n  .md\\:border-l-4 {\n    border-left-width: 4px;\n  }\n\n  .md\\:border-t-8 {\n    border-top-width: 8px;\n  }\n\n  .md\\:border-r-8 {\n    border-right-width: 8px;\n  }\n\n  .md\\:border-b-8 {\n    border-bottom-width: 8px;\n  }\n\n  .md\\:border-l-8 {\n    border-left-width: 8px;\n  }\n\n  .md\\:border-t {\n    border-top-width: 1px;\n  }\n\n  .md\\:border-r {\n    border-right-width: 1px;\n  }\n\n  .md\\:border-b {\n    border-bottom-width: 1px;\n  }\n\n  .md\\:border-l {\n    border-left-width: 1px;\n  }\n\n  .md\\:cursor-auto {\n    cursor: auto;\n  }\n\n  .md\\:cursor-default {\n    cursor: default;\n  }\n\n  .md\\:cursor-pointer {\n    cursor: pointer;\n  }\n\n  .md\\:cursor-wait {\n    cursor: wait;\n  }\n\n  .md\\:cursor-move {\n    cursor: move;\n  }\n\n  .md\\:cursor-not-allowed {\n    cursor: not-allowed;\n  }\n\n  .md\\:block {\n    display: block;\n  }\n\n  .md\\:inline-block {\n    display: inline-block;\n  }\n\n  .md\\:inline {\n    display: inline;\n  }\n\n  .md\\:table {\n    display: table;\n  }\n\n  .md\\:table-row {\n    display: table-row;\n  }\n\n  .md\\:table-cell {\n    display: table-cell;\n  }\n\n  .md\\:hidden {\n    display: none;\n  }\n\n  .md\\:flex {\n    display: flex;\n  }\n\n  .md\\:inline-flex {\n    display: inline-flex;\n  }\n\n  .md\\:flex-row {\n    flex-direction: row;\n  }\n\n  .md\\:flex-row-reverse {\n    flex-direction: row-reverse;\n  }\n\n  .md\\:flex-col {\n    flex-direction: column;\n  }\n\n  .md\\:flex-col-reverse {\n    flex-direction: column-reverse;\n  }\n\n  .md\\:flex-wrap {\n    flex-wrap: wrap;\n  }\n\n  .md\\:flex-wrap-reverse {\n    flex-wrap: wrap-reverse;\n  }\n\n  .md\\:flex-no-wrap {\n    flex-wrap: nowrap;\n  }\n\n  .md\\:items-start {\n    align-items: flex-start;\n  }\n\n  .md\\:items-end {\n    align-items: flex-end;\n  }\n\n  .md\\:items-center {\n    align-items: center;\n  }\n\n  .md\\:items-baseline {\n    align-items: baseline;\n  }\n\n  .md\\:items-stretch {\n    align-items: stretch;\n  }\n\n  .md\\:self-auto {\n    align-self: auto;\n  }\n\n  .md\\:self-start {\n    align-self: flex-start;\n  }\n\n  .md\\:self-end {\n    align-self: flex-end;\n  }\n\n  .md\\:self-center {\n    align-self: center;\n  }\n\n  .md\\:self-stretch {\n    align-self: stretch;\n  }\n\n  .md\\:justify-start {\n    justify-content: flex-start;\n  }\n\n  .md\\:justify-end {\n    justify-content: flex-end;\n  }\n\n  .md\\:justify-center {\n    justify-content: center;\n  }\n\n  .md\\:justify-between {\n    justify-content: space-between;\n  }\n\n  .md\\:justify-around {\n    justify-content: space-around;\n  }\n\n  .md\\:content-center {\n    align-content: center;\n  }\n\n  .md\\:content-start {\n    align-content: flex-start;\n  }\n\n  .md\\:content-end {\n    align-content: flex-end;\n  }\n\n  .md\\:content-between {\n    align-content: space-between;\n  }\n\n  .md\\:content-around {\n    align-content: space-around;\n  }\n\n  .md\\:flex-1 {\n    flex: 1;\n  }\n\n  .md\\:flex-auto {\n    flex: auto;\n  }\n\n  .md\\:flex-initial {\n    flex: initial;\n  }\n\n  .md\\:flex-none {\n    flex: none;\n  }\n\n  .md\\:flex-grow {\n    flex-grow: 1;\n  }\n\n  .md\\:flex-shrink {\n    flex-shrink: 1;\n  }\n\n  .md\\:flex-no-grow {\n    flex-grow: 0;\n  }\n\n  .md\\:flex-no-shrink {\n    flex-shrink: 0;\n  }\n\n  .md\\:float-right {\n    float: right;\n  }\n\n  .md\\:float-left {\n    float: left;\n  }\n\n  .md\\:float-none {\n    float: none;\n  }\n\n  .md\\:clearfix:after {\n    content: \"\";\n    display: table;\n    clear: both;\n  }\n\n  .md\\:font-sans {\n    font-family: system-ui, BlinkMacSystemFont, -apple-system, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  }\n\n  .md\\:font-serif {\n    font-family: Constantia, Lucida Bright, Lucidabright, Lucida Serif, Lucida, DejaVu Serif, Bitstream Vera Serif, Liberation Serif, Georgia, serif;\n  }\n\n  .md\\:font-mono {\n    font-family: Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;\n  }\n\n  .md\\:font-hairline {\n    font-weight: 100;\n  }\n\n  .md\\:font-thin {\n    font-weight: 200;\n  }\n\n  .md\\:font-light {\n    font-weight: 300;\n  }\n\n  .md\\:font-normal {\n    font-weight: 400;\n  }\n\n  .md\\:font-medium {\n    font-weight: 500;\n  }\n\n  .md\\:font-semibold {\n    font-weight: 600;\n  }\n\n  .md\\:font-bold {\n    font-weight: 700;\n  }\n\n  .md\\:font-extrabold {\n    font-weight: 800;\n  }\n\n  .md\\:font-black {\n    font-weight: 900;\n  }\n\n  .md\\:hover\\:font-hairline:hover {\n    font-weight: 100;\n  }\n\n  .md\\:hover\\:font-thin:hover {\n    font-weight: 200;\n  }\n\n  .md\\:hover\\:font-light:hover {\n    font-weight: 300;\n  }\n\n  .md\\:hover\\:font-normal:hover {\n    font-weight: 400;\n  }\n\n  .md\\:hover\\:font-medium:hover {\n    font-weight: 500;\n  }\n\n  .md\\:hover\\:font-semibold:hover {\n    font-weight: 600;\n  }\n\n  .md\\:hover\\:font-bold:hover {\n    font-weight: 700;\n  }\n\n  .md\\:hover\\:font-extrabold:hover {\n    font-weight: 800;\n  }\n\n  .md\\:hover\\:font-black:hover {\n    font-weight: 900;\n  }\n\n  .md\\:h-0 {\n    height: 0;\n  }\n\n  .md\\:h-1 {\n    height: 2px;\n  }\n\n  .md\\:h-2 {\n    height: 4px;\n  }\n\n  .md\\:h-3 {\n    height: 8px;\n  }\n\n  .md\\:h-4 {\n    height: 16px;\n  }\n\n  .md\\:h-5 {\n    height: 24px;\n  }\n\n  .md\\:h-6 {\n    height: 32px;\n  }\n\n  .md\\:h-7 {\n    height: 36px;\n  }\n\n  .md\\:h-8 {\n    height: 48px;\n  }\n\n  .md\\:h-9 {\n    height: 64px;\n  }\n\n  .md\\:h-10 {\n    height: 96px;\n  }\n\n  .md\\:h-screen {\n    height: 100vh;\n  }\n\n  .md\\:h-auto {\n    height: auto;\n  }\n\n  .md\\:h-full {\n    height: 100%;\n  }\n\n  .md\\:h-px {\n    height: 1px;\n  }\n\n  .md\\:h-1\\/6 {\n    height: 16.666666667%;\n  }\n\n  .md\\:leading-none {\n    line-height: 1;\n  }\n\n  .md\\:leading-tight {\n    line-height: 1.25;\n  }\n\n  .md\\:leading-normal {\n    line-height: 1.5;\n  }\n\n  .md\\:leading-loose {\n    line-height: 2;\n  }\n\n  .md\\:m-0 {\n    margin: 0;\n  }\n\n  .md\\:m-1 {\n    margin: 2px;\n  }\n\n  .md\\:m-2 {\n    margin: 4px;\n  }\n\n  .md\\:m-3 {\n    margin: 8px;\n  }\n\n  .md\\:m-4 {\n    margin: 16px;\n  }\n\n  .md\\:m-5 {\n    margin: 24px;\n  }\n\n  .md\\:m-6 {\n    margin: 32px;\n  }\n\n  .md\\:m-7 {\n    margin: 36px;\n  }\n\n  .md\\:m-8 {\n    margin: 48px;\n  }\n\n  .md\\:m-9 {\n    margin: 64px;\n  }\n\n  .md\\:m-10 {\n    margin: 96px;\n  }\n\n  .md\\:m-auto {\n    margin: auto;\n  }\n\n  .md\\:m-full {\n    margin: 100%;\n  }\n\n  .md\\:m-px {\n    margin: 1px;\n  }\n\n  .md\\:m-1\\/6 {\n    margin: 16.666666667%;\n  }\n\n  .md\\:my-0 {\n    margin-top: 0;\n    margin-bottom: 0;\n  }\n\n  .md\\:mx-0 {\n    margin-left: 0;\n    margin-right: 0;\n  }\n\n  .md\\:my-1 {\n    margin-top: 2px;\n    margin-bottom: 2px;\n  }\n\n  .md\\:mx-1 {\n    margin-left: 2px;\n    margin-right: 2px;\n  }\n\n  .md\\:my-2 {\n    margin-top: 4px;\n    margin-bottom: 4px;\n  }\n\n  .md\\:mx-2 {\n    margin-left: 4px;\n    margin-right: 4px;\n  }\n\n  .md\\:my-3 {\n    margin-top: 8px;\n    margin-bottom: 8px;\n  }\n\n  .md\\:mx-3 {\n    margin-left: 8px;\n    margin-right: 8px;\n  }\n\n  .md\\:my-4 {\n    margin-top: 16px;\n    margin-bottom: 16px;\n  }\n\n  .md\\:mx-4 {\n    margin-left: 16px;\n    margin-right: 16px;\n  }\n\n  .md\\:my-5 {\n    margin-top: 24px;\n    margin-bottom: 24px;\n  }\n\n  .md\\:mx-5 {\n    margin-left: 24px;\n    margin-right: 24px;\n  }\n\n  .md\\:my-6 {\n    margin-top: 32px;\n    margin-bottom: 32px;\n  }\n\n  .md\\:mx-6 {\n    margin-left: 32px;\n    margin-right: 32px;\n  }\n\n  .md\\:my-7 {\n    margin-top: 36px;\n    margin-bottom: 36px;\n  }\n\n  .md\\:mx-7 {\n    margin-left: 36px;\n    margin-right: 36px;\n  }\n\n  .md\\:my-8 {\n    margin-top: 48px;\n    margin-bottom: 48px;\n  }\n\n  .md\\:mx-8 {\n    margin-left: 48px;\n    margin-right: 48px;\n  }\n\n  .md\\:my-9 {\n    margin-top: 64px;\n    margin-bottom: 64px;\n  }\n\n  .md\\:mx-9 {\n    margin-left: 64px;\n    margin-right: 64px;\n  }\n\n  .md\\:my-10 {\n    margin-top: 96px;\n    margin-bottom: 96px;\n  }\n\n  .md\\:mx-10 {\n    margin-left: 96px;\n    margin-right: 96px;\n  }\n\n  .md\\:my-auto {\n    margin-top: auto;\n    margin-bottom: auto;\n  }\n\n  .md\\:mx-auto {\n    margin-left: auto;\n    margin-right: auto;\n  }\n\n  .md\\:my-full {\n    margin-top: 100%;\n    margin-bottom: 100%;\n  }\n\n  .md\\:mx-full {\n    margin-left: 100%;\n    margin-right: 100%;\n  }\n\n  .md\\:my-px {\n    margin-top: 1px;\n    margin-bottom: 1px;\n  }\n\n  .md\\:mx-px {\n    margin-left: 1px;\n    margin-right: 1px;\n  }\n\n  .md\\:my-1\\/6 {\n    margin-top: 16.666666667%;\n    margin-bottom: 16.666666667%;\n  }\n\n  .md\\:mx-1\\/6 {\n    margin-left: 16.666666667%;\n    margin-right: 16.666666667%;\n  }\n\n  .md\\:mt-0 {\n    margin-top: 0;\n  }\n\n  .md\\:mr-0 {\n    margin-right: 0;\n  }\n\n  .md\\:mb-0 {\n    margin-bottom: 0;\n  }\n\n  .md\\:ml-0 {\n    margin-left: 0;\n  }\n\n  .md\\:mt-1 {\n    margin-top: 2px;\n  }\n\n  .md\\:mr-1 {\n    margin-right: 2px;\n  }\n\n  .md\\:mb-1 {\n    margin-bottom: 2px;\n  }\n\n  .md\\:ml-1 {\n    margin-left: 2px;\n  }\n\n  .md\\:mt-2 {\n    margin-top: 4px;\n  }\n\n  .md\\:mr-2 {\n    margin-right: 4px;\n  }\n\n  .md\\:mb-2 {\n    margin-bottom: 4px;\n  }\n\n  .md\\:ml-2 {\n    margin-left: 4px;\n  }\n\n  .md\\:mt-3 {\n    margin-top: 8px;\n  }\n\n  .md\\:mr-3 {\n    margin-right: 8px;\n  }\n\n  .md\\:mb-3 {\n    margin-bottom: 8px;\n  }\n\n  .md\\:ml-3 {\n    margin-left: 8px;\n  }\n\n  .md\\:mt-4 {\n    margin-top: 16px;\n  }\n\n  .md\\:mr-4 {\n    margin-right: 16px;\n  }\n\n  .md\\:mb-4 {\n    margin-bottom: 16px;\n  }\n\n  .md\\:ml-4 {\n    margin-left: 16px;\n  }\n\n  .md\\:mt-5 {\n    margin-top: 24px;\n  }\n\n  .md\\:mr-5 {\n    margin-right: 24px;\n  }\n\n  .md\\:mb-5 {\n    margin-bottom: 24px;\n  }\n\n  .md\\:ml-5 {\n    margin-left: 24px;\n  }\n\n  .md\\:mt-6 {\n    margin-top: 32px;\n  }\n\n  .md\\:mr-6 {\n    margin-right: 32px;\n  }\n\n  .md\\:mb-6 {\n    margin-bottom: 32px;\n  }\n\n  .md\\:ml-6 {\n    margin-left: 32px;\n  }\n\n  .md\\:mt-7 {\n    margin-top: 36px;\n  }\n\n  .md\\:mr-7 {\n    margin-right: 36px;\n  }\n\n  .md\\:mb-7 {\n    margin-bottom: 36px;\n  }\n\n  .md\\:ml-7 {\n    margin-left: 36px;\n  }\n\n  .md\\:mt-8 {\n    margin-top: 48px;\n  }\n\n  .md\\:mr-8 {\n    margin-right: 48px;\n  }\n\n  .md\\:mb-8 {\n    margin-bottom: 48px;\n  }\n\n  .md\\:ml-8 {\n    margin-left: 48px;\n  }\n\n  .md\\:mt-9 {\n    margin-top: 64px;\n  }\n\n  .md\\:mr-9 {\n    margin-right: 64px;\n  }\n\n  .md\\:mb-9 {\n    margin-bottom: 64px;\n  }\n\n  .md\\:ml-9 {\n    margin-left: 64px;\n  }\n\n  .md\\:mt-10 {\n    margin-top: 96px;\n  }\n\n  .md\\:mr-10 {\n    margin-right: 96px;\n  }\n\n  .md\\:mb-10 {\n    margin-bottom: 96px;\n  }\n\n  .md\\:ml-10 {\n    margin-left: 96px;\n  }\n\n  .md\\:mt-auto {\n    margin-top: auto;\n  }\n\n  .md\\:mr-auto {\n    margin-right: auto;\n  }\n\n  .md\\:mb-auto {\n    margin-bottom: auto;\n  }\n\n  .md\\:ml-auto {\n    margin-left: auto;\n  }\n\n  .md\\:mt-full {\n    margin-top: 100%;\n  }\n\n  .md\\:mr-full {\n    margin-right: 100%;\n  }\n\n  .md\\:mb-full {\n    margin-bottom: 100%;\n  }\n\n  .md\\:ml-full {\n    margin-left: 100%;\n  }\n\n  .md\\:mt-px {\n    margin-top: 1px;\n  }\n\n  .md\\:mr-px {\n    margin-right: 1px;\n  }\n\n  .md\\:mb-px {\n    margin-bottom: 1px;\n  }\n\n  .md\\:ml-px {\n    margin-left: 1px;\n  }\n\n  .md\\:mt-1\\/6 {\n    margin-top: 16.666666667%;\n  }\n\n  .md\\:mr-1\\/6 {\n    margin-right: 16.666666667%;\n  }\n\n  .md\\:mb-1\\/6 {\n    margin-bottom: 16.666666667%;\n  }\n\n  .md\\:ml-1\\/6 {\n    margin-left: 16.666666667%;\n  }\n\n  .md\\:max-h-0 {\n    max-height: 0;\n  }\n\n  .md\\:max-h-1 {\n    max-height: 2px;\n  }\n\n  .md\\:max-h-2 {\n    max-height: 4px;\n  }\n\n  .md\\:max-h-3 {\n    max-height: 8px;\n  }\n\n  .md\\:max-h-4 {\n    max-height: 16px;\n  }\n\n  .md\\:max-h-5 {\n    max-height: 24px;\n  }\n\n  .md\\:max-h-6 {\n    max-height: 32px;\n  }\n\n  .md\\:max-h-7 {\n    max-height: 36px;\n  }\n\n  .md\\:max-h-8 {\n    max-height: 48px;\n  }\n\n  .md\\:max-h-9 {\n    max-height: 64px;\n  }\n\n  .md\\:max-h-10 {\n    max-height: 96px;\n  }\n\n  .md\\:max-h-screen {\n    max-height: 100vh;\n  }\n\n  .md\\:max-h-auto {\n    max-height: auto;\n  }\n\n  .md\\:max-h-full {\n    max-height: 100%;\n  }\n\n  .md\\:max-h-px {\n    max-height: 1px;\n  }\n\n  .md\\:max-h-1\\/6 {\n    max-height: 16.666666667%;\n  }\n\n  .md\\:max-w-0 {\n    max-width: 0;\n  }\n\n  .md\\:max-w-1 {\n    max-width: 2px;\n  }\n\n  .md\\:max-w-2 {\n    max-width: 4px;\n  }\n\n  .md\\:max-w-3 {\n    max-width: 8px;\n  }\n\n  .md\\:max-w-4 {\n    max-width: 16px;\n  }\n\n  .md\\:max-w-5 {\n    max-width: 24px;\n  }\n\n  .md\\:max-w-6 {\n    max-width: 32px;\n  }\n\n  .md\\:max-w-7 {\n    max-width: 36px;\n  }\n\n  .md\\:max-w-8 {\n    max-width: 48px;\n  }\n\n  .md\\:max-w-9 {\n    max-width: 64px;\n  }\n\n  .md\\:max-w-10 {\n    max-width: 96px;\n  }\n\n  .md\\:max-w-auto {\n    max-width: auto;\n  }\n\n  .md\\:max-w-full {\n    max-width: 100%;\n  }\n\n  .md\\:max-w-px {\n    max-width: 1px;\n  }\n\n  .md\\:max-w-1\\/6 {\n    max-width: 16.666666667%;\n  }\n\n  .md\\:min-h-0 {\n    min-height: 0;\n  }\n\n  .md\\:min-h-1 {\n    min-height: 2px;\n  }\n\n  .md\\:min-h-2 {\n    min-height: 4px;\n  }\n\n  .md\\:min-h-3 {\n    min-height: 8px;\n  }\n\n  .md\\:min-h-4 {\n    min-height: 16px;\n  }\n\n  .md\\:min-h-5 {\n    min-height: 24px;\n  }\n\n  .md\\:min-h-6 {\n    min-height: 32px;\n  }\n\n  .md\\:min-h-7 {\n    min-height: 36px;\n  }\n\n  .md\\:min-h-8 {\n    min-height: 48px;\n  }\n\n  .md\\:min-h-9 {\n    min-height: 64px;\n  }\n\n  .md\\:min-h-10 {\n    min-height: 96px;\n  }\n\n  .md\\:min-h-screen {\n    min-height: 100vh;\n  }\n\n  .md\\:min-h-auto {\n    min-height: auto;\n  }\n\n  .md\\:min-h-full {\n    min-height: 100%;\n  }\n\n  .md\\:min-h-px {\n    min-height: 1px;\n  }\n\n  .md\\:min-h-1\\/6 {\n    min-height: 16.666666667%;\n  }\n\n  .md\\:min-w-0 {\n    min-width: 0;\n  }\n\n  .md\\:min-w-1 {\n    min-width: 2px;\n  }\n\n  .md\\:min-w-2 {\n    min-width: 4px;\n  }\n\n  .md\\:min-w-3 {\n    min-width: 8px;\n  }\n\n  .md\\:min-w-4 {\n    min-width: 16px;\n  }\n\n  .md\\:min-w-5 {\n    min-width: 24px;\n  }\n\n  .md\\:min-w-6 {\n    min-width: 32px;\n  }\n\n  .md\\:min-w-7 {\n    min-width: 36px;\n  }\n\n  .md\\:min-w-8 {\n    min-width: 48px;\n  }\n\n  .md\\:min-w-9 {\n    min-width: 64px;\n  }\n\n  .md\\:min-w-10 {\n    min-width: 96px;\n  }\n\n  .md\\:min-w-auto {\n    min-width: auto;\n  }\n\n  .md\\:min-w-full {\n    min-width: 100%;\n  }\n\n  .md\\:min-w-px {\n    min-width: 1px;\n  }\n\n  .md\\:min-w-1\\/6 {\n    min-width: 16.666666667%;\n  }\n\n  .md\\:-m-0 {\n    margin: 0;\n  }\n\n  .md\\:-m-1 {\n    margin: -2px;\n  }\n\n  .md\\:-m-2 {\n    margin: -4px;\n  }\n\n  .md\\:-m-3 {\n    margin: -8px;\n  }\n\n  .md\\:-m-4 {\n    margin: -16px;\n  }\n\n  .md\\:-m-5 {\n    margin: -24px;\n  }\n\n  .md\\:-m-6 {\n    margin: -32px;\n  }\n\n  .md\\:-m-7 {\n    margin: -36px;\n  }\n\n  .md\\:-m-8 {\n    margin: -48px;\n  }\n\n  .md\\:-m-9 {\n    margin: -64px;\n  }\n\n  .md\\:-m-10 {\n    margin: -96px;\n  }\n\n  .md\\:-m-auto {\n    margin: -auto;\n  }\n\n  .md\\:-m-full {\n    margin: -100%;\n  }\n\n  .md\\:-m-px {\n    margin: -1px;\n  }\n\n  .md\\:-m-1\\/6 {\n    margin: -16.666666667%;\n  }\n\n  .md\\:-my-0 {\n    margin-top: 0;\n    margin-bottom: 0;\n  }\n\n  .md\\:-mx-0 {\n    margin-left: 0;\n    margin-right: 0;\n  }\n\n  .md\\:-my-1 {\n    margin-top: -2px;\n    margin-bottom: -2px;\n  }\n\n  .md\\:-mx-1 {\n    margin-left: -2px;\n    margin-right: -2px;\n  }\n\n  .md\\:-my-2 {\n    margin-top: -4px;\n    margin-bottom: -4px;\n  }\n\n  .md\\:-mx-2 {\n    margin-left: -4px;\n    margin-right: -4px;\n  }\n\n  .md\\:-my-3 {\n    margin-top: -8px;\n    margin-bottom: -8px;\n  }\n\n  .md\\:-mx-3 {\n    margin-left: -8px;\n    margin-right: -8px;\n  }\n\n  .md\\:-my-4 {\n    margin-top: -16px;\n    margin-bottom: -16px;\n  }\n\n  .md\\:-mx-4 {\n    margin-left: -16px;\n    margin-right: -16px;\n  }\n\n  .md\\:-my-5 {\n    margin-top: -24px;\n    margin-bottom: -24px;\n  }\n\n  .md\\:-mx-5 {\n    margin-left: -24px;\n    margin-right: -24px;\n  }\n\n  .md\\:-my-6 {\n    margin-top: -32px;\n    margin-bottom: -32px;\n  }\n\n  .md\\:-mx-6 {\n    margin-left: -32px;\n    margin-right: -32px;\n  }\n\n  .md\\:-my-7 {\n    margin-top: -36px;\n    margin-bottom: -36px;\n  }\n\n  .md\\:-mx-7 {\n    margin-left: -36px;\n    margin-right: -36px;\n  }\n\n  .md\\:-my-8 {\n    margin-top: -48px;\n    margin-bottom: -48px;\n  }\n\n  .md\\:-mx-8 {\n    margin-left: -48px;\n    margin-right: -48px;\n  }\n\n  .md\\:-my-9 {\n    margin-top: -64px;\n    margin-bottom: -64px;\n  }\n\n  .md\\:-mx-9 {\n    margin-left: -64px;\n    margin-right: -64px;\n  }\n\n  .md\\:-my-10 {\n    margin-top: -96px;\n    margin-bottom: -96px;\n  }\n\n  .md\\:-mx-10 {\n    margin-left: -96px;\n    margin-right: -96px;\n  }\n\n  .md\\:-my-auto {\n    margin-top: -auto;\n    margin-bottom: -auto;\n  }\n\n  .md\\:-mx-auto {\n    margin-left: -auto;\n    margin-right: -auto;\n  }\n\n  .md\\:-my-full {\n    margin-top: -100%;\n    margin-bottom: -100%;\n  }\n\n  .md\\:-mx-full {\n    margin-left: -100%;\n    margin-right: -100%;\n  }\n\n  .md\\:-my-px {\n    margin-top: -1px;\n    margin-bottom: -1px;\n  }\n\n  .md\\:-mx-px {\n    margin-left: -1px;\n    margin-right: -1px;\n  }\n\n  .md\\:-my-1\\/6 {\n    margin-top: -16.666666667%;\n    margin-bottom: -16.666666667%;\n  }\n\n  .md\\:-mx-1\\/6 {\n    margin-left: -16.666666667%;\n    margin-right: -16.666666667%;\n  }\n\n  .md\\:-mt-0 {\n    margin-top: 0;\n  }\n\n  .md\\:-mr-0 {\n    margin-right: 0;\n  }\n\n  .md\\:-mb-0 {\n    margin-bottom: 0;\n  }\n\n  .md\\:-ml-0 {\n    margin-left: 0;\n  }\n\n  .md\\:-mt-1 {\n    margin-top: -2px;\n  }\n\n  .md\\:-mr-1 {\n    margin-right: -2px;\n  }\n\n  .md\\:-mb-1 {\n    margin-bottom: -2px;\n  }\n\n  .md\\:-ml-1 {\n    margin-left: -2px;\n  }\n\n  .md\\:-mt-2 {\n    margin-top: -4px;\n  }\n\n  .md\\:-mr-2 {\n    margin-right: -4px;\n  }\n\n  .md\\:-mb-2 {\n    margin-bottom: -4px;\n  }\n\n  .md\\:-ml-2 {\n    margin-left: -4px;\n  }\n\n  .md\\:-mt-3 {\n    margin-top: -8px;\n  }\n\n  .md\\:-mr-3 {\n    margin-right: -8px;\n  }\n\n  .md\\:-mb-3 {\n    margin-bottom: -8px;\n  }\n\n  .md\\:-ml-3 {\n    margin-left: -8px;\n  }\n\n  .md\\:-mt-4 {\n    margin-top: -16px;\n  }\n\n  .md\\:-mr-4 {\n    margin-right: -16px;\n  }\n\n  .md\\:-mb-4 {\n    margin-bottom: -16px;\n  }\n\n  .md\\:-ml-4 {\n    margin-left: -16px;\n  }\n\n  .md\\:-mt-5 {\n    margin-top: -24px;\n  }\n\n  .md\\:-mr-5 {\n    margin-right: -24px;\n  }\n\n  .md\\:-mb-5 {\n    margin-bottom: -24px;\n  }\n\n  .md\\:-ml-5 {\n    margin-left: -24px;\n  }\n\n  .md\\:-mt-6 {\n    margin-top: -32px;\n  }\n\n  .md\\:-mr-6 {\n    margin-right: -32px;\n  }\n\n  .md\\:-mb-6 {\n    margin-bottom: -32px;\n  }\n\n  .md\\:-ml-6 {\n    margin-left: -32px;\n  }\n\n  .md\\:-mt-7 {\n    margin-top: -36px;\n  }\n\n  .md\\:-mr-7 {\n    margin-right: -36px;\n  }\n\n  .md\\:-mb-7 {\n    margin-bottom: -36px;\n  }\n\n  .md\\:-ml-7 {\n    margin-left: -36px;\n  }\n\n  .md\\:-mt-8 {\n    margin-top: -48px;\n  }\n\n  .md\\:-mr-8 {\n    margin-right: -48px;\n  }\n\n  .md\\:-mb-8 {\n    margin-bottom: -48px;\n  }\n\n  .md\\:-ml-8 {\n    margin-left: -48px;\n  }\n\n  .md\\:-mt-9 {\n    margin-top: -64px;\n  }\n\n  .md\\:-mr-9 {\n    margin-right: -64px;\n  }\n\n  .md\\:-mb-9 {\n    margin-bottom: -64px;\n  }\n\n  .md\\:-ml-9 {\n    margin-left: -64px;\n  }\n\n  .md\\:-mt-10 {\n    margin-top: -96px;\n  }\n\n  .md\\:-mr-10 {\n    margin-right: -96px;\n  }\n\n  .md\\:-mb-10 {\n    margin-bottom: -96px;\n  }\n\n  .md\\:-ml-10 {\n    margin-left: -96px;\n  }\n\n  .md\\:-mt-auto {\n    margin-top: -auto;\n  }\n\n  .md\\:-mr-auto {\n    margin-right: -auto;\n  }\n\n  .md\\:-mb-auto {\n    margin-bottom: -auto;\n  }\n\n  .md\\:-ml-auto {\n    margin-left: -auto;\n  }\n\n  .md\\:-mt-full {\n    margin-top: -100%;\n  }\n\n  .md\\:-mr-full {\n    margin-right: -100%;\n  }\n\n  .md\\:-mb-full {\n    margin-bottom: -100%;\n  }\n\n  .md\\:-ml-full {\n    margin-left: -100%;\n  }\n\n  .md\\:-mt-px {\n    margin-top: -1px;\n  }\n\n  .md\\:-mr-px {\n    margin-right: -1px;\n  }\n\n  .md\\:-mb-px {\n    margin-bottom: -1px;\n  }\n\n  .md\\:-ml-px {\n    margin-left: -1px;\n  }\n\n  .md\\:-mt-1\\/6 {\n    margin-top: -16.666666667%;\n  }\n\n  .md\\:-mr-1\\/6 {\n    margin-right: -16.666666667%;\n  }\n\n  .md\\:-mb-1\\/6 {\n    margin-bottom: -16.666666667%;\n  }\n\n  .md\\:-ml-1\\/6 {\n    margin-left: -16.666666667%;\n  }\n\n  .md\\:opacity-0 {\n    opacity: 0;\n  }\n\n  .md\\:opacity-25 {\n    opacity: .25;\n  }\n\n  .md\\:opacity-50 {\n    opacity: .5;\n  }\n\n  .md\\:opacity-75 {\n    opacity: .75;\n  }\n\n  .md\\:opacity-100 {\n    opacity: 1;\n  }\n\n  .md\\:overflow-auto {\n    overflow: auto;\n  }\n\n  .md\\:overflow-hidden {\n    overflow: hidden;\n  }\n\n  .md\\:overflow-visible {\n    overflow: visible;\n  }\n\n  .md\\:overflow-scroll {\n    overflow: scroll;\n  }\n\n  .md\\:overflow-x-auto {\n    overflow-x: auto;\n  }\n\n  .md\\:overflow-y-auto {\n    overflow-y: auto;\n  }\n\n  .md\\:overflow-x-hidden {\n    overflow-x: hidden;\n  }\n\n  .md\\:overflow-y-hidden {\n    overflow-y: hidden;\n  }\n\n  .md\\:overflow-x-visible {\n    overflow-x: visible;\n  }\n\n  .md\\:overflow-y-visible {\n    overflow-y: visible;\n  }\n\n  .md\\:overflow-x-scroll {\n    overflow-x: scroll;\n  }\n\n  .md\\:overflow-y-scroll {\n    overflow-y: scroll;\n  }\n\n  .md\\:scrolling-touch {\n    -webkit-overflow-scrolling: touch;\n  }\n\n  .md\\:scrolling-auto {\n    -webkit-overflow-scrolling: auto;\n  }\n\n  .md\\:p-0 {\n    padding: 0;\n  }\n\n  .md\\:p-1 {\n    padding: 2px;\n  }\n\n  .md\\:p-2 {\n    padding: 4px;\n  }\n\n  .md\\:p-3 {\n    padding: 8px;\n  }\n\n  .md\\:p-4 {\n    padding: 16px;\n  }\n\n  .md\\:p-5 {\n    padding: 24px;\n  }\n\n  .md\\:p-6 {\n    padding: 32px;\n  }\n\n  .md\\:p-7 {\n    padding: 36px;\n  }\n\n  .md\\:p-8 {\n    padding: 48px;\n  }\n\n  .md\\:p-9 {\n    padding: 64px;\n  }\n\n  .md\\:p-10 {\n    padding: 96px;\n  }\n\n  .md\\:p-auto {\n    padding: auto;\n  }\n\n  .md\\:p-full {\n    padding: 100%;\n  }\n\n  .md\\:p-px {\n    padding: 1px;\n  }\n\n  .md\\:p-1\\/6 {\n    padding: 16.666666667%;\n  }\n\n  .md\\:py-0 {\n    padding-top: 0;\n    padding-bottom: 0;\n  }\n\n  .md\\:px-0 {\n    padding-left: 0;\n    padding-right: 0;\n  }\n\n  .md\\:py-1 {\n    padding-top: 2px;\n    padding-bottom: 2px;\n  }\n\n  .md\\:px-1 {\n    padding-left: 2px;\n    padding-right: 2px;\n  }\n\n  .md\\:py-2 {\n    padding-top: 4px;\n    padding-bottom: 4px;\n  }\n\n  .md\\:px-2 {\n    padding-left: 4px;\n    padding-right: 4px;\n  }\n\n  .md\\:py-3 {\n    padding-top: 8px;\n    padding-bottom: 8px;\n  }\n\n  .md\\:px-3 {\n    padding-left: 8px;\n    padding-right: 8px;\n  }\n\n  .md\\:py-4 {\n    padding-top: 16px;\n    padding-bottom: 16px;\n  }\n\n  .md\\:px-4 {\n    padding-left: 16px;\n    padding-right: 16px;\n  }\n\n  .md\\:py-5 {\n    padding-top: 24px;\n    padding-bottom: 24px;\n  }\n\n  .md\\:px-5 {\n    padding-left: 24px;\n    padding-right: 24px;\n  }\n\n  .md\\:py-6 {\n    padding-top: 32px;\n    padding-bottom: 32px;\n  }\n\n  .md\\:px-6 {\n    padding-left: 32px;\n    padding-right: 32px;\n  }\n\n  .md\\:py-7 {\n    padding-top: 36px;\n    padding-bottom: 36px;\n  }\n\n  .md\\:px-7 {\n    padding-left: 36px;\n    padding-right: 36px;\n  }\n\n  .md\\:py-8 {\n    padding-top: 48px;\n    padding-bottom: 48px;\n  }\n\n  .md\\:px-8 {\n    padding-left: 48px;\n    padding-right: 48px;\n  }\n\n  .md\\:py-9 {\n    padding-top: 64px;\n    padding-bottom: 64px;\n  }\n\n  .md\\:px-9 {\n    padding-left: 64px;\n    padding-right: 64px;\n  }\n\n  .md\\:py-10 {\n    padding-top: 96px;\n    padding-bottom: 96px;\n  }\n\n  .md\\:px-10 {\n    padding-left: 96px;\n    padding-right: 96px;\n  }\n\n  .md\\:py-auto {\n    padding-top: auto;\n    padding-bottom: auto;\n  }\n\n  .md\\:px-auto {\n    padding-left: auto;\n    padding-right: auto;\n  }\n\n  .md\\:py-full {\n    padding-top: 100%;\n    padding-bottom: 100%;\n  }\n\n  .md\\:px-full {\n    padding-left: 100%;\n    padding-right: 100%;\n  }\n\n  .md\\:py-px {\n    padding-top: 1px;\n    padding-bottom: 1px;\n  }\n\n  .md\\:px-px {\n    padding-left: 1px;\n    padding-right: 1px;\n  }\n\n  .md\\:py-1\\/6 {\n    padding-top: 16.666666667%;\n    padding-bottom: 16.666666667%;\n  }\n\n  .md\\:px-1\\/6 {\n    padding-left: 16.666666667%;\n    padding-right: 16.666666667%;\n  }\n\n  .md\\:pt-0 {\n    padding-top: 0;\n  }\n\n  .md\\:pr-0 {\n    padding-right: 0;\n  }\n\n  .md\\:pb-0 {\n    padding-bottom: 0;\n  }\n\n  .md\\:pl-0 {\n    padding-left: 0;\n  }\n\n  .md\\:pt-1 {\n    padding-top: 2px;\n  }\n\n  .md\\:pr-1 {\n    padding-right: 2px;\n  }\n\n  .md\\:pb-1 {\n    padding-bottom: 2px;\n  }\n\n  .md\\:pl-1 {\n    padding-left: 2px;\n  }\n\n  .md\\:pt-2 {\n    padding-top: 4px;\n  }\n\n  .md\\:pr-2 {\n    padding-right: 4px;\n  }\n\n  .md\\:pb-2 {\n    padding-bottom: 4px;\n  }\n\n  .md\\:pl-2 {\n    padding-left: 4px;\n  }\n\n  .md\\:pt-3 {\n    padding-top: 8px;\n  }\n\n  .md\\:pr-3 {\n    padding-right: 8px;\n  }\n\n  .md\\:pb-3 {\n    padding-bottom: 8px;\n  }\n\n  .md\\:pl-3 {\n    padding-left: 8px;\n  }\n\n  .md\\:pt-4 {\n    padding-top: 16px;\n  }\n\n  .md\\:pr-4 {\n    padding-right: 16px;\n  }\n\n  .md\\:pb-4 {\n    padding-bottom: 16px;\n  }\n\n  .md\\:pl-4 {\n    padding-left: 16px;\n  }\n\n  .md\\:pt-5 {\n    padding-top: 24px;\n  }\n\n  .md\\:pr-5 {\n    padding-right: 24px;\n  }\n\n  .md\\:pb-5 {\n    padding-bottom: 24px;\n  }\n\n  .md\\:pl-5 {\n    padding-left: 24px;\n  }\n\n  .md\\:pt-6 {\n    padding-top: 32px;\n  }\n\n  .md\\:pr-6 {\n    padding-right: 32px;\n  }\n\n  .md\\:pb-6 {\n    padding-bottom: 32px;\n  }\n\n  .md\\:pl-6 {\n    padding-left: 32px;\n  }\n\n  .md\\:pt-7 {\n    padding-top: 36px;\n  }\n\n  .md\\:pr-7 {\n    padding-right: 36px;\n  }\n\n  .md\\:pb-7 {\n    padding-bottom: 36px;\n  }\n\n  .md\\:pl-7 {\n    padding-left: 36px;\n  }\n\n  .md\\:pt-8 {\n    padding-top: 48px;\n  }\n\n  .md\\:pr-8 {\n    padding-right: 48px;\n  }\n\n  .md\\:pb-8 {\n    padding-bottom: 48px;\n  }\n\n  .md\\:pl-8 {\n    padding-left: 48px;\n  }\n\n  .md\\:pt-9 {\n    padding-top: 64px;\n  }\n\n  .md\\:pr-9 {\n    padding-right: 64px;\n  }\n\n  .md\\:pb-9 {\n    padding-bottom: 64px;\n  }\n\n  .md\\:pl-9 {\n    padding-left: 64px;\n  }\n\n  .md\\:pt-10 {\n    padding-top: 96px;\n  }\n\n  .md\\:pr-10 {\n    padding-right: 96px;\n  }\n\n  .md\\:pb-10 {\n    padding-bottom: 96px;\n  }\n\n  .md\\:pl-10 {\n    padding-left: 96px;\n  }\n\n  .md\\:pt-auto {\n    padding-top: auto;\n  }\n\n  .md\\:pr-auto {\n    padding-right: auto;\n  }\n\n  .md\\:pb-auto {\n    padding-bottom: auto;\n  }\n\n  .md\\:pl-auto {\n    padding-left: auto;\n  }\n\n  .md\\:pt-full {\n    padding-top: 100%;\n  }\n\n  .md\\:pr-full {\n    padding-right: 100%;\n  }\n\n  .md\\:pb-full {\n    padding-bottom: 100%;\n  }\n\n  .md\\:pl-full {\n    padding-left: 100%;\n  }\n\n  .md\\:pt-px {\n    padding-top: 1px;\n  }\n\n  .md\\:pr-px {\n    padding-right: 1px;\n  }\n\n  .md\\:pb-px {\n    padding-bottom: 1px;\n  }\n\n  .md\\:pl-px {\n    padding-left: 1px;\n  }\n\n  .md\\:pt-1\\/6 {\n    padding-top: 16.666666667%;\n  }\n\n  .md\\:pr-1\\/6 {\n    padding-right: 16.666666667%;\n  }\n\n  .md\\:pb-1\\/6 {\n    padding-bottom: 16.666666667%;\n  }\n\n  .md\\:pl-1\\/6 {\n    padding-left: 16.666666667%;\n  }\n\n  .md\\:pointer-events-none {\n    pointer-events: none;\n  }\n\n  .md\\:pointer-events-auto {\n    pointer-events: auto;\n  }\n\n  .md\\:static {\n    position: static;\n  }\n\n  .md\\:fixed {\n    position: fixed;\n  }\n\n  .md\\:absolute {\n    position: absolute;\n  }\n\n  .md\\:relative {\n    position: relative;\n  }\n\n  .md\\:sticky {\n    position: sticky;\n  }\n\n  .md\\:pin-none {\n    top: auto;\n    right: auto;\n    bottom: auto;\n    left: auto;\n  }\n\n  .md\\:pin {\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n\n  .md\\:pin-y {\n    top: 0;\n    bottom: 0;\n  }\n\n  .md\\:pin-x {\n    right: 0;\n    left: 0;\n  }\n\n  .md\\:pin-t {\n    top: 0;\n  }\n\n  .md\\:pin-r {\n    right: 0;\n  }\n\n  .md\\:pin-b {\n    bottom: 0;\n  }\n\n  .md\\:pin-l {\n    left: 0;\n  }\n\n  .md\\:resize-none {\n    resize: none;\n  }\n\n  .md\\:resize-y {\n    resize: vertical;\n  }\n\n  .md\\:resize-x {\n    resize: horizontal;\n  }\n\n  .md\\:resize {\n    resize: both;\n  }\n\n  .md\\:shadow {\n    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .1);\n  }\n\n  .md\\:shadow-md {\n    box-shadow:  0 8px 20px 0 rgba(0, 0, 0, .42);\n  }\n\n  .md\\:shadow-none {\n    box-shadow: none;\n  }\n\n  .md\\:table-auto {\n    table-layout: auto;\n  }\n\n  .md\\:table-fixed {\n    table-layout: fixed;\n  }\n\n  .md\\:text-left {\n    text-align: left;\n  }\n\n  .md\\:text-center {\n    text-align: center;\n  }\n\n  .md\\:text-right {\n    text-align: right;\n  }\n\n  .md\\:text-justify {\n    text-align: justify;\n  }\n\n  .md\\:text-inherit {\n    color: inherit;\n  }\n\n  .md\\:text-transparent {\n    color: transparent;\n  }\n\n  .md\\:text-black {\n    color: #282828;\n  }\n\n  .md\\:text-white {\n    color: #fff;\n  }\n\n  .md\\:text-grey-lighter {\n    color: #f3f3f7;\n  }\n\n  .md\\:text-grey-light {\n    color: #e7e7ec;\n  }\n\n  .md\\:text-grey {\n    color: #c2c2c6;\n  }\n\n  .md\\:text-purple-lighter {\n    color: #ccc2e9;\n  }\n\n  .md\\:text-purple-light {\n    color: #87809b;\n  }\n\n  .md\\:text-purple {\n    color: #8360d6;\n  }\n\n  .md\\:text-purple-bright {\n    color: #4c29b0;\n  }\n\n  .md\\:text-purple-dark {\n    color: #453f56;\n  }\n\n  .md\\:text-purple-dark-10 {\n    color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:text-purple-darker {\n    color: #2a2538;\n  }\n\n  .md\\:hover\\:text-inherit:hover {\n    color: inherit;\n  }\n\n  .md\\:hover\\:text-transparent:hover {\n    color: transparent;\n  }\n\n  .md\\:hover\\:text-black:hover {\n    color: #282828;\n  }\n\n  .md\\:hover\\:text-white:hover {\n    color: #fff;\n  }\n\n  .md\\:hover\\:text-grey-lighter:hover {\n    color: #f3f3f7;\n  }\n\n  .md\\:hover\\:text-grey-light:hover {\n    color: #e7e7ec;\n  }\n\n  .md\\:hover\\:text-grey:hover {\n    color: #c2c2c6;\n  }\n\n  .md\\:hover\\:text-purple-lighter:hover {\n    color: #ccc2e9;\n  }\n\n  .md\\:hover\\:text-purple-light:hover {\n    color: #87809b;\n  }\n\n  .md\\:hover\\:text-purple:hover {\n    color: #8360d6;\n  }\n\n  .md\\:hover\\:text-purple-bright:hover {\n    color: #4c29b0;\n  }\n\n  .md\\:hover\\:text-purple-dark:hover {\n    color: #453f56;\n  }\n\n  .md\\:hover\\:text-purple-dark-10:hover {\n    color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:hover\\:text-purple-darker:hover {\n    color: #2a2538;\n  }\n\n  .md\\:text-sm {\n    font-size: 1.4rem;\n  }\n\n  .md\\:text-base {\n    font-size: 1.6rem;\n  }\n\n  .md\\:italic {\n    font-style: italic;\n  }\n\n  .md\\:roman {\n    font-style: normal;\n  }\n\n  .md\\:uppercase {\n    text-transform: uppercase;\n  }\n\n  .md\\:lowercase {\n    text-transform: lowercase;\n  }\n\n  .md\\:capitalize {\n    text-transform: capitalize;\n  }\n\n  .md\\:normal-case {\n    text-transform: none;\n  }\n\n  .md\\:underline {\n    text-decoration: underline;\n  }\n\n  .md\\:line-through {\n    text-decoration: line-through;\n  }\n\n  .md\\:no-underline {\n    text-decoration: none;\n  }\n\n  .md\\:antialiased {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  .md\\:subpixel-antialiased {\n    -webkit-font-smoothing: auto;\n    -moz-osx-font-smoothing: auto;\n  }\n\n  .md\\:hover\\:italic:hover {\n    font-style: italic;\n  }\n\n  .md\\:hover\\:roman:hover {\n    font-style: normal;\n  }\n\n  .md\\:hover\\:uppercase:hover {\n    text-transform: uppercase;\n  }\n\n  .md\\:hover\\:lowercase:hover {\n    text-transform: lowercase;\n  }\n\n  .md\\:hover\\:capitalize:hover {\n    text-transform: capitalize;\n  }\n\n  .md\\:hover\\:normal-case:hover {\n    text-transform: none;\n  }\n\n  .md\\:hover\\:underline:hover {\n    text-decoration: underline;\n  }\n\n  .md\\:hover\\:line-through:hover {\n    text-decoration: line-through;\n  }\n\n  .md\\:hover\\:no-underline:hover {\n    text-decoration: none;\n  }\n\n  .md\\:hover\\:antialiased:hover {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  .md\\:hover\\:subpixel-antialiased:hover {\n    -webkit-font-smoothing: auto;\n    -moz-osx-font-smoothing: auto;\n  }\n\n  .md\\:tracking-tight {\n    letter-spacing: -0.05em;\n  }\n\n  .md\\:tracking-normal {\n    letter-spacing: 0;\n  }\n\n  .md\\:tracking-wide {\n    letter-spacing: .05em;\n  }\n\n  .md\\:select-none {\n    user-select: none;\n  }\n\n  .md\\:select-text {\n    user-select: text;\n  }\n\n  .md\\:align-baseline {\n    vertical-align: baseline;\n  }\n\n  .md\\:align-top {\n    vertical-align: top;\n  }\n\n  .md\\:align-middle {\n    vertical-align: middle;\n  }\n\n  .md\\:align-bottom {\n    vertical-align: bottom;\n  }\n\n  .md\\:align-text-top {\n    vertical-align: text-top;\n  }\n\n  .md\\:align-text-bottom {\n    vertical-align: text-bottom;\n  }\n\n  .md\\:visible {\n    visibility: visible;\n  }\n\n  .md\\:invisible {\n    visibility: hidden;\n  }\n\n  .md\\:whitespace-normal {\n    white-space: normal;\n  }\n\n  .md\\:whitespace-no-wrap {\n    white-space: nowrap;\n  }\n\n  .md\\:whitespace-pre {\n    white-space: pre;\n  }\n\n  .md\\:whitespace-pre-line {\n    white-space: pre-line;\n  }\n\n  .md\\:whitespace-pre-wrap {\n    white-space: pre-wrap;\n  }\n\n  .md\\:break-words {\n    word-wrap: break-word;\n  }\n\n  .md\\:break-normal {\n    word-wrap: normal;\n  }\n\n  .md\\:truncate {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .md\\:w-0 {\n    width: 0;\n  }\n\n  .md\\:w-1 {\n    width: 2px;\n  }\n\n  .md\\:w-2 {\n    width: 4px;\n  }\n\n  .md\\:w-3 {\n    width: 8px;\n  }\n\n  .md\\:w-4 {\n    width: 16px;\n  }\n\n  .md\\:w-5 {\n    width: 24px;\n  }\n\n  .md\\:w-6 {\n    width: 32px;\n  }\n\n  .md\\:w-7 {\n    width: 36px;\n  }\n\n  .md\\:w-8 {\n    width: 48px;\n  }\n\n  .md\\:w-9 {\n    width: 64px;\n  }\n\n  .md\\:w-10 {\n    width: 96px;\n  }\n\n  .md\\:w-screen {\n    width: 100vw;\n  }\n\n  .md\\:w-auto {\n    width: auto;\n  }\n\n  .md\\:w-full {\n    width: 100%;\n  }\n\n  .md\\:w-px {\n    width: 1px;\n  }\n\n  .md\\:w-1\\/6 {\n    width: 16.666666667%;\n  }\n\n  .md\\:z-0 {\n    z-index: 0;\n  }\n\n  .md\\:z-10 {\n    z-index: 10;\n  }\n\n  .md\\:z-20 {\n    z-index: 20;\n  }\n\n  .md\\:z-30 {\n    z-index: 30;\n  }\n\n  .md\\:z-40 {\n    z-index: 40;\n  }\n\n  .md\\:z-50 {\n    z-index: 50;\n  }\n\n  .md\\:z-auto {\n    z-index: auto;\n  }\n\n  .md\\:bg-black-10 {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .md\\:bg-white-10 {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .md\\:bg-grey-lighter-10 {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .md\\:bg-grey-light-10 {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .md\\:bg-grey-10 {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .md\\:bg-purple-lighter-10 {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .md\\:bg-purple-light-10 {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .md\\:bg-purple-10 {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .md\\:bg-purple-bright-10 {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .md\\:bg-purple-dark-10 {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:bg-purple-darker-10 {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .md\\:hover\\:bg-black-10:hover {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .md\\:hover\\:bg-white-10:hover {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .md\\:hover\\:bg-grey-lighter-10:hover {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .md\\:hover\\:bg-grey-light-10:hover {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .md\\:hover\\:bg-grey-10:hover {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .md\\:hover\\:bg-purple-lighter-10:hover {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .md\\:hover\\:bg-purple-light-10:hover {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .md\\:hover\\:bg-purple-10:hover {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .md\\:hover\\:bg-purple-bright-10:hover {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .md\\:hover\\:bg-purple-dark-10:hover {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:hover\\:bg-purple-darker-10:hover {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .md\\:focus\\:bg-black-10:focus {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .md\\:focus\\:bg-white-10:focus {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .md\\:focus\\:bg-grey-lighter-10:focus {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .md\\:focus\\:bg-grey-light-10:focus {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .md\\:focus\\:bg-grey-10:focus {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .md\\:focus\\:bg-purple-lighter-10:focus {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .md\\:focus\\:bg-purple-light-10:focus {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .md\\:focus\\:bg-purple-10:focus {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .md\\:focus\\:bg-purple-bright-10:focus {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .md\\:focus\\:bg-purple-dark-10:focus {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .md\\:focus\\:bg-purple-darker-10:focus {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .md\\:bg-black-30 {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .md\\:bg-white-30 {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .md\\:bg-grey-lighter-30 {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .md\\:bg-grey-light-30 {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .md\\:bg-grey-30 {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .md\\:bg-purple-lighter-30 {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .md\\:bg-purple-light-30 {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .md\\:bg-purple-30 {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .md\\:bg-purple-bright-30 {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .md\\:bg-purple-dark-30 {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .md\\:bg-purple-darker-30 {\n    background-color: rgba(42, 37, 56, .3);\n  }\n\n  .md\\:hover\\:bg-black-30:hover {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .md\\:hover\\:bg-white-30:hover {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .md\\:hover\\:bg-grey-lighter-30:hover {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .md\\:hover\\:bg-grey-light-30:hover {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .md\\:hover\\:bg-grey-30:hover {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .md\\:hover\\:bg-purple-lighter-30:hover {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .md\\:hover\\:bg-purple-light-30:hover {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .md\\:hover\\:bg-purple-30:hover {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .md\\:hover\\:bg-purple-bright-30:hover {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .md\\:hover\\:bg-purple-dark-30:hover {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .md\\:hover\\:bg-purple-darker-30:hover {\n    background-color: rgba(42, 37, 56, .3);\n  }\n\n  .md\\:focus\\:bg-black-30:focus {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .md\\:focus\\:bg-white-30:focus {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .md\\:focus\\:bg-grey-lighter-30:focus {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .md\\:focus\\:bg-grey-light-30:focus {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .md\\:focus\\:bg-grey-30:focus {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .md\\:focus\\:bg-purple-lighter-30:focus {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .md\\:focus\\:bg-purple-light-30:focus {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .md\\:focus\\:bg-purple-30:focus {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .md\\:focus\\:bg-purple-bright-30:focus {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .md\\:focus\\:bg-purple-dark-30:focus {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .md\\:focus\\:bg-purple-darker-30:focus {\n    background-color: rgba(42, 37, 56, .3);\n  }\n}\n\n@media (min-width: 992px) {\n  .lg\\:list-reset {\n    list-style: none;\n    padding: 0;\n  }\n\n  .lg\\:appearance-none {\n    appearance: none;\n  }\n\n  .lg\\:bg-fixed {\n    background-attachment: fixed;\n  }\n\n  .lg\\:bg-local {\n    background-attachment: local;\n  }\n\n  .lg\\:bg-scroll {\n    background-attachment: scroll;\n  }\n\n  .lg\\:bg-inherit {\n    background-color: inherit;\n  }\n\n  .lg\\:bg-transparent {\n    background-color: transparent;\n  }\n\n  .lg\\:bg-black {\n    background-color: #282828;\n  }\n\n  .lg\\:bg-white {\n    background-color: #fff;\n  }\n\n  .lg\\:bg-grey-lighter {\n    background-color: #f3f3f7;\n  }\n\n  .lg\\:bg-grey-light {\n    background-color: #e7e7ec;\n  }\n\n  .lg\\:bg-grey {\n    background-color: #c2c2c6;\n  }\n\n  .lg\\:bg-purple-lighter {\n    background-color: #ccc2e9;\n  }\n\n  .lg\\:bg-purple-light {\n    background-color: #87809b;\n  }\n\n  .lg\\:bg-purple {\n    background-color: #8360d6;\n  }\n\n  .lg\\:bg-purple-bright {\n    background-color: #4c29b0;\n  }\n\n  .lg\\:bg-purple-dark {\n    background-color: #453f56;\n  }\n\n  .lg\\:bg-purple-dark-10 {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:bg-purple-darker {\n    background-color: #2a2538;\n  }\n\n  .lg\\:hover\\:bg-inherit:hover {\n    background-color: inherit;\n  }\n\n  .lg\\:hover\\:bg-transparent:hover {\n    background-color: transparent;\n  }\n\n  .lg\\:hover\\:bg-black:hover {\n    background-color: #282828;\n  }\n\n  .lg\\:hover\\:bg-white:hover {\n    background-color: #fff;\n  }\n\n  .lg\\:hover\\:bg-grey-lighter:hover {\n    background-color: #f3f3f7;\n  }\n\n  .lg\\:hover\\:bg-grey-light:hover {\n    background-color: #e7e7ec;\n  }\n\n  .lg\\:hover\\:bg-grey:hover {\n    background-color: #c2c2c6;\n  }\n\n  .lg\\:hover\\:bg-purple-lighter:hover {\n    background-color: #ccc2e9;\n  }\n\n  .lg\\:hover\\:bg-purple-light:hover {\n    background-color: #87809b;\n  }\n\n  .lg\\:hover\\:bg-purple:hover {\n    background-color: #8360d6;\n  }\n\n  .lg\\:hover\\:bg-purple-bright:hover {\n    background-color: #4c29b0;\n  }\n\n  .lg\\:hover\\:bg-purple-dark:hover {\n    background-color: #453f56;\n  }\n\n  .lg\\:hover\\:bg-purple-dark-10:hover {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:hover\\:bg-purple-darker:hover {\n    background-color: #2a2538;\n  }\n\n  .lg\\:focus\\:bg-inherit:focus {\n    background-color: inherit;\n  }\n\n  .lg\\:focus\\:bg-transparent:focus {\n    background-color: transparent;\n  }\n\n  .lg\\:focus\\:bg-black:focus {\n    background-color: #282828;\n  }\n\n  .lg\\:focus\\:bg-white:focus {\n    background-color: #fff;\n  }\n\n  .lg\\:focus\\:bg-grey-lighter:focus {\n    background-color: #f3f3f7;\n  }\n\n  .lg\\:focus\\:bg-grey-light:focus {\n    background-color: #e7e7ec;\n  }\n\n  .lg\\:focus\\:bg-grey:focus {\n    background-color: #c2c2c6;\n  }\n\n  .lg\\:focus\\:bg-purple-lighter:focus {\n    background-color: #ccc2e9;\n  }\n\n  .lg\\:focus\\:bg-purple-light:focus {\n    background-color: #87809b;\n  }\n\n  .lg\\:focus\\:bg-purple:focus {\n    background-color: #8360d6;\n  }\n\n  .lg\\:focus\\:bg-purple-bright:focus {\n    background-color: #4c29b0;\n  }\n\n  .lg\\:focus\\:bg-purple-dark:focus {\n    background-color: #453f56;\n  }\n\n  .lg\\:focus\\:bg-purple-dark-10:focus {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:focus\\:bg-purple-darker:focus {\n    background-color: #2a2538;\n  }\n\n  .lg\\:bg-bottom {\n    background-position: bottom;\n  }\n\n  .lg\\:bg-center {\n    background-position: center;\n  }\n\n  .lg\\:bg-left {\n    background-position: left;\n  }\n\n  .lg\\:bg-left-bottom {\n    background-position: left bottom;\n  }\n\n  .lg\\:bg-left-top {\n    background-position: left top;\n  }\n\n  .lg\\:bg-right {\n    background-position: right;\n  }\n\n  .lg\\:bg-right-bottom {\n    background-position: right bottom;\n  }\n\n  .lg\\:bg-right-top {\n    background-position: right top;\n  }\n\n  .lg\\:bg-top {\n    background-position: top;\n  }\n\n  .lg\\:bg-repeat {\n    background-repeat: repeat;\n  }\n\n  .lg\\:bg-no-repeat {\n    background-repeat: no-repeat;\n  }\n\n  .lg\\:bg-repeat-x {\n    background-repeat: repeat-x;\n  }\n\n  .lg\\:bg-repeat-y {\n    background-repeat: repeat-y;\n  }\n\n  .lg\\:bg-auto {\n    background-size: auto;\n  }\n\n  .lg\\:bg-cover {\n    background-size: cover;\n  }\n\n  .lg\\:bg-contain {\n    background-size: contain;\n  }\n\n  .lg\\:border-inherit {\n    border-color: inherit;\n  }\n\n  .lg\\:border-transparent {\n    border-color: transparent;\n  }\n\n  .lg\\:border-black {\n    border-color: #282828;\n  }\n\n  .lg\\:border-white {\n    border-color: #fff;\n  }\n\n  .lg\\:border-grey-lighter {\n    border-color: #f3f3f7;\n  }\n\n  .lg\\:border-grey-light {\n    border-color: #e7e7ec;\n  }\n\n  .lg\\:border-grey {\n    border-color: #c2c2c6;\n  }\n\n  .lg\\:border-purple-lighter {\n    border-color: #ccc2e9;\n  }\n\n  .lg\\:border-purple-light {\n    border-color: #87809b;\n  }\n\n  .lg\\:border-purple {\n    border-color: #8360d6;\n  }\n\n  .lg\\:border-purple-bright {\n    border-color: #4c29b0;\n  }\n\n  .lg\\:border-purple-dark {\n    border-color: #453f56;\n  }\n\n  .lg\\:border-purple-dark-10 {\n    border-color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:border-purple-darker {\n    border-color: #2a2538;\n  }\n\n  .lg\\:hover\\:border-inherit:hover {\n    border-color: inherit;\n  }\n\n  .lg\\:hover\\:border-transparent:hover {\n    border-color: transparent;\n  }\n\n  .lg\\:hover\\:border-black:hover {\n    border-color: #282828;\n  }\n\n  .lg\\:hover\\:border-white:hover {\n    border-color: #fff;\n  }\n\n  .lg\\:hover\\:border-grey-lighter:hover {\n    border-color: #f3f3f7;\n  }\n\n  .lg\\:hover\\:border-grey-light:hover {\n    border-color: #e7e7ec;\n  }\n\n  .lg\\:hover\\:border-grey:hover {\n    border-color: #c2c2c6;\n  }\n\n  .lg\\:hover\\:border-purple-lighter:hover {\n    border-color: #ccc2e9;\n  }\n\n  .lg\\:hover\\:border-purple-light:hover {\n    border-color: #87809b;\n  }\n\n  .lg\\:hover\\:border-purple:hover {\n    border-color: #8360d6;\n  }\n\n  .lg\\:hover\\:border-purple-bright:hover {\n    border-color: #4c29b0;\n  }\n\n  .lg\\:hover\\:border-purple-dark:hover {\n    border-color: #453f56;\n  }\n\n  .lg\\:hover\\:border-purple-dark-10:hover {\n    border-color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:hover\\:border-purple-darker:hover {\n    border-color: #2a2538;\n  }\n\n  .lg\\:rounded-none {\n    border-radius: 0;\n  }\n\n  .lg\\:rounded-sm {\n    border-radius: 2px;\n  }\n\n  .lg\\:rounded {\n    border-radius: 4px;\n  }\n\n  .lg\\:rounded-full {\n    border-radius: 9999px;\n  }\n\n  .lg\\:rounded-t-none {\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n  }\n\n  .lg\\:rounded-r-none {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n\n  .lg\\:rounded-b-none {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  .lg\\:rounded-l-none {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  .lg\\:rounded-t-sm {\n    border-top-left-radius: 2px;\n    border-top-right-radius: 2px;\n  }\n\n  .lg\\:rounded-r-sm {\n    border-top-right-radius: 2px;\n    border-bottom-right-radius: 2px;\n  }\n\n  .lg\\:rounded-b-sm {\n    border-bottom-right-radius: 2px;\n    border-bottom-left-radius: 2px;\n  }\n\n  .lg\\:rounded-l-sm {\n    border-top-left-radius: 2px;\n    border-bottom-left-radius: 2px;\n  }\n\n  .lg\\:rounded-t {\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n  }\n\n  .lg\\:rounded-r {\n    border-top-right-radius: 4px;\n    border-bottom-right-radius: 4px;\n  }\n\n  .lg\\:rounded-b {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n\n  .lg\\:rounded-l {\n    border-top-left-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n\n  .lg\\:rounded-t-full {\n    border-top-left-radius: 9999px;\n    border-top-right-radius: 9999px;\n  }\n\n  .lg\\:rounded-r-full {\n    border-top-right-radius: 9999px;\n    border-bottom-right-radius: 9999px;\n  }\n\n  .lg\\:rounded-b-full {\n    border-bottom-right-radius: 9999px;\n    border-bottom-left-radius: 9999px;\n  }\n\n  .lg\\:rounded-l-full {\n    border-top-left-radius: 9999px;\n    border-bottom-left-radius: 9999px;\n  }\n\n  .lg\\:rounded-tl-none {\n    border-top-left-radius: 0;\n  }\n\n  .lg\\:rounded-tr-none {\n    border-top-right-radius: 0;\n  }\n\n  .lg\\:rounded-br-none {\n    border-bottom-right-radius: 0;\n  }\n\n  .lg\\:rounded-bl-none {\n    border-bottom-left-radius: 0;\n  }\n\n  .lg\\:rounded-tl-sm {\n    border-top-left-radius: 2px;\n  }\n\n  .lg\\:rounded-tr-sm {\n    border-top-right-radius: 2px;\n  }\n\n  .lg\\:rounded-br-sm {\n    border-bottom-right-radius: 2px;\n  }\n\n  .lg\\:rounded-bl-sm {\n    border-bottom-left-radius: 2px;\n  }\n\n  .lg\\:rounded-tl {\n    border-top-left-radius: 4px;\n  }\n\n  .lg\\:rounded-tr {\n    border-top-right-radius: 4px;\n  }\n\n  .lg\\:rounded-br {\n    border-bottom-right-radius: 4px;\n  }\n\n  .lg\\:rounded-bl {\n    border-bottom-left-radius: 4px;\n  }\n\n  .lg\\:rounded-tl-full {\n    border-top-left-radius: 9999px;\n  }\n\n  .lg\\:rounded-tr-full {\n    border-top-right-radius: 9999px;\n  }\n\n  .lg\\:rounded-br-full {\n    border-bottom-right-radius: 9999px;\n  }\n\n  .lg\\:rounded-bl-full {\n    border-bottom-left-radius: 9999px;\n  }\n\n  .lg\\:border-solid {\n    border-style: solid;\n  }\n\n  .lg\\:border-dashed {\n    border-style: dashed;\n  }\n\n  .lg\\:border-dotted {\n    border-style: dotted;\n  }\n\n  .lg\\:border-none {\n    border-style: none;\n  }\n\n  .lg\\:border-0 {\n    border-width: 0;\n  }\n\n  .lg\\:border-2 {\n    border-width: 2px;\n  }\n\n  .lg\\:border-4 {\n    border-width: 4px;\n  }\n\n  .lg\\:border-8 {\n    border-width: 8px;\n  }\n\n  .lg\\:border {\n    border-width: 1px;\n  }\n\n  .lg\\:border-t-0 {\n    border-top-width: 0;\n  }\n\n  .lg\\:border-r-0 {\n    border-right-width: 0;\n  }\n\n  .lg\\:border-b-0 {\n    border-bottom-width: 0;\n  }\n\n  .lg\\:border-l-0 {\n    border-left-width: 0;\n  }\n\n  .lg\\:border-t-2 {\n    border-top-width: 2px;\n  }\n\n  .lg\\:border-r-2 {\n    border-right-width: 2px;\n  }\n\n  .lg\\:border-b-2 {\n    border-bottom-width: 2px;\n  }\n\n  .lg\\:border-l-2 {\n    border-left-width: 2px;\n  }\n\n  .lg\\:border-t-4 {\n    border-top-width: 4px;\n  }\n\n  .lg\\:border-r-4 {\n    border-right-width: 4px;\n  }\n\n  .lg\\:border-b-4 {\n    border-bottom-width: 4px;\n  }\n\n  .lg\\:border-l-4 {\n    border-left-width: 4px;\n  }\n\n  .lg\\:border-t-8 {\n    border-top-width: 8px;\n  }\n\n  .lg\\:border-r-8 {\n    border-right-width: 8px;\n  }\n\n  .lg\\:border-b-8 {\n    border-bottom-width: 8px;\n  }\n\n  .lg\\:border-l-8 {\n    border-left-width: 8px;\n  }\n\n  .lg\\:border-t {\n    border-top-width: 1px;\n  }\n\n  .lg\\:border-r {\n    border-right-width: 1px;\n  }\n\n  .lg\\:border-b {\n    border-bottom-width: 1px;\n  }\n\n  .lg\\:border-l {\n    border-left-width: 1px;\n  }\n\n  .lg\\:cursor-auto {\n    cursor: auto;\n  }\n\n  .lg\\:cursor-default {\n    cursor: default;\n  }\n\n  .lg\\:cursor-pointer {\n    cursor: pointer;\n  }\n\n  .lg\\:cursor-wait {\n    cursor: wait;\n  }\n\n  .lg\\:cursor-move {\n    cursor: move;\n  }\n\n  .lg\\:cursor-not-allowed {\n    cursor: not-allowed;\n  }\n\n  .lg\\:block {\n    display: block;\n  }\n\n  .lg\\:inline-block {\n    display: inline-block;\n  }\n\n  .lg\\:inline {\n    display: inline;\n  }\n\n  .lg\\:table {\n    display: table;\n  }\n\n  .lg\\:table-row {\n    display: table-row;\n  }\n\n  .lg\\:table-cell {\n    display: table-cell;\n  }\n\n  .lg\\:hidden {\n    display: none;\n  }\n\n  .lg\\:flex {\n    display: flex;\n  }\n\n  .lg\\:inline-flex {\n    display: inline-flex;\n  }\n\n  .lg\\:flex-row {\n    flex-direction: row;\n  }\n\n  .lg\\:flex-row-reverse {\n    flex-direction: row-reverse;\n  }\n\n  .lg\\:flex-col {\n    flex-direction: column;\n  }\n\n  .lg\\:flex-col-reverse {\n    flex-direction: column-reverse;\n  }\n\n  .lg\\:flex-wrap {\n    flex-wrap: wrap;\n  }\n\n  .lg\\:flex-wrap-reverse {\n    flex-wrap: wrap-reverse;\n  }\n\n  .lg\\:flex-no-wrap {\n    flex-wrap: nowrap;\n  }\n\n  .lg\\:items-start {\n    align-items: flex-start;\n  }\n\n  .lg\\:items-end {\n    align-items: flex-end;\n  }\n\n  .lg\\:items-center {\n    align-items: center;\n  }\n\n  .lg\\:items-baseline {\n    align-items: baseline;\n  }\n\n  .lg\\:items-stretch {\n    align-items: stretch;\n  }\n\n  .lg\\:self-auto {\n    align-self: auto;\n  }\n\n  .lg\\:self-start {\n    align-self: flex-start;\n  }\n\n  .lg\\:self-end {\n    align-self: flex-end;\n  }\n\n  .lg\\:self-center {\n    align-self: center;\n  }\n\n  .lg\\:self-stretch {\n    align-self: stretch;\n  }\n\n  .lg\\:justify-start {\n    justify-content: flex-start;\n  }\n\n  .lg\\:justify-end {\n    justify-content: flex-end;\n  }\n\n  .lg\\:justify-center {\n    justify-content: center;\n  }\n\n  .lg\\:justify-between {\n    justify-content: space-between;\n  }\n\n  .lg\\:justify-around {\n    justify-content: space-around;\n  }\n\n  .lg\\:content-center {\n    align-content: center;\n  }\n\n  .lg\\:content-start {\n    align-content: flex-start;\n  }\n\n  .lg\\:content-end {\n    align-content: flex-end;\n  }\n\n  .lg\\:content-between {\n    align-content: space-between;\n  }\n\n  .lg\\:content-around {\n    align-content: space-around;\n  }\n\n  .lg\\:flex-1 {\n    flex: 1;\n  }\n\n  .lg\\:flex-auto {\n    flex: auto;\n  }\n\n  .lg\\:flex-initial {\n    flex: initial;\n  }\n\n  .lg\\:flex-none {\n    flex: none;\n  }\n\n  .lg\\:flex-grow {\n    flex-grow: 1;\n  }\n\n  .lg\\:flex-shrink {\n    flex-shrink: 1;\n  }\n\n  .lg\\:flex-no-grow {\n    flex-grow: 0;\n  }\n\n  .lg\\:flex-no-shrink {\n    flex-shrink: 0;\n  }\n\n  .lg\\:float-right {\n    float: right;\n  }\n\n  .lg\\:float-left {\n    float: left;\n  }\n\n  .lg\\:float-none {\n    float: none;\n  }\n\n  .lg\\:clearfix:after {\n    content: \"\";\n    display: table;\n    clear: both;\n  }\n\n  .lg\\:font-sans {\n    font-family: system-ui, BlinkMacSystemFont, -apple-system, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  }\n\n  .lg\\:font-serif {\n    font-family: Constantia, Lucida Bright, Lucidabright, Lucida Serif, Lucida, DejaVu Serif, Bitstream Vera Serif, Liberation Serif, Georgia, serif;\n  }\n\n  .lg\\:font-mono {\n    font-family: Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;\n  }\n\n  .lg\\:font-hairline {\n    font-weight: 100;\n  }\n\n  .lg\\:font-thin {\n    font-weight: 200;\n  }\n\n  .lg\\:font-light {\n    font-weight: 300;\n  }\n\n  .lg\\:font-normal {\n    font-weight: 400;\n  }\n\n  .lg\\:font-medium {\n    font-weight: 500;\n  }\n\n  .lg\\:font-semibold {\n    font-weight: 600;\n  }\n\n  .lg\\:font-bold {\n    font-weight: 700;\n  }\n\n  .lg\\:font-extrabold {\n    font-weight: 800;\n  }\n\n  .lg\\:font-black {\n    font-weight: 900;\n  }\n\n  .lg\\:hover\\:font-hairline:hover {\n    font-weight: 100;\n  }\n\n  .lg\\:hover\\:font-thin:hover {\n    font-weight: 200;\n  }\n\n  .lg\\:hover\\:font-light:hover {\n    font-weight: 300;\n  }\n\n  .lg\\:hover\\:font-normal:hover {\n    font-weight: 400;\n  }\n\n  .lg\\:hover\\:font-medium:hover {\n    font-weight: 500;\n  }\n\n  .lg\\:hover\\:font-semibold:hover {\n    font-weight: 600;\n  }\n\n  .lg\\:hover\\:font-bold:hover {\n    font-weight: 700;\n  }\n\n  .lg\\:hover\\:font-extrabold:hover {\n    font-weight: 800;\n  }\n\n  .lg\\:hover\\:font-black:hover {\n    font-weight: 900;\n  }\n\n  .lg\\:h-0 {\n    height: 0;\n  }\n\n  .lg\\:h-1 {\n    height: 2px;\n  }\n\n  .lg\\:h-2 {\n    height: 4px;\n  }\n\n  .lg\\:h-3 {\n    height: 8px;\n  }\n\n  .lg\\:h-4 {\n    height: 16px;\n  }\n\n  .lg\\:h-5 {\n    height: 24px;\n  }\n\n  .lg\\:h-6 {\n    height: 32px;\n  }\n\n  .lg\\:h-7 {\n    height: 36px;\n  }\n\n  .lg\\:h-8 {\n    height: 48px;\n  }\n\n  .lg\\:h-9 {\n    height: 64px;\n  }\n\n  .lg\\:h-10 {\n    height: 96px;\n  }\n\n  .lg\\:h-screen {\n    height: 100vh;\n  }\n\n  .lg\\:h-auto {\n    height: auto;\n  }\n\n  .lg\\:h-full {\n    height: 100%;\n  }\n\n  .lg\\:h-px {\n    height: 1px;\n  }\n\n  .lg\\:h-1\\/6 {\n    height: 16.666666667%;\n  }\n\n  .lg\\:leading-none {\n    line-height: 1;\n  }\n\n  .lg\\:leading-tight {\n    line-height: 1.25;\n  }\n\n  .lg\\:leading-normal {\n    line-height: 1.5;\n  }\n\n  .lg\\:leading-loose {\n    line-height: 2;\n  }\n\n  .lg\\:m-0 {\n    margin: 0;\n  }\n\n  .lg\\:m-1 {\n    margin: 2px;\n  }\n\n  .lg\\:m-2 {\n    margin: 4px;\n  }\n\n  .lg\\:m-3 {\n    margin: 8px;\n  }\n\n  .lg\\:m-4 {\n    margin: 16px;\n  }\n\n  .lg\\:m-5 {\n    margin: 24px;\n  }\n\n  .lg\\:m-6 {\n    margin: 32px;\n  }\n\n  .lg\\:m-7 {\n    margin: 36px;\n  }\n\n  .lg\\:m-8 {\n    margin: 48px;\n  }\n\n  .lg\\:m-9 {\n    margin: 64px;\n  }\n\n  .lg\\:m-10 {\n    margin: 96px;\n  }\n\n  .lg\\:m-auto {\n    margin: auto;\n  }\n\n  .lg\\:m-full {\n    margin: 100%;\n  }\n\n  .lg\\:m-px {\n    margin: 1px;\n  }\n\n  .lg\\:m-1\\/6 {\n    margin: 16.666666667%;\n  }\n\n  .lg\\:my-0 {\n    margin-top: 0;\n    margin-bottom: 0;\n  }\n\n  .lg\\:mx-0 {\n    margin-left: 0;\n    margin-right: 0;\n  }\n\n  .lg\\:my-1 {\n    margin-top: 2px;\n    margin-bottom: 2px;\n  }\n\n  .lg\\:mx-1 {\n    margin-left: 2px;\n    margin-right: 2px;\n  }\n\n  .lg\\:my-2 {\n    margin-top: 4px;\n    margin-bottom: 4px;\n  }\n\n  .lg\\:mx-2 {\n    margin-left: 4px;\n    margin-right: 4px;\n  }\n\n  .lg\\:my-3 {\n    margin-top: 8px;\n    margin-bottom: 8px;\n  }\n\n  .lg\\:mx-3 {\n    margin-left: 8px;\n    margin-right: 8px;\n  }\n\n  .lg\\:my-4 {\n    margin-top: 16px;\n    margin-bottom: 16px;\n  }\n\n  .lg\\:mx-4 {\n    margin-left: 16px;\n    margin-right: 16px;\n  }\n\n  .lg\\:my-5 {\n    margin-top: 24px;\n    margin-bottom: 24px;\n  }\n\n  .lg\\:mx-5 {\n    margin-left: 24px;\n    margin-right: 24px;\n  }\n\n  .lg\\:my-6 {\n    margin-top: 32px;\n    margin-bottom: 32px;\n  }\n\n  .lg\\:mx-6 {\n    margin-left: 32px;\n    margin-right: 32px;\n  }\n\n  .lg\\:my-7 {\n    margin-top: 36px;\n    margin-bottom: 36px;\n  }\n\n  .lg\\:mx-7 {\n    margin-left: 36px;\n    margin-right: 36px;\n  }\n\n  .lg\\:my-8 {\n    margin-top: 48px;\n    margin-bottom: 48px;\n  }\n\n  .lg\\:mx-8 {\n    margin-left: 48px;\n    margin-right: 48px;\n  }\n\n  .lg\\:my-9 {\n    margin-top: 64px;\n    margin-bottom: 64px;\n  }\n\n  .lg\\:mx-9 {\n    margin-left: 64px;\n    margin-right: 64px;\n  }\n\n  .lg\\:my-10 {\n    margin-top: 96px;\n    margin-bottom: 96px;\n  }\n\n  .lg\\:mx-10 {\n    margin-left: 96px;\n    margin-right: 96px;\n  }\n\n  .lg\\:my-auto {\n    margin-top: auto;\n    margin-bottom: auto;\n  }\n\n  .lg\\:mx-auto {\n    margin-left: auto;\n    margin-right: auto;\n  }\n\n  .lg\\:my-full {\n    margin-top: 100%;\n    margin-bottom: 100%;\n  }\n\n  .lg\\:mx-full {\n    margin-left: 100%;\n    margin-right: 100%;\n  }\n\n  .lg\\:my-px {\n    margin-top: 1px;\n    margin-bottom: 1px;\n  }\n\n  .lg\\:mx-px {\n    margin-left: 1px;\n    margin-right: 1px;\n  }\n\n  .lg\\:my-1\\/6 {\n    margin-top: 16.666666667%;\n    margin-bottom: 16.666666667%;\n  }\n\n  .lg\\:mx-1\\/6 {\n    margin-left: 16.666666667%;\n    margin-right: 16.666666667%;\n  }\n\n  .lg\\:mt-0 {\n    margin-top: 0;\n  }\n\n  .lg\\:mr-0 {\n    margin-right: 0;\n  }\n\n  .lg\\:mb-0 {\n    margin-bottom: 0;\n  }\n\n  .lg\\:ml-0 {\n    margin-left: 0;\n  }\n\n  .lg\\:mt-1 {\n    margin-top: 2px;\n  }\n\n  .lg\\:mr-1 {\n    margin-right: 2px;\n  }\n\n  .lg\\:mb-1 {\n    margin-bottom: 2px;\n  }\n\n  .lg\\:ml-1 {\n    margin-left: 2px;\n  }\n\n  .lg\\:mt-2 {\n    margin-top: 4px;\n  }\n\n  .lg\\:mr-2 {\n    margin-right: 4px;\n  }\n\n  .lg\\:mb-2 {\n    margin-bottom: 4px;\n  }\n\n  .lg\\:ml-2 {\n    margin-left: 4px;\n  }\n\n  .lg\\:mt-3 {\n    margin-top: 8px;\n  }\n\n  .lg\\:mr-3 {\n    margin-right: 8px;\n  }\n\n  .lg\\:mb-3 {\n    margin-bottom: 8px;\n  }\n\n  .lg\\:ml-3 {\n    margin-left: 8px;\n  }\n\n  .lg\\:mt-4 {\n    margin-top: 16px;\n  }\n\n  .lg\\:mr-4 {\n    margin-right: 16px;\n  }\n\n  .lg\\:mb-4 {\n    margin-bottom: 16px;\n  }\n\n  .lg\\:ml-4 {\n    margin-left: 16px;\n  }\n\n  .lg\\:mt-5 {\n    margin-top: 24px;\n  }\n\n  .lg\\:mr-5 {\n    margin-right: 24px;\n  }\n\n  .lg\\:mb-5 {\n    margin-bottom: 24px;\n  }\n\n  .lg\\:ml-5 {\n    margin-left: 24px;\n  }\n\n  .lg\\:mt-6 {\n    margin-top: 32px;\n  }\n\n  .lg\\:mr-6 {\n    margin-right: 32px;\n  }\n\n  .lg\\:mb-6 {\n    margin-bottom: 32px;\n  }\n\n  .lg\\:ml-6 {\n    margin-left: 32px;\n  }\n\n  .lg\\:mt-7 {\n    margin-top: 36px;\n  }\n\n  .lg\\:mr-7 {\n    margin-right: 36px;\n  }\n\n  .lg\\:mb-7 {\n    margin-bottom: 36px;\n  }\n\n  .lg\\:ml-7 {\n    margin-left: 36px;\n  }\n\n  .lg\\:mt-8 {\n    margin-top: 48px;\n  }\n\n  .lg\\:mr-8 {\n    margin-right: 48px;\n  }\n\n  .lg\\:mb-8 {\n    margin-bottom: 48px;\n  }\n\n  .lg\\:ml-8 {\n    margin-left: 48px;\n  }\n\n  .lg\\:mt-9 {\n    margin-top: 64px;\n  }\n\n  .lg\\:mr-9 {\n    margin-right: 64px;\n  }\n\n  .lg\\:mb-9 {\n    margin-bottom: 64px;\n  }\n\n  .lg\\:ml-9 {\n    margin-left: 64px;\n  }\n\n  .lg\\:mt-10 {\n    margin-top: 96px;\n  }\n\n  .lg\\:mr-10 {\n    margin-right: 96px;\n  }\n\n  .lg\\:mb-10 {\n    margin-bottom: 96px;\n  }\n\n  .lg\\:ml-10 {\n    margin-left: 96px;\n  }\n\n  .lg\\:mt-auto {\n    margin-top: auto;\n  }\n\n  .lg\\:mr-auto {\n    margin-right: auto;\n  }\n\n  .lg\\:mb-auto {\n    margin-bottom: auto;\n  }\n\n  .lg\\:ml-auto {\n    margin-left: auto;\n  }\n\n  .lg\\:mt-full {\n    margin-top: 100%;\n  }\n\n  .lg\\:mr-full {\n    margin-right: 100%;\n  }\n\n  .lg\\:mb-full {\n    margin-bottom: 100%;\n  }\n\n  .lg\\:ml-full {\n    margin-left: 100%;\n  }\n\n  .lg\\:mt-px {\n    margin-top: 1px;\n  }\n\n  .lg\\:mr-px {\n    margin-right: 1px;\n  }\n\n  .lg\\:mb-px {\n    margin-bottom: 1px;\n  }\n\n  .lg\\:ml-px {\n    margin-left: 1px;\n  }\n\n  .lg\\:mt-1\\/6 {\n    margin-top: 16.666666667%;\n  }\n\n  .lg\\:mr-1\\/6 {\n    margin-right: 16.666666667%;\n  }\n\n  .lg\\:mb-1\\/6 {\n    margin-bottom: 16.666666667%;\n  }\n\n  .lg\\:ml-1\\/6 {\n    margin-left: 16.666666667%;\n  }\n\n  .lg\\:max-h-0 {\n    max-height: 0;\n  }\n\n  .lg\\:max-h-1 {\n    max-height: 2px;\n  }\n\n  .lg\\:max-h-2 {\n    max-height: 4px;\n  }\n\n  .lg\\:max-h-3 {\n    max-height: 8px;\n  }\n\n  .lg\\:max-h-4 {\n    max-height: 16px;\n  }\n\n  .lg\\:max-h-5 {\n    max-height: 24px;\n  }\n\n  .lg\\:max-h-6 {\n    max-height: 32px;\n  }\n\n  .lg\\:max-h-7 {\n    max-height: 36px;\n  }\n\n  .lg\\:max-h-8 {\n    max-height: 48px;\n  }\n\n  .lg\\:max-h-9 {\n    max-height: 64px;\n  }\n\n  .lg\\:max-h-10 {\n    max-height: 96px;\n  }\n\n  .lg\\:max-h-screen {\n    max-height: 100vh;\n  }\n\n  .lg\\:max-h-auto {\n    max-height: auto;\n  }\n\n  .lg\\:max-h-full {\n    max-height: 100%;\n  }\n\n  .lg\\:max-h-px {\n    max-height: 1px;\n  }\n\n  .lg\\:max-h-1\\/6 {\n    max-height: 16.666666667%;\n  }\n\n  .lg\\:max-w-0 {\n    max-width: 0;\n  }\n\n  .lg\\:max-w-1 {\n    max-width: 2px;\n  }\n\n  .lg\\:max-w-2 {\n    max-width: 4px;\n  }\n\n  .lg\\:max-w-3 {\n    max-width: 8px;\n  }\n\n  .lg\\:max-w-4 {\n    max-width: 16px;\n  }\n\n  .lg\\:max-w-5 {\n    max-width: 24px;\n  }\n\n  .lg\\:max-w-6 {\n    max-width: 32px;\n  }\n\n  .lg\\:max-w-7 {\n    max-width: 36px;\n  }\n\n  .lg\\:max-w-8 {\n    max-width: 48px;\n  }\n\n  .lg\\:max-w-9 {\n    max-width: 64px;\n  }\n\n  .lg\\:max-w-10 {\n    max-width: 96px;\n  }\n\n  .lg\\:max-w-auto {\n    max-width: auto;\n  }\n\n  .lg\\:max-w-full {\n    max-width: 100%;\n  }\n\n  .lg\\:max-w-px {\n    max-width: 1px;\n  }\n\n  .lg\\:max-w-1\\/6 {\n    max-width: 16.666666667%;\n  }\n\n  .lg\\:min-h-0 {\n    min-height: 0;\n  }\n\n  .lg\\:min-h-1 {\n    min-height: 2px;\n  }\n\n  .lg\\:min-h-2 {\n    min-height: 4px;\n  }\n\n  .lg\\:min-h-3 {\n    min-height: 8px;\n  }\n\n  .lg\\:min-h-4 {\n    min-height: 16px;\n  }\n\n  .lg\\:min-h-5 {\n    min-height: 24px;\n  }\n\n  .lg\\:min-h-6 {\n    min-height: 32px;\n  }\n\n  .lg\\:min-h-7 {\n    min-height: 36px;\n  }\n\n  .lg\\:min-h-8 {\n    min-height: 48px;\n  }\n\n  .lg\\:min-h-9 {\n    min-height: 64px;\n  }\n\n  .lg\\:min-h-10 {\n    min-height: 96px;\n  }\n\n  .lg\\:min-h-screen {\n    min-height: 100vh;\n  }\n\n  .lg\\:min-h-auto {\n    min-height: auto;\n  }\n\n  .lg\\:min-h-full {\n    min-height: 100%;\n  }\n\n  .lg\\:min-h-px {\n    min-height: 1px;\n  }\n\n  .lg\\:min-h-1\\/6 {\n    min-height: 16.666666667%;\n  }\n\n  .lg\\:min-w-0 {\n    min-width: 0;\n  }\n\n  .lg\\:min-w-1 {\n    min-width: 2px;\n  }\n\n  .lg\\:min-w-2 {\n    min-width: 4px;\n  }\n\n  .lg\\:min-w-3 {\n    min-width: 8px;\n  }\n\n  .lg\\:min-w-4 {\n    min-width: 16px;\n  }\n\n  .lg\\:min-w-5 {\n    min-width: 24px;\n  }\n\n  .lg\\:min-w-6 {\n    min-width: 32px;\n  }\n\n  .lg\\:min-w-7 {\n    min-width: 36px;\n  }\n\n  .lg\\:min-w-8 {\n    min-width: 48px;\n  }\n\n  .lg\\:min-w-9 {\n    min-width: 64px;\n  }\n\n  .lg\\:min-w-10 {\n    min-width: 96px;\n  }\n\n  .lg\\:min-w-auto {\n    min-width: auto;\n  }\n\n  .lg\\:min-w-full {\n    min-width: 100%;\n  }\n\n  .lg\\:min-w-px {\n    min-width: 1px;\n  }\n\n  .lg\\:min-w-1\\/6 {\n    min-width: 16.666666667%;\n  }\n\n  .lg\\:-m-0 {\n    margin: 0;\n  }\n\n  .lg\\:-m-1 {\n    margin: -2px;\n  }\n\n  .lg\\:-m-2 {\n    margin: -4px;\n  }\n\n  .lg\\:-m-3 {\n    margin: -8px;\n  }\n\n  .lg\\:-m-4 {\n    margin: -16px;\n  }\n\n  .lg\\:-m-5 {\n    margin: -24px;\n  }\n\n  .lg\\:-m-6 {\n    margin: -32px;\n  }\n\n  .lg\\:-m-7 {\n    margin: -36px;\n  }\n\n  .lg\\:-m-8 {\n    margin: -48px;\n  }\n\n  .lg\\:-m-9 {\n    margin: -64px;\n  }\n\n  .lg\\:-m-10 {\n    margin: -96px;\n  }\n\n  .lg\\:-m-auto {\n    margin: -auto;\n  }\n\n  .lg\\:-m-full {\n    margin: -100%;\n  }\n\n  .lg\\:-m-px {\n    margin: -1px;\n  }\n\n  .lg\\:-m-1\\/6 {\n    margin: -16.666666667%;\n  }\n\n  .lg\\:-my-0 {\n    margin-top: 0;\n    margin-bottom: 0;\n  }\n\n  .lg\\:-mx-0 {\n    margin-left: 0;\n    margin-right: 0;\n  }\n\n  .lg\\:-my-1 {\n    margin-top: -2px;\n    margin-bottom: -2px;\n  }\n\n  .lg\\:-mx-1 {\n    margin-left: -2px;\n    margin-right: -2px;\n  }\n\n  .lg\\:-my-2 {\n    margin-top: -4px;\n    margin-bottom: -4px;\n  }\n\n  .lg\\:-mx-2 {\n    margin-left: -4px;\n    margin-right: -4px;\n  }\n\n  .lg\\:-my-3 {\n    margin-top: -8px;\n    margin-bottom: -8px;\n  }\n\n  .lg\\:-mx-3 {\n    margin-left: -8px;\n    margin-right: -8px;\n  }\n\n  .lg\\:-my-4 {\n    margin-top: -16px;\n    margin-bottom: -16px;\n  }\n\n  .lg\\:-mx-4 {\n    margin-left: -16px;\n    margin-right: -16px;\n  }\n\n  .lg\\:-my-5 {\n    margin-top: -24px;\n    margin-bottom: -24px;\n  }\n\n  .lg\\:-mx-5 {\n    margin-left: -24px;\n    margin-right: -24px;\n  }\n\n  .lg\\:-my-6 {\n    margin-top: -32px;\n    margin-bottom: -32px;\n  }\n\n  .lg\\:-mx-6 {\n    margin-left: -32px;\n    margin-right: -32px;\n  }\n\n  .lg\\:-my-7 {\n    margin-top: -36px;\n    margin-bottom: -36px;\n  }\n\n  .lg\\:-mx-7 {\n    margin-left: -36px;\n    margin-right: -36px;\n  }\n\n  .lg\\:-my-8 {\n    margin-top: -48px;\n    margin-bottom: -48px;\n  }\n\n  .lg\\:-mx-8 {\n    margin-left: -48px;\n    margin-right: -48px;\n  }\n\n  .lg\\:-my-9 {\n    margin-top: -64px;\n    margin-bottom: -64px;\n  }\n\n  .lg\\:-mx-9 {\n    margin-left: -64px;\n    margin-right: -64px;\n  }\n\n  .lg\\:-my-10 {\n    margin-top: -96px;\n    margin-bottom: -96px;\n  }\n\n  .lg\\:-mx-10 {\n    margin-left: -96px;\n    margin-right: -96px;\n  }\n\n  .lg\\:-my-auto {\n    margin-top: -auto;\n    margin-bottom: -auto;\n  }\n\n  .lg\\:-mx-auto {\n    margin-left: -auto;\n    margin-right: -auto;\n  }\n\n  .lg\\:-my-full {\n    margin-top: -100%;\n    margin-bottom: -100%;\n  }\n\n  .lg\\:-mx-full {\n    margin-left: -100%;\n    margin-right: -100%;\n  }\n\n  .lg\\:-my-px {\n    margin-top: -1px;\n    margin-bottom: -1px;\n  }\n\n  .lg\\:-mx-px {\n    margin-left: -1px;\n    margin-right: -1px;\n  }\n\n  .lg\\:-my-1\\/6 {\n    margin-top: -16.666666667%;\n    margin-bottom: -16.666666667%;\n  }\n\n  .lg\\:-mx-1\\/6 {\n    margin-left: -16.666666667%;\n    margin-right: -16.666666667%;\n  }\n\n  .lg\\:-mt-0 {\n    margin-top: 0;\n  }\n\n  .lg\\:-mr-0 {\n    margin-right: 0;\n  }\n\n  .lg\\:-mb-0 {\n    margin-bottom: 0;\n  }\n\n  .lg\\:-ml-0 {\n    margin-left: 0;\n  }\n\n  .lg\\:-mt-1 {\n    margin-top: -2px;\n  }\n\n  .lg\\:-mr-1 {\n    margin-right: -2px;\n  }\n\n  .lg\\:-mb-1 {\n    margin-bottom: -2px;\n  }\n\n  .lg\\:-ml-1 {\n    margin-left: -2px;\n  }\n\n  .lg\\:-mt-2 {\n    margin-top: -4px;\n  }\n\n  .lg\\:-mr-2 {\n    margin-right: -4px;\n  }\n\n  .lg\\:-mb-2 {\n    margin-bottom: -4px;\n  }\n\n  .lg\\:-ml-2 {\n    margin-left: -4px;\n  }\n\n  .lg\\:-mt-3 {\n    margin-top: -8px;\n  }\n\n  .lg\\:-mr-3 {\n    margin-right: -8px;\n  }\n\n  .lg\\:-mb-3 {\n    margin-bottom: -8px;\n  }\n\n  .lg\\:-ml-3 {\n    margin-left: -8px;\n  }\n\n  .lg\\:-mt-4 {\n    margin-top: -16px;\n  }\n\n  .lg\\:-mr-4 {\n    margin-right: -16px;\n  }\n\n  .lg\\:-mb-4 {\n    margin-bottom: -16px;\n  }\n\n  .lg\\:-ml-4 {\n    margin-left: -16px;\n  }\n\n  .lg\\:-mt-5 {\n    margin-top: -24px;\n  }\n\n  .lg\\:-mr-5 {\n    margin-right: -24px;\n  }\n\n  .lg\\:-mb-5 {\n    margin-bottom: -24px;\n  }\n\n  .lg\\:-ml-5 {\n    margin-left: -24px;\n  }\n\n  .lg\\:-mt-6 {\n    margin-top: -32px;\n  }\n\n  .lg\\:-mr-6 {\n    margin-right: -32px;\n  }\n\n  .lg\\:-mb-6 {\n    margin-bottom: -32px;\n  }\n\n  .lg\\:-ml-6 {\n    margin-left: -32px;\n  }\n\n  .lg\\:-mt-7 {\n    margin-top: -36px;\n  }\n\n  .lg\\:-mr-7 {\n    margin-right: -36px;\n  }\n\n  .lg\\:-mb-7 {\n    margin-bottom: -36px;\n  }\n\n  .lg\\:-ml-7 {\n    margin-left: -36px;\n  }\n\n  .lg\\:-mt-8 {\n    margin-top: -48px;\n  }\n\n  .lg\\:-mr-8 {\n    margin-right: -48px;\n  }\n\n  .lg\\:-mb-8 {\n    margin-bottom: -48px;\n  }\n\n  .lg\\:-ml-8 {\n    margin-left: -48px;\n  }\n\n  .lg\\:-mt-9 {\n    margin-top: -64px;\n  }\n\n  .lg\\:-mr-9 {\n    margin-right: -64px;\n  }\n\n  .lg\\:-mb-9 {\n    margin-bottom: -64px;\n  }\n\n  .lg\\:-ml-9 {\n    margin-left: -64px;\n  }\n\n  .lg\\:-mt-10 {\n    margin-top: -96px;\n  }\n\n  .lg\\:-mr-10 {\n    margin-right: -96px;\n  }\n\n  .lg\\:-mb-10 {\n    margin-bottom: -96px;\n  }\n\n  .lg\\:-ml-10 {\n    margin-left: -96px;\n  }\n\n  .lg\\:-mt-auto {\n    margin-top: -auto;\n  }\n\n  .lg\\:-mr-auto {\n    margin-right: -auto;\n  }\n\n  .lg\\:-mb-auto {\n    margin-bottom: -auto;\n  }\n\n  .lg\\:-ml-auto {\n    margin-left: -auto;\n  }\n\n  .lg\\:-mt-full {\n    margin-top: -100%;\n  }\n\n  .lg\\:-mr-full {\n    margin-right: -100%;\n  }\n\n  .lg\\:-mb-full {\n    margin-bottom: -100%;\n  }\n\n  .lg\\:-ml-full {\n    margin-left: -100%;\n  }\n\n  .lg\\:-mt-px {\n    margin-top: -1px;\n  }\n\n  .lg\\:-mr-px {\n    margin-right: -1px;\n  }\n\n  .lg\\:-mb-px {\n    margin-bottom: -1px;\n  }\n\n  .lg\\:-ml-px {\n    margin-left: -1px;\n  }\n\n  .lg\\:-mt-1\\/6 {\n    margin-top: -16.666666667%;\n  }\n\n  .lg\\:-mr-1\\/6 {\n    margin-right: -16.666666667%;\n  }\n\n  .lg\\:-mb-1\\/6 {\n    margin-bottom: -16.666666667%;\n  }\n\n  .lg\\:-ml-1\\/6 {\n    margin-left: -16.666666667%;\n  }\n\n  .lg\\:opacity-0 {\n    opacity: 0;\n  }\n\n  .lg\\:opacity-25 {\n    opacity: .25;\n  }\n\n  .lg\\:opacity-50 {\n    opacity: .5;\n  }\n\n  .lg\\:opacity-75 {\n    opacity: .75;\n  }\n\n  .lg\\:opacity-100 {\n    opacity: 1;\n  }\n\n  .lg\\:overflow-auto {\n    overflow: auto;\n  }\n\n  .lg\\:overflow-hidden {\n    overflow: hidden;\n  }\n\n  .lg\\:overflow-visible {\n    overflow: visible;\n  }\n\n  .lg\\:overflow-scroll {\n    overflow: scroll;\n  }\n\n  .lg\\:overflow-x-auto {\n    overflow-x: auto;\n  }\n\n  .lg\\:overflow-y-auto {\n    overflow-y: auto;\n  }\n\n  .lg\\:overflow-x-hidden {\n    overflow-x: hidden;\n  }\n\n  .lg\\:overflow-y-hidden {\n    overflow-y: hidden;\n  }\n\n  .lg\\:overflow-x-visible {\n    overflow-x: visible;\n  }\n\n  .lg\\:overflow-y-visible {\n    overflow-y: visible;\n  }\n\n  .lg\\:overflow-x-scroll {\n    overflow-x: scroll;\n  }\n\n  .lg\\:overflow-y-scroll {\n    overflow-y: scroll;\n  }\n\n  .lg\\:scrolling-touch {\n    -webkit-overflow-scrolling: touch;\n  }\n\n  .lg\\:scrolling-auto {\n    -webkit-overflow-scrolling: auto;\n  }\n\n  .lg\\:p-0 {\n    padding: 0;\n  }\n\n  .lg\\:p-1 {\n    padding: 2px;\n  }\n\n  .lg\\:p-2 {\n    padding: 4px;\n  }\n\n  .lg\\:p-3 {\n    padding: 8px;\n  }\n\n  .lg\\:p-4 {\n    padding: 16px;\n  }\n\n  .lg\\:p-5 {\n    padding: 24px;\n  }\n\n  .lg\\:p-6 {\n    padding: 32px;\n  }\n\n  .lg\\:p-7 {\n    padding: 36px;\n  }\n\n  .lg\\:p-8 {\n    padding: 48px;\n  }\n\n  .lg\\:p-9 {\n    padding: 64px;\n  }\n\n  .lg\\:p-10 {\n    padding: 96px;\n  }\n\n  .lg\\:p-auto {\n    padding: auto;\n  }\n\n  .lg\\:p-full {\n    padding: 100%;\n  }\n\n  .lg\\:p-px {\n    padding: 1px;\n  }\n\n  .lg\\:p-1\\/6 {\n    padding: 16.666666667%;\n  }\n\n  .lg\\:py-0 {\n    padding-top: 0;\n    padding-bottom: 0;\n  }\n\n  .lg\\:px-0 {\n    padding-left: 0;\n    padding-right: 0;\n  }\n\n  .lg\\:py-1 {\n    padding-top: 2px;\n    padding-bottom: 2px;\n  }\n\n  .lg\\:px-1 {\n    padding-left: 2px;\n    padding-right: 2px;\n  }\n\n  .lg\\:py-2 {\n    padding-top: 4px;\n    padding-bottom: 4px;\n  }\n\n  .lg\\:px-2 {\n    padding-left: 4px;\n    padding-right: 4px;\n  }\n\n  .lg\\:py-3 {\n    padding-top: 8px;\n    padding-bottom: 8px;\n  }\n\n  .lg\\:px-3 {\n    padding-left: 8px;\n    padding-right: 8px;\n  }\n\n  .lg\\:py-4 {\n    padding-top: 16px;\n    padding-bottom: 16px;\n  }\n\n  .lg\\:px-4 {\n    padding-left: 16px;\n    padding-right: 16px;\n  }\n\n  .lg\\:py-5 {\n    padding-top: 24px;\n    padding-bottom: 24px;\n  }\n\n  .lg\\:px-5 {\n    padding-left: 24px;\n    padding-right: 24px;\n  }\n\n  .lg\\:py-6 {\n    padding-top: 32px;\n    padding-bottom: 32px;\n  }\n\n  .lg\\:px-6 {\n    padding-left: 32px;\n    padding-right: 32px;\n  }\n\n  .lg\\:py-7 {\n    padding-top: 36px;\n    padding-bottom: 36px;\n  }\n\n  .lg\\:px-7 {\n    padding-left: 36px;\n    padding-right: 36px;\n  }\n\n  .lg\\:py-8 {\n    padding-top: 48px;\n    padding-bottom: 48px;\n  }\n\n  .lg\\:px-8 {\n    padding-left: 48px;\n    padding-right: 48px;\n  }\n\n  .lg\\:py-9 {\n    padding-top: 64px;\n    padding-bottom: 64px;\n  }\n\n  .lg\\:px-9 {\n    padding-left: 64px;\n    padding-right: 64px;\n  }\n\n  .lg\\:py-10 {\n    padding-top: 96px;\n    padding-bottom: 96px;\n  }\n\n  .lg\\:px-10 {\n    padding-left: 96px;\n    padding-right: 96px;\n  }\n\n  .lg\\:py-auto {\n    padding-top: auto;\n    padding-bottom: auto;\n  }\n\n  .lg\\:px-auto {\n    padding-left: auto;\n    padding-right: auto;\n  }\n\n  .lg\\:py-full {\n    padding-top: 100%;\n    padding-bottom: 100%;\n  }\n\n  .lg\\:px-full {\n    padding-left: 100%;\n    padding-right: 100%;\n  }\n\n  .lg\\:py-px {\n    padding-top: 1px;\n    padding-bottom: 1px;\n  }\n\n  .lg\\:px-px {\n    padding-left: 1px;\n    padding-right: 1px;\n  }\n\n  .lg\\:py-1\\/6 {\n    padding-top: 16.666666667%;\n    padding-bottom: 16.666666667%;\n  }\n\n  .lg\\:px-1\\/6 {\n    padding-left: 16.666666667%;\n    padding-right: 16.666666667%;\n  }\n\n  .lg\\:pt-0 {\n    padding-top: 0;\n  }\n\n  .lg\\:pr-0 {\n    padding-right: 0;\n  }\n\n  .lg\\:pb-0 {\n    padding-bottom: 0;\n  }\n\n  .lg\\:pl-0 {\n    padding-left: 0;\n  }\n\n  .lg\\:pt-1 {\n    padding-top: 2px;\n  }\n\n  .lg\\:pr-1 {\n    padding-right: 2px;\n  }\n\n  .lg\\:pb-1 {\n    padding-bottom: 2px;\n  }\n\n  .lg\\:pl-1 {\n    padding-left: 2px;\n  }\n\n  .lg\\:pt-2 {\n    padding-top: 4px;\n  }\n\n  .lg\\:pr-2 {\n    padding-right: 4px;\n  }\n\n  .lg\\:pb-2 {\n    padding-bottom: 4px;\n  }\n\n  .lg\\:pl-2 {\n    padding-left: 4px;\n  }\n\n  .lg\\:pt-3 {\n    padding-top: 8px;\n  }\n\n  .lg\\:pr-3 {\n    padding-right: 8px;\n  }\n\n  .lg\\:pb-3 {\n    padding-bottom: 8px;\n  }\n\n  .lg\\:pl-3 {\n    padding-left: 8px;\n  }\n\n  .lg\\:pt-4 {\n    padding-top: 16px;\n  }\n\n  .lg\\:pr-4 {\n    padding-right: 16px;\n  }\n\n  .lg\\:pb-4 {\n    padding-bottom: 16px;\n  }\n\n  .lg\\:pl-4 {\n    padding-left: 16px;\n  }\n\n  .lg\\:pt-5 {\n    padding-top: 24px;\n  }\n\n  .lg\\:pr-5 {\n    padding-right: 24px;\n  }\n\n  .lg\\:pb-5 {\n    padding-bottom: 24px;\n  }\n\n  .lg\\:pl-5 {\n    padding-left: 24px;\n  }\n\n  .lg\\:pt-6 {\n    padding-top: 32px;\n  }\n\n  .lg\\:pr-6 {\n    padding-right: 32px;\n  }\n\n  .lg\\:pb-6 {\n    padding-bottom: 32px;\n  }\n\n  .lg\\:pl-6 {\n    padding-left: 32px;\n  }\n\n  .lg\\:pt-7 {\n    padding-top: 36px;\n  }\n\n  .lg\\:pr-7 {\n    padding-right: 36px;\n  }\n\n  .lg\\:pb-7 {\n    padding-bottom: 36px;\n  }\n\n  .lg\\:pl-7 {\n    padding-left: 36px;\n  }\n\n  .lg\\:pt-8 {\n    padding-top: 48px;\n  }\n\n  .lg\\:pr-8 {\n    padding-right: 48px;\n  }\n\n  .lg\\:pb-8 {\n    padding-bottom: 48px;\n  }\n\n  .lg\\:pl-8 {\n    padding-left: 48px;\n  }\n\n  .lg\\:pt-9 {\n    padding-top: 64px;\n  }\n\n  .lg\\:pr-9 {\n    padding-right: 64px;\n  }\n\n  .lg\\:pb-9 {\n    padding-bottom: 64px;\n  }\n\n  .lg\\:pl-9 {\n    padding-left: 64px;\n  }\n\n  .lg\\:pt-10 {\n    padding-top: 96px;\n  }\n\n  .lg\\:pr-10 {\n    padding-right: 96px;\n  }\n\n  .lg\\:pb-10 {\n    padding-bottom: 96px;\n  }\n\n  .lg\\:pl-10 {\n    padding-left: 96px;\n  }\n\n  .lg\\:pt-auto {\n    padding-top: auto;\n  }\n\n  .lg\\:pr-auto {\n    padding-right: auto;\n  }\n\n  .lg\\:pb-auto {\n    padding-bottom: auto;\n  }\n\n  .lg\\:pl-auto {\n    padding-left: auto;\n  }\n\n  .lg\\:pt-full {\n    padding-top: 100%;\n  }\n\n  .lg\\:pr-full {\n    padding-right: 100%;\n  }\n\n  .lg\\:pb-full {\n    padding-bottom: 100%;\n  }\n\n  .lg\\:pl-full {\n    padding-left: 100%;\n  }\n\n  .lg\\:pt-px {\n    padding-top: 1px;\n  }\n\n  .lg\\:pr-px {\n    padding-right: 1px;\n  }\n\n  .lg\\:pb-px {\n    padding-bottom: 1px;\n  }\n\n  .lg\\:pl-px {\n    padding-left: 1px;\n  }\n\n  .lg\\:pt-1\\/6 {\n    padding-top: 16.666666667%;\n  }\n\n  .lg\\:pr-1\\/6 {\n    padding-right: 16.666666667%;\n  }\n\n  .lg\\:pb-1\\/6 {\n    padding-bottom: 16.666666667%;\n  }\n\n  .lg\\:pl-1\\/6 {\n    padding-left: 16.666666667%;\n  }\n\n  .lg\\:pointer-events-none {\n    pointer-events: none;\n  }\n\n  .lg\\:pointer-events-auto {\n    pointer-events: auto;\n  }\n\n  .lg\\:static {\n    position: static;\n  }\n\n  .lg\\:fixed {\n    position: fixed;\n  }\n\n  .lg\\:absolute {\n    position: absolute;\n  }\n\n  .lg\\:relative {\n    position: relative;\n  }\n\n  .lg\\:sticky {\n    position: sticky;\n  }\n\n  .lg\\:pin-none {\n    top: auto;\n    right: auto;\n    bottom: auto;\n    left: auto;\n  }\n\n  .lg\\:pin {\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n\n  .lg\\:pin-y {\n    top: 0;\n    bottom: 0;\n  }\n\n  .lg\\:pin-x {\n    right: 0;\n    left: 0;\n  }\n\n  .lg\\:pin-t {\n    top: 0;\n  }\n\n  .lg\\:pin-r {\n    right: 0;\n  }\n\n  .lg\\:pin-b {\n    bottom: 0;\n  }\n\n  .lg\\:pin-l {\n    left: 0;\n  }\n\n  .lg\\:resize-none {\n    resize: none;\n  }\n\n  .lg\\:resize-y {\n    resize: vertical;\n  }\n\n  .lg\\:resize-x {\n    resize: horizontal;\n  }\n\n  .lg\\:resize {\n    resize: both;\n  }\n\n  .lg\\:shadow {\n    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .1);\n  }\n\n  .lg\\:shadow-md {\n    box-shadow:  0 8px 20px 0 rgba(0, 0, 0, .42);\n  }\n\n  .lg\\:shadow-none {\n    box-shadow: none;\n  }\n\n  .lg\\:table-auto {\n    table-layout: auto;\n  }\n\n  .lg\\:table-fixed {\n    table-layout: fixed;\n  }\n\n  .lg\\:text-left {\n    text-align: left;\n  }\n\n  .lg\\:text-center {\n    text-align: center;\n  }\n\n  .lg\\:text-right {\n    text-align: right;\n  }\n\n  .lg\\:text-justify {\n    text-align: justify;\n  }\n\n  .lg\\:text-inherit {\n    color: inherit;\n  }\n\n  .lg\\:text-transparent {\n    color: transparent;\n  }\n\n  .lg\\:text-black {\n    color: #282828;\n  }\n\n  .lg\\:text-white {\n    color: #fff;\n  }\n\n  .lg\\:text-grey-lighter {\n    color: #f3f3f7;\n  }\n\n  .lg\\:text-grey-light {\n    color: #e7e7ec;\n  }\n\n  .lg\\:text-grey {\n    color: #c2c2c6;\n  }\n\n  .lg\\:text-purple-lighter {\n    color: #ccc2e9;\n  }\n\n  .lg\\:text-purple-light {\n    color: #87809b;\n  }\n\n  .lg\\:text-purple {\n    color: #8360d6;\n  }\n\n  .lg\\:text-purple-bright {\n    color: #4c29b0;\n  }\n\n  .lg\\:text-purple-dark {\n    color: #453f56;\n  }\n\n  .lg\\:text-purple-dark-10 {\n    color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:text-purple-darker {\n    color: #2a2538;\n  }\n\n  .lg\\:hover\\:text-inherit:hover {\n    color: inherit;\n  }\n\n  .lg\\:hover\\:text-transparent:hover {\n    color: transparent;\n  }\n\n  .lg\\:hover\\:text-black:hover {\n    color: #282828;\n  }\n\n  .lg\\:hover\\:text-white:hover {\n    color: #fff;\n  }\n\n  .lg\\:hover\\:text-grey-lighter:hover {\n    color: #f3f3f7;\n  }\n\n  .lg\\:hover\\:text-grey-light:hover {\n    color: #e7e7ec;\n  }\n\n  .lg\\:hover\\:text-grey:hover {\n    color: #c2c2c6;\n  }\n\n  .lg\\:hover\\:text-purple-lighter:hover {\n    color: #ccc2e9;\n  }\n\n  .lg\\:hover\\:text-purple-light:hover {\n    color: #87809b;\n  }\n\n  .lg\\:hover\\:text-purple:hover {\n    color: #8360d6;\n  }\n\n  .lg\\:hover\\:text-purple-bright:hover {\n    color: #4c29b0;\n  }\n\n  .lg\\:hover\\:text-purple-dark:hover {\n    color: #453f56;\n  }\n\n  .lg\\:hover\\:text-purple-dark-10:hover {\n    color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:hover\\:text-purple-darker:hover {\n    color: #2a2538;\n  }\n\n  .lg\\:text-sm {\n    font-size: 1.4rem;\n  }\n\n  .lg\\:text-base {\n    font-size: 1.6rem;\n  }\n\n  .lg\\:italic {\n    font-style: italic;\n  }\n\n  .lg\\:roman {\n    font-style: normal;\n  }\n\n  .lg\\:uppercase {\n    text-transform: uppercase;\n  }\n\n  .lg\\:lowercase {\n    text-transform: lowercase;\n  }\n\n  .lg\\:capitalize {\n    text-transform: capitalize;\n  }\n\n  .lg\\:normal-case {\n    text-transform: none;\n  }\n\n  .lg\\:underline {\n    text-decoration: underline;\n  }\n\n  .lg\\:line-through {\n    text-decoration: line-through;\n  }\n\n  .lg\\:no-underline {\n    text-decoration: none;\n  }\n\n  .lg\\:antialiased {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  .lg\\:subpixel-antialiased {\n    -webkit-font-smoothing: auto;\n    -moz-osx-font-smoothing: auto;\n  }\n\n  .lg\\:hover\\:italic:hover {\n    font-style: italic;\n  }\n\n  .lg\\:hover\\:roman:hover {\n    font-style: normal;\n  }\n\n  .lg\\:hover\\:uppercase:hover {\n    text-transform: uppercase;\n  }\n\n  .lg\\:hover\\:lowercase:hover {\n    text-transform: lowercase;\n  }\n\n  .lg\\:hover\\:capitalize:hover {\n    text-transform: capitalize;\n  }\n\n  .lg\\:hover\\:normal-case:hover {\n    text-transform: none;\n  }\n\n  .lg\\:hover\\:underline:hover {\n    text-decoration: underline;\n  }\n\n  .lg\\:hover\\:line-through:hover {\n    text-decoration: line-through;\n  }\n\n  .lg\\:hover\\:no-underline:hover {\n    text-decoration: none;\n  }\n\n  .lg\\:hover\\:antialiased:hover {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  .lg\\:hover\\:subpixel-antialiased:hover {\n    -webkit-font-smoothing: auto;\n    -moz-osx-font-smoothing: auto;\n  }\n\n  .lg\\:tracking-tight {\n    letter-spacing: -0.05em;\n  }\n\n  .lg\\:tracking-normal {\n    letter-spacing: 0;\n  }\n\n  .lg\\:tracking-wide {\n    letter-spacing: .05em;\n  }\n\n  .lg\\:select-none {\n    user-select: none;\n  }\n\n  .lg\\:select-text {\n    user-select: text;\n  }\n\n  .lg\\:align-baseline {\n    vertical-align: baseline;\n  }\n\n  .lg\\:align-top {\n    vertical-align: top;\n  }\n\n  .lg\\:align-middle {\n    vertical-align: middle;\n  }\n\n  .lg\\:align-bottom {\n    vertical-align: bottom;\n  }\n\n  .lg\\:align-text-top {\n    vertical-align: text-top;\n  }\n\n  .lg\\:align-text-bottom {\n    vertical-align: text-bottom;\n  }\n\n  .lg\\:visible {\n    visibility: visible;\n  }\n\n  .lg\\:invisible {\n    visibility: hidden;\n  }\n\n  .lg\\:whitespace-normal {\n    white-space: normal;\n  }\n\n  .lg\\:whitespace-no-wrap {\n    white-space: nowrap;\n  }\n\n  .lg\\:whitespace-pre {\n    white-space: pre;\n  }\n\n  .lg\\:whitespace-pre-line {\n    white-space: pre-line;\n  }\n\n  .lg\\:whitespace-pre-wrap {\n    white-space: pre-wrap;\n  }\n\n  .lg\\:break-words {\n    word-wrap: break-word;\n  }\n\n  .lg\\:break-normal {\n    word-wrap: normal;\n  }\n\n  .lg\\:truncate {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .lg\\:w-0 {\n    width: 0;\n  }\n\n  .lg\\:w-1 {\n    width: 2px;\n  }\n\n  .lg\\:w-2 {\n    width: 4px;\n  }\n\n  .lg\\:w-3 {\n    width: 8px;\n  }\n\n  .lg\\:w-4 {\n    width: 16px;\n  }\n\n  .lg\\:w-5 {\n    width: 24px;\n  }\n\n  .lg\\:w-6 {\n    width: 32px;\n  }\n\n  .lg\\:w-7 {\n    width: 36px;\n  }\n\n  .lg\\:w-8 {\n    width: 48px;\n  }\n\n  .lg\\:w-9 {\n    width: 64px;\n  }\n\n  .lg\\:w-10 {\n    width: 96px;\n  }\n\n  .lg\\:w-screen {\n    width: 100vw;\n  }\n\n  .lg\\:w-auto {\n    width: auto;\n  }\n\n  .lg\\:w-full {\n    width: 100%;\n  }\n\n  .lg\\:w-px {\n    width: 1px;\n  }\n\n  .lg\\:w-1\\/6 {\n    width: 16.666666667%;\n  }\n\n  .lg\\:z-0 {\n    z-index: 0;\n  }\n\n  .lg\\:z-10 {\n    z-index: 10;\n  }\n\n  .lg\\:z-20 {\n    z-index: 20;\n  }\n\n  .lg\\:z-30 {\n    z-index: 30;\n  }\n\n  .lg\\:z-40 {\n    z-index: 40;\n  }\n\n  .lg\\:z-50 {\n    z-index: 50;\n  }\n\n  .lg\\:z-auto {\n    z-index: auto;\n  }\n\n  .lg\\:bg-black-10 {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .lg\\:bg-white-10 {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .lg\\:bg-grey-lighter-10 {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .lg\\:bg-grey-light-10 {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .lg\\:bg-grey-10 {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .lg\\:bg-purple-lighter-10 {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .lg\\:bg-purple-light-10 {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .lg\\:bg-purple-10 {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .lg\\:bg-purple-bright-10 {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .lg\\:bg-purple-dark-10 {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:bg-purple-darker-10 {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .lg\\:hover\\:bg-black-10:hover {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .lg\\:hover\\:bg-white-10:hover {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .lg\\:hover\\:bg-grey-lighter-10:hover {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .lg\\:hover\\:bg-grey-light-10:hover {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .lg\\:hover\\:bg-grey-10:hover {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .lg\\:hover\\:bg-purple-lighter-10:hover {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .lg\\:hover\\:bg-purple-light-10:hover {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .lg\\:hover\\:bg-purple-10:hover {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .lg\\:hover\\:bg-purple-bright-10:hover {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .lg\\:hover\\:bg-purple-dark-10:hover {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:hover\\:bg-purple-darker-10:hover {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .lg\\:focus\\:bg-black-10:focus {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .lg\\:focus\\:bg-white-10:focus {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .lg\\:focus\\:bg-grey-lighter-10:focus {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .lg\\:focus\\:bg-grey-light-10:focus {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .lg\\:focus\\:bg-grey-10:focus {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .lg\\:focus\\:bg-purple-lighter-10:focus {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .lg\\:focus\\:bg-purple-light-10:focus {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .lg\\:focus\\:bg-purple-10:focus {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .lg\\:focus\\:bg-purple-bright-10:focus {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .lg\\:focus\\:bg-purple-dark-10:focus {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .lg\\:focus\\:bg-purple-darker-10:focus {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .lg\\:bg-black-30 {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .lg\\:bg-white-30 {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .lg\\:bg-grey-lighter-30 {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .lg\\:bg-grey-light-30 {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .lg\\:bg-grey-30 {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .lg\\:bg-purple-lighter-30 {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .lg\\:bg-purple-light-30 {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .lg\\:bg-purple-30 {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .lg\\:bg-purple-bright-30 {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .lg\\:bg-purple-dark-30 {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .lg\\:bg-purple-darker-30 {\n    background-color: rgba(42, 37, 56, .3);\n  }\n\n  .lg\\:hover\\:bg-black-30:hover {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .lg\\:hover\\:bg-white-30:hover {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .lg\\:hover\\:bg-grey-lighter-30:hover {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .lg\\:hover\\:bg-grey-light-30:hover {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .lg\\:hover\\:bg-grey-30:hover {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .lg\\:hover\\:bg-purple-lighter-30:hover {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .lg\\:hover\\:bg-purple-light-30:hover {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .lg\\:hover\\:bg-purple-30:hover {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .lg\\:hover\\:bg-purple-bright-30:hover {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .lg\\:hover\\:bg-purple-dark-30:hover {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .lg\\:hover\\:bg-purple-darker-30:hover {\n    background-color: rgba(42, 37, 56, .3);\n  }\n\n  .lg\\:focus\\:bg-black-30:focus {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .lg\\:focus\\:bg-white-30:focus {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .lg\\:focus\\:bg-grey-lighter-30:focus {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .lg\\:focus\\:bg-grey-light-30:focus {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .lg\\:focus\\:bg-grey-30:focus {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .lg\\:focus\\:bg-purple-lighter-30:focus {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .lg\\:focus\\:bg-purple-light-30:focus {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .lg\\:focus\\:bg-purple-30:focus {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .lg\\:focus\\:bg-purple-bright-30:focus {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .lg\\:focus\\:bg-purple-dark-30:focus {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .lg\\:focus\\:bg-purple-darker-30:focus {\n    background-color: rgba(42, 37, 56, .3);\n  }\n}\n\n@media (min-width: 1200px) {\n  .xl\\:list-reset {\n    list-style: none;\n    padding: 0;\n  }\n\n  .xl\\:appearance-none {\n    appearance: none;\n  }\n\n  .xl\\:bg-fixed {\n    background-attachment: fixed;\n  }\n\n  .xl\\:bg-local {\n    background-attachment: local;\n  }\n\n  .xl\\:bg-scroll {\n    background-attachment: scroll;\n  }\n\n  .xl\\:bg-inherit {\n    background-color: inherit;\n  }\n\n  .xl\\:bg-transparent {\n    background-color: transparent;\n  }\n\n  .xl\\:bg-black {\n    background-color: #282828;\n  }\n\n  .xl\\:bg-white {\n    background-color: #fff;\n  }\n\n  .xl\\:bg-grey-lighter {\n    background-color: #f3f3f7;\n  }\n\n  .xl\\:bg-grey-light {\n    background-color: #e7e7ec;\n  }\n\n  .xl\\:bg-grey {\n    background-color: #c2c2c6;\n  }\n\n  .xl\\:bg-purple-lighter {\n    background-color: #ccc2e9;\n  }\n\n  .xl\\:bg-purple-light {\n    background-color: #87809b;\n  }\n\n  .xl\\:bg-purple {\n    background-color: #8360d6;\n  }\n\n  .xl\\:bg-purple-bright {\n    background-color: #4c29b0;\n  }\n\n  .xl\\:bg-purple-dark {\n    background-color: #453f56;\n  }\n\n  .xl\\:bg-purple-dark-10 {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:bg-purple-darker {\n    background-color: #2a2538;\n  }\n\n  .xl\\:hover\\:bg-inherit:hover {\n    background-color: inherit;\n  }\n\n  .xl\\:hover\\:bg-transparent:hover {\n    background-color: transparent;\n  }\n\n  .xl\\:hover\\:bg-black:hover {\n    background-color: #282828;\n  }\n\n  .xl\\:hover\\:bg-white:hover {\n    background-color: #fff;\n  }\n\n  .xl\\:hover\\:bg-grey-lighter:hover {\n    background-color: #f3f3f7;\n  }\n\n  .xl\\:hover\\:bg-grey-light:hover {\n    background-color: #e7e7ec;\n  }\n\n  .xl\\:hover\\:bg-grey:hover {\n    background-color: #c2c2c6;\n  }\n\n  .xl\\:hover\\:bg-purple-lighter:hover {\n    background-color: #ccc2e9;\n  }\n\n  .xl\\:hover\\:bg-purple-light:hover {\n    background-color: #87809b;\n  }\n\n  .xl\\:hover\\:bg-purple:hover {\n    background-color: #8360d6;\n  }\n\n  .xl\\:hover\\:bg-purple-bright:hover {\n    background-color: #4c29b0;\n  }\n\n  .xl\\:hover\\:bg-purple-dark:hover {\n    background-color: #453f56;\n  }\n\n  .xl\\:hover\\:bg-purple-dark-10:hover {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:hover\\:bg-purple-darker:hover {\n    background-color: #2a2538;\n  }\n\n  .xl\\:focus\\:bg-inherit:focus {\n    background-color: inherit;\n  }\n\n  .xl\\:focus\\:bg-transparent:focus {\n    background-color: transparent;\n  }\n\n  .xl\\:focus\\:bg-black:focus {\n    background-color: #282828;\n  }\n\n  .xl\\:focus\\:bg-white:focus {\n    background-color: #fff;\n  }\n\n  .xl\\:focus\\:bg-grey-lighter:focus {\n    background-color: #f3f3f7;\n  }\n\n  .xl\\:focus\\:bg-grey-light:focus {\n    background-color: #e7e7ec;\n  }\n\n  .xl\\:focus\\:bg-grey:focus {\n    background-color: #c2c2c6;\n  }\n\n  .xl\\:focus\\:bg-purple-lighter:focus {\n    background-color: #ccc2e9;\n  }\n\n  .xl\\:focus\\:bg-purple-light:focus {\n    background-color: #87809b;\n  }\n\n  .xl\\:focus\\:bg-purple:focus {\n    background-color: #8360d6;\n  }\n\n  .xl\\:focus\\:bg-purple-bright:focus {\n    background-color: #4c29b0;\n  }\n\n  .xl\\:focus\\:bg-purple-dark:focus {\n    background-color: #453f56;\n  }\n\n  .xl\\:focus\\:bg-purple-dark-10:focus {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:focus\\:bg-purple-darker:focus {\n    background-color: #2a2538;\n  }\n\n  .xl\\:bg-bottom {\n    background-position: bottom;\n  }\n\n  .xl\\:bg-center {\n    background-position: center;\n  }\n\n  .xl\\:bg-left {\n    background-position: left;\n  }\n\n  .xl\\:bg-left-bottom {\n    background-position: left bottom;\n  }\n\n  .xl\\:bg-left-top {\n    background-position: left top;\n  }\n\n  .xl\\:bg-right {\n    background-position: right;\n  }\n\n  .xl\\:bg-right-bottom {\n    background-position: right bottom;\n  }\n\n  .xl\\:bg-right-top {\n    background-position: right top;\n  }\n\n  .xl\\:bg-top {\n    background-position: top;\n  }\n\n  .xl\\:bg-repeat {\n    background-repeat: repeat;\n  }\n\n  .xl\\:bg-no-repeat {\n    background-repeat: no-repeat;\n  }\n\n  .xl\\:bg-repeat-x {\n    background-repeat: repeat-x;\n  }\n\n  .xl\\:bg-repeat-y {\n    background-repeat: repeat-y;\n  }\n\n  .xl\\:bg-auto {\n    background-size: auto;\n  }\n\n  .xl\\:bg-cover {\n    background-size: cover;\n  }\n\n  .xl\\:bg-contain {\n    background-size: contain;\n  }\n\n  .xl\\:border-inherit {\n    border-color: inherit;\n  }\n\n  .xl\\:border-transparent {\n    border-color: transparent;\n  }\n\n  .xl\\:border-black {\n    border-color: #282828;\n  }\n\n  .xl\\:border-white {\n    border-color: #fff;\n  }\n\n  .xl\\:border-grey-lighter {\n    border-color: #f3f3f7;\n  }\n\n  .xl\\:border-grey-light {\n    border-color: #e7e7ec;\n  }\n\n  .xl\\:border-grey {\n    border-color: #c2c2c6;\n  }\n\n  .xl\\:border-purple-lighter {\n    border-color: #ccc2e9;\n  }\n\n  .xl\\:border-purple-light {\n    border-color: #87809b;\n  }\n\n  .xl\\:border-purple {\n    border-color: #8360d6;\n  }\n\n  .xl\\:border-purple-bright {\n    border-color: #4c29b0;\n  }\n\n  .xl\\:border-purple-dark {\n    border-color: #453f56;\n  }\n\n  .xl\\:border-purple-dark-10 {\n    border-color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:border-purple-darker {\n    border-color: #2a2538;\n  }\n\n  .xl\\:hover\\:border-inherit:hover {\n    border-color: inherit;\n  }\n\n  .xl\\:hover\\:border-transparent:hover {\n    border-color: transparent;\n  }\n\n  .xl\\:hover\\:border-black:hover {\n    border-color: #282828;\n  }\n\n  .xl\\:hover\\:border-white:hover {\n    border-color: #fff;\n  }\n\n  .xl\\:hover\\:border-grey-lighter:hover {\n    border-color: #f3f3f7;\n  }\n\n  .xl\\:hover\\:border-grey-light:hover {\n    border-color: #e7e7ec;\n  }\n\n  .xl\\:hover\\:border-grey:hover {\n    border-color: #c2c2c6;\n  }\n\n  .xl\\:hover\\:border-purple-lighter:hover {\n    border-color: #ccc2e9;\n  }\n\n  .xl\\:hover\\:border-purple-light:hover {\n    border-color: #87809b;\n  }\n\n  .xl\\:hover\\:border-purple:hover {\n    border-color: #8360d6;\n  }\n\n  .xl\\:hover\\:border-purple-bright:hover {\n    border-color: #4c29b0;\n  }\n\n  .xl\\:hover\\:border-purple-dark:hover {\n    border-color: #453f56;\n  }\n\n  .xl\\:hover\\:border-purple-dark-10:hover {\n    border-color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:hover\\:border-purple-darker:hover {\n    border-color: #2a2538;\n  }\n\n  .xl\\:rounded-none {\n    border-radius: 0;\n  }\n\n  .xl\\:rounded-sm {\n    border-radius: 2px;\n  }\n\n  .xl\\:rounded {\n    border-radius: 4px;\n  }\n\n  .xl\\:rounded-full {\n    border-radius: 9999px;\n  }\n\n  .xl\\:rounded-t-none {\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n  }\n\n  .xl\\:rounded-r-none {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n\n  .xl\\:rounded-b-none {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  .xl\\:rounded-l-none {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  .xl\\:rounded-t-sm {\n    border-top-left-radius: 2px;\n    border-top-right-radius: 2px;\n  }\n\n  .xl\\:rounded-r-sm {\n    border-top-right-radius: 2px;\n    border-bottom-right-radius: 2px;\n  }\n\n  .xl\\:rounded-b-sm {\n    border-bottom-right-radius: 2px;\n    border-bottom-left-radius: 2px;\n  }\n\n  .xl\\:rounded-l-sm {\n    border-top-left-radius: 2px;\n    border-bottom-left-radius: 2px;\n  }\n\n  .xl\\:rounded-t {\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n  }\n\n  .xl\\:rounded-r {\n    border-top-right-radius: 4px;\n    border-bottom-right-radius: 4px;\n  }\n\n  .xl\\:rounded-b {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n\n  .xl\\:rounded-l {\n    border-top-left-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n\n  .xl\\:rounded-t-full {\n    border-top-left-radius: 9999px;\n    border-top-right-radius: 9999px;\n  }\n\n  .xl\\:rounded-r-full {\n    border-top-right-radius: 9999px;\n    border-bottom-right-radius: 9999px;\n  }\n\n  .xl\\:rounded-b-full {\n    border-bottom-right-radius: 9999px;\n    border-bottom-left-radius: 9999px;\n  }\n\n  .xl\\:rounded-l-full {\n    border-top-left-radius: 9999px;\n    border-bottom-left-radius: 9999px;\n  }\n\n  .xl\\:rounded-tl-none {\n    border-top-left-radius: 0;\n  }\n\n  .xl\\:rounded-tr-none {\n    border-top-right-radius: 0;\n  }\n\n  .xl\\:rounded-br-none {\n    border-bottom-right-radius: 0;\n  }\n\n  .xl\\:rounded-bl-none {\n    border-bottom-left-radius: 0;\n  }\n\n  .xl\\:rounded-tl-sm {\n    border-top-left-radius: 2px;\n  }\n\n  .xl\\:rounded-tr-sm {\n    border-top-right-radius: 2px;\n  }\n\n  .xl\\:rounded-br-sm {\n    border-bottom-right-radius: 2px;\n  }\n\n  .xl\\:rounded-bl-sm {\n    border-bottom-left-radius: 2px;\n  }\n\n  .xl\\:rounded-tl {\n    border-top-left-radius: 4px;\n  }\n\n  .xl\\:rounded-tr {\n    border-top-right-radius: 4px;\n  }\n\n  .xl\\:rounded-br {\n    border-bottom-right-radius: 4px;\n  }\n\n  .xl\\:rounded-bl {\n    border-bottom-left-radius: 4px;\n  }\n\n  .xl\\:rounded-tl-full {\n    border-top-left-radius: 9999px;\n  }\n\n  .xl\\:rounded-tr-full {\n    border-top-right-radius: 9999px;\n  }\n\n  .xl\\:rounded-br-full {\n    border-bottom-right-radius: 9999px;\n  }\n\n  .xl\\:rounded-bl-full {\n    border-bottom-left-radius: 9999px;\n  }\n\n  .xl\\:border-solid {\n    border-style: solid;\n  }\n\n  .xl\\:border-dashed {\n    border-style: dashed;\n  }\n\n  .xl\\:border-dotted {\n    border-style: dotted;\n  }\n\n  .xl\\:border-none {\n    border-style: none;\n  }\n\n  .xl\\:border-0 {\n    border-width: 0;\n  }\n\n  .xl\\:border-2 {\n    border-width: 2px;\n  }\n\n  .xl\\:border-4 {\n    border-width: 4px;\n  }\n\n  .xl\\:border-8 {\n    border-width: 8px;\n  }\n\n  .xl\\:border {\n    border-width: 1px;\n  }\n\n  .xl\\:border-t-0 {\n    border-top-width: 0;\n  }\n\n  .xl\\:border-r-0 {\n    border-right-width: 0;\n  }\n\n  .xl\\:border-b-0 {\n    border-bottom-width: 0;\n  }\n\n  .xl\\:border-l-0 {\n    border-left-width: 0;\n  }\n\n  .xl\\:border-t-2 {\n    border-top-width: 2px;\n  }\n\n  .xl\\:border-r-2 {\n    border-right-width: 2px;\n  }\n\n  .xl\\:border-b-2 {\n    border-bottom-width: 2px;\n  }\n\n  .xl\\:border-l-2 {\n    border-left-width: 2px;\n  }\n\n  .xl\\:border-t-4 {\n    border-top-width: 4px;\n  }\n\n  .xl\\:border-r-4 {\n    border-right-width: 4px;\n  }\n\n  .xl\\:border-b-4 {\n    border-bottom-width: 4px;\n  }\n\n  .xl\\:border-l-4 {\n    border-left-width: 4px;\n  }\n\n  .xl\\:border-t-8 {\n    border-top-width: 8px;\n  }\n\n  .xl\\:border-r-8 {\n    border-right-width: 8px;\n  }\n\n  .xl\\:border-b-8 {\n    border-bottom-width: 8px;\n  }\n\n  .xl\\:border-l-8 {\n    border-left-width: 8px;\n  }\n\n  .xl\\:border-t {\n    border-top-width: 1px;\n  }\n\n  .xl\\:border-r {\n    border-right-width: 1px;\n  }\n\n  .xl\\:border-b {\n    border-bottom-width: 1px;\n  }\n\n  .xl\\:border-l {\n    border-left-width: 1px;\n  }\n\n  .xl\\:cursor-auto {\n    cursor: auto;\n  }\n\n  .xl\\:cursor-default {\n    cursor: default;\n  }\n\n  .xl\\:cursor-pointer {\n    cursor: pointer;\n  }\n\n  .xl\\:cursor-wait {\n    cursor: wait;\n  }\n\n  .xl\\:cursor-move {\n    cursor: move;\n  }\n\n  .xl\\:cursor-not-allowed {\n    cursor: not-allowed;\n  }\n\n  .xl\\:block {\n    display: block;\n  }\n\n  .xl\\:inline-block {\n    display: inline-block;\n  }\n\n  .xl\\:inline {\n    display: inline;\n  }\n\n  .xl\\:table {\n    display: table;\n  }\n\n  .xl\\:table-row {\n    display: table-row;\n  }\n\n  .xl\\:table-cell {\n    display: table-cell;\n  }\n\n  .xl\\:hidden {\n    display: none;\n  }\n\n  .xl\\:flex {\n    display: flex;\n  }\n\n  .xl\\:inline-flex {\n    display: inline-flex;\n  }\n\n  .xl\\:flex-row {\n    flex-direction: row;\n  }\n\n  .xl\\:flex-row-reverse {\n    flex-direction: row-reverse;\n  }\n\n  .xl\\:flex-col {\n    flex-direction: column;\n  }\n\n  .xl\\:flex-col-reverse {\n    flex-direction: column-reverse;\n  }\n\n  .xl\\:flex-wrap {\n    flex-wrap: wrap;\n  }\n\n  .xl\\:flex-wrap-reverse {\n    flex-wrap: wrap-reverse;\n  }\n\n  .xl\\:flex-no-wrap {\n    flex-wrap: nowrap;\n  }\n\n  .xl\\:items-start {\n    align-items: flex-start;\n  }\n\n  .xl\\:items-end {\n    align-items: flex-end;\n  }\n\n  .xl\\:items-center {\n    align-items: center;\n  }\n\n  .xl\\:items-baseline {\n    align-items: baseline;\n  }\n\n  .xl\\:items-stretch {\n    align-items: stretch;\n  }\n\n  .xl\\:self-auto {\n    align-self: auto;\n  }\n\n  .xl\\:self-start {\n    align-self: flex-start;\n  }\n\n  .xl\\:self-end {\n    align-self: flex-end;\n  }\n\n  .xl\\:self-center {\n    align-self: center;\n  }\n\n  .xl\\:self-stretch {\n    align-self: stretch;\n  }\n\n  .xl\\:justify-start {\n    justify-content: flex-start;\n  }\n\n  .xl\\:justify-end {\n    justify-content: flex-end;\n  }\n\n  .xl\\:justify-center {\n    justify-content: center;\n  }\n\n  .xl\\:justify-between {\n    justify-content: space-between;\n  }\n\n  .xl\\:justify-around {\n    justify-content: space-around;\n  }\n\n  .xl\\:content-center {\n    align-content: center;\n  }\n\n  .xl\\:content-start {\n    align-content: flex-start;\n  }\n\n  .xl\\:content-end {\n    align-content: flex-end;\n  }\n\n  .xl\\:content-between {\n    align-content: space-between;\n  }\n\n  .xl\\:content-around {\n    align-content: space-around;\n  }\n\n  .xl\\:flex-1 {\n    flex: 1;\n  }\n\n  .xl\\:flex-auto {\n    flex: auto;\n  }\n\n  .xl\\:flex-initial {\n    flex: initial;\n  }\n\n  .xl\\:flex-none {\n    flex: none;\n  }\n\n  .xl\\:flex-grow {\n    flex-grow: 1;\n  }\n\n  .xl\\:flex-shrink {\n    flex-shrink: 1;\n  }\n\n  .xl\\:flex-no-grow {\n    flex-grow: 0;\n  }\n\n  .xl\\:flex-no-shrink {\n    flex-shrink: 0;\n  }\n\n  .xl\\:float-right {\n    float: right;\n  }\n\n  .xl\\:float-left {\n    float: left;\n  }\n\n  .xl\\:float-none {\n    float: none;\n  }\n\n  .xl\\:clearfix:after {\n    content: \"\";\n    display: table;\n    clear: both;\n  }\n\n  .xl\\:font-sans {\n    font-family: system-ui, BlinkMacSystemFont, -apple-system, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  }\n\n  .xl\\:font-serif {\n    font-family: Constantia, Lucida Bright, Lucidabright, Lucida Serif, Lucida, DejaVu Serif, Bitstream Vera Serif, Liberation Serif, Georgia, serif;\n  }\n\n  .xl\\:font-mono {\n    font-family: Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;\n  }\n\n  .xl\\:font-hairline {\n    font-weight: 100;\n  }\n\n  .xl\\:font-thin {\n    font-weight: 200;\n  }\n\n  .xl\\:font-light {\n    font-weight: 300;\n  }\n\n  .xl\\:font-normal {\n    font-weight: 400;\n  }\n\n  .xl\\:font-medium {\n    font-weight: 500;\n  }\n\n  .xl\\:font-semibold {\n    font-weight: 600;\n  }\n\n  .xl\\:font-bold {\n    font-weight: 700;\n  }\n\n  .xl\\:font-extrabold {\n    font-weight: 800;\n  }\n\n  .xl\\:font-black {\n    font-weight: 900;\n  }\n\n  .xl\\:hover\\:font-hairline:hover {\n    font-weight: 100;\n  }\n\n  .xl\\:hover\\:font-thin:hover {\n    font-weight: 200;\n  }\n\n  .xl\\:hover\\:font-light:hover {\n    font-weight: 300;\n  }\n\n  .xl\\:hover\\:font-normal:hover {\n    font-weight: 400;\n  }\n\n  .xl\\:hover\\:font-medium:hover {\n    font-weight: 500;\n  }\n\n  .xl\\:hover\\:font-semibold:hover {\n    font-weight: 600;\n  }\n\n  .xl\\:hover\\:font-bold:hover {\n    font-weight: 700;\n  }\n\n  .xl\\:hover\\:font-extrabold:hover {\n    font-weight: 800;\n  }\n\n  .xl\\:hover\\:font-black:hover {\n    font-weight: 900;\n  }\n\n  .xl\\:h-0 {\n    height: 0;\n  }\n\n  .xl\\:h-1 {\n    height: 2px;\n  }\n\n  .xl\\:h-2 {\n    height: 4px;\n  }\n\n  .xl\\:h-3 {\n    height: 8px;\n  }\n\n  .xl\\:h-4 {\n    height: 16px;\n  }\n\n  .xl\\:h-5 {\n    height: 24px;\n  }\n\n  .xl\\:h-6 {\n    height: 32px;\n  }\n\n  .xl\\:h-7 {\n    height: 36px;\n  }\n\n  .xl\\:h-8 {\n    height: 48px;\n  }\n\n  .xl\\:h-9 {\n    height: 64px;\n  }\n\n  .xl\\:h-10 {\n    height: 96px;\n  }\n\n  .xl\\:h-screen {\n    height: 100vh;\n  }\n\n  .xl\\:h-auto {\n    height: auto;\n  }\n\n  .xl\\:h-full {\n    height: 100%;\n  }\n\n  .xl\\:h-px {\n    height: 1px;\n  }\n\n  .xl\\:h-1\\/6 {\n    height: 16.666666667%;\n  }\n\n  .xl\\:leading-none {\n    line-height: 1;\n  }\n\n  .xl\\:leading-tight {\n    line-height: 1.25;\n  }\n\n  .xl\\:leading-normal {\n    line-height: 1.5;\n  }\n\n  .xl\\:leading-loose {\n    line-height: 2;\n  }\n\n  .xl\\:m-0 {\n    margin: 0;\n  }\n\n  .xl\\:m-1 {\n    margin: 2px;\n  }\n\n  .xl\\:m-2 {\n    margin: 4px;\n  }\n\n  .xl\\:m-3 {\n    margin: 8px;\n  }\n\n  .xl\\:m-4 {\n    margin: 16px;\n  }\n\n  .xl\\:m-5 {\n    margin: 24px;\n  }\n\n  .xl\\:m-6 {\n    margin: 32px;\n  }\n\n  .xl\\:m-7 {\n    margin: 36px;\n  }\n\n  .xl\\:m-8 {\n    margin: 48px;\n  }\n\n  .xl\\:m-9 {\n    margin: 64px;\n  }\n\n  .xl\\:m-10 {\n    margin: 96px;\n  }\n\n  .xl\\:m-auto {\n    margin: auto;\n  }\n\n  .xl\\:m-full {\n    margin: 100%;\n  }\n\n  .xl\\:m-px {\n    margin: 1px;\n  }\n\n  .xl\\:m-1\\/6 {\n    margin: 16.666666667%;\n  }\n\n  .xl\\:my-0 {\n    margin-top: 0;\n    margin-bottom: 0;\n  }\n\n  .xl\\:mx-0 {\n    margin-left: 0;\n    margin-right: 0;\n  }\n\n  .xl\\:my-1 {\n    margin-top: 2px;\n    margin-bottom: 2px;\n  }\n\n  .xl\\:mx-1 {\n    margin-left: 2px;\n    margin-right: 2px;\n  }\n\n  .xl\\:my-2 {\n    margin-top: 4px;\n    margin-bottom: 4px;\n  }\n\n  .xl\\:mx-2 {\n    margin-left: 4px;\n    margin-right: 4px;\n  }\n\n  .xl\\:my-3 {\n    margin-top: 8px;\n    margin-bottom: 8px;\n  }\n\n  .xl\\:mx-3 {\n    margin-left: 8px;\n    margin-right: 8px;\n  }\n\n  .xl\\:my-4 {\n    margin-top: 16px;\n    margin-bottom: 16px;\n  }\n\n  .xl\\:mx-4 {\n    margin-left: 16px;\n    margin-right: 16px;\n  }\n\n  .xl\\:my-5 {\n    margin-top: 24px;\n    margin-bottom: 24px;\n  }\n\n  .xl\\:mx-5 {\n    margin-left: 24px;\n    margin-right: 24px;\n  }\n\n  .xl\\:my-6 {\n    margin-top: 32px;\n    margin-bottom: 32px;\n  }\n\n  .xl\\:mx-6 {\n    margin-left: 32px;\n    margin-right: 32px;\n  }\n\n  .xl\\:my-7 {\n    margin-top: 36px;\n    margin-bottom: 36px;\n  }\n\n  .xl\\:mx-7 {\n    margin-left: 36px;\n    margin-right: 36px;\n  }\n\n  .xl\\:my-8 {\n    margin-top: 48px;\n    margin-bottom: 48px;\n  }\n\n  .xl\\:mx-8 {\n    margin-left: 48px;\n    margin-right: 48px;\n  }\n\n  .xl\\:my-9 {\n    margin-top: 64px;\n    margin-bottom: 64px;\n  }\n\n  .xl\\:mx-9 {\n    margin-left: 64px;\n    margin-right: 64px;\n  }\n\n  .xl\\:my-10 {\n    margin-top: 96px;\n    margin-bottom: 96px;\n  }\n\n  .xl\\:mx-10 {\n    margin-left: 96px;\n    margin-right: 96px;\n  }\n\n  .xl\\:my-auto {\n    margin-top: auto;\n    margin-bottom: auto;\n  }\n\n  .xl\\:mx-auto {\n    margin-left: auto;\n    margin-right: auto;\n  }\n\n  .xl\\:my-full {\n    margin-top: 100%;\n    margin-bottom: 100%;\n  }\n\n  .xl\\:mx-full {\n    margin-left: 100%;\n    margin-right: 100%;\n  }\n\n  .xl\\:my-px {\n    margin-top: 1px;\n    margin-bottom: 1px;\n  }\n\n  .xl\\:mx-px {\n    margin-left: 1px;\n    margin-right: 1px;\n  }\n\n  .xl\\:my-1\\/6 {\n    margin-top: 16.666666667%;\n    margin-bottom: 16.666666667%;\n  }\n\n  .xl\\:mx-1\\/6 {\n    margin-left: 16.666666667%;\n    margin-right: 16.666666667%;\n  }\n\n  .xl\\:mt-0 {\n    margin-top: 0;\n  }\n\n  .xl\\:mr-0 {\n    margin-right: 0;\n  }\n\n  .xl\\:mb-0 {\n    margin-bottom: 0;\n  }\n\n  .xl\\:ml-0 {\n    margin-left: 0;\n  }\n\n  .xl\\:mt-1 {\n    margin-top: 2px;\n  }\n\n  .xl\\:mr-1 {\n    margin-right: 2px;\n  }\n\n  .xl\\:mb-1 {\n    margin-bottom: 2px;\n  }\n\n  .xl\\:ml-1 {\n    margin-left: 2px;\n  }\n\n  .xl\\:mt-2 {\n    margin-top: 4px;\n  }\n\n  .xl\\:mr-2 {\n    margin-right: 4px;\n  }\n\n  .xl\\:mb-2 {\n    margin-bottom: 4px;\n  }\n\n  .xl\\:ml-2 {\n    margin-left: 4px;\n  }\n\n  .xl\\:mt-3 {\n    margin-top: 8px;\n  }\n\n  .xl\\:mr-3 {\n    margin-right: 8px;\n  }\n\n  .xl\\:mb-3 {\n    margin-bottom: 8px;\n  }\n\n  .xl\\:ml-3 {\n    margin-left: 8px;\n  }\n\n  .xl\\:mt-4 {\n    margin-top: 16px;\n  }\n\n  .xl\\:mr-4 {\n    margin-right: 16px;\n  }\n\n  .xl\\:mb-4 {\n    margin-bottom: 16px;\n  }\n\n  .xl\\:ml-4 {\n    margin-left: 16px;\n  }\n\n  .xl\\:mt-5 {\n    margin-top: 24px;\n  }\n\n  .xl\\:mr-5 {\n    margin-right: 24px;\n  }\n\n  .xl\\:mb-5 {\n    margin-bottom: 24px;\n  }\n\n  .xl\\:ml-5 {\n    margin-left: 24px;\n  }\n\n  .xl\\:mt-6 {\n    margin-top: 32px;\n  }\n\n  .xl\\:mr-6 {\n    margin-right: 32px;\n  }\n\n  .xl\\:mb-6 {\n    margin-bottom: 32px;\n  }\n\n  .xl\\:ml-6 {\n    margin-left: 32px;\n  }\n\n  .xl\\:mt-7 {\n    margin-top: 36px;\n  }\n\n  .xl\\:mr-7 {\n    margin-right: 36px;\n  }\n\n  .xl\\:mb-7 {\n    margin-bottom: 36px;\n  }\n\n  .xl\\:ml-7 {\n    margin-left: 36px;\n  }\n\n  .xl\\:mt-8 {\n    margin-top: 48px;\n  }\n\n  .xl\\:mr-8 {\n    margin-right: 48px;\n  }\n\n  .xl\\:mb-8 {\n    margin-bottom: 48px;\n  }\n\n  .xl\\:ml-8 {\n    margin-left: 48px;\n  }\n\n  .xl\\:mt-9 {\n    margin-top: 64px;\n  }\n\n  .xl\\:mr-9 {\n    margin-right: 64px;\n  }\n\n  .xl\\:mb-9 {\n    margin-bottom: 64px;\n  }\n\n  .xl\\:ml-9 {\n    margin-left: 64px;\n  }\n\n  .xl\\:mt-10 {\n    margin-top: 96px;\n  }\n\n  .xl\\:mr-10 {\n    margin-right: 96px;\n  }\n\n  .xl\\:mb-10 {\n    margin-bottom: 96px;\n  }\n\n  .xl\\:ml-10 {\n    margin-left: 96px;\n  }\n\n  .xl\\:mt-auto {\n    margin-top: auto;\n  }\n\n  .xl\\:mr-auto {\n    margin-right: auto;\n  }\n\n  .xl\\:mb-auto {\n    margin-bottom: auto;\n  }\n\n  .xl\\:ml-auto {\n    margin-left: auto;\n  }\n\n  .xl\\:mt-full {\n    margin-top: 100%;\n  }\n\n  .xl\\:mr-full {\n    margin-right: 100%;\n  }\n\n  .xl\\:mb-full {\n    margin-bottom: 100%;\n  }\n\n  .xl\\:ml-full {\n    margin-left: 100%;\n  }\n\n  .xl\\:mt-px {\n    margin-top: 1px;\n  }\n\n  .xl\\:mr-px {\n    margin-right: 1px;\n  }\n\n  .xl\\:mb-px {\n    margin-bottom: 1px;\n  }\n\n  .xl\\:ml-px {\n    margin-left: 1px;\n  }\n\n  .xl\\:mt-1\\/6 {\n    margin-top: 16.666666667%;\n  }\n\n  .xl\\:mr-1\\/6 {\n    margin-right: 16.666666667%;\n  }\n\n  .xl\\:mb-1\\/6 {\n    margin-bottom: 16.666666667%;\n  }\n\n  .xl\\:ml-1\\/6 {\n    margin-left: 16.666666667%;\n  }\n\n  .xl\\:max-h-0 {\n    max-height: 0;\n  }\n\n  .xl\\:max-h-1 {\n    max-height: 2px;\n  }\n\n  .xl\\:max-h-2 {\n    max-height: 4px;\n  }\n\n  .xl\\:max-h-3 {\n    max-height: 8px;\n  }\n\n  .xl\\:max-h-4 {\n    max-height: 16px;\n  }\n\n  .xl\\:max-h-5 {\n    max-height: 24px;\n  }\n\n  .xl\\:max-h-6 {\n    max-height: 32px;\n  }\n\n  .xl\\:max-h-7 {\n    max-height: 36px;\n  }\n\n  .xl\\:max-h-8 {\n    max-height: 48px;\n  }\n\n  .xl\\:max-h-9 {\n    max-height: 64px;\n  }\n\n  .xl\\:max-h-10 {\n    max-height: 96px;\n  }\n\n  .xl\\:max-h-screen {\n    max-height: 100vh;\n  }\n\n  .xl\\:max-h-auto {\n    max-height: auto;\n  }\n\n  .xl\\:max-h-full {\n    max-height: 100%;\n  }\n\n  .xl\\:max-h-px {\n    max-height: 1px;\n  }\n\n  .xl\\:max-h-1\\/6 {\n    max-height: 16.666666667%;\n  }\n\n  .xl\\:max-w-0 {\n    max-width: 0;\n  }\n\n  .xl\\:max-w-1 {\n    max-width: 2px;\n  }\n\n  .xl\\:max-w-2 {\n    max-width: 4px;\n  }\n\n  .xl\\:max-w-3 {\n    max-width: 8px;\n  }\n\n  .xl\\:max-w-4 {\n    max-width: 16px;\n  }\n\n  .xl\\:max-w-5 {\n    max-width: 24px;\n  }\n\n  .xl\\:max-w-6 {\n    max-width: 32px;\n  }\n\n  .xl\\:max-w-7 {\n    max-width: 36px;\n  }\n\n  .xl\\:max-w-8 {\n    max-width: 48px;\n  }\n\n  .xl\\:max-w-9 {\n    max-width: 64px;\n  }\n\n  .xl\\:max-w-10 {\n    max-width: 96px;\n  }\n\n  .xl\\:max-w-auto {\n    max-width: auto;\n  }\n\n  .xl\\:max-w-full {\n    max-width: 100%;\n  }\n\n  .xl\\:max-w-px {\n    max-width: 1px;\n  }\n\n  .xl\\:max-w-1\\/6 {\n    max-width: 16.666666667%;\n  }\n\n  .xl\\:min-h-0 {\n    min-height: 0;\n  }\n\n  .xl\\:min-h-1 {\n    min-height: 2px;\n  }\n\n  .xl\\:min-h-2 {\n    min-height: 4px;\n  }\n\n  .xl\\:min-h-3 {\n    min-height: 8px;\n  }\n\n  .xl\\:min-h-4 {\n    min-height: 16px;\n  }\n\n  .xl\\:min-h-5 {\n    min-height: 24px;\n  }\n\n  .xl\\:min-h-6 {\n    min-height: 32px;\n  }\n\n  .xl\\:min-h-7 {\n    min-height: 36px;\n  }\n\n  .xl\\:min-h-8 {\n    min-height: 48px;\n  }\n\n  .xl\\:min-h-9 {\n    min-height: 64px;\n  }\n\n  .xl\\:min-h-10 {\n    min-height: 96px;\n  }\n\n  .xl\\:min-h-screen {\n    min-height: 100vh;\n  }\n\n  .xl\\:min-h-auto {\n    min-height: auto;\n  }\n\n  .xl\\:min-h-full {\n    min-height: 100%;\n  }\n\n  .xl\\:min-h-px {\n    min-height: 1px;\n  }\n\n  .xl\\:min-h-1\\/6 {\n    min-height: 16.666666667%;\n  }\n\n  .xl\\:min-w-0 {\n    min-width: 0;\n  }\n\n  .xl\\:min-w-1 {\n    min-width: 2px;\n  }\n\n  .xl\\:min-w-2 {\n    min-width: 4px;\n  }\n\n  .xl\\:min-w-3 {\n    min-width: 8px;\n  }\n\n  .xl\\:min-w-4 {\n    min-width: 16px;\n  }\n\n  .xl\\:min-w-5 {\n    min-width: 24px;\n  }\n\n  .xl\\:min-w-6 {\n    min-width: 32px;\n  }\n\n  .xl\\:min-w-7 {\n    min-width: 36px;\n  }\n\n  .xl\\:min-w-8 {\n    min-width: 48px;\n  }\n\n  .xl\\:min-w-9 {\n    min-width: 64px;\n  }\n\n  .xl\\:min-w-10 {\n    min-width: 96px;\n  }\n\n  .xl\\:min-w-auto {\n    min-width: auto;\n  }\n\n  .xl\\:min-w-full {\n    min-width: 100%;\n  }\n\n  .xl\\:min-w-px {\n    min-width: 1px;\n  }\n\n  .xl\\:min-w-1\\/6 {\n    min-width: 16.666666667%;\n  }\n\n  .xl\\:-m-0 {\n    margin: 0;\n  }\n\n  .xl\\:-m-1 {\n    margin: -2px;\n  }\n\n  .xl\\:-m-2 {\n    margin: -4px;\n  }\n\n  .xl\\:-m-3 {\n    margin: -8px;\n  }\n\n  .xl\\:-m-4 {\n    margin: -16px;\n  }\n\n  .xl\\:-m-5 {\n    margin: -24px;\n  }\n\n  .xl\\:-m-6 {\n    margin: -32px;\n  }\n\n  .xl\\:-m-7 {\n    margin: -36px;\n  }\n\n  .xl\\:-m-8 {\n    margin: -48px;\n  }\n\n  .xl\\:-m-9 {\n    margin: -64px;\n  }\n\n  .xl\\:-m-10 {\n    margin: -96px;\n  }\n\n  .xl\\:-m-auto {\n    margin: -auto;\n  }\n\n  .xl\\:-m-full {\n    margin: -100%;\n  }\n\n  .xl\\:-m-px {\n    margin: -1px;\n  }\n\n  .xl\\:-m-1\\/6 {\n    margin: -16.666666667%;\n  }\n\n  .xl\\:-my-0 {\n    margin-top: 0;\n    margin-bottom: 0;\n  }\n\n  .xl\\:-mx-0 {\n    margin-left: 0;\n    margin-right: 0;\n  }\n\n  .xl\\:-my-1 {\n    margin-top: -2px;\n    margin-bottom: -2px;\n  }\n\n  .xl\\:-mx-1 {\n    margin-left: -2px;\n    margin-right: -2px;\n  }\n\n  .xl\\:-my-2 {\n    margin-top: -4px;\n    margin-bottom: -4px;\n  }\n\n  .xl\\:-mx-2 {\n    margin-left: -4px;\n    margin-right: -4px;\n  }\n\n  .xl\\:-my-3 {\n    margin-top: -8px;\n    margin-bottom: -8px;\n  }\n\n  .xl\\:-mx-3 {\n    margin-left: -8px;\n    margin-right: -8px;\n  }\n\n  .xl\\:-my-4 {\n    margin-top: -16px;\n    margin-bottom: -16px;\n  }\n\n  .xl\\:-mx-4 {\n    margin-left: -16px;\n    margin-right: -16px;\n  }\n\n  .xl\\:-my-5 {\n    margin-top: -24px;\n    margin-bottom: -24px;\n  }\n\n  .xl\\:-mx-5 {\n    margin-left: -24px;\n    margin-right: -24px;\n  }\n\n  .xl\\:-my-6 {\n    margin-top: -32px;\n    margin-bottom: -32px;\n  }\n\n  .xl\\:-mx-6 {\n    margin-left: -32px;\n    margin-right: -32px;\n  }\n\n  .xl\\:-my-7 {\n    margin-top: -36px;\n    margin-bottom: -36px;\n  }\n\n  .xl\\:-mx-7 {\n    margin-left: -36px;\n    margin-right: -36px;\n  }\n\n  .xl\\:-my-8 {\n    margin-top: -48px;\n    margin-bottom: -48px;\n  }\n\n  .xl\\:-mx-8 {\n    margin-left: -48px;\n    margin-right: -48px;\n  }\n\n  .xl\\:-my-9 {\n    margin-top: -64px;\n    margin-bottom: -64px;\n  }\n\n  .xl\\:-mx-9 {\n    margin-left: -64px;\n    margin-right: -64px;\n  }\n\n  .xl\\:-my-10 {\n    margin-top: -96px;\n    margin-bottom: -96px;\n  }\n\n  .xl\\:-mx-10 {\n    margin-left: -96px;\n    margin-right: -96px;\n  }\n\n  .xl\\:-my-auto {\n    margin-top: -auto;\n    margin-bottom: -auto;\n  }\n\n  .xl\\:-mx-auto {\n    margin-left: -auto;\n    margin-right: -auto;\n  }\n\n  .xl\\:-my-full {\n    margin-top: -100%;\n    margin-bottom: -100%;\n  }\n\n  .xl\\:-mx-full {\n    margin-left: -100%;\n    margin-right: -100%;\n  }\n\n  .xl\\:-my-px {\n    margin-top: -1px;\n    margin-bottom: -1px;\n  }\n\n  .xl\\:-mx-px {\n    margin-left: -1px;\n    margin-right: -1px;\n  }\n\n  .xl\\:-my-1\\/6 {\n    margin-top: -16.666666667%;\n    margin-bottom: -16.666666667%;\n  }\n\n  .xl\\:-mx-1\\/6 {\n    margin-left: -16.666666667%;\n    margin-right: -16.666666667%;\n  }\n\n  .xl\\:-mt-0 {\n    margin-top: 0;\n  }\n\n  .xl\\:-mr-0 {\n    margin-right: 0;\n  }\n\n  .xl\\:-mb-0 {\n    margin-bottom: 0;\n  }\n\n  .xl\\:-ml-0 {\n    margin-left: 0;\n  }\n\n  .xl\\:-mt-1 {\n    margin-top: -2px;\n  }\n\n  .xl\\:-mr-1 {\n    margin-right: -2px;\n  }\n\n  .xl\\:-mb-1 {\n    margin-bottom: -2px;\n  }\n\n  .xl\\:-ml-1 {\n    margin-left: -2px;\n  }\n\n  .xl\\:-mt-2 {\n    margin-top: -4px;\n  }\n\n  .xl\\:-mr-2 {\n    margin-right: -4px;\n  }\n\n  .xl\\:-mb-2 {\n    margin-bottom: -4px;\n  }\n\n  .xl\\:-ml-2 {\n    margin-left: -4px;\n  }\n\n  .xl\\:-mt-3 {\n    margin-top: -8px;\n  }\n\n  .xl\\:-mr-3 {\n    margin-right: -8px;\n  }\n\n  .xl\\:-mb-3 {\n    margin-bottom: -8px;\n  }\n\n  .xl\\:-ml-3 {\n    margin-left: -8px;\n  }\n\n  .xl\\:-mt-4 {\n    margin-top: -16px;\n  }\n\n  .xl\\:-mr-4 {\n    margin-right: -16px;\n  }\n\n  .xl\\:-mb-4 {\n    margin-bottom: -16px;\n  }\n\n  .xl\\:-ml-4 {\n    margin-left: -16px;\n  }\n\n  .xl\\:-mt-5 {\n    margin-top: -24px;\n  }\n\n  .xl\\:-mr-5 {\n    margin-right: -24px;\n  }\n\n  .xl\\:-mb-5 {\n    margin-bottom: -24px;\n  }\n\n  .xl\\:-ml-5 {\n    margin-left: -24px;\n  }\n\n  .xl\\:-mt-6 {\n    margin-top: -32px;\n  }\n\n  .xl\\:-mr-6 {\n    margin-right: -32px;\n  }\n\n  .xl\\:-mb-6 {\n    margin-bottom: -32px;\n  }\n\n  .xl\\:-ml-6 {\n    margin-left: -32px;\n  }\n\n  .xl\\:-mt-7 {\n    margin-top: -36px;\n  }\n\n  .xl\\:-mr-7 {\n    margin-right: -36px;\n  }\n\n  .xl\\:-mb-7 {\n    margin-bottom: -36px;\n  }\n\n  .xl\\:-ml-7 {\n    margin-left: -36px;\n  }\n\n  .xl\\:-mt-8 {\n    margin-top: -48px;\n  }\n\n  .xl\\:-mr-8 {\n    margin-right: -48px;\n  }\n\n  .xl\\:-mb-8 {\n    margin-bottom: -48px;\n  }\n\n  .xl\\:-ml-8 {\n    margin-left: -48px;\n  }\n\n  .xl\\:-mt-9 {\n    margin-top: -64px;\n  }\n\n  .xl\\:-mr-9 {\n    margin-right: -64px;\n  }\n\n  .xl\\:-mb-9 {\n    margin-bottom: -64px;\n  }\n\n  .xl\\:-ml-9 {\n    margin-left: -64px;\n  }\n\n  .xl\\:-mt-10 {\n    margin-top: -96px;\n  }\n\n  .xl\\:-mr-10 {\n    margin-right: -96px;\n  }\n\n  .xl\\:-mb-10 {\n    margin-bottom: -96px;\n  }\n\n  .xl\\:-ml-10 {\n    margin-left: -96px;\n  }\n\n  .xl\\:-mt-auto {\n    margin-top: -auto;\n  }\n\n  .xl\\:-mr-auto {\n    margin-right: -auto;\n  }\n\n  .xl\\:-mb-auto {\n    margin-bottom: -auto;\n  }\n\n  .xl\\:-ml-auto {\n    margin-left: -auto;\n  }\n\n  .xl\\:-mt-full {\n    margin-top: -100%;\n  }\n\n  .xl\\:-mr-full {\n    margin-right: -100%;\n  }\n\n  .xl\\:-mb-full {\n    margin-bottom: -100%;\n  }\n\n  .xl\\:-ml-full {\n    margin-left: -100%;\n  }\n\n  .xl\\:-mt-px {\n    margin-top: -1px;\n  }\n\n  .xl\\:-mr-px {\n    margin-right: -1px;\n  }\n\n  .xl\\:-mb-px {\n    margin-bottom: -1px;\n  }\n\n  .xl\\:-ml-px {\n    margin-left: -1px;\n  }\n\n  .xl\\:-mt-1\\/6 {\n    margin-top: -16.666666667%;\n  }\n\n  .xl\\:-mr-1\\/6 {\n    margin-right: -16.666666667%;\n  }\n\n  .xl\\:-mb-1\\/6 {\n    margin-bottom: -16.666666667%;\n  }\n\n  .xl\\:-ml-1\\/6 {\n    margin-left: -16.666666667%;\n  }\n\n  .xl\\:opacity-0 {\n    opacity: 0;\n  }\n\n  .xl\\:opacity-25 {\n    opacity: .25;\n  }\n\n  .xl\\:opacity-50 {\n    opacity: .5;\n  }\n\n  .xl\\:opacity-75 {\n    opacity: .75;\n  }\n\n  .xl\\:opacity-100 {\n    opacity: 1;\n  }\n\n  .xl\\:overflow-auto {\n    overflow: auto;\n  }\n\n  .xl\\:overflow-hidden {\n    overflow: hidden;\n  }\n\n  .xl\\:overflow-visible {\n    overflow: visible;\n  }\n\n  .xl\\:overflow-scroll {\n    overflow: scroll;\n  }\n\n  .xl\\:overflow-x-auto {\n    overflow-x: auto;\n  }\n\n  .xl\\:overflow-y-auto {\n    overflow-y: auto;\n  }\n\n  .xl\\:overflow-x-hidden {\n    overflow-x: hidden;\n  }\n\n  .xl\\:overflow-y-hidden {\n    overflow-y: hidden;\n  }\n\n  .xl\\:overflow-x-visible {\n    overflow-x: visible;\n  }\n\n  .xl\\:overflow-y-visible {\n    overflow-y: visible;\n  }\n\n  .xl\\:overflow-x-scroll {\n    overflow-x: scroll;\n  }\n\n  .xl\\:overflow-y-scroll {\n    overflow-y: scroll;\n  }\n\n  .xl\\:scrolling-touch {\n    -webkit-overflow-scrolling: touch;\n  }\n\n  .xl\\:scrolling-auto {\n    -webkit-overflow-scrolling: auto;\n  }\n\n  .xl\\:p-0 {\n    padding: 0;\n  }\n\n  .xl\\:p-1 {\n    padding: 2px;\n  }\n\n  .xl\\:p-2 {\n    padding: 4px;\n  }\n\n  .xl\\:p-3 {\n    padding: 8px;\n  }\n\n  .xl\\:p-4 {\n    padding: 16px;\n  }\n\n  .xl\\:p-5 {\n    padding: 24px;\n  }\n\n  .xl\\:p-6 {\n    padding: 32px;\n  }\n\n  .xl\\:p-7 {\n    padding: 36px;\n  }\n\n  .xl\\:p-8 {\n    padding: 48px;\n  }\n\n  .xl\\:p-9 {\n    padding: 64px;\n  }\n\n  .xl\\:p-10 {\n    padding: 96px;\n  }\n\n  .xl\\:p-auto {\n    padding: auto;\n  }\n\n  .xl\\:p-full {\n    padding: 100%;\n  }\n\n  .xl\\:p-px {\n    padding: 1px;\n  }\n\n  .xl\\:p-1\\/6 {\n    padding: 16.666666667%;\n  }\n\n  .xl\\:py-0 {\n    padding-top: 0;\n    padding-bottom: 0;\n  }\n\n  .xl\\:px-0 {\n    padding-left: 0;\n    padding-right: 0;\n  }\n\n  .xl\\:py-1 {\n    padding-top: 2px;\n    padding-bottom: 2px;\n  }\n\n  .xl\\:px-1 {\n    padding-left: 2px;\n    padding-right: 2px;\n  }\n\n  .xl\\:py-2 {\n    padding-top: 4px;\n    padding-bottom: 4px;\n  }\n\n  .xl\\:px-2 {\n    padding-left: 4px;\n    padding-right: 4px;\n  }\n\n  .xl\\:py-3 {\n    padding-top: 8px;\n    padding-bottom: 8px;\n  }\n\n  .xl\\:px-3 {\n    padding-left: 8px;\n    padding-right: 8px;\n  }\n\n  .xl\\:py-4 {\n    padding-top: 16px;\n    padding-bottom: 16px;\n  }\n\n  .xl\\:px-4 {\n    padding-left: 16px;\n    padding-right: 16px;\n  }\n\n  .xl\\:py-5 {\n    padding-top: 24px;\n    padding-bottom: 24px;\n  }\n\n  .xl\\:px-5 {\n    padding-left: 24px;\n    padding-right: 24px;\n  }\n\n  .xl\\:py-6 {\n    padding-top: 32px;\n    padding-bottom: 32px;\n  }\n\n  .xl\\:px-6 {\n    padding-left: 32px;\n    padding-right: 32px;\n  }\n\n  .xl\\:py-7 {\n    padding-top: 36px;\n    padding-bottom: 36px;\n  }\n\n  .xl\\:px-7 {\n    padding-left: 36px;\n    padding-right: 36px;\n  }\n\n  .xl\\:py-8 {\n    padding-top: 48px;\n    padding-bottom: 48px;\n  }\n\n  .xl\\:px-8 {\n    padding-left: 48px;\n    padding-right: 48px;\n  }\n\n  .xl\\:py-9 {\n    padding-top: 64px;\n    padding-bottom: 64px;\n  }\n\n  .xl\\:px-9 {\n    padding-left: 64px;\n    padding-right: 64px;\n  }\n\n  .xl\\:py-10 {\n    padding-top: 96px;\n    padding-bottom: 96px;\n  }\n\n  .xl\\:px-10 {\n    padding-left: 96px;\n    padding-right: 96px;\n  }\n\n  .xl\\:py-auto {\n    padding-top: auto;\n    padding-bottom: auto;\n  }\n\n  .xl\\:px-auto {\n    padding-left: auto;\n    padding-right: auto;\n  }\n\n  .xl\\:py-full {\n    padding-top: 100%;\n    padding-bottom: 100%;\n  }\n\n  .xl\\:px-full {\n    padding-left: 100%;\n    padding-right: 100%;\n  }\n\n  .xl\\:py-px {\n    padding-top: 1px;\n    padding-bottom: 1px;\n  }\n\n  .xl\\:px-px {\n    padding-left: 1px;\n    padding-right: 1px;\n  }\n\n  .xl\\:py-1\\/6 {\n    padding-top: 16.666666667%;\n    padding-bottom: 16.666666667%;\n  }\n\n  .xl\\:px-1\\/6 {\n    padding-left: 16.666666667%;\n    padding-right: 16.666666667%;\n  }\n\n  .xl\\:pt-0 {\n    padding-top: 0;\n  }\n\n  .xl\\:pr-0 {\n    padding-right: 0;\n  }\n\n  .xl\\:pb-0 {\n    padding-bottom: 0;\n  }\n\n  .xl\\:pl-0 {\n    padding-left: 0;\n  }\n\n  .xl\\:pt-1 {\n    padding-top: 2px;\n  }\n\n  .xl\\:pr-1 {\n    padding-right: 2px;\n  }\n\n  .xl\\:pb-1 {\n    padding-bottom: 2px;\n  }\n\n  .xl\\:pl-1 {\n    padding-left: 2px;\n  }\n\n  .xl\\:pt-2 {\n    padding-top: 4px;\n  }\n\n  .xl\\:pr-2 {\n    padding-right: 4px;\n  }\n\n  .xl\\:pb-2 {\n    padding-bottom: 4px;\n  }\n\n  .xl\\:pl-2 {\n    padding-left: 4px;\n  }\n\n  .xl\\:pt-3 {\n    padding-top: 8px;\n  }\n\n  .xl\\:pr-3 {\n    padding-right: 8px;\n  }\n\n  .xl\\:pb-3 {\n    padding-bottom: 8px;\n  }\n\n  .xl\\:pl-3 {\n    padding-left: 8px;\n  }\n\n  .xl\\:pt-4 {\n    padding-top: 16px;\n  }\n\n  .xl\\:pr-4 {\n    padding-right: 16px;\n  }\n\n  .xl\\:pb-4 {\n    padding-bottom: 16px;\n  }\n\n  .xl\\:pl-4 {\n    padding-left: 16px;\n  }\n\n  .xl\\:pt-5 {\n    padding-top: 24px;\n  }\n\n  .xl\\:pr-5 {\n    padding-right: 24px;\n  }\n\n  .xl\\:pb-5 {\n    padding-bottom: 24px;\n  }\n\n  .xl\\:pl-5 {\n    padding-left: 24px;\n  }\n\n  .xl\\:pt-6 {\n    padding-top: 32px;\n  }\n\n  .xl\\:pr-6 {\n    padding-right: 32px;\n  }\n\n  .xl\\:pb-6 {\n    padding-bottom: 32px;\n  }\n\n  .xl\\:pl-6 {\n    padding-left: 32px;\n  }\n\n  .xl\\:pt-7 {\n    padding-top: 36px;\n  }\n\n  .xl\\:pr-7 {\n    padding-right: 36px;\n  }\n\n  .xl\\:pb-7 {\n    padding-bottom: 36px;\n  }\n\n  .xl\\:pl-7 {\n    padding-left: 36px;\n  }\n\n  .xl\\:pt-8 {\n    padding-top: 48px;\n  }\n\n  .xl\\:pr-8 {\n    padding-right: 48px;\n  }\n\n  .xl\\:pb-8 {\n    padding-bottom: 48px;\n  }\n\n  .xl\\:pl-8 {\n    padding-left: 48px;\n  }\n\n  .xl\\:pt-9 {\n    padding-top: 64px;\n  }\n\n  .xl\\:pr-9 {\n    padding-right: 64px;\n  }\n\n  .xl\\:pb-9 {\n    padding-bottom: 64px;\n  }\n\n  .xl\\:pl-9 {\n    padding-left: 64px;\n  }\n\n  .xl\\:pt-10 {\n    padding-top: 96px;\n  }\n\n  .xl\\:pr-10 {\n    padding-right: 96px;\n  }\n\n  .xl\\:pb-10 {\n    padding-bottom: 96px;\n  }\n\n  .xl\\:pl-10 {\n    padding-left: 96px;\n  }\n\n  .xl\\:pt-auto {\n    padding-top: auto;\n  }\n\n  .xl\\:pr-auto {\n    padding-right: auto;\n  }\n\n  .xl\\:pb-auto {\n    padding-bottom: auto;\n  }\n\n  .xl\\:pl-auto {\n    padding-left: auto;\n  }\n\n  .xl\\:pt-full {\n    padding-top: 100%;\n  }\n\n  .xl\\:pr-full {\n    padding-right: 100%;\n  }\n\n  .xl\\:pb-full {\n    padding-bottom: 100%;\n  }\n\n  .xl\\:pl-full {\n    padding-left: 100%;\n  }\n\n  .xl\\:pt-px {\n    padding-top: 1px;\n  }\n\n  .xl\\:pr-px {\n    padding-right: 1px;\n  }\n\n  .xl\\:pb-px {\n    padding-bottom: 1px;\n  }\n\n  .xl\\:pl-px {\n    padding-left: 1px;\n  }\n\n  .xl\\:pt-1\\/6 {\n    padding-top: 16.666666667%;\n  }\n\n  .xl\\:pr-1\\/6 {\n    padding-right: 16.666666667%;\n  }\n\n  .xl\\:pb-1\\/6 {\n    padding-bottom: 16.666666667%;\n  }\n\n  .xl\\:pl-1\\/6 {\n    padding-left: 16.666666667%;\n  }\n\n  .xl\\:pointer-events-none {\n    pointer-events: none;\n  }\n\n  .xl\\:pointer-events-auto {\n    pointer-events: auto;\n  }\n\n  .xl\\:static {\n    position: static;\n  }\n\n  .xl\\:fixed {\n    position: fixed;\n  }\n\n  .xl\\:absolute {\n    position: absolute;\n  }\n\n  .xl\\:relative {\n    position: relative;\n  }\n\n  .xl\\:sticky {\n    position: sticky;\n  }\n\n  .xl\\:pin-none {\n    top: auto;\n    right: auto;\n    bottom: auto;\n    left: auto;\n  }\n\n  .xl\\:pin {\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n\n  .xl\\:pin-y {\n    top: 0;\n    bottom: 0;\n  }\n\n  .xl\\:pin-x {\n    right: 0;\n    left: 0;\n  }\n\n  .xl\\:pin-t {\n    top: 0;\n  }\n\n  .xl\\:pin-r {\n    right: 0;\n  }\n\n  .xl\\:pin-b {\n    bottom: 0;\n  }\n\n  .xl\\:pin-l {\n    left: 0;\n  }\n\n  .xl\\:resize-none {\n    resize: none;\n  }\n\n  .xl\\:resize-y {\n    resize: vertical;\n  }\n\n  .xl\\:resize-x {\n    resize: horizontal;\n  }\n\n  .xl\\:resize {\n    resize: both;\n  }\n\n  .xl\\:shadow {\n    box-shadow: 0 2px 4px 0 rgba(0, 0, 0, .1);\n  }\n\n  .xl\\:shadow-md {\n    box-shadow:  0 8px 20px 0 rgba(0, 0, 0, .42);\n  }\n\n  .xl\\:shadow-none {\n    box-shadow: none;\n  }\n\n  .xl\\:table-auto {\n    table-layout: auto;\n  }\n\n  .xl\\:table-fixed {\n    table-layout: fixed;\n  }\n\n  .xl\\:text-left {\n    text-align: left;\n  }\n\n  .xl\\:text-center {\n    text-align: center;\n  }\n\n  .xl\\:text-right {\n    text-align: right;\n  }\n\n  .xl\\:text-justify {\n    text-align: justify;\n  }\n\n  .xl\\:text-inherit {\n    color: inherit;\n  }\n\n  .xl\\:text-transparent {\n    color: transparent;\n  }\n\n  .xl\\:text-black {\n    color: #282828;\n  }\n\n  .xl\\:text-white {\n    color: #fff;\n  }\n\n  .xl\\:text-grey-lighter {\n    color: #f3f3f7;\n  }\n\n  .xl\\:text-grey-light {\n    color: #e7e7ec;\n  }\n\n  .xl\\:text-grey {\n    color: #c2c2c6;\n  }\n\n  .xl\\:text-purple-lighter {\n    color: #ccc2e9;\n  }\n\n  .xl\\:text-purple-light {\n    color: #87809b;\n  }\n\n  .xl\\:text-purple {\n    color: #8360d6;\n  }\n\n  .xl\\:text-purple-bright {\n    color: #4c29b0;\n  }\n\n  .xl\\:text-purple-dark {\n    color: #453f56;\n  }\n\n  .xl\\:text-purple-dark-10 {\n    color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:text-purple-darker {\n    color: #2a2538;\n  }\n\n  .xl\\:hover\\:text-inherit:hover {\n    color: inherit;\n  }\n\n  .xl\\:hover\\:text-transparent:hover {\n    color: transparent;\n  }\n\n  .xl\\:hover\\:text-black:hover {\n    color: #282828;\n  }\n\n  .xl\\:hover\\:text-white:hover {\n    color: #fff;\n  }\n\n  .xl\\:hover\\:text-grey-lighter:hover {\n    color: #f3f3f7;\n  }\n\n  .xl\\:hover\\:text-grey-light:hover {\n    color: #e7e7ec;\n  }\n\n  .xl\\:hover\\:text-grey:hover {\n    color: #c2c2c6;\n  }\n\n  .xl\\:hover\\:text-purple-lighter:hover {\n    color: #ccc2e9;\n  }\n\n  .xl\\:hover\\:text-purple-light:hover {\n    color: #87809b;\n  }\n\n  .xl\\:hover\\:text-purple:hover {\n    color: #8360d6;\n  }\n\n  .xl\\:hover\\:text-purple-bright:hover {\n    color: #4c29b0;\n  }\n\n  .xl\\:hover\\:text-purple-dark:hover {\n    color: #453f56;\n  }\n\n  .xl\\:hover\\:text-purple-dark-10:hover {\n    color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:hover\\:text-purple-darker:hover {\n    color: #2a2538;\n  }\n\n  .xl\\:text-sm {\n    font-size: 1.4rem;\n  }\n\n  .xl\\:text-base {\n    font-size: 1.6rem;\n  }\n\n  .xl\\:italic {\n    font-style: italic;\n  }\n\n  .xl\\:roman {\n    font-style: normal;\n  }\n\n  .xl\\:uppercase {\n    text-transform: uppercase;\n  }\n\n  .xl\\:lowercase {\n    text-transform: lowercase;\n  }\n\n  .xl\\:capitalize {\n    text-transform: capitalize;\n  }\n\n  .xl\\:normal-case {\n    text-transform: none;\n  }\n\n  .xl\\:underline {\n    text-decoration: underline;\n  }\n\n  .xl\\:line-through {\n    text-decoration: line-through;\n  }\n\n  .xl\\:no-underline {\n    text-decoration: none;\n  }\n\n  .xl\\:antialiased {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  .xl\\:subpixel-antialiased {\n    -webkit-font-smoothing: auto;\n    -moz-osx-font-smoothing: auto;\n  }\n\n  .xl\\:hover\\:italic:hover {\n    font-style: italic;\n  }\n\n  .xl\\:hover\\:roman:hover {\n    font-style: normal;\n  }\n\n  .xl\\:hover\\:uppercase:hover {\n    text-transform: uppercase;\n  }\n\n  .xl\\:hover\\:lowercase:hover {\n    text-transform: lowercase;\n  }\n\n  .xl\\:hover\\:capitalize:hover {\n    text-transform: capitalize;\n  }\n\n  .xl\\:hover\\:normal-case:hover {\n    text-transform: none;\n  }\n\n  .xl\\:hover\\:underline:hover {\n    text-decoration: underline;\n  }\n\n  .xl\\:hover\\:line-through:hover {\n    text-decoration: line-through;\n  }\n\n  .xl\\:hover\\:no-underline:hover {\n    text-decoration: none;\n  }\n\n  .xl\\:hover\\:antialiased:hover {\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  .xl\\:hover\\:subpixel-antialiased:hover {\n    -webkit-font-smoothing: auto;\n    -moz-osx-font-smoothing: auto;\n  }\n\n  .xl\\:tracking-tight {\n    letter-spacing: -0.05em;\n  }\n\n  .xl\\:tracking-normal {\n    letter-spacing: 0;\n  }\n\n  .xl\\:tracking-wide {\n    letter-spacing: .05em;\n  }\n\n  .xl\\:select-none {\n    user-select: none;\n  }\n\n  .xl\\:select-text {\n    user-select: text;\n  }\n\n  .xl\\:align-baseline {\n    vertical-align: baseline;\n  }\n\n  .xl\\:align-top {\n    vertical-align: top;\n  }\n\n  .xl\\:align-middle {\n    vertical-align: middle;\n  }\n\n  .xl\\:align-bottom {\n    vertical-align: bottom;\n  }\n\n  .xl\\:align-text-top {\n    vertical-align: text-top;\n  }\n\n  .xl\\:align-text-bottom {\n    vertical-align: text-bottom;\n  }\n\n  .xl\\:visible {\n    visibility: visible;\n  }\n\n  .xl\\:invisible {\n    visibility: hidden;\n  }\n\n  .xl\\:whitespace-normal {\n    white-space: normal;\n  }\n\n  .xl\\:whitespace-no-wrap {\n    white-space: nowrap;\n  }\n\n  .xl\\:whitespace-pre {\n    white-space: pre;\n  }\n\n  .xl\\:whitespace-pre-line {\n    white-space: pre-line;\n  }\n\n  .xl\\:whitespace-pre-wrap {\n    white-space: pre-wrap;\n  }\n\n  .xl\\:break-words {\n    word-wrap: break-word;\n  }\n\n  .xl\\:break-normal {\n    word-wrap: normal;\n  }\n\n  .xl\\:truncate {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n\n  .xl\\:w-0 {\n    width: 0;\n  }\n\n  .xl\\:w-1 {\n    width: 2px;\n  }\n\n  .xl\\:w-2 {\n    width: 4px;\n  }\n\n  .xl\\:w-3 {\n    width: 8px;\n  }\n\n  .xl\\:w-4 {\n    width: 16px;\n  }\n\n  .xl\\:w-5 {\n    width: 24px;\n  }\n\n  .xl\\:w-6 {\n    width: 32px;\n  }\n\n  .xl\\:w-7 {\n    width: 36px;\n  }\n\n  .xl\\:w-8 {\n    width: 48px;\n  }\n\n  .xl\\:w-9 {\n    width: 64px;\n  }\n\n  .xl\\:w-10 {\n    width: 96px;\n  }\n\n  .xl\\:w-screen {\n    width: 100vw;\n  }\n\n  .xl\\:w-auto {\n    width: auto;\n  }\n\n  .xl\\:w-full {\n    width: 100%;\n  }\n\n  .xl\\:w-px {\n    width: 1px;\n  }\n\n  .xl\\:w-1\\/6 {\n    width: 16.666666667%;\n  }\n\n  .xl\\:z-0 {\n    z-index: 0;\n  }\n\n  .xl\\:z-10 {\n    z-index: 10;\n  }\n\n  .xl\\:z-20 {\n    z-index: 20;\n  }\n\n  .xl\\:z-30 {\n    z-index: 30;\n  }\n\n  .xl\\:z-40 {\n    z-index: 40;\n  }\n\n  .xl\\:z-50 {\n    z-index: 50;\n  }\n\n  .xl\\:z-auto {\n    z-index: auto;\n  }\n\n  .xl\\:bg-black-10 {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .xl\\:bg-white-10 {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .xl\\:bg-grey-lighter-10 {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .xl\\:bg-grey-light-10 {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .xl\\:bg-grey-10 {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .xl\\:bg-purple-lighter-10 {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .xl\\:bg-purple-light-10 {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .xl\\:bg-purple-10 {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .xl\\:bg-purple-bright-10 {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .xl\\:bg-purple-dark-10 {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:bg-purple-darker-10 {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .xl\\:hover\\:bg-black-10:hover {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .xl\\:hover\\:bg-white-10:hover {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .xl\\:hover\\:bg-grey-lighter-10:hover {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .xl\\:hover\\:bg-grey-light-10:hover {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .xl\\:hover\\:bg-grey-10:hover {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .xl\\:hover\\:bg-purple-lighter-10:hover {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .xl\\:hover\\:bg-purple-light-10:hover {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .xl\\:hover\\:bg-purple-10:hover {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .xl\\:hover\\:bg-purple-bright-10:hover {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .xl\\:hover\\:bg-purple-dark-10:hover {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:hover\\:bg-purple-darker-10:hover {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .xl\\:focus\\:bg-black-10:focus {\n    background-color: rgba(40, 40, 40, .1);\n  }\n\n  .xl\\:focus\\:bg-white-10:focus {\n    background-color: rgba(255, 255, 255, .1);\n  }\n\n  .xl\\:focus\\:bg-grey-lighter-10:focus {\n    background-color: rgba(243, 243, 247, .1);\n  }\n\n  .xl\\:focus\\:bg-grey-light-10:focus {\n    background-color: rgba(231, 231, 236, .1);\n  }\n\n  .xl\\:focus\\:bg-grey-10:focus {\n    background-color: rgba(194, 194, 198, .1);\n  }\n\n  .xl\\:focus\\:bg-purple-lighter-10:focus {\n    background-color: rgba(204, 194, 233, .1);\n  }\n\n  .xl\\:focus\\:bg-purple-light-10:focus {\n    background-color: rgba(135, 128, 155, .1);\n  }\n\n  .xl\\:focus\\:bg-purple-10:focus {\n    background-color: rgba(131, 96, 214, .1);\n  }\n\n  .xl\\:focus\\:bg-purple-bright-10:focus {\n    background-color: rgba(76, 41, 176, .1);\n  }\n\n  .xl\\:focus\\:bg-purple-dark-10:focus {\n    background-color: rgba(69, 63, 86, .1);\n  }\n\n  .xl\\:focus\\:bg-purple-darker-10:focus {\n    background-color: rgba(42, 37, 56, .1);\n  }\n\n  .xl\\:bg-black-30 {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .xl\\:bg-white-30 {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .xl\\:bg-grey-lighter-30 {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .xl\\:bg-grey-light-30 {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .xl\\:bg-grey-30 {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .xl\\:bg-purple-lighter-30 {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .xl\\:bg-purple-light-30 {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .xl\\:bg-purple-30 {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .xl\\:bg-purple-bright-30 {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .xl\\:bg-purple-dark-30 {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .xl\\:bg-purple-darker-30 {\n    background-color: rgba(42, 37, 56, .3);\n  }\n\n  .xl\\:hover\\:bg-black-30:hover {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .xl\\:hover\\:bg-white-30:hover {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .xl\\:hover\\:bg-grey-lighter-30:hover {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .xl\\:hover\\:bg-grey-light-30:hover {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .xl\\:hover\\:bg-grey-30:hover {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .xl\\:hover\\:bg-purple-lighter-30:hover {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .xl\\:hover\\:bg-purple-light-30:hover {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .xl\\:hover\\:bg-purple-30:hover {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .xl\\:hover\\:bg-purple-bright-30:hover {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .xl\\:hover\\:bg-purple-dark-30:hover {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .xl\\:hover\\:bg-purple-darker-30:hover {\n    background-color: rgba(42, 37, 56, .3);\n  }\n\n  .xl\\:focus\\:bg-black-30:focus {\n    background-color: rgba(40, 40, 40, .3);\n  }\n\n  .xl\\:focus\\:bg-white-30:focus {\n    background-color: rgba(255, 255, 255, .3);\n  }\n\n  .xl\\:focus\\:bg-grey-lighter-30:focus {\n    background-color: rgba(243, 243, 247, .3);\n  }\n\n  .xl\\:focus\\:bg-grey-light-30:focus {\n    background-color: rgba(231, 231, 236, .3);\n  }\n\n  .xl\\:focus\\:bg-grey-30:focus {\n    background-color: rgba(194, 194, 198, .3);\n  }\n\n  .xl\\:focus\\:bg-purple-lighter-30:focus {\n    background-color: rgba(204, 194, 233, .3);\n  }\n\n  .xl\\:focus\\:bg-purple-light-30:focus {\n    background-color: rgba(135, 128, 155, .3);\n  }\n\n  .xl\\:focus\\:bg-purple-30:focus {\n    background-color: rgba(131, 96, 214, .3);\n  }\n\n  .xl\\:focus\\:bg-purple-bright-30:focus {\n    background-color: rgba(76, 41, 176, .3);\n  }\n\n  .xl\\:focus\\:bg-purple-dark-30:focus {\n    background-color: rgba(69, 63, 86, .3);\n  }\n\n  .xl\\:focus\\:bg-purple-darker-30:focus {\n    background-color: rgba(42, 37, 56, .3);\n  }\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/fbjs/lib/emptyFunction.js":
/*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ "./node_modules/fbjs/lib/warning.js":
/*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(/*! ./emptyFunction */ "./node_modules/fbjs/lib/emptyFunction.js");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),

/***/ "./node_modules/framesync/dist/framesync.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/framesync/dist/framesync.es.js ***!
  \*****************************************************/
/*! exports provided: currentTime, onFrameStart, onFrameUpdate, onFrameRender, onFrameEnd, cancelOnFrameStart, cancelOnFrameUpdate, cancelOnFrameRender, cancelOnFrameEnd, timeSinceLastFrame, currentFrameTime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "currentTime", function() { return currentTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onFrameStart", function() { return onFrameStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onFrameUpdate", function() { return onFrameUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onFrameRender", function() { return onFrameRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onFrameEnd", function() { return onFrameEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelOnFrameStart", function() { return cancelOnFrameStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelOnFrameUpdate", function() { return cancelOnFrameUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelOnFrameRender", function() { return cancelOnFrameRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelOnFrameEnd", function() { return cancelOnFrameEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeSinceLastFrame", function() { return timeSinceLastFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "currentFrameTime", function() { return currentFrameTime; });
var hasRAF = typeof window !== 'undefined' && window.requestAnimationFrame !== undefined;
var prevTime = 0;
var onNextFrame = hasRAF
    ? function (callback) { return window.requestAnimationFrame(callback); }
    : function (callback) {
        var currentTime = Date.now();
        var timeToCall = Math.max(0, 16.7 - (currentTime - prevTime));
        prevTime = currentTime + timeToCall;
        setTimeout(function () { return callback(prevTime); }, timeToCall);
    };

function createRenderStep(startRenderLoop) {
    var functionsToRun = [];
    var functionsToRunNextFrame = [];
    var numThisFrame = 0;
    var isProcessing = false;
    var i = 0;
    return {
        cancel: function (callback) {
            var indexOfCallback = functionsToRunNextFrame.indexOf(callback);
            if (indexOfCallback !== -1) {
                functionsToRunNextFrame.splice(indexOfCallback, 1);
            }
        },
        process: function () {
            isProcessing = true;
            _a = [functionsToRunNextFrame, functionsToRun], functionsToRun = _a[0], functionsToRunNextFrame = _a[1];
            functionsToRunNextFrame.length = 0;
            numThisFrame = functionsToRun.length;
            for (i = 0; i < numThisFrame; i++) {
                functionsToRun[i]();
            }
            isProcessing = false;
            var _a;
        },
        schedule: function (callback, immediate) {
            if (immediate === void 0) { immediate = false; }
            startRenderLoop();
            var addToCurrentBuffer = immediate && isProcessing;
            var buffer = addToCurrentBuffer ? functionsToRun : functionsToRunNextFrame;
            if (buffer.indexOf(callback) === -1) {
                buffer.push(callback);
                if (addToCurrentBuffer) {
                    numThisFrame = functionsToRun.length;
                }
            }
        },
    };
}

var HAS_PERFORMANCE_NOW = typeof performance !== 'undefined' && performance.now !== undefined;
var currentTime = HAS_PERFORMANCE_NOW ? function () { return performance.now(); } : function () { return Date.now(); };
var willRenderNextFrame = false;
var MAX_ELAPSED = 40;
var defaultElapsed = 16.7;
var useDefaultElapsed = true;
var currentFramestamp = 0;
var elapsed = 0;
function startRenderLoop() {
    if (willRenderNextFrame)
        return;
    willRenderNextFrame = true;
    useDefaultElapsed = true;
    onNextFrame(processFrame);
}
var frameStart = createRenderStep(startRenderLoop);
var frameUpdate = createRenderStep(startRenderLoop);
var frameRender = createRenderStep(startRenderLoop);
var frameEnd = createRenderStep(startRenderLoop);
function processFrame(framestamp) {
    willRenderNextFrame = false;
    elapsed = useDefaultElapsed
        ? defaultElapsed
        : Math.max(Math.min(framestamp - currentFramestamp, MAX_ELAPSED), 1);
    if (!useDefaultElapsed)
        defaultElapsed = elapsed;
    currentFramestamp = framestamp;
    frameStart.process();
    frameUpdate.process();
    frameRender.process();
    frameEnd.process();
    if (willRenderNextFrame)
        useDefaultElapsed = false;
}
var onFrameStart = frameStart.schedule;
var onFrameUpdate = frameUpdate.schedule;
var onFrameRender = frameRender.schedule;
var onFrameEnd = frameEnd.schedule;
var cancelOnFrameStart = frameStart.cancel;
var cancelOnFrameUpdate = frameUpdate.cancel;
var cancelOnFrameRender = frameRender.cancel;
var cancelOnFrameEnd = frameEnd.cancel;
var timeSinceLastFrame = function () { return elapsed; };
var currentFrameTime = function () { return currentFramestamp; };




/***/ }),

/***/ "./node_modules/gud/index.js":
/*!***********************************!*\
  !*** ./node_modules/gud/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {// @flow


var key = '__global_unique_id__';

module.exports = function() {
  return global[key] = (global[key] || 0) + 1;
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/hey-listen/dist/hey-listen.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/hey-listen/dist/hey-listen.es.js ***!
  \*******************************************************/
/*! exports provided: warning, invariant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warning", function() { return warning; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invariant", function() { return invariant; });
var HEY_LISTEN = 'Hey, listen! ';
var warning = function () { };
var invariant = function () { };
if (true) {
    warning = function (check, message) {
        if (!check && typeof console !== 'undefined') {
            console.warn(HEY_LISTEN + message);
        }
    };
    invariant = function (check, message) {
        if (!check) {
            throw new Error(HEY_LISTEN.toUpperCase() + message);
        }
    };
}




/***/ }),

/***/ "./node_modules/invariant/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/invariant/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (true) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/popmotion-pose/dist/popmotion-pose.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/popmotion-pose/dist/popmotion-pose.es.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var popmotion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! popmotion */ "./node_modules/popmotion/dist/popmotion.es.js");
/* harmony import */ var style_value_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! style-value-types */ "./node_modules/style-value-types/dist/style-value-types.es.js");
/* harmony import */ var pose_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pose-core */ "./node_modules/pose-core/dist/pose-core.es.js");
/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hey-listen */ "./node_modules/hey-listen/dist/hey-listen.es.js");





/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function () {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
    return t;
}

var BoundingBoxDimension;
(function (BoundingBoxDimension) {
    BoundingBoxDimension["width"] = "width";
    BoundingBoxDimension["height"] = "height";
    BoundingBoxDimension["left"] = "left";
    BoundingBoxDimension["right"] = "right";
    BoundingBoxDimension["top"] = "top";
    BoundingBoxDimension["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));

var linear = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].linear;
var interpolate = popmotion__WEBPACK_IMPORTED_MODULE_0__["transform"].interpolate;
var singleAxisPointer = function (axis) {
    return function (from) {
        var _a;
        return Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["pointer"])((_a = {}, _a[axis] = typeof from === 'string' ? parseFloat(from) : from, _a)).pipe(function (v) {
            return v[axis];
        });
    };
};
var pointerX = /*#__PURE__*/singleAxisPointer('x');
var pointerY = /*#__PURE__*/singleAxisPointer('y');
var createPointer = function (axisPointerCreator, min, max, measurement) {
    return function (_a) {
        var from = _a.from,
            type = _a.type,
            dimensions = _a.dimensions,
            dragBounds = _a.dragBounds;
        var axisPointer = axisPointerCreator(dimensions.measurementAsPixels(measurement, from, type));
        var transformQueue = [];
        if (dragBounds) {
            if (dragBounds[min] !== undefined) {
                transformQueue.push(function (v) {
                    return Math.max(v, dimensions.measurementAsPixels(measurement, dragBounds[min], type));
                });
            }
            if (dragBounds[max] !== undefined) {
                transformQueue.push(function (v) {
                    return Math.min(v, dimensions.measurementAsPixels(measurement, dragBounds[max], type));
                });
            }
        }
        if (type === style_value_types__WEBPACK_IMPORTED_MODULE_1__["percent"]) {
            transformQueue.push(interpolate([0, dimensions.get(measurement)], [0, 100]), function (v) {
                return v + '%';
            });
        }
        return transformQueue.length ? axisPointer.pipe.apply(axisPointer, transformQueue) : axisPointer;
    };
};
var just = function (from) {
    return Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["action"])(function (_a) {
        var update = _a.update,
            complete = _a.complete;
        update(from);
        complete();
    });
};
var underDampedSpring = function (_a) {
    var from = _a.from,
        velocity = _a.velocity,
        to = _a.to;
    return Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["spring"])({
        from: from,
        to: to,
        velocity: velocity,
        stiffness: 500,
        damping: 25,
        restDelta: 0.5,
        restSpeed: 10
    });
};
var overDampedSpring = function (_a) {
    var from = _a.from,
        velocity = _a.velocity,
        to = _a.to;
    return Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["spring"])({ from: from, to: to, velocity: velocity, stiffness: 700, damping: to === 0 ? 100 : 35 });
};
var linearTween = function (_a) {
    var from = _a.from,
        to = _a.to;
    return Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["tween"])({ from: from, to: to, ease: linear });
};
var intelligentTransition = {
    x: underDampedSpring,
    y: underDampedSpring,
    z: underDampedSpring,
    rotate: underDampedSpring,
    rotateX: underDampedSpring,
    rotateY: underDampedSpring,
    rotateZ: underDampedSpring,
    scaleX: overDampedSpring,
    scaleY: overDampedSpring,
    scale: overDampedSpring,
    opacity: linearTween,
    default: popmotion__WEBPACK_IMPORTED_MODULE_0__["tween"]
};
var dragAction = /*#__PURE__*/__assign({}, intelligentTransition, { x: /*#__PURE__*/createPointer(pointerX, 'left', 'right', BoundingBoxDimension.width), y: /*#__PURE__*/createPointer(pointerY, 'top', 'bottom', BoundingBoxDimension.height) });
var justAxis = function (_a) {
    var from = _a.from;
    return just(from);
};
var intelligentDragEnd = /*#__PURE__*/__assign({}, intelligentTransition, { x: justAxis, y: justAxis });
var defaultTransitions = /*#__PURE__*/new Map([['default', intelligentTransition], ['drag', dragAction], ['dragEnd', intelligentDragEnd]]);

var auto = {
    test: function (v) {
        return v === 'auto';
    },
    parse: function (v) {
        return v;
    }
};
var valueTypeTests = [style_value_types__WEBPACK_IMPORTED_MODULE_1__["number"], style_value_types__WEBPACK_IMPORTED_MODULE_1__["degrees"], style_value_types__WEBPACK_IMPORTED_MODULE_1__["percent"], style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"], style_value_types__WEBPACK_IMPORTED_MODULE_1__["vw"], style_value_types__WEBPACK_IMPORTED_MODULE_1__["vh"], auto];
var testValueType = function (v) {
    return function (type) {
        return type.test(v);
    };
};
var getValueType = function (v) {
    return valueTypeTests.find(testValueType(v));
};

var createPassiveValue = function (init, parent, transform$$1) {
    var raw = Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["value"])(transform$$1(init));
    parent.raw.subscribe(function (v) {
        return raw.update(transform$$1(v));
    });
    return { raw: raw };
};
var createValue = function (init) {
    var type = getValueType(init);
    var raw = Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["value"])(init);
    return { raw: raw, type: type };
};
var addActionDelay = function (delay$$1, transition) {
    if (delay$$1 === void 0) {
        delay$$1 = 0;
    }
    return Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["chain"])(Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["delay"])(delay$$1), transition);
};
var animationLookup = {
    tween: popmotion__WEBPACK_IMPORTED_MODULE_0__["tween"],
    spring: popmotion__WEBPACK_IMPORTED_MODULE_0__["spring"],
    decay: popmotion__WEBPACK_IMPORTED_MODULE_0__["decay"],
    keyframes: popmotion__WEBPACK_IMPORTED_MODULE_0__["keyframes"],
    physics: popmotion__WEBPACK_IMPORTED_MODULE_0__["physics"]
};
var linear$1 = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].linear,
    easeIn = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].easeIn,
    easeOut = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].easeOut,
    easeInOut = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].easeInOut,
    circIn = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].circIn,
    circOut = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].circOut,
    circInOut = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].circInOut,
    backIn = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].backIn,
    backOut = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].backOut,
    backInOut = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].backInOut,
    anticipate = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].anticipate;
var easingLookup = {
    linear: linear$1,
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut,
    circIn: circIn,
    circOut: circOut,
    circInOut: circInOut,
    backIn: backIn,
    backOut: backOut,
    backInOut: backInOut,
    anticipate: anticipate
};
var getAction = function (v, _a, _b) {
    var from = _b.from,
        to = _b.to,
        velocity = _b.velocity;
    var _c = _a.type,
        type = _c === void 0 ? 'tween' : _c,
        ease = _a.ease,
        def = __rest(_a, ["type", "ease"]);
    Object(hey_listen__WEBPACK_IMPORTED_MODULE_3__["invariant"])(animationLookup[type] !== undefined, "Invalid transition type '" + type + "'. Valid transition types are: tween, spring, decay, physics and keyframes.");
    if (type === 'tween') {
        var typeOfEase = typeof ease;
        if (typeOfEase !== 'function') {
            if (typeOfEase === 'string') {
                Object(hey_listen__WEBPACK_IMPORTED_MODULE_3__["invariant"])(easingLookup[ease] !== undefined, "Invalid easing type '" + ease + "'. popmotion.io/pose/api/config");
                ease = easingLookup[ease];
            } else if (Array.isArray(ease)) {
                Object(hey_listen__WEBPACK_IMPORTED_MODULE_3__["invariant"])(ease.length === 4, "Cubic bezier arrays must contain four numerical values.");
                var x1 = ease[0],
                    y1 = ease[1],
                    x2 = ease[2],
                    y2 = ease[3];
                ease = popmotion__WEBPACK_IMPORTED_MODULE_0__["easing"].cubicBezier(x1, y1, x2, y2);
            }
        }
    }
    var baseProps = type !== 'keyframes' ? {
        from: from,
        to: to,
        velocity: velocity,
        ease: ease
    } : { ease: ease };
    return animationLookup[type](__assign({}, baseProps, def));
};
var isAction = function (action$$1) {
    return typeof action$$1.start !== 'undefined';
};
var pose = function (_a) {
    var transformPose = _a.transformPose,
        addListenerToValue = _a.addListenerToValue,
        extendAPI = _a.extendAPI,
        readValueFromSource = _a.readValueFromSource,
        posePriority = _a.posePriority,
        setValueNative = _a.setValueNative;
    return Object(pose_core__WEBPACK_IMPORTED_MODULE_2__["default"])({
        bindOnChange: function (values, onChange) {
            return function (key) {
                if (!values.has(key)) return;
                var raw = values.get(key).raw;
                raw.subscribe(onChange[key]);
            };
        },
        readValue: function (_a) {
            var raw = _a.raw;
            return raw.get();
        },
        setValue: function (_a, to) {
            var raw = _a.raw;
            return raw.update(to);
        },
        createValue: function (init, key, _a, _b) {
            var elementStyler = _a.elementStyler;
            var _c = _b === void 0 ? {} : _b,
                passiveParent = _c.passiveParent,
                passiveProps = _c.passiveProps;
            var val = passiveParent ? createPassiveValue(init, passiveParent, passiveProps) : createValue(init);
            if (addListenerToValue) {
                val.raw.subscribe(addListenerToValue(key, elementStyler));
            }
            return val;
        },
        convertValue: function (raw, key, _a) {
            var elementStyler = _a.elementStyler;
            if (addListenerToValue) {
                raw.subscribe(addListenerToValue(key, elementStyler));
            }
            return {
                raw: raw,
                type: getValueType(raw.get())
            };
        },
        getTransitionProps: function (_a, to) {
            var raw = _a.raw,
                type = _a.type;
            return {
                from: raw.get(),
                velocity: raw.getVelocity(),
                to: to,
                type: type
            };
        },
        resolveTarget: function (_, to) {
            return to;
        },
        selectValueToRead: function (_a) {
            var raw = _a.raw;
            return raw;
        },
        startAction: function (_a, action$$1, complete) {
            var raw = _a.raw;
            var reaction = {
                update: function (v) {
                    return raw.update(v);
                },
                complete: complete
            };
            return action$$1.start(reaction);
        },
        stopAction: function (action$$1) {
            return action$$1.stop();
        },
        getInstantTransition: function (_, _a) {
            var to = _a.to;
            return just(to);
        },
        convertTransitionDefinition: function (val, def, props) {
            if (isAction(def)) return def;
            var delay$$1 = def.delay,
                min = def.min,
                max = def.max,
                round = def.round,
                remainingDef = __rest(def, ["delay", "min", "max", "round"]);
            var action$$1 = getAction(val, remainingDef, props);
            var outputPipe = [];
            if (delay$$1) action$$1 = addActionDelay(delay$$1, action$$1);
            if (min !== undefined) outputPipe.push(function (v) {
                return Math.max(v, min);
            });
            if (max !== undefined) outputPipe.push(function (v) {
                return Math.min(v, max);
            });
            if (round) outputPipe.push(Math.round);
            return outputPipe.length ? action$$1.pipe.apply(action$$1, outputPipe) : action$$1;
        },
        setValueNative: setValueNative,
        addActionDelay: addActionDelay,
        defaultTransitions: defaultTransitions,
        transformPose: transformPose,
        readValueFromSource: readValueFromSource,
        posePriority: posePriority,
        extendAPI: extendAPI
    });
};

var createDimensions = function (element) {
    var hasMeasured = false;
    var current = {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
    };
    return {
        get: function (measurement) {
            return measurement ? current[measurement] : current;
        },
        measure: function () {
            current = element.getBoundingClientRect();
            hasMeasured = true;
            return current;
        },
        measurementAsPixels: function (measurement, value$$1, type) {
            return type === style_value_types__WEBPACK_IMPORTED_MODULE_1__["percent"] ? (typeof value$$1 === 'string' ? parseFloat(value$$1) : value$$1) / 100 * current[measurement] : value$$1;
        },
        has: function () {
            return hasMeasured;
        }
    };
};

var makeUIEventApplicator = function (_a) {
    var startEvents = _a.startEvents,
        endEvents = _a.endEvents,
        startPose = _a.startPose,
        endPose = _a.endPose,
        startCallback = _a.startCallback,
        endCallback = _a.endCallback,
        useDocumentToEnd = _a.useDocumentToEnd,
        preventDefault = _a.preventDefault;
    return function (element, activeActions, poser, config) {
        var startListener = startPose + 'Start';
        var endListener = startPose + 'End';
        var eventStartListener = Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["listen"])(element, startEvents).start(function (startEvent) {
            if (preventDefault) startEvent.preventDefault();
            poser.set(startPose);
            if (startCallback && config[startCallback]) config[startCallback](startEvent);
            var eventEndListener = Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["listen"])(useDocumentToEnd ? document.documentElement : element, endEvents + (useDocumentToEnd ? ' mouseenter' : '')).start(function (endEvent) {
                if (useDocumentToEnd && endEvent.type === 'mouseenter' && endEvent.buttons === 1) {
                    return;
                }
                if (preventDefault) endEvent.preventDefault();
                activeActions.get(endListener).stop();
                poser.unset(startPose);
                poser.set(endPose);
                if (endCallback && config[endCallback]) config[endCallback](endEvent);
            });
            activeActions.set(endListener, eventEndListener);
        });
        activeActions.set(startListener, eventStartListener);
    };
};
var events = {
    draggable: /*#__PURE__*/makeUIEventApplicator({
        startEvents: 'mousedown touchstart',
        endEvents: 'mouseup touchend',
        startPose: 'drag',
        endPose: 'dragEnd',
        startCallback: 'onDragStart',
        endCallback: 'onDragEnd',
        useDocumentToEnd: true,
        preventDefault: true
    }),
    hoverable: /*#__PURE__*/makeUIEventApplicator({
        startEvents: 'mouseenter',
        endEvents: 'mouseleave',
        startPose: 'hover',
        endPose: 'hoverEnd'
    }),
    focusable: /*#__PURE__*/makeUIEventApplicator({
        startEvents: 'focus',
        endEvents: 'blur',
        startPose: 'focus',
        endPose: 'blur'
    }),
    pressable: /*#__PURE__*/makeUIEventApplicator({
        startEvents: 'mousedown touchstart',
        endEvents: 'mouseup touchend',
        startPose: 'press',
        endPose: 'pressEnd',
        startCallback: 'onPressStart',
        endCallback: 'onPressEnd',
        useDocumentToEnd: true
    })
};
var eventKeys = /*#__PURE__*/Object.keys(events);
var appendEventListeners = function (element, activeActions, poser, _a) {
    var props = _a.props;
    return eventKeys.forEach(function (key) {
        if (props[key]) events[key](element, activeActions, poser, props);
    });
};

var measureWithoutTransform = function (element) {
    var transform$$1 = element.style.transform;
    element.style.transform = '';
    var bbox = element.getBoundingClientRect();
    element.style.transform = transform$$1;
    return bbox;
};
var resolveProp = function (target, props) {
    return typeof target === 'function' ? target(props) : target;
};

var ORIGIN_START = 0;
var ORIGIN_CENTER = '50%';
var ORIGIN_END = '100%';
var findCenter = function (_a) {
    var top = _a.top,
        right = _a.right,
        bottom = _a.bottom,
        left = _a.left;
    return {
        x: (left + right) / 2,
        y: (top + bottom) / 2
    };
};
var positionalProps = ['width', 'height', 'top', 'left', 'bottom', 'right'];
var positionalPropsDict = /*#__PURE__*/new Set(positionalProps);
var checkPositionalProp = function (key) {
    return positionalPropsDict.has(key);
};
var hasPositionalProps = function (pose) {
    return Object.keys(pose).some(checkPositionalProp);
};
var isFlipPose = function (flip, key, state) {
    return state.props.element instanceof HTMLElement && (flip === true || key === 'flip');
};
var setValue = function (_a, key, to) {
    var values = _a.values,
        props = _a.props;
    if (values.has(key)) {
        var raw = values.get(key).raw;
        raw.update(to);
        raw.update(to);
    } else {
        values.set(key, {
            raw: Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["value"])(to, function (v) {
                return props.elementStyler.set(key, v);
            })
        });
    }
};
var explicitlyFlipPose = function (state, nextPose) {
    var _a = state.props,
        dimensions = _a.dimensions,
        elementStyler = _a.elementStyler;
    dimensions.measure();
    var width = nextPose.width,
        height = nextPose.height,
        top = nextPose.top,
        left = nextPose.left,
        bottom = nextPose.bottom,
        right = nextPose.right,
        position = nextPose.position,
        remainingPose = __rest(nextPose, ["width", "height", "top", "left", "bottom", "right", "position"]);
    var propsToSet = positionalProps.concat('position').reduce(function (acc, key) {
        if (nextPose[key] !== undefined) {
            acc[key] = resolveProp(nextPose[key], state.props);
        }
        return acc;
    }, {});
    elementStyler.set(propsToSet).render();
    return implicitlyFlipPose(state, remainingPose);
};
var implicitlyFlipPose = function (state, nextPose) {
    var _a = state.props,
        dimensions = _a.dimensions,
        element = _a.element,
        elementStyler = _a.elementStyler;
    if (!dimensions.has()) return {};
    var prev = dimensions.get();
    var next = measureWithoutTransform(element);
    var originX = prev.left === next.left ? ORIGIN_START : prev.right === next.right ? ORIGIN_END : ORIGIN_CENTER;
    var originY = prev.top === next.top ? ORIGIN_START : prev.bottom === next.bottom ? ORIGIN_END : ORIGIN_CENTER;
    elementStyler.set({ originX: originX, originY: originY });
    var flipPoseProps = {};
    if (prev.width !== next.width) {
        setValue(state, 'scaleX', prev.width / next.width);
        flipPoseProps.scaleX = 1;
    }
    if (prev.height !== next.height) {
        setValue(state, 'scaleY', prev.height / next.height);
        flipPoseProps.scaleY = 1;
    }
    var prevCenter = findCenter(prev);
    var nextCenter = findCenter(next);
    if (originX === ORIGIN_CENTER) {
        setValue(state, 'x', prevCenter.x - nextCenter.x);
        flipPoseProps.x = 0;
    }
    if (originY === ORIGIN_CENTER) {
        setValue(state, 'y', prevCenter.y - nextCenter.y);
        flipPoseProps.y = 0;
    }
    elementStyler.render();
    return __assign({}, nextPose, flipPoseProps);
};
var flipPose = function (props, nextPose) {
    return hasPositionalProps(nextPose) ? explicitlyFlipPose(props, nextPose) : implicitlyFlipPose(props, nextPose);
};

var getPosFromMatrix = function (matrix, pos) {
    return parseFloat(matrix.split(', ')[pos]);
};
var getTranslateFromMatrix = function (pos2, pos3) {
    return function (element, bbox, _a) {
        var transform$$1 = _a.transform;
        if (transform$$1 === 'none') return 0;
        var matrix3d = transform$$1.match(/^matrix3d\((.+)\)$/);
        if (matrix3d) return getPosFromMatrix(matrix3d[1], pos3);
        return getPosFromMatrix(transform$$1.match(/^matrix\((.+)\)$/)[1], pos2);
    };
};
var positionalValues = {
    width: function (element, _a) {
        var width = _a.width;
        return width;
    },
    height: function (element, _a) {
        var height = _a.height;
        return height;
    },
    top: function (element, bbox, _a) {
        var top = _a.top;
        return parseFloat(top);
    },
    left: function (element, bbox, _a) {
        var left = _a.left;
        return parseFloat(left);
    },
    bottom: function (element, _a, _b) {
        var height = _a.height;
        var top = _b.top;
        return parseFloat(top) + height;
    },
    right: function (element, _a, _b) {
        var width = _a.width;
        var left = _b.left;
        return parseFloat(left) + width;
    },
    x: /*#__PURE__*/getTranslateFromMatrix(4, 13),
    y: /*#__PURE__*/getTranslateFromMatrix(5, 14)
};
var isPositionalKey = function (v) {
    return positionalValues[v] !== undefined;
};
var isPositional = function (pose) {
    return Object.keys(pose).some(isPositionalKey);
};
var convertPositionalUnits = function (state, pose) {
    var values = state.values,
        props = state.props;
    var element = props.element,
        elementStyler = props.elementStyler;
    var positionalPoseKeys = Object.keys(pose).filter(isPositionalKey);
    var changedPositionalKeys = [];
    var elementComputedStyle = getComputedStyle(element);
    positionalPoseKeys.forEach(function (key) {
        var value$$1 = values.get(key);
        var fromValueType = getValueType(value$$1.raw.get());
        var to = resolveProp(pose[key], props);
        var toValueType = getValueType(to);
        if (fromValueType !== toValueType) {
            changedPositionalKeys.push(key);
            pose.applyAtEnd = pose.applyAtEnd || {};
            pose.applyAtEnd[key] = pose[key];
            setValue(state, key, to);
        }
    });
    if (!changedPositionalKeys.length) return pose;
    var originBbox = element.getBoundingClientRect();
    var top = elementComputedStyle.top,
        left = elementComputedStyle.left,
        bottom = elementComputedStyle.bottom,
        right = elementComputedStyle.right,
        transform$$1 = elementComputedStyle.transform;
    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform$$1 };
    elementStyler.render();
    var targetBbox = element.getBoundingClientRect();
    var newPose = __assign({}, pose);
    changedPositionalKeys.forEach(function (key) {
        setValue(state, key, positionalValues[key](element, originBbox, originComputedStyle));
        newPose[key] = positionalValues[key](element, targetBbox, elementComputedStyle);
    });
    elementStyler.render();
    return newPose;
};

var dragPoses = function (draggable) {
    var drag = {
        preTransition: function (_a) {
            var dimensions = _a.dimensions;
            return dimensions.measure();
        }
    };
    var dragEnd = {};
    if (draggable === true || draggable === 'x') drag.x = dragEnd.x = 0;
    if (draggable === true || draggable === 'y') drag.y = dragEnd.y = 0;
    return { drag: drag, dragEnd: dragEnd };
};
var createPoseConfig = function (element, _a) {
    var onDragStart = _a.onDragStart,
        onDragEnd = _a.onDragEnd,
        onPressStart = _a.onPressStart,
        onPressEnd = _a.onPressEnd,
        draggable = _a.draggable,
        hoverable = _a.hoverable,
        focusable = _a.focusable,
        pressable = _a.pressable,
        dragBounds = _a.dragBounds,
        config = __rest(_a, ["onDragStart", "onDragEnd", "onPressStart", "onPressEnd", "draggable", "hoverable", "focusable", "pressable", "dragBounds"]);
    var poseConfig = __assign({ flip: {} }, config, { props: __assign({}, config.props, { onDragStart: onDragStart,
            onDragEnd: onDragEnd,
            onPressStart: onPressStart,
            onPressEnd: onPressEnd,
            dragBounds: dragBounds,
            draggable: draggable,
            hoverable: hoverable,
            focusable: focusable,
            pressable: pressable,
            element: element, elementStyler: Object(popmotion__WEBPACK_IMPORTED_MODULE_0__["styler"])(element, { preparseOutput: false }), dimensions: createDimensions(element) }) });
    if (draggable) {
        var _b = dragPoses(draggable),
            drag = _b.drag,
            dragEnd = _b.dragEnd;
        poseConfig.drag = __assign({}, poseConfig.drag, drag);
        poseConfig.dragEnd = __assign({}, poseConfig.dragEnd, dragEnd);
    }
    return poseConfig;
};
var domPose = /*#__PURE__*/pose({
    posePriority: ['drag', 'press', 'focus', 'hover'],
    transformPose: function (_a, name, state) {
        var flip = _a.flip,
            pose$$1 = __rest(_a, ["flip"]);
        if (isFlipPose(flip, name, state)) {
            return flipPose(state, pose$$1);
        } else if (isPositional(pose$$1)) {
            return convertPositionalUnits(state, pose$$1);
        }
        return pose$$1;
    },
    addListenerToValue: function (key, elementStyler) {
        return function (v) {
            return elementStyler.set(key, v);
        };
    },
    readValueFromSource: function (key, _a) {
        var elementStyler = _a.elementStyler,
            dragBounds = _a.dragBounds;
        var value$$1 = elementStyler.get(key);
        if (dragBounds && (key === 'x' || key === 'y')) {
            var bound = key === 'x' ? dragBounds.left || dragBounds.right : dragBounds.top || dragBounds.bottom;
            if (bound) {
                var boundType = getValueType(bound);
                value$$1 = boundType.transform(value$$1);
            }
        }
        return isNaN(value$$1) ? value$$1 : parseFloat(value$$1);
    },
    setValueNative: function (key, to, _a) {
        var elementStyler = _a.elementStyler;
        return elementStyler.set(key, to);
    },
    extendAPI: function (api, _a, config) {
        var props = _a.props,
            activeActions = _a.activeActions;
        var measure = props.dimensions.measure;
        var poserApi = __assign({}, api, { addChild: function (element, childConfig) {
                return api._addChild(createPoseConfig(element, childConfig), domPose);
            }, measure: measure, flip: function (op) {
                if (op) {
                    measure();
                    op();
                }
                return api.set('flip');
            } });
        props.elementStyler.render();
        appendEventListeners(props.element, activeActions, poserApi, config);
        return poserApi;
    }
});
var domPose$1 = function (element, config) {
    return domPose(createPoseConfig(element, config));
};

/* harmony default export */ __webpack_exports__["default"] = (domPose$1);


/***/ }),

/***/ "./node_modules/popmotion/dist/popmotion.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/popmotion/dist/popmotion.es.js ***!
  \*****************************************************/
/*! exports provided: valueTypes, easing, styler, action, multicast, value, decay, keyframes, everyFrame, physics, spring, timeline, tween, listen, pointer, mouse, multitouch, chain, composite, crossfade, delay, merge, parallel, schedule, stagger, calc, transform, css, svg, Action, ValueReaction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "action", function() { return action; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multicast", function() { return multicast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "value", function() { return value; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decay", function() { return vectorDecay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyframes", function() { return keyframes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "everyFrame", function() { return frame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "physics", function() { return vectorPhysics; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spring", function() { return vectorSpring; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeline", function() { return timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tween", function() { return tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listen", function() { return listen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointer", function() { return index; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return mouse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multitouch", function() { return multitouch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return chain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "composite", function() { return composite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crossfade", function() { return crossfade; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return delay; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parallel", function() { return parallel$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "schedule", function() { return schedule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stagger", function() { return stagger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calc", function() { return calc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transformers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "css", function() { return css; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "svg", function() { return svg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Action", function() { return Action; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ValueReaction", function() { return ValueReaction; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var framesync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framesync */ "./node_modules/framesync/dist/framesync.es.js");
/* harmony import */ var style_value_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-value-types */ "./node_modules/style-value-types/dist/style-value-types.es.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "valueTypes", function() { return style_value_types__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hey-listen */ "./node_modules/hey-listen/dist/hey-listen.es.js");
/* harmony import */ var _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @popmotion/easing */ "./node_modules/@popmotion/easing/dist/easing.es.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "easing", function() { return _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var stylefire__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stylefire */ "./node_modules/stylefire/dist/stylefire.es.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "styler", function() { return stylefire__WEBPACK_IMPORTED_MODULE_5__["default"]; });













var isNum = function (v) {
    return typeof v === 'number';
};
var isPoint = function (point) {
    return point.x !== undefined && point.y !== undefined;
};
var isPoint3D = function (point) {
    return point.z !== undefined;
};
var toDecimal = function (num, precision) {
    if (precision === void 0) {
        precision = 2;
    }
    precision = Math.pow(10, precision);
    return Math.round(num * precision) / precision;
};
var ZERO_POINT = {
    x: 0,
    y: 0,
    z: 0
};
var distance1D = function (a, b) {
    return Math.abs(a - b);
};
var angle = function (a, b) {
    if (b === void 0) {
        b = ZERO_POINT;
    }
    return radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));
};
var degreesToRadians = function (degrees$$1) {
    return degrees$$1 * Math.PI / 180;
};
var dilate = function (a, b, dilation) {
    return a + (b - a) * dilation;
};
var distance = function (a, b) {
    if (b === void 0) {
        b = ZERO_POINT;
    }
    if (isNum(a) && isNum(b)) {
        return distance1D(a, b);
    } else if (isPoint(a) && isPoint(b)) {
        var xDelta = distance1D(a.x, b.x);
        var yDelta = distance1D(a.y, b.y);
        var zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;
        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
    }
    return 0;
};
var getProgressFromValue = function (from, to, value) {
    var toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
var getValueFromProgress = function (from, to, progress) {
    return -progress * from + progress * to + from;
};
var pointFromAngleAndDistance = function (origin, angle, distance) {
    angle = degreesToRadians(angle);
    return {
        x: distance * Math.cos(angle) + origin.x,
        y: distance * Math.sin(angle) + origin.y
    };
};
var radiansToDegrees = function (radians) {
    return radians * 180 / Math.PI;
};
var smooth = function (newValue, oldValue, duration, smoothing) {
    if (smoothing === void 0) {
        smoothing = 0;
    }
    return toDecimal(oldValue + duration * (newValue - oldValue) / Math.max(smoothing, duration));
};
var speedPerFrame = function (xps, frameDuration) {
    return isNum(xps) ? xps / (1000 / frameDuration) : 0;
};
var speedPerSecond = function (velocity, frameDuration) {
    return frameDuration ? velocity * (1000 / frameDuration) : 0;
};
var stepProgress = function (steps, progress) {
    var segment = 1 / (steps - 1);
    var target = 1 - 1 / steps;
    var progressOfTarget = Math.min(progress / target, 1);
    return Math.floor(progressOfTarget / segment) * segment;
};

var calc = /*#__PURE__*/Object.freeze({
    isPoint: isPoint,
    isPoint3D: isPoint3D,
    angle: angle,
    degreesToRadians: degreesToRadians,
    dilate: dilate,
    distance: distance,
    getProgressFromValue: getProgressFromValue,
    getValueFromProgress: getValueFromProgress,
    pointFromAngleAndDistance: pointFromAngleAndDistance,
    radiansToDegrees: radiansToDegrees,
    smooth: smooth,
    speedPerFrame: speedPerFrame,
    speedPerSecond: speedPerSecond,
    stepProgress: stepProgress
});

var identity = function (v) {
    return v;
};
var appendUnit = function (unit) {
    return function (v) {
        return "" + v + unit;
    };
};
var applyOffset = function (from, to) {
    var hasReceivedFrom = true;
    if (to === undefined) {
        to = from;
        hasReceivedFrom = false;
    }
    var getOffset = function (v) {
        return v - from;
    };
    var applyOffsetTo = function (v) {
        return v + to;
    };
    return function (v) {
        if (hasReceivedFrom) {
            return applyOffsetTo(getOffset(v));
        } else {
            from = v;
            hasReceivedFrom = true;
            return to;
        }
    };
};
var blend = function (from, to, v) {
    var fromExpo = from * from;
    var toExpo = to * to;
    return Math.sqrt(v * (toExpo - fromExpo) + fromExpo);
};
var blendColor = function (from, to) {
    var fromColor = typeof from === 'string' ? style_value_types__WEBPACK_IMPORTED_MODULE_2__["color"].parse(from) : from;
    var toColor = typeof to === 'string' ? style_value_types__WEBPACK_IMPORTED_MODULE_2__["color"].parse(to) : to;
    var blended = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, fromColor);
    var blendFunc = from.hue !== undefined || typeof from === 'string' && style_value_types__WEBPACK_IMPORTED_MODULE_2__["hsla"].test(from) ? getValueFromProgress : blend;
    return function (v) {
        blended = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, blended);
        for (var key in blended) {
            if (key !== 'alpha' && blended.hasOwnProperty(key)) {
                blended[key] = blendFunc(fromColor[key], toColor[key], v);
            }
        }
        blended.alpha = getValueFromProgress(fromColor.alpha, toColor.alpha, v);
        return blended;
    };
};
var blendArray = function (from, to) {
    var output = from.slice();
    var numValues = output.length;
    var blendValue = from.map(function (fromThis, i) {
        var toThis = to[i];
        return typeof fromThis === 'number' ? function (v) {
            return getValueFromProgress(fromThis, toThis, v);
        } : blendColor(fromThis, toThis);
    });
    return function (v) {
        for (var i = 0; i < numValues; i++) {
            output[i] = blendValue[i](v);
        }
        return output;
    };
};
var clamp = function (min, max) {
    return function (v) {
        return Math.min(Math.max(v, min), max);
    };
};
var combineFunctions = function (a, b) {
    return function (v) {
        return b(a(v));
    };
};
var pipe = function () {
    var transformers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        transformers[_i] = arguments[_i];
    }
    return transformers.reduce(combineFunctions);
};
var conditional = function (check, apply) {
    return function (v) {
        return check(v) ? apply(v) : v;
    };
};
var slowInterpolate = function (input, output, rangeLength, rangeEasing) {
    var finalIndex = rangeLength - 1;
    if (input[0] > input[finalIndex]) {
        input.reverse();
        output.reverse();
    }
    return function (v) {
        if (v <= input[0]) {
            return output[0];
        }
        if (v >= input[finalIndex]) {
            return output[finalIndex];
        }
        var i = 1;
        for (; i < rangeLength; i++) {
            if (input[i] > v || i === finalIndex) {
                break;
            }
        }
        var progressInRange = getProgressFromValue(input[i - 1], input[i], v);
        var easedProgress = rangeEasing ? rangeEasing[i - 1](progressInRange) : progressInRange;
        return getValueFromProgress(output[i - 1], output[i], easedProgress);
    };
};
var fastInterpolate = function (minA, maxA, minB, maxB) {
    return function (v) {
        return (v - minA) * (maxB - minB) / (maxA - minA) + minB;
    };
};
var interpolate = function (input, output, rangeEasing) {
    var rangeLength = input.length;
    return rangeLength !== 2 ? slowInterpolate(input, output, rangeLength, rangeEasing) : fastInterpolate(input[0], input[1], output[0], output[1]);
};
var generateStaticSpring = function (alterDisplacement) {
    if (alterDisplacement === void 0) {
        alterDisplacement = identity;
    }
    return function (constant, origin) {
        return function (v) {
            var displacement = origin - v;
            var springModifiedDisplacement = -constant * (0 - alterDisplacement(Math.abs(displacement)));
            return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;
        };
    };
};
var linearSpring = /*#__PURE__*/generateStaticSpring();
var nonlinearSpring = /*#__PURE__*/generateStaticSpring(Math.sqrt);
var wrap = function (min, max) {
    return function (v) {
        var rangeSize = max - min;
        return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
    };
};
var smooth$1 = function (strength) {
    if (strength === void 0) {
        strength = 50;
    }
    var previousValue = 0;
    var lastUpdated = 0;
    return function (v) {
        var currentFramestamp = Object(framesync__WEBPACK_IMPORTED_MODULE_1__["currentFrameTime"])();
        var timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;
        var newValue = timeDelta ? smooth(v, previousValue, timeDelta, strength) : previousValue;
        lastUpdated = currentFramestamp;
        previousValue = newValue;
        return newValue;
    };
};
var snap = function (points) {
    if (typeof points === 'number') {
        return function (v) {
            return Math.round(v / points) * points;
        };
    } else {
        var i_1 = 0;
        var numPoints_1 = points.length;
        return function (v) {
            var lastDistance = Math.abs(points[0] - v);
            for (i_1 = 1; i_1 < numPoints_1; i_1++) {
                var point = points[i_1];
                var distance$$1 = Math.abs(point - v);
                if (distance$$1 === 0) return point;
                if (distance$$1 > lastDistance) return points[i_1 - 1];
                if (i_1 === numPoints_1 - 1) return point;
                lastDistance = distance$$1;
            }
        };
    }
};
var steps = function (st, min, max) {
    if (min === void 0) {
        min = 0;
    }
    if (max === void 0) {
        max = 1;
    }
    return function (v) {
        var progress = getProgressFromValue(min, max, v);
        return getValueFromProgress(min, max, stepProgress(st, progress));
    };
};
var transformMap = function (childTransformers) {
    return function (v) {
        var output = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, v);
        for (var key in childTransformers) {
            if (childTransformers.hasOwnProperty(key)) {
                var childTransformer = childTransformers[key];
                output[key] = childTransformer(v[key]);
            }
        }
        return output;
    };
};

var transformers = /*#__PURE__*/Object.freeze({
    appendUnit: appendUnit,
    applyOffset: applyOffset,
    blendColor: blendColor,
    blendArray: blendArray,
    clamp: clamp,
    pipe: pipe,
    conditional: conditional,
    interpolate: interpolate,
    generateStaticSpring: generateStaticSpring,
    linearSpring: linearSpring,
    nonlinearSpring: nonlinearSpring,
    wrap: wrap,
    smooth: smooth$1,
    snap: snap,
    steps: steps,
    transformMap: transformMap
});

var Chainable = /*#__PURE__*/function () {
    function Chainable(props) {
        if (props === void 0) {
            props = {};
        }
        this.props = props;
    }
    Chainable.prototype.applyMiddleware = function (middleware) {
        return this.create(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, this.props, { middleware: this.props.middleware ? [middleware].concat(this.props.middleware) : [middleware] }));
    };
    Chainable.prototype.pipe = function () {
        var funcs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            funcs[_i] = arguments[_i];
        }
        var pipedUpdate = funcs.length === 1 ? funcs[0] : pipe.apply(void 0, funcs);
        return this.applyMiddleware(function (update) {
            return function (v) {
                return update(pipedUpdate(v));
            };
        });
    };
    Chainable.prototype.while = function (predicate) {
        return this.applyMiddleware(function (update, complete) {
            return function (v) {
                return predicate(v) ? update(v) : complete();
            };
        });
    };
    Chainable.prototype.filter = function (predicate) {
        return this.applyMiddleware(function (update) {
            return function (v) {
                return predicate(v) && update(v);
            };
        });
    };
    return Chainable;
}();

var Observer = /*#__PURE__*/function () {
    function Observer(_a, observer) {
        var middleware = _a.middleware,
            onComplete = _a.onComplete;
        var _this = this;
        this.isActive = true;
        this.update = function (v) {
            if (_this.observer.update) _this.updateObserver(v);
        };
        this.complete = function () {
            if (_this.observer.complete && _this.isActive) _this.observer.complete();
            if (_this.onComplete) _this.onComplete();
            _this.isActive = false;
        };
        this.error = function (err) {
            if (_this.observer.error && _this.isActive) _this.observer.error(err);
            _this.isActive = false;
        };
        this.observer = observer;
        this.updateObserver = function (v) {
            return observer.update(v);
        };
        this.onComplete = onComplete;
        if (observer.update && middleware && middleware.length) {
            middleware.forEach(function (m) {
                return _this.updateObserver = m(_this.updateObserver, _this.complete);
            });
        }
    }
    return Observer;
}();
var createObserver = function (observerCandidate, _a, onComplete) {
    var middleware = _a.middleware;
    if (typeof observerCandidate === 'function') {
        return new Observer({ middleware: middleware, onComplete: onComplete }, { update: observerCandidate });
    } else {
        return new Observer({ middleware: middleware, onComplete: onComplete }, observerCandidate);
    }
};

var Action = /*#__PURE__*/function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(Action, _super);
    function Action() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Action.prototype.create = function (props) {
        return new Action(props);
    };
    Action.prototype.start = function (observerCandidate) {
        if (observerCandidate === void 0) {
            observerCandidate = {};
        }
        var isComplete = false;
        var subscription = {
            stop: function () {
                return undefined;
            }
        };
        var _a = this.props,
            init = _a.init,
            observerProps = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["init"]);
        var observer = createObserver(observerCandidate, observerProps, function () {
            isComplete = true;
            subscription.stop();
        });
        var api = init(observer);
        subscription = api ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, subscription, api) : subscription;
        if (observerCandidate.registerParent) {
            observerCandidate.registerParent(subscription);
        }
        if (isComplete) subscription.stop();
        return subscription;
    };
    return Action;
}(Chainable);
var action = function (init) {
    return new Action({ init: init });
};

var BaseMulticast = /*#__PURE__*/function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(BaseMulticast, _super);
    function BaseMulticast() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.subscribers = [];
        return _this;
    }
    BaseMulticast.prototype.complete = function () {
        this.subscribers.forEach(function (subscriber) {
            return subscriber.complete();
        });
    };
    BaseMulticast.prototype.error = function (err) {
        this.subscribers.forEach(function (subscriber) {
            return subscriber.error(err);
        });
    };
    BaseMulticast.prototype.update = function (v) {
        for (var i = 0; i < this.subscribers.length; i++) {
            this.subscribers[i].update(v);
        }
    };
    BaseMulticast.prototype.subscribe = function (observerCandidate) {
        var _this = this;
        var observer = createObserver(observerCandidate, this.props);
        this.subscribers.push(observer);
        var subscription = {
            unsubscribe: function () {
                var index = _this.subscribers.indexOf(observer);
                if (index !== -1) _this.subscribers.splice(index, 1);
            }
        };
        return subscription;
    };
    BaseMulticast.prototype.stop = function () {
        if (this.parent) this.parent.stop();
    };
    BaseMulticast.prototype.registerParent = function (subscription) {
        this.stop();
        this.parent = subscription;
    };
    return BaseMulticast;
}(Chainable);

var Multicast = /*#__PURE__*/function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(Multicast, _super);
    function Multicast() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Multicast.prototype.create = function (props) {
        return new Multicast(props);
    };
    return Multicast;
}(BaseMulticast);
var multicast = function () {
    return new Multicast();
};

var isValueList = function (v) {
    return Array.isArray(v);
};
var isSingleValue = function (v) {
    var typeOfV = typeof v;
    return typeOfV === 'string' || typeOfV === 'number';
};
var ValueReaction = /*#__PURE__*/function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(ValueReaction, _super);
    function ValueReaction(props) {
        var _this = _super.call(this, props) || this;
        _this.scheduleVelocityCheck = function () {
            return Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameEnd"])(_this.velocityCheck);
        };
        _this.velocityCheck = function () {
            if (Object(framesync__WEBPACK_IMPORTED_MODULE_1__["currentFrameTime"])() !== _this.lastUpdated) {
                _this.prev = _this.current;
            }
        };
        _this.prev = _this.current = props.value || 0;
        if (isSingleValue(_this.current)) {
            _this.updateCurrent = function (v) {
                return _this.current = v;
            };
            _this.getVelocityOfCurrent = function () {
                return _this.getSingleVelocity(_this.current, _this.prev);
            };
        } else if (isValueList(_this.current)) {
            _this.updateCurrent = function (v) {
                return _this.current = v.slice();
            };
            _this.getVelocityOfCurrent = function () {
                return _this.getListVelocity();
            };
        } else {
            _this.updateCurrent = function (v) {
                _this.current = {};
                for (var key in v) {
                    if (v.hasOwnProperty(key)) {
                        _this.current[key] = v[key];
                    }
                }
            };
            _this.getVelocityOfCurrent = function () {
                return _this.getMapVelocity();
            };
        }
        if (props.initialSubscription) _this.subscribe(props.initialSubscription);
        return _this;
    }
    ValueReaction.prototype.create = function (props) {
        return new ValueReaction(props);
    };
    ValueReaction.prototype.get = function () {
        return this.current;
    };
    ValueReaction.prototype.getVelocity = function () {
        return this.getVelocityOfCurrent();
    };
    ValueReaction.prototype.update = function (v) {
        _super.prototype.update.call(this, v);
        this.prev = this.current;
        this.updateCurrent(v);
        this.timeDelta = Object(framesync__WEBPACK_IMPORTED_MODULE_1__["timeSinceLastFrame"])();
        this.lastUpdated = Object(framesync__WEBPACK_IMPORTED_MODULE_1__["currentFrameTime"])();
        Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameEnd"])(this.scheduleVelocityCheck);
    };
    ValueReaction.prototype.subscribe = function (observerCandidate) {
        var sub = _super.prototype.subscribe.call(this, observerCandidate);
        this.update(this.current);
        return sub;
    };
    ValueReaction.prototype.getSingleVelocity = function (current, prev) {
        return typeof current === 'number' && typeof prev === 'number' ? speedPerSecond(current - prev, this.timeDelta) : speedPerSecond(parseFloat(current) - parseFloat(prev), this.timeDelta) || 0;
    };
    ValueReaction.prototype.getListVelocity = function () {
        var _this = this;
        return this.current.map(function (c, i) {
            return _this.getSingleVelocity(c, _this.prev[i]);
        });
    };
    ValueReaction.prototype.getMapVelocity = function () {
        var velocity = {};
        for (var key in this.current) {
            if (this.current.hasOwnProperty(key)) {
                velocity[key] = this.getSingleVelocity(this.current[key], this.prev[key]);
            }
        }
        return velocity;
    };
    return ValueReaction;
}(BaseMulticast);
var value = function (value, initialSubscription) {
    return new ValueReaction({ value: value, initialSubscription: initialSubscription });
};

var multi = function (_a) {
    var getCount = _a.getCount,
        getFirst = _a.getFirst,
        getOutput = _a.getOutput,
        mapApi = _a.mapApi,
        setProp = _a.setProp,
        startActions = _a.startActions;
    return function (actions) {
        return action(function (_a) {
            var update = _a.update,
                complete = _a.complete,
                error = _a.error;
            var numActions = getCount(actions);
            var output = getOutput();
            var updateOutput = function () {
                return update(output);
            };
            var numCompletedActions = 0;
            var subs = startActions(actions, function (a, name) {
                var hasCompleted = false;
                return a.start({
                    complete: function () {
                        if (!hasCompleted) {
                            hasCompleted = true;
                            numCompletedActions++;
                            if (numCompletedActions === numActions) Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(complete);
                        }
                    },
                    error: error,
                    update: function (v) {
                        setProp(output, name, v);
                        Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(updateOutput, true);
                    }
                });
            });
            return Object.keys(getFirst(subs)).reduce(function (api, methodName) {
                api[methodName] = mapApi(subs, methodName);
                return api;
            }, {});
        });
    };
};

var composite = /*#__PURE__*/multi({
    getOutput: function () {
        return {};
    },
    getCount: function (subs) {
        return Object.keys(subs).length;
    },
    getFirst: function (subs) {
        return subs[Object.keys(subs)[0]];
    },
    mapApi: function (subs, methodName) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return Object.keys(subs).reduce(function (output, propKey) {
                var _a;
                if (subs[propKey][methodName]) {
                    args[0] && args[0][propKey] !== undefined ? output[propKey] = subs[propKey][methodName](args[0][propKey]) : output[propKey] = (_a = subs[propKey])[methodName].apply(_a, args);
                }
                return output;
            }, {});
        };
    },
    setProp: function (output, name, v) {
        return output[name] = v;
    },
    startActions: function (actions, starter) {
        return Object.keys(actions).reduce(function (subs, key) {
            subs[key] = starter(actions[key], key);
            return subs;
        }, {});
    }
});

var parallel = /*#__PURE__*/multi({
    getOutput: function () {
        return [];
    },
    getCount: function (subs) {
        return subs.length;
    },
    getFirst: function (subs) {
        return subs[0];
    },
    mapApi: function (subs, methodName) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return subs.map(function (sub, i) {
                if (sub[methodName]) {
                    return Array.isArray(args[0]) ? sub[methodName](args[0][i]) : sub[methodName].apply(sub, args);
                }
            });
        };
    },
    setProp: function (output, name, v) {
        return output[name] = v;
    },
    startActions: function (actions, starter) {
        return actions.map(function (action, i) {
            return starter(action, i);
        });
    }
});
var parallel$1 = function () {
    var actions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actions[_i] = arguments[_i];
    }
    return parallel(actions);
};

var createVectorTests = function (typeTests) {
    var testNames = Object.keys(typeTests);
    var isVectorProp = function (prop, key) {
        return prop !== undefined && !typeTests[key](prop);
    };
    var getVectorKeys = function (props) {
        return testNames.reduce(function (vectorKeys, key) {
            if (isVectorProp(props[key], key)) vectorKeys.push(key);
            return vectorKeys;
        }, []);
    };
    var testVectorProps = function (props) {
        return props && testNames.some(function (key) {
            return isVectorProp(props[key], key);
        });
    };
    return { getVectorKeys: getVectorKeys, testVectorProps: testVectorProps };
};
var unitTypes = [style_value_types__WEBPACK_IMPORTED_MODULE_2__["px"], style_value_types__WEBPACK_IMPORTED_MODULE_2__["percent"], style_value_types__WEBPACK_IMPORTED_MODULE_2__["degrees"], style_value_types__WEBPACK_IMPORTED_MODULE_2__["vh"], style_value_types__WEBPACK_IMPORTED_MODULE_2__["vw"]];
var findUnitType = function (prop) {
    return unitTypes.find(function (type) {
        return type.test(prop);
    });
};
var isUnitProp = function (prop) {
    return Boolean(findUnitType(prop));
};
var createAction = function (action, props) {
    return action(props);
};
var reduceArrayValue = function (i) {
    return function (props, key) {
        props[key] = props[key][i];
        return props;
    };
};
var createArrayAction = function (action, props, vectorKeys) {
    var firstVectorKey = vectorKeys[0];
    var actionList = props[firstVectorKey].map(function (v, i) {
        var childActionProps = vectorKeys.reduce(reduceArrayValue(i), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, props));
        return getActionCreator(v)(action, childActionProps);
    });
    return parallel$1.apply(void 0, actionList);
};
var reduceObjectValue = function (key) {
    return function (props, propKey) {
        props[propKey] = props[propKey][key];
        return props;
    };
};
var createObjectAction = function (action, props, vectorKeys) {
    var firstVectorKey = vectorKeys[0];
    var actionMap = Object.keys(props[firstVectorKey]).reduce(function (map, key) {
        var childActionProps = vectorKeys.reduce(reduceObjectValue(key), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, props));
        map[key] = getActionCreator(props[firstVectorKey][key])(action, childActionProps);
        return map;
    }, {});
    return composite(actionMap);
};
var createUnitAction = function (action, _a) {
    var from = _a.from,
        to = _a.to,
        props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["from", "to"]);
    var unitType = findUnitType(from) || findUnitType(to);
    var transform = unitType.transform,
        parse = unitType.parse;
    return action(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, props, { from: typeof from === 'string' ? parse(from) : from, to: typeof to === 'string' ? parse(to) : to })).pipe(transform);
};
var createColorAction = function (action, _a) {
    var from = _a.from,
        to = _a.to,
        props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["from", "to"]);
    return action(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, props, { from: 0, to: 1 })).pipe(blendColor(from, to), style_value_types__WEBPACK_IMPORTED_MODULE_2__["color"].transform);
};
var createComplexAction = function (action, _a) {
    var from = _a.from,
        to = _a.to,
        props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["from", "to"]);
    var valueTemplate = style_value_types__WEBPACK_IMPORTED_MODULE_2__["complex"].createTransformer(from);
    Object(hey_listen__WEBPACK_IMPORTED_MODULE_3__["invariant"])(valueTemplate(from) === style_value_types__WEBPACK_IMPORTED_MODULE_2__["complex"].createTransformer(to)(from), "Values '" + from + "' and '" + to + "' are of different format, or a value might have changed value type.");
    return action(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, props, { from: 0, to: 1 })).pipe(blendArray(style_value_types__WEBPACK_IMPORTED_MODULE_2__["complex"].parse(from), style_value_types__WEBPACK_IMPORTED_MODULE_2__["complex"].parse(to)), valueTemplate);
};
var createVectorAction = function (action, typeTests) {
    var _a = createVectorTests(typeTests),
        testVectorProps = _a.testVectorProps,
        getVectorKeys = _a.getVectorKeys;
    var vectorAction = function (props) {
        var isVector = testVectorProps(props);
        if (!isVector) return action(props);
        var vectorKeys = getVectorKeys(props);
        var testKey = vectorKeys[0];
        var testProp = props[testKey];
        return getActionCreator(testProp)(action, props, vectorKeys);
    };
    return vectorAction;
};
var getActionCreator = function (prop) {
    var actionCreator = createAction;
    if (typeof prop === 'number') {
        actionCreator = createAction;
    } else if (Array.isArray(prop)) {
        actionCreator = createArrayAction;
    } else if (isUnitProp(prop)) {
        actionCreator = createUnitAction;
    } else if (style_value_types__WEBPACK_IMPORTED_MODULE_2__["color"].test(prop)) {
        actionCreator = createColorAction;
    } else if (style_value_types__WEBPACK_IMPORTED_MODULE_2__["complex"].test(prop)) {
        actionCreator = createComplexAction;
    } else if (typeof prop === 'object') {
        actionCreator = createObjectAction;
    }
    return actionCreator;
};

var frame = function () {
    return action(function (_a) {
        var update = _a.update;
        var isActive = true;
        var startTime = Object(framesync__WEBPACK_IMPORTED_MODULE_1__["currentTime"])();
        var nextFrame = function () {
            if (!isActive) return;
            update(Math.max(Object(framesync__WEBPACK_IMPORTED_MODULE_1__["currentFrameTime"])() - startTime, 0));
            Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(nextFrame);
        };
        Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(nextFrame);
        return {
            stop: function () {
                return isActive = false;
            }
        };
    });
};

var decay = function (props) {
    if (props === void 0) {
        props = {};
    }
    return action(function (_a) {
        var complete = _a.complete,
            update = _a.update;
        var _b = props.velocity,
            velocity = _b === void 0 ? 0 : _b,
            _c = props.from,
            from = _c === void 0 ? 0 : _c,
            _d = props.power,
            power = _d === void 0 ? 0.8 : _d,
            _e = props.timeConstant,
            timeConstant = _e === void 0 ? 350 : _e,
            _f = props.restDelta,
            restDelta = _f === void 0 ? 0.5 : _f,
            modifyTarget = props.modifyTarget;
        var elapsed = 0;
        var amplitude = power * velocity;
        var idealTarget = Math.round(from + amplitude);
        var target = typeof modifyTarget === 'undefined' ? idealTarget : modifyTarget(idealTarget);
        var timer = frame().start(function () {
            elapsed += Object(framesync__WEBPACK_IMPORTED_MODULE_1__["timeSinceLastFrame"])();
            var delta = -amplitude * Math.exp(-elapsed / timeConstant);
            var isMoving = delta > restDelta || delta < -restDelta;
            var current = isMoving ? target + delta : target;
            update(current);
            if (!isMoving) {
                timer.stop();
                complete();
            }
        });
        return {
            stop: function () {
                return timer.stop();
            }
        };
    });
};
var vectorDecay = /*#__PURE__*/createVectorAction(decay, {
    from: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    modifyTarget: function (func) {
        return typeof func === 'function';
    },
    velocity: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test
});

var scrubber = function (_a) {
    var _b = _a.from,
        from = _b === void 0 ? 0 : _b,
        _c = _a.to,
        to = _c === void 0 ? 1 : _c,
        _d = _a.ease,
        ease = _d === void 0 ? _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__["linear"] : _d;
    return action(function (_a) {
        var update = _a.update;
        return {
            seek: function (progress) {
                return update(progress);
            }
        };
    }).pipe(ease, function (v) {
        return getValueFromProgress(from, to, v);
    });
};
var vectorScrubber = /*#__PURE__*/createVectorAction(scrubber, {
    ease: function (func) {
        return typeof func === 'function';
    },
    from: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    to: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test
});

var clampProgress = /*#__PURE__*/clamp(0, 1);
var tween = function (props) {
    if (props === void 0) {
        props = {};
    }
    return action(function (_a) {
        var update = _a.update,
            complete = _a.complete;
        var _b = props.duration,
            duration = _b === void 0 ? 300 : _b,
            _c = props.ease,
            ease = _c === void 0 ? _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__["easeOut"] : _c,
            _d = props.flip,
            flip = _d === void 0 ? 0 : _d,
            _e = props.loop,
            loop = _e === void 0 ? 0 : _e,
            _f = props.yoyo,
            yoyo = _f === void 0 ? 0 : _f;
        var _g = props.from,
            from = _g === void 0 ? 0 : _g,
            _h = props.to,
            to = _h === void 0 ? 1 : _h,
            _j = props.elapsed,
            elapsed = _j === void 0 ? 0 : _j,
            _k = props.playDirection,
            playDirection = _k === void 0 ? 1 : _k,
            _l = props.flipCount,
            flipCount = _l === void 0 ? 0 : _l,
            _m = props.yoyoCount,
            yoyoCount = _m === void 0 ? 0 : _m,
            _o = props.loopCount,
            loopCount = _o === void 0 ? 0 : _o;
        var playhead = vectorScrubber({ from: from, to: to, ease: ease }).start(update);
        var progress = 0;
        var tweenTimer;
        var isActive = false;
        var reverseTween = function () {
            return playDirection *= -1;
        };
        var isTweenComplete = function () {
            var _a;
            var isComplete = playDirection === 1 ? isActive && elapsed >= duration : isActive && elapsed <= 0;
            if (!isComplete) return false;
            if (isComplete && !loop && !flip && !yoyo) return true;
            var isStepTaken = false;
            if (loop && loopCount < loop) {
                elapsed = 0;
                loopCount++;
                isStepTaken = true;
            } else if (flip && flipCount < flip) {
                elapsed = duration - elapsed;
                _a = [to, from], from = _a[0], to = _a[1];
                playhead = vectorScrubber({ from: from, to: to, ease: ease }).start(update);
                flipCount++;
                isStepTaken = true;
            } else if (yoyo && yoyoCount < yoyo) {
                reverseTween();
                yoyoCount++;
                isStepTaken = true;
            }
            return !isStepTaken;
        };
        var updateTween = function () {
            progress = clampProgress(getProgressFromValue(0, duration, elapsed));
            playhead.seek(progress);
        };
        var startTimer = function () {
            isActive = true;
            tweenTimer = frame().start(function () {
                elapsed += Object(framesync__WEBPACK_IMPORTED_MODULE_1__["timeSinceLastFrame"])() * playDirection;
                updateTween();
                if (isTweenComplete() && complete) {
                    tweenTimer.stop();
                    Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(complete, true);
                }
            });
        };
        var stopTimer = function () {
            isActive = false;
            if (tweenTimer) tweenTimer.stop();
        };
        startTimer();
        return {
            isActive: function () {
                return isActive;
            },
            getElapsed: function () {
                return clamp(0, duration)(elapsed);
            },
            getProgress: function () {
                return progress;
            },
            stop: function () {
                stopTimer();
            },
            pause: function () {
                stopTimer();
                return this;
            },
            resume: function () {
                if (!isActive) startTimer();
                return this;
            },
            seek: function (newProgress) {
                elapsed = getValueFromProgress(0, duration, newProgress);
                Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(updateTween, true);
                return this;
            },
            reverse: function () {
                reverseTween();
                return this;
            }
        };
    });
};

var clampProgress$1 = /*#__PURE__*/clamp(0, 1);
var defaultEasings = function (values, easing$$1) {
    return values.map(function () {
        return easing$$1 || _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__["easeOut"];
    }).splice(0, values.length - 1);
};
var defaultTimings = function (values) {
    var numValues = values.length;
    return values.map(function (value, i) {
        return i !== 0 ? i / (numValues - 1) : 0;
    });
};
var interpolateScrubbers = function (input, scrubbers, update) {
    var rangeLength = input.length;
    var finalInputIndex = rangeLength - 1;
    var finalScrubberIndex = finalInputIndex - 1;
    var subs = scrubbers.map(function (scrub) {
        return scrub.start(update);
    });
    return function (v) {
        if (v <= input[0]) {
            subs[0].seek(0);
        }
        if (v >= input[finalInputIndex]) {
            subs[finalScrubberIndex].seek(1);
        }
        var i = 1;
        for (; i < rangeLength; i++) {
            if (input[i] > v || i === finalInputIndex) break;
        }
        var progressInRange = getProgressFromValue(input[i - 1], input[i], v);
        subs[i - 1].seek(clampProgress$1(progressInRange));
    };
};
var keyframes = function (_a) {
    var easings = _a.easings,
        _b = _a.ease,
        ease = _b === void 0 ? _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__["linear"] : _b,
        times = _a.times,
        values = _a.values,
        tweenProps = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["easings", "ease", "times", "values"]);
    easings = Array.isArray(easings) ? easings : defaultEasings(values, easings);
    times = times || defaultTimings(values);
    var scrubbers = easings.map(function (easing$$1, i) {
        return vectorScrubber({
            from: values[i],
            to: values[i + 1],
            ease: easing$$1
        });
    });
    return tween(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, tweenProps, { ease: ease })).applyMiddleware(function (update) {
        return interpolateScrubbers(times, scrubbers, update);
    });
};

var physics = function (props) {
    if (props === void 0) {
        props = {};
    }
    return action(function (_a) {
        var complete = _a.complete,
            update = _a.update;
        var _b = props.acceleration,
            acceleration = _b === void 0 ? 0 : _b,
            _c = props.friction,
            friction = _c === void 0 ? 0 : _c,
            _d = props.velocity,
            velocity = _d === void 0 ? 0 : _d,
            springStrength = props.springStrength,
            to = props.to;
        var _e = props.restSpeed,
            restSpeed = _e === void 0 ? 0.001 : _e,
            _f = props.from,
            from = _f === void 0 ? 0 : _f;
        var current = from;
        var timer = frame().start(function () {
            var elapsed = Math.max(Object(framesync__WEBPACK_IMPORTED_MODULE_1__["timeSinceLastFrame"])(), 16);
            if (acceleration) velocity += speedPerFrame(acceleration, elapsed);
            if (friction) velocity *= Math.pow(1 - friction, elapsed / 100);
            if (springStrength !== undefined && to !== undefined) {
                var distanceToTarget = to - current;
                velocity += distanceToTarget * speedPerFrame(springStrength, elapsed);
            }
            current += speedPerFrame(velocity, elapsed);
            update(current);
            var isComplete = restSpeed !== false && (!velocity || Math.abs(velocity) <= restSpeed);
            if (isComplete) {
                timer.stop();
                complete();
            }
        });
        return {
            set: function (v) {
                current = v;
                return this;
            },
            setAcceleration: function (v) {
                acceleration = v;
                return this;
            },
            setFriction: function (v) {
                friction = v;
                return this;
            },
            setSpringStrength: function (v) {
                springStrength = v;
                return this;
            },
            setSpringTarget: function (v) {
                to = v;
                return this;
            },
            setVelocity: function (v) {
                velocity = v;
                return this;
            },
            stop: function () {
                return timer.stop();
            }
        };
    });
};
var vectorPhysics = /*#__PURE__*/createVectorAction(physics, {
    acceleration: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    friction: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    velocity: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    from: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    to: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    springStrength: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test
});

var spring = function (props) {
    if (props === void 0) {
        props = {};
    }
    return action(function (_a) {
        var update = _a.update,
            complete = _a.complete;
        var _b = props.velocity,
            velocity = _b === void 0 ? 0.0 : _b;
        var _c = props.from,
            from = _c === void 0 ? 0.0 : _c,
            _d = props.to,
            to = _d === void 0 ? 0.0 : _d,
            _e = props.stiffness,
            stiffness = _e === void 0 ? 100 : _e,
            _f = props.damping,
            damping = _f === void 0 ? 10 : _f,
            _g = props.mass,
            mass = _g === void 0 ? 1.0 : _g,
            _h = props.restSpeed,
            restSpeed = _h === void 0 ? 0.01 : _h,
            _j = props.restDelta,
            restDelta = _j === void 0 ? 0.01 : _j;
        var initialVelocity = velocity ? -(velocity / 1000) : 0.0;
        var t = 0;
        var delta = to - from;
        var position = from;
        var prevPosition = position;
        var springTimer = frame().start(function () {
            var timeDelta = Object(framesync__WEBPACK_IMPORTED_MODULE_1__["timeSinceLastFrame"])();
            t += timeDelta;
            var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
            var angularFreq = Math.sqrt(stiffness / mass) / 1000;
            prevPosition = position;
            if (dampingRatio < 1) {
                var envelope = Math.exp(-dampingRatio * angularFreq * t);
                var expoDecay = angularFreq * Math.sqrt(1.0 - dampingRatio * dampingRatio);
                position = to - envelope * ((initialVelocity + dampingRatio * angularFreq * delta) / expoDecay * Math.sin(expoDecay * t) + delta * Math.cos(expoDecay * t));
            } else {
                var envelope = Math.exp(-angularFreq * t);
                position = to - envelope * (delta + (initialVelocity + angularFreq * delta) * t);
            }
            velocity = speedPerSecond(position - prevPosition, timeDelta);
            var isBelowVelocityThreshold = Math.abs(velocity) <= restSpeed;
            var isBelowDisplacementThreshold = Math.abs(to - position) <= restDelta;
            if (isBelowVelocityThreshold && isBelowDisplacementThreshold) {
                position = to;
                update(position);
                springTimer.stop();
                complete();
            } else {
                update(position);
            }
        });
        return {
            stop: function () {
                return springTimer.stop();
            }
        };
    });
};
var vectorSpring = /*#__PURE__*/createVectorAction(spring, {
    from: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    to: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    stiffness: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    damping: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    mass: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test,
    velocity: style_value_types__WEBPACK_IMPORTED_MODULE_2__["number"].test
});

var DEFAULT_DURATION = 300;
var flattenTimings = function (instructions) {
    var flatInstructions = [];
    var lastArg = instructions[instructions.length - 1];
    var isStaggered = typeof lastArg === 'number';
    var staggerDelay = isStaggered ? lastArg : 0;
    var segments = isStaggered ? instructions.slice(0, -1) : instructions;
    var numSegments = segments.length;
    var offset = 0;
    segments.forEach(function (item, i) {
        flatInstructions.push(item);
        if (i !== numSegments - 1) {
            var duration = item.duration || DEFAULT_DURATION;
            offset += staggerDelay;
            flatInstructions.push("-" + (duration - offset));
        }
    });
    return flatInstructions;
};
var flattenArrayInstructions = function (instructions, instruction) {
    Array.isArray(instruction) ? instructions.push.apply(instructions, flattenTimings(instruction)) : instructions.push(instruction);
    return instructions;
};
var convertDefToProps = function (props, def, i) {
    var duration = props.duration,
        easings = props.easings,
        times = props.times,
        values = props.values;
    var numValues = values.length;
    var prevTimeTo = times[numValues - 1];
    var timeFrom = def.at === 0 ? 0 : def.at / duration;
    var timeTo = (def.at + def.duration) / duration;
    if (i === 0) {
        values.push(def.from);
        times.push(timeFrom);
    } else {
        if (prevTimeTo !== timeFrom) {
            if (def.from !== undefined) {
                values.push(values[numValues - 1]);
                times.push(timeFrom);
                easings.push(_popmotion_easing__WEBPACK_IMPORTED_MODULE_4__["linear"]);
            }
            var from = def.from !== undefined ? def.from : values[numValues - 1];
            values.push(from);
            times.push(timeFrom);
            easings.push(_popmotion_easing__WEBPACK_IMPORTED_MODULE_4__["linear"]);
        } else if (def.from !== undefined) {
            values.push(def.from);
            times.push(timeFrom);
            easings.push(_popmotion_easing__WEBPACK_IMPORTED_MODULE_4__["linear"]);
        }
    }
    values.push(def.to);
    times.push(timeTo);
    easings.push(def.ease || _popmotion_easing__WEBPACK_IMPORTED_MODULE_4__["easeInOut"]);
    return props;
};
var timeline = function (instructions, _a) {
    var _b = _a === void 0 ? {} : _a,
        duration = _b.duration,
        elapsed = _b.elapsed,
        ease = _b.ease,
        loop = _b.loop,
        flip = _b.flip,
        yoyo = _b.yoyo;
    var playhead = 0;
    var calculatedDuration = 0;
    var flatInstructions = instructions.reduce(flattenArrayInstructions, []);
    var animationDefs = [];
    flatInstructions.forEach(function (instruction) {
        if (typeof instruction === 'string') {
            playhead += parseFloat(instruction);
        } else if (typeof instruction === 'number') {
            playhead = instruction;
        } else {
            var def = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, instruction, { at: playhead });
            def.duration = def.duration === undefined ? DEFAULT_DURATION : def.duration;
            animationDefs.push(def);
            playhead += def.duration;
            calculatedDuration = Math.max(calculatedDuration, def.at + def.duration);
        }
    });
    var tracks = {};
    var numDefs = animationDefs.length;
    for (var i = 0; i < numDefs; i++) {
        var def = animationDefs[i];
        var track = def.track;
        if (track === undefined) {
            throw new Error('No track defined');
        }
        if (!tracks.hasOwnProperty(track)) tracks[track] = [];
        tracks[track].push(def);
    }
    var trackKeyframes = {};
    for (var key in tracks) {
        if (tracks.hasOwnProperty(key)) {
            var keyframeProps = tracks[key].reduce(convertDefToProps, {
                duration: calculatedDuration,
                easings: [],
                times: [],
                values: []
            });
            trackKeyframes[key] = keyframes(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, keyframeProps, { duration: duration || calculatedDuration, ease: ease,
                elapsed: elapsed,
                loop: loop,
                yoyo: yoyo,
                flip: flip }));
        }
    }
    return composite(trackKeyframes);
};

var listen = function (element, events, options) {
    return action(function (_a) {
        var update = _a.update;
        var eventNames = events.split(' ').map(function (eventName) {
            element.addEventListener(eventName, update, options);
            return eventName;
        });
        return {
            stop: function () {
                return eventNames.forEach(function (eventName) {
                    return element.removeEventListener(eventName, update, options);
                });
            }
        };
    });
};

var defaultPointerPos = function () {
    return {
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        x: 0,
        y: 0
    };
};
var eventToPoint = function (e, point) {
    if (point === void 0) {
        point = defaultPointerPos();
    }
    point.clientX = point.x = e.clientX;
    point.clientY = point.y = e.clientY;
    point.pageX = e.pageX;
    point.pageY = e.pageY;
    return point;
};

var points = [/*#__PURE__*/defaultPointerPos()];
var isTouchDevice = false;
if (typeof document !== 'undefined') {
    var updatePointsLocation = function (_a) {
        var touches = _a.touches;
        isTouchDevice = true;
        var numTouches = touches.length;
        points.length = 0;
        for (var i = 0; i < numTouches; i++) {
            var thisTouch = touches[i];
            points.push(eventToPoint(thisTouch));
        }
    };
    listen(document, 'touchstart touchmove', {
        passive: true,
        capture: true
    }).start(updatePointsLocation);
}
var multitouch = function (_a) {
    var _b = _a === void 0 ? {} : _a,
        _c = _b.preventDefault,
        preventDefault = _c === void 0 ? true : _c,
        _d = _b.scale,
        scale = _d === void 0 ? 1.0 : _d,
        _e = _b.rotate,
        rotate = _e === void 0 ? 0.0 : _e;
    return action(function (_a) {
        var update = _a.update;
        var output = {
            touches: points,
            scale: scale,
            rotate: rotate
        };
        var initialDistance = 0.0;
        var initialRotation = 0.0;
        var isGesture = points.length > 1;
        if (isGesture) {
            var firstTouch = points[0],
                secondTouch = points[1];
            initialDistance = distance(firstTouch, secondTouch);
            initialRotation = angle(firstTouch, secondTouch);
        }
        var updatePoint = function () {
            if (isGesture) {
                var firstTouch = points[0],
                    secondTouch = points[1];
                var newDistance = distance(firstTouch, secondTouch);
                var newRotation = angle(firstTouch, secondTouch);
                output.scale = scale * (newDistance / initialDistance);
                output.rotate = rotate + (newRotation - initialRotation);
            }
            update(output);
        };
        var onMove = function (e) {
            if (preventDefault || e.touches.length > 1) e.preventDefault();
            Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(updatePoint);
        };
        var updateOnMove = listen(document, 'touchmove', {
            passive: !preventDefault
        }).start(onMove);
        if (isTouchDevice) Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(updatePoint);
        return {
            stop: function () {
                Object(framesync__WEBPACK_IMPORTED_MODULE_1__["cancelOnFrameUpdate"])(updatePoint);
                updateOnMove.stop();
            }
        };
    });
};
var getIsTouchDevice = function () {
    return isTouchDevice;
};

var point = /*#__PURE__*/defaultPointerPos();
var isMouseDevice = false;
if (typeof document !== 'undefined') {
    var updatePointLocation = function (e) {
        isMouseDevice = true;
        eventToPoint(e, point);
    };
    listen(document, 'mousedown mousemove', true).start(updatePointLocation);
}
var mouse = function (_a) {
    var _b = (_a === void 0 ? {} : _a).preventDefault,
        preventDefault = _b === void 0 ? true : _b;
    return action(function (_a) {
        var update = _a.update;
        var updatePoint = function () {
            return update(point);
        };
        var onMove = function (e) {
            if (preventDefault) e.preventDefault();
            Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(updatePoint);
        };
        var updateOnMove = listen(document, 'mousemove').start(onMove);
        if (isMouseDevice) Object(framesync__WEBPACK_IMPORTED_MODULE_1__["onFrameUpdate"])(updatePoint);
        return {
            stop: function () {
                Object(framesync__WEBPACK_IMPORTED_MODULE_1__["cancelOnFrameUpdate"])(updatePoint);
                updateOnMove.stop();
            }
        };
    });
};

var getFirstTouch = function (_a) {
    var firstTouch = _a[0];
    return firstTouch;
};
var pointer = function (props) {
    if (props === void 0) {
        props = {};
    }
    return getIsTouchDevice() ? multitouch(props).pipe(function (_a) {
        var touches = _a.touches;
        return touches;
    }, getFirstTouch) : mouse(props);
};
var index = function (_a) {
    if (_a === void 0) {
        _a = {};
    }
    var x = _a.x,
        y = _a.y,
        props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["x", "y"]);
    if (x !== undefined || y !== undefined) {
        var applyXOffset_1 = applyOffset(x || 0);
        var applyYOffset_1 = applyOffset(y || 0);
        var delta_1 = { x: 0, y: 0 };
        return pointer(props).pipe(function (point) {
            delta_1.x = applyXOffset_1(point.x);
            delta_1.y = applyYOffset_1(point.y);
            return delta_1;
        });
    } else {
        return pointer(props);
    }
};

var chain = function () {
    var actions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actions[_i] = arguments[_i];
    }
    return action(function (_a) {
        var update = _a.update,
            complete = _a.complete;
        var i = 0;
        var current;
        var playCurrent = function () {
            current = actions[i].start({
                complete: function () {
                    i++;
                    i >= actions.length ? complete() : playCurrent();
                },
                update: update
            });
        };
        playCurrent();
        return {
            stop: function () {
                return current && current.stop();
            }
        };
    });
};

var crossfade = function (a, b) {
    return action(function (observer) {
        var balance = 0;
        var fadable = parallel$1(a, b).start(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, observer, { update: function (_a) {
                var va = _a[0],
                    vb = _a[1];
                observer.update(getValueFromProgress(va, vb, balance));
            } }));
        return {
            setBalance: function (v) {
                return balance = v;
            },
            stop: function () {
                return fadable.stop();
            }
        };
    });
};

var delay = function (timeToDelay) {
    return action(function (_a) {
        var complete = _a.complete;
        var timeout = setTimeout(complete, timeToDelay);
        return {
            stop: function () {
                return clearTimeout(timeout);
            }
        };
    });
};

var merge = function () {
    var actions = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        actions[_i] = arguments[_i];
    }
    return action(function (observer) {
        var subs = actions.map(function (thisAction) {
            return thisAction.start(observer);
        });
        return {
            stop: function () {
                return subs.forEach(function (sub) {
                    return sub.stop();
                });
            }
        };
    });
};

var schedule = function (scheduler, schedulee) {
    return action(function (_a) {
        var update = _a.update,
            complete = _a.complete;
        var latest;
        var schedulerSub = scheduler.start({
            update: function () {
                return latest !== undefined && update(latest);
            },
            complete: complete
        });
        var scheduleeSub = schedulee.start({
            update: function (v) {
                return latest = v;
            },
            complete: complete
        });
        return {
            stop: function () {
                schedulerSub.stop();
                scheduleeSub.stop();
            }
        };
    });
};

var stagger = function (actions, interval) {
    var intervalIsNumber = typeof interval === 'number';
    var actionsWithDelay = actions.map(function (a, i) {
        var timeToDelay = intervalIsNumber ? interval * i : interval(i);
        return chain(delay(timeToDelay), a);
    });
    return parallel$1.apply(void 0, actionsWithDelay);
};

var css = function (element, props) {
    Object(hey_listen__WEBPACK_IMPORTED_MODULE_3__["warning"])(false, 'css() is deprecated, use styler instead');
    return Object(stylefire__WEBPACK_IMPORTED_MODULE_5__["default"])(element, props);
};
var svg = function (element, props) {
    Object(hey_listen__WEBPACK_IMPORTED_MODULE_3__["warning"])(false, 'svg() is deprecated, use styler instead');
    return Object(stylefire__WEBPACK_IMPORTED_MODULE_5__["default"])(element, props);
};




/***/ }),

/***/ "./node_modules/pose-core/dist/pose-core.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/pose-core/dist/pose-core.es.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hey-listen */ "./node_modules/hey-listen/dist/hey-listen.es.js");



var getPoseValues = function (_a) {
    var transition = _a.transition,
        delay = _a.delay,
        delayChildren = _a.delayChildren,
        staggerChildren = _a.staggerChildren,
        staggerDirection = _a.staggerDirection,
        afterChildren = _a.afterChildren,
        beforeChildren = _a.beforeChildren,
        preTransition = _a.preTransition,
        applyAtStart = _a.applyAtStart,
        applyAtEnd = _a.applyAtEnd,
        props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["transition", "delay", "delayChildren", "staggerChildren", "staggerDirection", "afterChildren", "beforeChildren", "preTransition", "applyAtStart", "applyAtEnd"]);
    return props;
};
var selectPoses = function (_a) {
    var label = _a.label,
        props = _a.props,
        values = _a.values,
        parentValues = _a.parentValues,
        ancestorValues = _a.ancestorValues,
        onChange = _a.onChange,
        passive = _a.passive,
        initialPose = _a.initialPose,
        poses = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["label", "props", "values", "parentValues", "ancestorValues", "onChange", "passive", "initialPose"]);
    return poses;
};
var selectAllValues = function (values, selectValue) {
    var allValues = {};
    values.forEach(function (value, key) {
        return allValues[key] = selectValue(value);
    });
    return allValues;
};

var resolveProp = function (target, props) {
    return typeof target === 'function' ? target(props) : target;
};
var poseDefault = function (pose, prop, defaultValue, resolveProps) {
    return pose && pose[prop] !== undefined ? resolveProp(pose[prop], resolveProps) : defaultValue;
};
var startChildAnimations = function (children, next, pose, props) {
    var animations = [];
    var delay = poseDefault(pose, 'delayChildren', 0, props);
    var stagger = poseDefault(pose, 'staggerChildren', 0, props);
    var staggerDirection = poseDefault(pose, 'staggerDirection', 1, props);
    var maxStaggerDuration = (children.size - 1) * stagger;
    var generateStaggerDuration = staggerDirection === 1 ? function (i) {
        return i * stagger;
    } : function (i) {
        return maxStaggerDuration - i * stagger;
    };
    Array.from(children).forEach(function (child, i) {
        animations.push(child.set(next, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, props, { delay: delay + generateStaggerDuration(i) })));
    });
    return animations;
};
var resolveTransition = function (transition, key, value, props, convertTransitionDefinition, getInstantTransition) {
    var resolvedTransition;
    if (typeof transition === 'function') {
        resolvedTransition = transition(props);
    } else if (transition[key] || transition.default) {
        var keyTransition = transition[key] || transition.default;
        if (typeof keyTransition === 'function') {
            resolvedTransition = keyTransition(props);
        } else {
            resolvedTransition = keyTransition;
        }
    } else {
        resolvedTransition = transition;
    }
    return resolvedTransition === false ? getInstantTransition(value, props) : convertTransitionDefinition(value, resolvedTransition, props);
};
var findInsertionIndex = function (poseList, priorityList, priorityIndex) {
    var insertionIndex = 0;
    for (var i = priorityIndex - 1; i >= 0; i--) {
        var nextHighestPriorityIndex = poseList.indexOf(priorityList[i]);
        if (nextHighestPriorityIndex !== -1) {
            insertionIndex = nextHighestPriorityIndex + 1;
            break;
        }
    }
    return insertionIndex;
};
var applyValues = function (toApply, values, props, setValue, setValueNative) {
    Object(hey_listen__WEBPACK_IMPORTED_MODULE_1__["invariant"])(typeof toApply === 'object', 'applyAtStart and applyAtEnd must be of type object');
    return Object.keys(toApply).forEach(function (key) {
        var valueToSet = resolveProp(toApply[key], props);
        values.has(key) ? setValue(values.get(key), valueToSet) : setValueNative(key, valueToSet, props);
    });
};
var createPoseSetter = function (setterProps) {
    var state = setterProps.state,
        poses = setterProps.poses,
        startAction = setterProps.startAction,
        stopAction = setterProps.stopAction,
        getInstantTransition = setterProps.getInstantTransition,
        addActionDelay = setterProps.addActionDelay,
        getTransitionProps = setterProps.getTransitionProps,
        resolveTarget = setterProps.resolveTarget,
        transformPose = setterProps.transformPose,
        posePriority = setterProps.posePriority,
        convertTransitionDefinition = setterProps.convertTransitionDefinition,
        setValue = setterProps.setValue,
        setValueNative = setterProps.setValueNative;
    return function (next, nextProps, propagate) {
        if (nextProps === void 0) {
            nextProps = {};
        }
        if (propagate === void 0) {
            propagate = true;
        }
        var children = state.children,
            values = state.values,
            props = state.props,
            activeActions = state.activeActions,
            activePoses = state.activePoses;
        var _a = nextProps.delay,
            delay = _a === void 0 ? 0 : _a;
        var hasChildren = children.size;
        var baseTransitionProps = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, props, nextProps);
        var nextPose = poses[next];
        var getChildAnimations = function () {
            return hasChildren && propagate ? startChildAnimations(children, next, nextPose, baseTransitionProps) : [];
        };
        var getParentAnimations = function () {
            if (!nextPose) return [];
            if (transformPose) nextPose = transformPose(nextPose, next, state);
            var preTransition = nextPose.preTransition,
                getTransition = nextPose.transition,
                applyAtStart = nextPose.applyAtStart,
                applyAtEnd = nextPose.applyAtEnd;
            if (preTransition) preTransition(baseTransitionProps);
            if (applyAtStart) {
                applyValues(applyAtStart, values, baseTransitionProps, setValue, setValueNative);
            }
            var animations = Object.keys(getPoseValues(nextPose)).map(function (key) {
                var valuePoses = activePoses.has(key) ? activePoses.get(key) : (activePoses.set(key, []), activePoses.get(key));
                var existingIndex = valuePoses.indexOf(next);
                if (existingIndex !== -1) valuePoses.splice(existingIndex, 1);
                var priority = posePriority ? posePriority.indexOf(next) : 0;
                var insertionIndex = priority <= 0 ? 0 : findInsertionIndex(valuePoses, posePriority, priority);
                valuePoses.splice(insertionIndex, 0, next);
                return insertionIndex === 0 ? new Promise(function (complete) {
                    var value = values.get(key);
                    var transitionProps = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, baseTransitionProps, { key: key,
                        value: value });
                    var target = resolveTarget(value, resolveProp(nextPose[key], transitionProps));
                    if (activeActions.has(key)) stopAction(activeActions.get(key));
                    var resolveTransitionProps = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ to: target }, transitionProps, getTransitionProps(value, target, transitionProps));
                    var transition = resolveTransition(getTransition, key, value, resolveTransitionProps, convertTransitionDefinition, getInstantTransition);
                    var poseDelay = resolveProp(nextPose.delay, transitionProps);
                    if (delay || poseDelay) {
                        transition = addActionDelay(delay || poseDelay, transition);
                    }
                    activeActions.set(key, startAction(value, transition, complete));
                }) : Promise.resolve();
            });
            return applyAtEnd ? [Promise.all(animations).then(function () {
                applyValues(applyAtEnd, values, baseTransitionProps, setValue, setValueNative);
            })] : animations;
        };
        if (nextPose && hasChildren) {
            if (resolveProp(nextPose.beforeChildren, baseTransitionProps)) {
                return Promise.all(getParentAnimations()).then(function () {
                    return Promise.all(getChildAnimations());
                });
            } else if (resolveProp(nextPose.afterChildren, baseTransitionProps)) {
                return Promise.all(getChildAnimations()).then(function () {
                    return Promise.all(getParentAnimations());
                });
            }
        }
        return Promise.all(getParentAnimations().concat(getChildAnimations()));
    };
};

var DEFAULT_INITIAL_POSE = 'init';
var isScale = function (key) {
    return key.includes('scale');
};
var defaultReadValueFromSource = function (key) {
    return isScale(key) ? 1 : 0;
};
var getInitialValue = function (poses, key, initialPose, props, readValueFromSource, activePoses) {
    if (readValueFromSource === void 0) {
        readValueFromSource = defaultReadValueFromSource;
    }
    var posesToSearch = Array.isArray(initialPose) ? initialPose : [initialPose];
    posesToSearch.push(DEFAULT_INITIAL_POSE);
    var pose = posesToSearch.filter(Boolean).find(function (name) {
        return poses[name] && poses[name][key] !== undefined;
    });
    activePoses.set(key, [pose || DEFAULT_INITIAL_POSE]);
    return pose ? resolveProp(poses[pose][key], props) : readValueFromSource(key, props);
};
var createValues = function (values, _a) {
    var userSetValues = _a.userSetValues,
        createValue = _a.createValue,
        convertValue = _a.convertValue,
        readValueFromSource = _a.readValueFromSource,
        initialPose = _a.initialPose,
        poses = _a.poses,
        activePoses = _a.activePoses,
        props = _a.props;
    return function (key) {
        if (values.has(key)) return;
        var value;
        if (userSetValues && userSetValues[key] !== undefined) {
            value = convertValue(userSetValues[key], key, props);
        } else {
            var initValue = getInitialValue(poses, key, initialPose, props, readValueFromSource, activePoses);
            value = createValue(initValue, key, props);
        }
        values.set(key, value);
    };
};
var scrapeValuesFromPose = function (values, props) {
    return function (key) {
        var pose = props.poses[key];
        Object.keys(getPoseValues(pose)).forEach(createValues(values, props));
    };
};
var getAncestorValue = function (key, fromParent, ancestors) {
    if (fromParent === true) {
        return ancestors[0] && ancestors[0].values.get(key);
    } else {
        var foundAncestor = ancestors.find(function (_a) {
            var label = _a.label;
            return label === fromParent;
        });
        return foundAncestor && foundAncestor.values.get(key);
    }
};
var bindPassiveValues = function (values, _a) {
    var passive = _a.passive,
        ancestorValues = _a.ancestorValues,
        createValue = _a.createValue,
        readValue = _a.readValue,
        props = _a.props;
    return function (key) {
        var _a = passive[key],
            valueKey = _a[0],
            passiveProps = _a[1],
            fromParent = _a[2];
        var valueToBind = fromParent && ancestorValues.length ? getAncestorValue(valueKey, fromParent, ancestorValues) : values.has(valueKey) ? values.get(valueKey) : false;
        if (!valueToBind) return;
        var newValue = createValue(readValue(valueToBind), key, props, {
            passiveParentKey: valueKey,
            passiveParent: valueToBind,
            passiveProps: passiveProps
        });
        values.set(key, newValue);
    };
};
var createValueMap = function (props) {
    var poses = props.poses,
        passive = props.passive;
    var values = new Map();
    Object.keys(poses).forEach(scrapeValuesFromPose(values, props));
    if (passive) Object.keys(passive).forEach(bindPassiveValues(values, props));
    return values;
};

var applyDefaultTransition = function (pose, key, defaultTransitions) {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, pose, { transition: defaultTransitions.has(key) ? defaultTransitions.get(key) : defaultTransitions.get('default') });
};
var generateTransitions = function (poses, defaultTransitions) {
    Object.keys(poses).forEach(function (key) {
        var pose = poses[key];
        Object(hey_listen__WEBPACK_IMPORTED_MODULE_1__["invariant"])(typeof pose === 'object', "Pose '" + key + "' is of invalid type. All poses should be objects.");
        poses[key] = pose.transition !== undefined ? pose : applyDefaultTransition(pose, key, defaultTransitions);
    });
    return poses;
};

var sortByReversePriority = function (priorityOrder) {
    return function (a, b) {
        var aP = priorityOrder.indexOf(a);
        var bP = priorityOrder.indexOf(b);
        if (aP === -1 && bP !== -1) return -1;
        if (aP !== -1 && bP === -1) return 1;
        return aP - bP;
    };
};

var poseFactory = function (_a) {
    var getDefaultProps = _a.getDefaultProps,
        defaultTransitions = _a.defaultTransitions,
        bindOnChange = _a.bindOnChange,
        startAction = _a.startAction,
        stopAction = _a.stopAction,
        readValue = _a.readValue,
        readValueFromSource = _a.readValueFromSource,
        resolveTarget = _a.resolveTarget,
        setValue = _a.setValue,
        setValueNative = _a.setValueNative,
        createValue = _a.createValue,
        convertValue = _a.convertValue,
        getInstantTransition = _a.getInstantTransition,
        getTransitionProps = _a.getTransitionProps,
        addActionDelay = _a.addActionDelay,
        selectValueToRead = _a.selectValueToRead,
        convertTransitionDefinition = _a.convertTransitionDefinition,
        transformPose = _a.transformPose,
        posePriority = _a.posePriority,
        extendAPI = _a.extendAPI;
    return function (config) {
        var parentValues = config.parentValues,
            _a = config.ancestorValues,
            ancestorValues = _a === void 0 ? [] : _a;
        if (parentValues) ancestorValues.unshift({ values: parentValues });
        var activeActions = new Map();
        var activePoses = new Map();
        var children = new Set();
        var poses = generateTransitions(selectPoses(config), defaultTransitions);
        var props = config.props || {};
        if (getDefaultProps) props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, props, getDefaultProps(config));
        var passive = config.passive,
            userSetValues = config.values,
            _b = config.initialPose,
            initialPose = _b === void 0 ? DEFAULT_INITIAL_POSE : _b;
        var values = createValueMap({
            poses: poses,
            passive: passive,
            ancestorValues: ancestorValues,
            readValue: readValue,
            createValue: createValue,
            convertValue: convertValue,
            readValueFromSource: readValueFromSource,
            userSetValues: userSetValues,
            initialPose: initialPose,
            activePoses: activePoses,
            props: props
        });
        var state = {
            activeActions: activeActions,
            activePoses: activePoses,
            children: children,
            props: props,
            values: values
        };
        var onChange = config.onChange;
        if (onChange) Object.keys(onChange).forEach(bindOnChange(values, onChange));
        var set = createPoseSetter({
            state: state,
            poses: poses,
            getInstantTransition: getInstantTransition,
            getTransitionProps: getTransitionProps,
            convertTransitionDefinition: convertTransitionDefinition,
            setValue: setValue,
            setValueNative: setValueNative,
            startAction: startAction,
            stopAction: stopAction,
            resolveTarget: resolveTarget,
            addActionDelay: addActionDelay,
            transformPose: transformPose,
            posePriority: posePriority
        });
        var has = function (poseName) {
            return !!poses[poseName];
        };
        var api = {
            set: set,
            unset: function (poseName, poseProps) {
                var posesToSet = [];
                activePoses.forEach(function (valuePoses) {
                    var poseIndex = valuePoses.indexOf(poseName);
                    if (poseIndex === -1) return;
                    var currentPose = valuePoses[0];
                    valuePoses.splice(poseIndex, 1);
                    var nextPose = valuePoses[0];
                    if (nextPose === currentPose) return;
                    if (posesToSet.indexOf(nextPose) === -1) {
                        posesToSet.push(nextPose);
                    }
                });
                var animationsToResolve = posesToSet.sort(sortByReversePriority(posePriority)).map(function (poseToSet) {
                    return set(poseToSet, poseProps, false);
                });
                children.forEach(function (child) {
                    return animationsToResolve.push(child.unset(poseName));
                });
                return Promise.all(animationsToResolve);
            },
            get: function (valueName) {
                return valueName ? selectValueToRead(values.get(valueName)) : selectAllValues(values, selectValueToRead);
            },
            has: has,
            setProps: function (newProps) {
                return state.props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, state.props, newProps);
            },
            _addChild: function (childConfig, factory) {
                var child = factory(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ initialPose: initialPose }, childConfig, { ancestorValues: [{ label: config.label, values: values }].concat(ancestorValues) }));
                children.add(child);
                return child;
            },
            removeChild: function (child) {
                return children.delete(child);
            },
            clearChildren: function () {
                children.forEach(function (child) {
                    return child.destroy();
                });
                children.clear();
            },
            destroy: function () {
                activeActions.forEach(stopAction);
                children.forEach(function (child) {
                    return child.destroy();
                });
            }
        };
        return extendAPI(api, state, config);
    };
};

/* harmony default export */ __webpack_exports__["default"] = (poseFactory);


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          )

        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
       true ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(isValidElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.5.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");
var schedule = __webpack_require__(/*! schedule */ "./node_modules/schedule/index.js");
var tracking = __webpack_require__(/*! schedule/tracking */ "./node_modules/schedule/tracking.js");

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function () {};

{
  validateFormat = function (format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error = void 0;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

// Relying on the `invariant()` implementation lets us
// preserve the format and params in the www builds.

!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

var invokeGuardedCallbackImpl = function (name, func, context, a, b, c, d, e, f) {
  var funcArgs = Array.prototype.slice.call(arguments, 3);
  try {
    func.apply(context, funcArgs);
  } catch (error) {
    this.onError(error);
  }
};

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // untintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!

  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
      // If document doesn't exist we know for sure we will crash in this method
      // when we call document.createEvent(). However this can cause confusing
      // errors: https://github.com/facebookincubator/create-react-app/issues/3482
      // So we preemptively throw with a better message instead.
      !(typeof document !== 'undefined') ? invariant(false, 'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.') : void 0;
      var evt = document.createEvent('Event');

      // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.
      var didError = true;

      // Keeps track of the value of window.event so that we can reset it
      // during the callback to let user code access window.event in the
      // browsers that support it.
      var windowEvent = window.event;

      // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      function callCallback() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false);

        // We check for window.hasOwnProperty('event') to prevent the
        // window.event assignment in both IE <= 10 as they throw an error
        // "Member not found" in strict mode, and in Firefox which does not
        // support window.event.
        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
          window.event = windowEvent;
        }

        func.apply(context, funcArgs);
        didError = false;
      }

      // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.
      var error = void 0;
      // Use this to track whether the error event is ever called.
      var didSetError = false;
      var isCrossOriginError = false;

      function handleWindowError(event) {
        error = event.error;
        didSetError = true;
        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }
        if (event.defaultPrevented) {
          // Some other error handler has prevented default.
          // Browsers silence the error report if this happens.
          // We'll remember this to later decide whether to log it or not.
          if (error != null && typeof error === 'object') {
            try {
              error._suppressLogging = true;
            } catch (inner) {
              // Ignore.
            }
          }
        }
      }

      // Create a fake event type.
      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

      // Attach our event handlers
      window.addEventListener('error', handleWindowError);
      fakeNode.addEventListener(evtType, callCallback, false);

      // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
        }
        this.onError(error);
      }

      // Remove our event listeners
      window.removeEventListener('error', handleWindowError);
    };

    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
  }
}

var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;

// Used by Fiber to simulate a try-catch.
var hasError = false;
var caughtError = null;

// Used by event system to capture/rethrow the first error.
var hasRethrowError = false;
var rethrowError = null;

var reporter = {
  onError: function (error) {
    hasError = true;
    caughtError = error;
  }
};

/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */
function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
  hasError = false;
  caughtError = null;
  invokeGuardedCallbackImpl$1.apply(reporter, arguments);
}

/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */
function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
  invokeGuardedCallback.apply(this, arguments);
  if (hasError) {
    var error = clearCaughtError();
    if (!hasRethrowError) {
      hasRethrowError = true;
      rethrowError = error;
    }
  }
}

/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */
function rethrowCaughtError() {
  if (hasRethrowError) {
    var error = rethrowError;
    hasRethrowError = false;
    rethrowError = null;
    throw error;
  }
}

function hasCaughtError() {
  return hasError;
}

function clearCaughtError() {
  if (hasError) {
    var error = caughtError;
    hasError = false;
    caughtError = null;
    return error;
  } else {
    invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
  }
}

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
    if (plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
    plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
  eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
  registrationNameModules[registrationName] = pluginModule;
  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */
var plugins = [];

/**
 * Mapping from event name to dispatch config
 */
var eventNameDispatchConfigs = {};

/**
 * Mapping from registration name to plugin module
 */
var registrationNameModules = {};

/**
 * Mapping from registration name to event name
 */
var registrationNameDependencies = {};

/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */
var possibleRegistrationNames = {};
// Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */
function injectEventPluginOrder(injectedEventPluginOrder) {
  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}

/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */
function injectEventPluginsByName(injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warningWithoutStack = function () {};

{
  warningWithoutStack = function (condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (condition) {
      return;
    }
    if (typeof console !== 'undefined') {
      var _console;

      var stringArgs = args.map(function (item) {
        return '' + item;
      });
      (_console = console).error.apply(_console, ['Warning: ' + format].concat(stringArgs));
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      throw new Error(message);
    } catch (x) {}
  };
}

var warningWithoutStack$1 = warningWithoutStack;

var getFiberCurrentPropsFromNode = null;
var getInstanceFromNode = null;
var getNodeFromInstance = null;

function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {
  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
  getInstanceFromNode = getInstanceFromNodeImpl;
  getNodeFromInstance = getNodeFromInstanceImpl;
  {
    !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
  }
}

var validateEventDispatches = void 0;
{
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, 'EventPluginUtils: Invalid `event`.') : void 0;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = getNodeFromInstance(inst);
  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */


/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */


/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */
function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */

/**
 * Methods for injecting dependencies.
 */
var injection = {
  /**
   * @param {array} InjectedEventPluginOrder
   * @public
   */
  injectEventPluginOrder: injectEventPluginOrder,

  /**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */
  injectEventPluginsByName: injectEventPluginsByName
};

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */
function getListener(inst, registrationName) {
  var listener = void 0;

  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode = inst.stateNode;
  if (!stateNode) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }
  var props = getFiberCurrentPropsFromNode(stateNode);
  if (!props) {
    // Work in progress.
    return null;
  }
  listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
  return listener;
}

/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */
function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = null;
  for (var i = 0; i < plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}

function runEventsInBatch(events, simulated) {
  if (events !== null) {
    eventQueue = accumulateInto(eventQueue, events);
  }

  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;

  if (!processingEventQueue) {
    return;
  }

  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  rethrowCaughtError();
}

function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventsInBatch(events, false);
}

var FunctionalComponent = 0;
var FunctionalComponentLazy = 1;
var ClassComponent = 2;
var ClassComponentLazy = 3;
var IndeterminateComponent = 4; // Before we know whether it is functional or class
var HostRoot = 5; // Root of a host tree. Could be nested inside another node.
var HostPortal = 6; // A subtree. Could be an entry point to a different renderer.
var HostComponent = 7;
var HostText = 8;
var Fragment = 9;
var Mode = 10;
var ContextConsumer = 11;
var ContextProvider = 12;
var ForwardRef = 13;
var ForwardRefLazy = 14;
var Profiler = 15;
var PlaceholderComponent = 16;

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactInternalInstance$' + randomKey;
var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

function precacheFiberNode(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  while (!node[internalInstanceKey]) {
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var inst = node[internalInstanceKey];
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber, this will always be the deepest root.
    return inst;
  }

  return null;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode$1(node) {
  var inst = node[internalInstanceKey];
  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance$1(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  }

  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  invariant(false, 'getNodeFromInstance: Invalid argument.');
}

function getFiberCurrentPropsFromNode$1(node) {
  return node[internalEventHandlersKey] || null;
}

function updateFiberProps(node, props) {
  node[internalEventHandlersKey] = props;
}

function getParent(inst) {
  do {
    inst = inst.return;
    // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);
  if (inst) {
    return inst;
  }
  return null;
}

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  var depthA = 0;
  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = getParent(instA);
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = getParent(instB);
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB || instA === instB.alternate) {
      return instA;
    }
    instA = getParent(instA);
    instB = getParent(instB);
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */


/**
 * Return the parent instance of the passed-in instance.
 */


/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = getParent(inst);
  }
  var i = void 0;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (true) {
    if (!from) {
      break;
    }
    if (from === common) {
      break;
    }
    var alternate = from.alternate;
    if (alternate !== null && alternate === common) {
      break;
    }
    pathFrom.push(from);
    from = getParent(from);
  }
  var pathTo = [];
  while (true) {
    if (!to) {
      break;
    }
    if (to === common) {
      break;
    }
    var _alternate = to.alternate;
    if (_alternate !== null && _alternate === common) {
      break;
    }
    pathTo.push(to);
    to = getParent(to);
  }
  for (var i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (var _i = pathTo.length; _i-- > 0;) {
    fn(pathTo[_i], 'captured', argTo);
  }
}

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  {
    !inst ? warningWithoutStack$1(false, 'Dispatching inst must not be null') : void 0;
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (inst && event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}



function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

// Do not uses the below two methods directly!
// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.
// (It is the only module that is allowed to access these methods.)

function unsafeCastStringToDOMTopLevelType(topLevelType) {
  return topLevelType;
}

function unsafeCastDOMTopLevelTypeToString(topLevelType) {
  return topLevelType;
}

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return eventName;
}

/**
 * To identify top level events in ReactDOM, we use constants defined by this
 * module. This is the only module that uses the unsafe* methods to express
 * that the constants actually correspond to the browser event names. This lets
 * us save some bundle size by avoiding a top level type -> event name map.
 * The rest of ReactDOM code should import top level types from this file.
 */
var TOP_ABORT = unsafeCastStringToDOMTopLevelType('abort');
var TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));
var TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));
var TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));
var TOP_BLUR = unsafeCastStringToDOMTopLevelType('blur');
var TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType('canplay');
var TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType('canplaythrough');
var TOP_CANCEL = unsafeCastStringToDOMTopLevelType('cancel');
var TOP_CHANGE = unsafeCastStringToDOMTopLevelType('change');
var TOP_CLICK = unsafeCastStringToDOMTopLevelType('click');
var TOP_CLOSE = unsafeCastStringToDOMTopLevelType('close');
var TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType('compositionend');
var TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType('compositionstart');
var TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType('compositionupdate');
var TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType('contextmenu');
var TOP_COPY = unsafeCastStringToDOMTopLevelType('copy');
var TOP_CUT = unsafeCastStringToDOMTopLevelType('cut');
var TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType('dblclick');
var TOP_AUX_CLICK = unsafeCastStringToDOMTopLevelType('auxclick');
var TOP_DRAG = unsafeCastStringToDOMTopLevelType('drag');
var TOP_DRAG_END = unsafeCastStringToDOMTopLevelType('dragend');
var TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType('dragenter');
var TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType('dragexit');
var TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType('dragleave');
var TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType('dragover');
var TOP_DRAG_START = unsafeCastStringToDOMTopLevelType('dragstart');
var TOP_DROP = unsafeCastStringToDOMTopLevelType('drop');
var TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType('durationchange');
var TOP_EMPTIED = unsafeCastStringToDOMTopLevelType('emptied');
var TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType('encrypted');
var TOP_ENDED = unsafeCastStringToDOMTopLevelType('ended');
var TOP_ERROR = unsafeCastStringToDOMTopLevelType('error');
var TOP_FOCUS = unsafeCastStringToDOMTopLevelType('focus');
var TOP_GOT_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('gotpointercapture');
var TOP_INPUT = unsafeCastStringToDOMTopLevelType('input');
var TOP_INVALID = unsafeCastStringToDOMTopLevelType('invalid');
var TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType('keydown');
var TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType('keypress');
var TOP_KEY_UP = unsafeCastStringToDOMTopLevelType('keyup');
var TOP_LOAD = unsafeCastStringToDOMTopLevelType('load');
var TOP_LOAD_START = unsafeCastStringToDOMTopLevelType('loadstart');
var TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType('loadeddata');
var TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType('loadedmetadata');
var TOP_LOST_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('lostpointercapture');
var TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType('mousedown');
var TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType('mousemove');
var TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType('mouseout');
var TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType('mouseover');
var TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType('mouseup');
var TOP_PASTE = unsafeCastStringToDOMTopLevelType('paste');
var TOP_PAUSE = unsafeCastStringToDOMTopLevelType('pause');
var TOP_PLAY = unsafeCastStringToDOMTopLevelType('play');
var TOP_PLAYING = unsafeCastStringToDOMTopLevelType('playing');
var TOP_POINTER_CANCEL = unsafeCastStringToDOMTopLevelType('pointercancel');
var TOP_POINTER_DOWN = unsafeCastStringToDOMTopLevelType('pointerdown');


var TOP_POINTER_MOVE = unsafeCastStringToDOMTopLevelType('pointermove');
var TOP_POINTER_OUT = unsafeCastStringToDOMTopLevelType('pointerout');
var TOP_POINTER_OVER = unsafeCastStringToDOMTopLevelType('pointerover');
var TOP_POINTER_UP = unsafeCastStringToDOMTopLevelType('pointerup');
var TOP_PROGRESS = unsafeCastStringToDOMTopLevelType('progress');
var TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType('ratechange');
var TOP_RESET = unsafeCastStringToDOMTopLevelType('reset');
var TOP_SCROLL = unsafeCastStringToDOMTopLevelType('scroll');
var TOP_SEEKED = unsafeCastStringToDOMTopLevelType('seeked');
var TOP_SEEKING = unsafeCastStringToDOMTopLevelType('seeking');
var TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType('selectionchange');
var TOP_STALLED = unsafeCastStringToDOMTopLevelType('stalled');
var TOP_SUBMIT = unsafeCastStringToDOMTopLevelType('submit');
var TOP_SUSPEND = unsafeCastStringToDOMTopLevelType('suspend');
var TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType('textInput');
var TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType('timeupdate');
var TOP_TOGGLE = unsafeCastStringToDOMTopLevelType('toggle');
var TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType('touchcancel');
var TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType('touchend');
var TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType('touchmove');
var TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType('touchstart');
var TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));
var TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType('volumechange');
var TOP_WAITING = unsafeCastStringToDOMTopLevelType('waiting');
var TOP_WHEEL = unsafeCastStringToDOMTopLevelType('wheel');

// List of events that need to be individually attached to media elements.
// Note that events in this list will *not* be listened to at the top level
// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.
var mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];

function getRawEventName(topLevelType) {
  return unsafeCastDOMTopLevelTypeToString(topLevelType);
}

/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */

var root = null;
var startText = null;
var fallbackText = null;

function initialize(nativeEventTarget) {
  root = nativeEventTarget;
  startText = getText();
  return true;
}

function reset() {
  root = null;
  startText = null;
  fallbackText = null;
}

function getData() {
  if (fallbackText) {
    return fallbackText;
  }

  var start = void 0;
  var startValue = startText;
  var startLength = startValue.length;
  var end = void 0;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  fallbackText = endValue.slice(start, sliceTail);
  return fallbackText;
}

function getText() {
  if ('value' in root) {
    return root.value;
  }
  return root.textContent;
}

/* eslint valid-typeof: 0 */

var EVENT_POOL_SIZE = 10;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: function () {
    return null;
  },
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

function functionThatReturnsTrue() {
  return true;
}

function functionThatReturnsFalse() {
  return false;
}

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
    delete this.isDefaultPrevented;
    delete this.isPropagationStopped;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = functionThatReturnsTrue;
  } else {
    this.isDefaultPrevented = functionThatReturnsFalse;
  }
  this.isPropagationStopped = functionThatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = functionThatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = functionThatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = functionThatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: functionThatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      }
    }
    this.dispatchConfig = null;
    this._targetInst = null;
    this.nativeEvent = null;
    this.isDefaultPrevented = functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    this._dispatchListeners = null;
    this._dispatchInstances = null;
    {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));
      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 */
SyntheticEvent.extend = function (Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  function Class() {
    return Super.apply(this, arguments);
  }
  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.extend = Super.extend;
  addEventPoolingTo(Class);

  return Class;
};

addEventPoolingTo(SyntheticEvent);

/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    !warningCondition ? warningWithoutStack$1(false, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
  }
}

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  var EventConstructor = this;
  if (EventConstructor.eventPool.length) {
    var instance = EventConstructor.eventPool.pop();
    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
    return instance;
  }
  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
}

function releasePooledEvent(event) {
  var EventConstructor = this;
  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance into a pool of a different type.') : void 0;
  event.destructor();
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

function addEventPoolingTo(EventConstructor) {
  EventConstructor.eventPool = [];
  EventConstructor.getPooled = getPooledEvent;
  EventConstructor.release = releasePooledEvent;
}

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var SyntheticCompositionEvent = SyntheticEvent.extend({
  data: null
});

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var SyntheticInputEvent = SyntheticEvent.extend({
  data: null
});

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode;

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case TOP_COMPOSITION_START:
      return eventTypes.compositionStart;
    case TOP_COMPOSITION_END:
      return eventTypes.compositionEnd;
    case TOP_COMPOSITION_UPDATE:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case TOP_KEY_UP:
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case TOP_KEY_DOWN:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case TOP_KEY_PRESS:
    case TOP_MOUSE_DOWN:
    case TOP_BLUR:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isUsingKoreanIME(nativeEvent) {
  return nativeEvent.locale === 'ko';
}

// Track the current IME composition status, if any.
var isComposing = false;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType = void 0;
  var fallbackData = void 0;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === eventTypes.compositionStart) {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {TopLevelType} topLevelType Number from `TopLevelType`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case TOP_COMPOSITION_END:
      return getDataFromCustomEvent(nativeEvent);
    case TOP_KEY_PRESS:
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case TOP_TEXT_INPUT:
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case TOP_PASTE:
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case TOP_KEY_PRESS:
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case TOP_COMPOSITION_END:
      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars = void 0;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);

    var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);

    if (composition === null) {
      return beforeInput;
    }

    if (beforeInput === null) {
      return composition;
    }

    return [composition, beforeInput];
  }
};

// Use to restore controlled state after a change event has fired.

var restoreImpl = null;
var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);
  if (!internalInstance) {
    // Unmounted
    return;
  }
  !(typeof restoreImpl === 'function') ? invariant(false, 'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
  restoreImpl(internalInstance.stateNode, internalInstance.type, props);
}

function setRestoreImplementation(impl) {
  restoreImpl = impl;
}

function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}

function needsStateRestore() {
  return restoreTarget !== null || restoreQueue !== null;
}

function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;

  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.

// Defaults
var _batchedUpdatesImpl = function (fn, bookkeeping) {
  return fn(bookkeeping);
};
var _interactiveUpdatesImpl = function (fn, a, b) {
  return fn(a, b);
};
var _flushInteractiveUpdatesImpl = function () {};

var isBatching = false;
function batchedUpdates(fn, bookkeeping) {
  if (isBatching) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(bookkeeping);
  }
  isBatching = true;
  try {
    return _batchedUpdatesImpl(fn, bookkeeping);
  } finally {
    // Here we wait until all updates have propagated, which is important
    // when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    // Then we restore state of any controlled component.
    isBatching = false;
    var controlledComponentsHavePendingUpdates = needsStateRestore();
    if (controlledComponentsHavePendingUpdates) {
      // If a controlled event was fired, we may need to restore the state of
      // the DOM node back to the controlled value. This is necessary when React
      // bails out of the update without touching the DOM.
      _flushInteractiveUpdatesImpl();
      restoreStateIfNeeded();
    }
  }
}

function interactiveUpdates(fn, a, b) {
  return _interactiveUpdatesImpl(fn, a, b);
}



function setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {
  _batchedUpdatesImpl = batchedUpdatesImpl;
  _interactiveUpdatesImpl = interactiveUpdatesImpl;
  _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;
}

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * HTML nodeType values that represent the type of the node
 */

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  // Fallback to nativeEvent.srcElement for IE9
  // https://github.com/facebook/react/issues/12506
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix) {
  if (!canUseDOM) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  return isSupported;
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';
  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

  var currentValue = '' + node[valueField];

  // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }
  var get = descriptor.get,
      set = descriptor.set;

  Object.defineProperty(node, valueField, {
    configurable: true,
    get: function () {
      return get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      set.call(this, value);
    }
  });
  // We could've passed this the first time
  // but it triggers a bug in IE11 and Edge 14/15.
  // Calling defineProperty() again should be equivalent.
  // https://github.com/facebook/react/issues/11768
  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable
  });

  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  }

  // TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker = trackValueOnNode(node);
}

function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node);
  // if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

var describeComponentFrame = function (name, source, ownerName) {
  var sourceInfo = '';
  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');
    {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);
        if (match) {
          var pathBeforeSlash = match[1];
          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }
    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }
  return '\n    in ' + (name || 'Unknown') + sourceInfo;
};

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for('react.placeholder') : 0xead1;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function getResultFromResolvedThenable(thenable) {
  return thenable._reactResult;
}

function refineResolvedThenable(thenable) {
  return thenable._reactStatus === Resolved ? thenable._reactResult : null;
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }
  {
    if (typeof type.tag === 'number') {
      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }
  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }
  if (typeof type === 'string') {
    return type;
  }
  switch (type) {
    case REACT_ASYNC_MODE_TYPE:
      return 'AsyncMode';
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';
    case REACT_PORTAL_TYPE:
      return 'Portal';
    case REACT_PROFILER_TYPE:
      return 'Profiler';
    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';
    case REACT_PLACEHOLDER_TYPE:
      return 'Placeholder';
  }
  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return 'Context.Consumer';
      case REACT_PROVIDER_TYPE:
        return 'Context.Provider';
      case REACT_FORWARD_REF_TYPE:
        var renderFn = type.render;
        var functionName = renderFn.displayName || renderFn.name || '';
        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
    }
    if (typeof type.then === 'function') {
      var thenable = type;
      var resolvedThenable = refineResolvedThenable(thenable);
      if (resolvedThenable) {
        return getComponentName(resolvedThenable);
      }
    }
  }
  return null;
}

var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function describeFiber(fiber) {
  switch (fiber.tag) {
    case IndeterminateComponent:
    case FunctionalComponent:
    case FunctionalComponentLazy:
    case ClassComponent:
    case ClassComponentLazy:
    case HostComponent:
    case Mode:
      var owner = fiber._debugOwner;
      var source = fiber._debugSource;
      var name = getComponentName(fiber.type);
      var ownerName = null;
      if (owner) {
        ownerName = getComponentName(owner.type);
      }
      return describeComponentFrame(name, source, ownerName);
    default:
      return '';
  }
}

function getStackByFiberInDevAndProd(workInProgress) {
  var info = '';
  var node = workInProgress;
  do {
    info += describeFiber(node);
    node = node.return;
  } while (node);
  return info;
}

var current = null;
var phase = null;

function getCurrentFiberOwnerNameInDevOrNull() {
  {
    if (current === null) {
      return null;
    }
    var owner = current._debugOwner;
    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner.type);
    }
  }
  return null;
}

function getCurrentFiberStackInDev() {
  {
    if (current === null) {
      return '';
    }
    // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.
    return getStackByFiberInDevAndProd(current);
  }
  return '';
}

function resetCurrentFiber() {
  {
    ReactDebugCurrentFrame.getCurrentStack = null;
    current = null;
    phase = null;
  }
}

function setCurrentFiber(fiber) {
  {
    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
    current = fiber;
    phase = null;
  }
}

function setCurrentPhase(lifeCyclePhase) {
  {
    phase = lifeCyclePhase;
  }
}

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = warningWithoutStack$1;

{
  warning = function (condition, format) {
    if (condition) {
      return;
    }
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();
    // eslint-disable-next-line react-internal/warning-and-invariant-args

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));
  };
}

var warning$1 = warning;

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0;

// A simple string attribute.
// Attributes that aren't in the whitelist are presumed to have this type.
var STRING = 1;

// A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.
var BOOLEANISH_STRING = 2;

// A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
var BOOLEAN = 3;

// An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.
var OVERLOADED_BOOLEAN = 4;

// An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.
var NUMERIC = 5;

// An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.
var POSITIVE_NUMERIC = 6;

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';


var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  {
    warning$1(false, 'Invalid attribute name: `%s`', attributeName);
  }
  return false;
}

function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }
  if (isCustomComponentTag) {
    return false;
  }
  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return true;
  }
  return false;
}

function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }
  switch (typeof value) {
    case 'function':
    // $FlowIssue symbol is perfectly valid here
    case 'symbol':
      // eslint-disable-line
      return true;
    case 'boolean':
      {
        if (isCustomComponentTag) {
          return false;
        }
        if (propertyInfo !== null) {
          return !propertyInfo.acceptsBooleans;
        } else {
          var prefix = name.toLowerCase().slice(0, 5);
          return prefix !== 'data-' && prefix !== 'aria-';
        }
      }
    default:
      return false;
  }
}

function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
  if (value === null || typeof value === 'undefined') {
    return true;
  }
  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }
  if (isCustomComponentTag) {
    return false;
  }
  if (propertyInfo !== null) {
    switch (propertyInfo.type) {
      case BOOLEAN:
        return !value;
      case OVERLOADED_BOOLEAN:
        return value === false;
      case NUMERIC:
        return isNaN(value);
      case POSITIVE_NUMERIC:
        return isNaN(value) || value < 1;
    }
  }
  return false;
}

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
}

// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
var properties = {};

// These props are reserved by React. They shouldn't be written to the DOM.
['children', 'dangerouslySetInnerHTML',
// TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.
[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var name = _ref[0],
      attributeName = _ref[1];

  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null);
} // attributeNamespace
);

// These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null);
} // attributeNamespace
);

// These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.
['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// These are HTML boolean attributes.
['allowFullScreen', 'async',
// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',
// Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null);
} // attributeNamespace
);

// These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.
['checked',
// Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.
['capture', 'download'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// These are HTML attributes that must be positive numbers.
['cols', 'rows', 'size', 'span'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null);
} // attributeNamespace
);

// These are HTML attributes that must be numbers.
['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null);
} // attributeNamespace
);

var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function (token) {
  return token[1].toUpperCase();
};

// This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML whitelist.
// Some of these attributes can be hard to find. This list was created by
// scrapping the MDN documentation.
['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null);
} // attributeNamespace
);

// String SVG attributes with the xlink namespace.
['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink');
});

// String SVG attributes with the xml namespace.
['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace');
});

// Special case: this attribute exists both in HTML and SVG.
// Its "tabindex" attribute name is case-sensitive in SVG so we can't just use
// its React `tabIndex` name, like we do for attributes that exist only in HTML.
properties.tabIndex = new PropertyInfoRecord('tabIndex', STRING, false, // mustUseProperty
'tabindex', // attributeName
null);

/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected, propertyInfo) {
  {
    if (propertyInfo.mustUseProperty) {
      var propertyName = propertyInfo.propertyName;

      return node[propertyName];
    } else {
      var attributeName = propertyInfo.attributeName;

      var stringValue = null;

      if (propertyInfo.type === OVERLOADED_BOOLEAN) {
        if (node.hasAttribute(attributeName)) {
          var value = node.getAttribute(attributeName);
          if (value === '') {
            return true;
          }
          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
            return value;
          }
          if (value === '' + expected) {
            return expected;
          }
          return value;
        }
      } else if (node.hasAttribute(attributeName)) {
        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
          // We had an attribute but shouldn't have had one, so read it
          // for the error message.
          return node.getAttribute(attributeName);
        }
        if (propertyInfo.type === BOOLEAN) {
          // If this was a boolean, it doesn't matter what the value is
          // the fact that we have it is the same as the expected.
          return expected;
        }
        // Even if this property uses a namespace we use getAttribute
        // because we assume its namespaced name is the same as our config.
        // To use getAttributeNS we need the local name which we don't have
        // in our config atm.
        stringValue = node.getAttribute(attributeName);
      }

      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
        return stringValue === null ? expected : stringValue;
      } else if (stringValue === '' + expected) {
        return expected;
      } else {
        return stringValue;
      }
    }
  }
}

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */
function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }
    var value = node.getAttribute(name);
    if (value === '' + expected) {
      return expected;
    }
    return value;
  }
}

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */
function setValueForProperty(node, name, value, isCustomComponentTag) {
  var propertyInfo = getPropertyInfo(name);
  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
    return;
  }
  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
    value = null;
  }
  // If the prop isn't in the special list, treat it as a simple attribute.
  if (isCustomComponentTag || propertyInfo === null) {
    if (isAttributeNameSafe(name)) {
      var _attributeName = name;
      if (value === null) {
        node.removeAttribute(_attributeName);
      } else {
        node.setAttribute(_attributeName, '' + value);
      }
    }
    return;
  }
  var mustUseProperty = propertyInfo.mustUseProperty;

  if (mustUseProperty) {
    var propertyName = propertyInfo.propertyName;

    if (value === null) {
      var type = propertyInfo.type;

      node[propertyName] = type === BOOLEAN ? false : '';
    } else {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyName] = value;
    }
    return;
  }
  // The rest are treated as attributes with special cases.
  var attributeName = propertyInfo.attributeName,
      attributeNamespace = propertyInfo.attributeNamespace;

  if (value === null) {
    node.removeAttribute(attributeName);
  } else {
    var _type = propertyInfo.type;

    var attributeValue = void 0;
    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
      attributeValue = '';
    } else {
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      attributeValue = '' + value;
    }
    if (attributeNamespace) {
      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
    } else {
      node.setAttribute(attributeName, attributeValue);
    }
  }
}

// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value) {
  return '' + value;
}

function getToStringValue(value) {
  switch (typeof value) {
    case 'boolean':
    case 'number':
    case 'object':
    case 'string':
    case 'undefined':
      return value;
    default:
      // function, symbol are assigned as empty strings
      return '';
  }
}

var ReactDebugCurrentFrame$1 = null;

var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };

  var propTypes = {
    value: function (props, propName, componentName) {
      if (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == null) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (props.onChange || props.readOnly || props.disabled || props[propName] == null) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props) {
    checkPropTypes(propTypes, props, 'prop', tagName, ReactDebugCurrentFrame$1.getStackAddendum);
  };
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

function getHostProps(element, props) {
  var node = element;
  var checked = props.checked;

  var hostProps = _assign({}, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: undefined,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}

function initWrapperState(element, props) {
  {
    ReactControlledValuePropTypes.checkPropTypes('input', props);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      warning$1(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      warning$1(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);
      didWarnValueDefaultValue = true;
    }
  }

  var node = element;
  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;

  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
    controlled: isControlled(props)
  };
}

function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;
  if (checked != null) {
    setValueForProperty(node, 'checked', checked, false);
  }
}

function updateWrapper(element, props) {
  var node = element;
  {
    var _controlled = isControlled(props);

    if (!node._wrapperState.controlled && _controlled && !didWarnUncontrolledToControlled) {
      warning$1(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);
      didWarnUncontrolledToControlled = true;
    }
    if (node._wrapperState.controlled && !_controlled && !didWarnControlledToUncontrolled) {
      warning$1(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);
      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);

  var value = getToStringValue(props.value);
  var type = props.type;

  if (value != null) {
    if (type === 'number') {
      if (value === 0 && node.value === '' ||
      // We explicitly want to coerce to number here if possible.
      // eslint-disable-next-line
      node.value != value) {
        node.value = toString(value);
      }
    } else if (node.value !== toString(value)) {
      node.value = toString(value);
    }
  } else if (type === 'submit' || type === 'reset') {
    // Submit/reset inputs need the attribute removed completely to avoid
    // blank-text buttons.
    node.removeAttribute('value');
    return;
  }

  if (props.hasOwnProperty('value')) {
    setDefaultValue(node, props.type, value);
  } else if (props.hasOwnProperty('defaultValue')) {
    setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
  }

  if (props.checked == null && props.defaultChecked != null) {
    node.defaultChecked = !!props.defaultChecked;
  }
}

function postMountWrapper(element, props, isHydrating) {
  var node = element;

  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
    // Avoid setting value attribute on submit/reset inputs as it overrides the
    // default value provided by the browser. See: #12872
    var type = props.type;
    if ((type === 'submit' || type === 'reset') && (props.value === undefined || props.value === null)) {
      return;
    }

    var _initialValue = toString(node._wrapperState.initialValue);
    var currentValue = node.value;

    // Do not assign value if it is already set. This prevents user text input
    // from being lost during SSR hydration.
    if (!isHydrating) {
      // Do not re-assign the value property if there is no change. This
      // potentially avoids a DOM write and prevents Firefox (~60.0.1) from
      // prematurely marking required inputs as invalid
      if (_initialValue !== currentValue) {
        node.value = _initialValue;
      }
    }

    // value must be assigned before defaultValue. This fixes an issue where the
    // visually displayed value of date inputs disappears on mobile Safari and Chrome:
    // https://github.com/facebook/react/issues/7233
    node.defaultValue = _initialValue;
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !!node._wrapperState.initialChecked;
  if (name !== '') {
    node.name = name;
  }
}

function restoreControlledState(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;

      // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set
      updateValueIfChanged(otherNode);

      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      updateWrapper(otherNode, otherProps);
    }
  }
}

// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
function setDefaultValue(node, type, value) {
  if (
  // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
  type !== 'number' || node.ownerDocument.activeElement !== node) {
    if (value == null) {
      node.defaultValue = toString(node._wrapperState.initialValue);
    } else if (node.defaultValue !== toString(value)) {
      node.defaultValue = toString(value);
    }
  }
}

var eventTypes$1 = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent.getPooled(eventTypes$1.change, inst, nativeEvent, target);
  event.type = 'change';
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  runEventsInBatch(event, false);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance$1(targetInst);
  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === TOP_CHANGE) {
    return targetInst;
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === TOP_FOCUS) {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === TOP_BLUR) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
  if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === TOP_CLICK) {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
  if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(node) {
  var state = node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  setDefaultValue(node, 'number', node.value);
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes$1,

  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    var getTargetInstFunc = void 0,
        handleEventFunc = void 0;
    if (shouldUseChangeEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === TOP_BLUR) {
      handleControlledInputBlur(targetNode);
    }
  }
};

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

var SyntheticUIEvent = SyntheticEvent.extend({
  view: null,
  detail: null
});

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

var previousScreenX = 0;
var previousScreenY = 0;
// Use flags to signal movementX/Y has already been set
var isMovementXSet = false;
var isMovementYSet = false;

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var SyntheticMouseEvent = SyntheticUIEvent.extend({
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: null,
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  movementX: function (event) {
    if ('movementX' in event) {
      return event.movementX;
    }

    var screenX = previousScreenX;
    previousScreenX = event.screenX;

    if (!isMovementXSet) {
      isMovementXSet = true;
      return 0;
    }

    return event.type === 'mousemove' ? event.screenX - screenX : 0;
  },
  movementY: function (event) {
    if ('movementY' in event) {
      return event.movementY;
    }

    var screenY = previousScreenY;
    previousScreenY = event.screenY;

    if (!isMovementYSet) {
      isMovementYSet = true;
      return 0;
    }

    return event.type === 'mousemove' ? event.screenY - screenY : 0;
  }
});

/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */
var SyntheticPointerEvent = SyntheticMouseEvent.extend({
  pointerId: null,
  width: null,
  height: null,
  pressure: null,
  tangentialPressure: null,
  tiltX: null,
  tiltY: null,
  twist: null,
  pointerType: null,
  isPrimary: null
});

var eventTypes$2 = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]
  },
  pointerEnter: {
    registrationName: 'onPointerEnter',
    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]
  },
  pointerLeave: {
    registrationName: 'onPointerLeave',
    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes$2,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;
    var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;

    if (isOverEvent && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }

    if (!isOutEvent && !isOverEvent) {
      // Must not be a mouse or pointer in or out - ignoring.
      return null;
    }

    var win = void 0;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from = void 0;
    var to = void 0;
    if (isOutEvent) {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var eventInterface = void 0,
        leaveEventType = void 0,
        enterEventType = void 0,
        eventTypePrefix = void 0;

    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {
      eventInterface = SyntheticMouseEvent;
      leaveEventType = eventTypes$2.mouseLeave;
      enterEventType = eventTypes$2.mouseEnter;
      eventTypePrefix = 'mouse';
    } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {
      eventInterface = SyntheticPointerEvent;
      leaveEventType = eventTypes$2.pointerLeave;
      enterEventType = eventTypes$2.pointerEnter;
      eventTypePrefix = 'pointer';
    }

    var fromNode = from == null ? win : getNodeFromInstance$1(from);
    var toNode = to == null ? win : getNodeFromInstance$1(to);

    var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);
    leave.type = eventTypePrefix + 'leave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);
    enter.type = eventTypePrefix + 'enter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

/*eslint-disable no-self-compare */

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty$1.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */


function get(key) {
  return key._reactInternalFiber;
}

function has(key) {
  return key._reactInternalFiber !== undefined;
}

function set(key, value) {
  key._reactInternalFiber = value;
}

// Don't change these two values. They're used by React Dev Tools.
var NoEffect = /*              */0;
var PerformedWork = /*         */1;

// You can change the rest (and add more).
var Placement = /*             */2;
var Update = /*                */4;
var PlacementAndUpdate = /*    */6;
var Deletion = /*              */8;
var ContentReset = /*          */16;
var Callback = /*              */32;
var DidCapture = /*            */64;
var Ref = /*                   */128;
var Snapshot = /*              */256;

// Update & Callback & Ref & Snapshot
var LifecycleEffectMask = /*   */420;

// Union of all host effects
var HostEffectMask = /*        */511;

var Incomplete = /*            */512;
var ShouldCapture = /*         */1024;

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;

var MOUNTING = 1;
var MOUNTED = 2;
var UNMOUNTED = 3;

function isFiberMountedImpl(fiber) {
  var node = fiber;
  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    if ((node.effectTag & Placement) !== NoEffect) {
      return MOUNTING;
    }
    while (node.return) {
      node = node.return;
      if ((node.effectTag & Placement) !== NoEffect) {
        return MOUNTING;
      }
    }
  } else {
    while (node.return) {
      node = node.return;
    }
  }
  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return MOUNTED;
  }
  // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return UNMOUNTED;
}

function isFiberMounted(fiber) {
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function isMounted(component) {
  {
    var owner = ReactCurrentOwner$1.current;
    if (owner !== null && (owner.tag === ClassComponent || owner.tag === ClassComponentLazy)) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;
      !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component') : void 0;
      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);
  if (!fiber) {
    return false;
  }
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function assertIsMounted(fiber) {
  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var state = isFiberMountedImpl(fiber);
    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    if (state === MOUNTING) {
      return null;
    }
    return fiber;
  }
  // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a = fiber;
  var b = alternate;
  while (true) {
    var parentA = a.return;
    var parentB = parentA ? parentA.alternate : null;
    if (!parentA || !parentB) {
      // We're at the root.
      break;
    }

    // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.
    if (parentA.child === parentB.child) {
      var child = parentA.child;
      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.
      invariant(false, 'Unable to find node on an unmounted component.');
    }

    if (a.return !== b.return) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;
      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        _child = _child.sibling;
      }
      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          _child = _child.sibling;
        }
        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
      }
    }

    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  }
  // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  }
  // Otherwise B has to be current branch.
  return alternate;
}

function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function addEventBubbleListener(element, eventType, listener) {
  element.addEventListener(eventType, listener, false);
}

function addEventCaptureListener(element, eventType, listener) {
  element.addEventListener(eventType, listener, true);
}

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var SyntheticAnimationEvent = SyntheticEvent.extend({
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
});

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var SyntheticClipboardEvent = SyntheticEvent.extend({
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
});

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var SyntheticFocusEvent = SyntheticUIEvent.extend({
  relatedTarget: null
});

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode = void 0;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
  // report Enter as charCode 10 when ctrl is pressed.
  if (charCode === 10) {
    charCode = 13;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var SyntheticKeyboardEvent = SyntheticUIEvent.extend({
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
});

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var SyntheticDragEvent = SyntheticMouseEvent.extend({
  dataTransfer: null
});

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var SyntheticTouchEvent = SyntheticUIEvent.extend({
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
});

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var SyntheticTransitionEvent = SyntheticEvent.extend({
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
});

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var SyntheticWheelEvent = SyntheticMouseEvent.extend({
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },

  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
});

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: [TOP_ABORT],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = new Map([
 *   [TOP_ABORT, { sameConfig }],
 * ]);
 */

var interactiveEventTypeNames = [[TOP_BLUR, 'blur'], [TOP_CANCEL, 'cancel'], [TOP_CLICK, 'click'], [TOP_CLOSE, 'close'], [TOP_CONTEXT_MENU, 'contextMenu'], [TOP_COPY, 'copy'], [TOP_CUT, 'cut'], [TOP_AUX_CLICK, 'auxClick'], [TOP_DOUBLE_CLICK, 'doubleClick'], [TOP_DRAG_END, 'dragEnd'], [TOP_DRAG_START, 'dragStart'], [TOP_DROP, 'drop'], [TOP_FOCUS, 'focus'], [TOP_INPUT, 'input'], [TOP_INVALID, 'invalid'], [TOP_KEY_DOWN, 'keyDown'], [TOP_KEY_PRESS, 'keyPress'], [TOP_KEY_UP, 'keyUp'], [TOP_MOUSE_DOWN, 'mouseDown'], [TOP_MOUSE_UP, 'mouseUp'], [TOP_PASTE, 'paste'], [TOP_PAUSE, 'pause'], [TOP_PLAY, 'play'], [TOP_POINTER_CANCEL, 'pointerCancel'], [TOP_POINTER_DOWN, 'pointerDown'], [TOP_POINTER_UP, 'pointerUp'], [TOP_RATE_CHANGE, 'rateChange'], [TOP_RESET, 'reset'], [TOP_SEEKED, 'seeked'], [TOP_SUBMIT, 'submit'], [TOP_TOUCH_CANCEL, 'touchCancel'], [TOP_TOUCH_END, 'touchEnd'], [TOP_TOUCH_START, 'touchStart'], [TOP_VOLUME_CHANGE, 'volumeChange']];
var nonInteractiveEventTypeNames = [[TOP_ABORT, 'abort'], [TOP_ANIMATION_END, 'animationEnd'], [TOP_ANIMATION_ITERATION, 'animationIteration'], [TOP_ANIMATION_START, 'animationStart'], [TOP_CAN_PLAY, 'canPlay'], [TOP_CAN_PLAY_THROUGH, 'canPlayThrough'], [TOP_DRAG, 'drag'], [TOP_DRAG_ENTER, 'dragEnter'], [TOP_DRAG_EXIT, 'dragExit'], [TOP_DRAG_LEAVE, 'dragLeave'], [TOP_DRAG_OVER, 'dragOver'], [TOP_DURATION_CHANGE, 'durationChange'], [TOP_EMPTIED, 'emptied'], [TOP_ENCRYPTED, 'encrypted'], [TOP_ENDED, 'ended'], [TOP_ERROR, 'error'], [TOP_GOT_POINTER_CAPTURE, 'gotPointerCapture'], [TOP_LOAD, 'load'], [TOP_LOADED_DATA, 'loadedData'], [TOP_LOADED_METADATA, 'loadedMetadata'], [TOP_LOAD_START, 'loadStart'], [TOP_LOST_POINTER_CAPTURE, 'lostPointerCapture'], [TOP_MOUSE_MOVE, 'mouseMove'], [TOP_MOUSE_OUT, 'mouseOut'], [TOP_MOUSE_OVER, 'mouseOver'], [TOP_PLAYING, 'playing'], [TOP_POINTER_MOVE, 'pointerMove'], [TOP_POINTER_OUT, 'pointerOut'], [TOP_POINTER_OVER, 'pointerOver'], [TOP_PROGRESS, 'progress'], [TOP_SCROLL, 'scroll'], [TOP_SEEKING, 'seeking'], [TOP_STALLED, 'stalled'], [TOP_SUSPEND, 'suspend'], [TOP_TIME_UPDATE, 'timeUpdate'], [TOP_TOGGLE, 'toggle'], [TOP_TOUCH_MOVE, 'touchMove'], [TOP_TRANSITION_END, 'transitionEnd'], [TOP_WAITING, 'waiting'], [TOP_WHEEL, 'wheel']];

var eventTypes$4 = {};
var topLevelEventsToDispatchConfig = {};

function addEventTypeNameToConfig(_ref, isInteractive) {
  var topEvent = _ref[0],
      event = _ref[1];

  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent],
    isInteractive: isInteractive
  };
  eventTypes$4[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
}

interactiveEventTypeNames.forEach(function (eventTuple) {
  addEventTypeNameToConfig(eventTuple, true);
});
nonInteractiveEventTypeNames.forEach(function (eventTuple) {
  addEventTypeNameToConfig(eventTuple, false);
});

// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes = [TOP_ABORT, TOP_CANCEL, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_CLOSE, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_INPUT, TOP_INVALID, TOP_LOAD, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_RESET, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUBMIT, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_TOGGLE, TOP_VOLUME_CHANGE, TOP_WAITING];

var SimpleEventPlugin = {
  eventTypes: eventTypes$4,

  isInteractiveTopLevelEventType: function (topLevelType) {
    var config = topLevelEventsToDispatchConfig[topLevelType];
    return config !== undefined && config.isInteractive === true;
  },


  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor = void 0;
    switch (topLevelType) {
      case TOP_KEY_PRESS:
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case TOP_KEY_DOWN:
      case TOP_KEY_UP:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case TOP_BLUR:
      case TOP_FOCUS:
        EventConstructor = SyntheticFocusEvent;
        break;
      case TOP_CLICK:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case TOP_AUX_CLICK:
      case TOP_DOUBLE_CLICK:
      case TOP_MOUSE_DOWN:
      case TOP_MOUSE_MOVE:
      case TOP_MOUSE_UP:
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case TOP_MOUSE_OUT:
      case TOP_MOUSE_OVER:
      case TOP_CONTEXT_MENU:
        EventConstructor = SyntheticMouseEvent;
        break;
      case TOP_DRAG:
      case TOP_DRAG_END:
      case TOP_DRAG_ENTER:
      case TOP_DRAG_EXIT:
      case TOP_DRAG_LEAVE:
      case TOP_DRAG_OVER:
      case TOP_DRAG_START:
      case TOP_DROP:
        EventConstructor = SyntheticDragEvent;
        break;
      case TOP_TOUCH_CANCEL:
      case TOP_TOUCH_END:
      case TOP_TOUCH_MOVE:
      case TOP_TOUCH_START:
        EventConstructor = SyntheticTouchEvent;
        break;
      case TOP_ANIMATION_END:
      case TOP_ANIMATION_ITERATION:
      case TOP_ANIMATION_START:
        EventConstructor = SyntheticAnimationEvent;
        break;
      case TOP_TRANSITION_END:
        EventConstructor = SyntheticTransitionEvent;
        break;
      case TOP_SCROLL:
        EventConstructor = SyntheticUIEvent;
        break;
      case TOP_WHEEL:
        EventConstructor = SyntheticWheelEvent;
        break;
      case TOP_COPY:
      case TOP_CUT:
      case TOP_PASTE:
        EventConstructor = SyntheticClipboardEvent;
        break;
      case TOP_GOT_POINTER_CAPTURE:
      case TOP_LOST_POINTER_CAPTURE:
      case TOP_POINTER_CANCEL:
      case TOP_POINTER_DOWN:
      case TOP_POINTER_MOVE:
      case TOP_POINTER_OUT:
      case TOP_POINTER_OVER:
      case TOP_POINTER_UP:
        EventConstructor = SyntheticPointerEvent;
        break;
      default:
        {
          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
            warningWithoutStack$1(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
          }
        }
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
    }
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    accumulateTwoPhaseDispatches(event);
    return event;
  }
};

var isInteractiveTopLevelEventType = SimpleEventPlugin.isInteractiveTopLevelEventType;


var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
var callbackBookkeepingPool = [];

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findRootContainerNode(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst.return) {
    inst = inst.return;
  }
  if (inst.tag !== HostRoot) {
    // This can happen if we're in a detached tree.
    return null;
  }
  return inst.stateNode.containerInfo;
}

// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
  if (callbackBookkeepingPool.length) {
    var instance = callbackBookkeepingPool.pop();
    instance.topLevelType = topLevelType;
    instance.nativeEvent = nativeEvent;
    instance.targetInst = targetInst;
    return instance;
  }
  return {
    topLevelType: topLevelType,
    nativeEvent: nativeEvent,
    targetInst: targetInst,
    ancestors: []
  };
}

function releaseTopLevelCallbackBookKeeping(instance) {
  instance.topLevelType = null;
  instance.nativeEvent = null;
  instance.targetInst = null;
  instance.ancestors.length = 0;
  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
    callbackBookkeepingPool.push(instance);
  }
}

function handleTopLevel(bookKeeping) {
  var targetInst = bookKeeping.targetInst;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    if (!ancestor) {
      bookKeeping.ancestors.push(ancestor);
      break;
    }
    var root = findRootContainerNode(ancestor);
    if (!root) {
      break;
    }
    bookKeeping.ancestors.push(ancestor);
    ancestor = getClosestInstanceFromNode(root);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    runExtractedEventsInBatch(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// TODO: can we stop exporting these?
var _enabled = true;

function setEnabled(enabled) {
  _enabled = !!enabled;
}

function isEnabled() {
  return _enabled;
}

/**
 * Traps top-level events by using event bubbling.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapBubbledEvent(topLevelType, element) {
  if (!element) {
    return null;
  }
  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;

  addEventBubbleListener(element, getRawEventName(topLevelType),
  // Check if interactive and wrap in interactiveUpdates
  dispatch.bind(null, topLevelType));
}

/**
 * Traps a top-level event by using event capturing.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapCapturedEvent(topLevelType, element) {
  if (!element) {
    return null;
  }
  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;

  addEventCaptureListener(element, getRawEventName(topLevelType),
  // Check if interactive and wrap in interactiveUpdates
  dispatch.bind(null, topLevelType));
}

function dispatchInteractiveEvent(topLevelType, nativeEvent) {
  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);
}

function dispatchEvent(topLevelType, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
    // If we get an event (ex: img onload) before committing that
    // component's mount, ignore it for now (that is, treat it as if it was an
    // event on a non-React tree). We might also consider queueing events and
    // dispatching them after the mount.
    targetInst = null;
  }

  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    batchedUpdates(handleTopLevel, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var reactTopListenersCounter = 0;

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} mountAt Container where to mount the listener
 */
function listenTo(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];

  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      switch (dependency) {
        case TOP_SCROLL:
          trapCapturedEvent(TOP_SCROLL, mountAt);
          break;
        case TOP_FOCUS:
        case TOP_BLUR:
          trapCapturedEvent(TOP_FOCUS, mountAt);
          trapCapturedEvent(TOP_BLUR, mountAt);
          // We set the flag for a single dependency later in this function,
          // but this ensures we mark both as attached rather than just one.
          isListening[TOP_BLUR] = true;
          isListening[TOP_FOCUS] = true;
          break;
        case TOP_CANCEL:
        case TOP_CLOSE:
          if (isEventSupported(getRawEventName(dependency))) {
            trapCapturedEvent(dependency, mountAt);
          }
          break;
        case TOP_INVALID:
        case TOP_SUBMIT:
        case TOP_RESET:
          // We listen to them on the target DOM elements.
          // Some of them bubble so we don't want them to fire twice.
          break;
        default:
          // By default, listen on the top level to all non-media events.
          // Media events don't bubble so adding the listener wouldn't do anything.
          var isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;
          if (!isMediaEvent) {
            trapBubbledEvent(dependency, mountAt);
          }
          break;
      }
      isListening[dependency] = true;
    }
  }
}

function isListeningToAllDependencies(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];
  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      return false;
    }
  }
  return true;
}

function getActiveElement(doc) {
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */
function getOffsets(outerNode) {
  var ownerDocument = outerNode.ownerDocument;

  var win = ownerDocument && ownerDocument.defaultView || window;
  var selection = win.getSelection && win.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode = selection.focusNode,
      focusOffset = selection.focusOffset;

  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
}

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */
function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }
      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      }
      // Moving from `node` to its first child `next`.
      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }
      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }
      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
        end = length;
      }
      if ((next = node.nextSibling) !== null) {
        break;
      }
      node = parentNode;
      parentNode = node.parentNode;
    }

    // Moving from `node` to its next sibling `next`.
    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setOffsets(node, offsets) {
  var doc = node.ownerDocument || document;
  var win = doc ? doc.defaultView : window;
  var selection = win.getSelection();
  var length = node.textContent.length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }
    var range = doc.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isTextNode(node) {
  return node && node.nodeType === TEXT_NODE;
}

function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

function isInDocument(node) {
  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
}

function getActiveElementDeep() {
  var win = window;
  var element = getActiveElement();
  while (element instanceof win.HTMLIFrameElement) {
    // Accessing the contentDocument of a HTMLIframeElement can cause the browser
    // to throw, e.g. if it has a cross-origin src attribute
    try {
      win = element.contentDocument.defaultView;
    } catch (e) {
      return element;
    }
    element = getActiveElement(win.document);
  }
  return element;
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

/**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
}

function getSelectionInformation() {
  var focusedElem = getActiveElementDeep();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
  };
}

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */
function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElementDeep();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    }

    // Focusing a node can change the scroll position, which is undesirable
    var ancestors = [];
    var ancestor = priorFocusedElem;
    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    if (typeof priorFocusedElem.focus === 'function') {
      priorFocusedElem.focus();
    }

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */
function getSelection$1(input) {
  var selection = void 0;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */
function setSelection(input, offsets) {
  var start = offsets.start,
      end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes$3 = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]
  }
};

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else {
    var win = node.ownerDocument && node.ownerDocument.defaultView || window;
    var selection = win.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Get document associated with the event target.
 *
 * @param {object} nativeEventTarget
 * @return {Document}
 */
function getEventTargetDocument(eventTarget) {
  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  var doc = getEventTargetDocument(nativeEventTarget);

  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes$3,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var doc = getEventTargetDocument(nativeEventTarget);
    // Track whether all listeners exists for this plugin. If none exist, we do
    // not extract events. See #3639.
    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
      return null;
    }

    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case TOP_FOCUS:
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement$1 = targetNode;
          activeElementInst$1 = targetInst;
          lastSelection = null;
        }
        break;
      case TOP_BLUR:
        activeElement$1 = null;
        activeElementInst$1 = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case TOP_MOUSE_DOWN:
        mouseDown = true;
        break;
      case TOP_CONTEXT_MENU:
      case TOP_MOUSE_UP:
      case TOP_DRAG_END:
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case TOP_SELECTION_CHANGE:
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case TOP_KEY_DOWN:
      case TOP_KEY_UP:
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  }
};

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
injection.injectEventPluginOrder(DOMEventPluginOrder);
setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
injection.injectEventPluginsByName({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});

var didWarnSelectedSetOnOption = false;
var didWarnInvalidChild = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children. We'll warn if they are invalid
  // during validateProps() which runs for hydration too.
  // Note that this would throw on non-element objects.
  // Elements are stringified (which is normally irrelevant
  // but matters for <fbt>).
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    content += child;
    // Note: we don't warn about invalid children here.
    // Instead, this is done separately below so that
    // it happens during the hydration codepath too.
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

function validateProps(element, props) {
  {
    // This mirrors the codepath above, but runs for hydration too.
    // Warn about invalid children here so that client and hydration are consistent.
    // TODO: this seems like it could cause a DEV-only throw for hydration
    // if children contains a non-element object. We should try to avoid that.
    if (typeof props.children === 'object' && props.children !== null) {
      React.Children.forEach(props.children, function (child) {
        if (child == null) {
          return;
        }
        if (typeof child === 'string' || typeof child === 'number') {
          return;
        }
        if (typeof child.type !== 'string') {
          return;
        }
        if (!didWarnInvalidChild) {
          didWarnInvalidChild = true;
          warning$1(false, 'Only strings and numbers are supported as <option> children.');
        }
      });
    }

    // TODO: Remove support for `selected` in <option>.
    if (props.selected != null && !didWarnSelectedSetOnOption) {
      warning$1(false, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
      didWarnSelectedSetOnOption = true;
    }
  }
}

function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', toString(getToStringValue(props.value)));
  }
}

function getHostProps$1(element, props) {
  var hostProps = _assign({ children: undefined }, props);
  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnValueDefaultValue$1 = void 0;

{
  didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerNameInDevOrNull();
  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 */
function checkSelectPropTypes(props) {
  ReactControlledValuePropTypes.checkPropTypes('select', props);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      warning$1(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
    } else if (!props.multiple && isArray) {
      warning$1(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};
    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }
    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = toString(getToStringValue(propValue));
    var defaultSelected = null;
    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;
        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}

function initWrapperState$1(element, props) {
  var node = element;
  {
    checkSelectPropTypes(props);
  }

  node._wrapperState = {
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      warning$1(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue$1 = true;
    }
  }
}

function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}

function postUpdateWrapper(element, props) {
  var node = element;
  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;

  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}

function restoreControlledState$2(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

function getHostProps$3(element, props) {
  var node = element;
  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: toString(node._wrapperState.initialValue)
  });

  return hostProps;
}

function initWrapperState$2(element, props) {
  var node = element;
  {
    ReactControlledValuePropTypes.checkPropTypes('textarea', props);
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      warning$1(false, '%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');
      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value;

  // Only bother fetching default value if we're going to use it
  if (initialValue == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      {
        warning$1(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }
      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
        children = children[0];
      }

      defaultValue = children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: getToStringValue(initialValue)
  };
}

function updateWrapper$1(element, props) {
  var node = element;
  var value = getToStringValue(props.value);
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = toString(value);
    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = toString(getToStringValue(props.defaultValue));
  }
}

function postMountWrapper$3(element, props) {
  var node = element;
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === node._wrapperState.initialValue) {
    node.value = textContent;
  }
}

function restoreControlledState$3(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var Namespaces = {
  html: HTML_NAMESPACE$1,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
};

// Assumes there is no parent namespace.
function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;
    case 'math':
      return MATH_NAMESPACE;
    default:
      return HTML_NAMESPACE$1;
  }
}

function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }
  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE$1;
  }
  // By default, pass namespace below.
  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer = void 0;

/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node

  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */
function hyphenateStyleName(name) {
  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

var warnValidStyle = function () {};

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  var msPattern$1 = /^-ms-/;
  var hyphenPattern = /-(.)/g;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var camelize = function (string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  };

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning$1(false, 'Unsupported style property %s. Did you mean %s?', name,
    // As Andi Smith suggests
    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
    // is converted to lowercase `ms`.
    camelize(name.replace(msPattern$1, 'ms-')));
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning$1(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning$1(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function (name, value) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning$1(false, '`NaN` is an invalid value for the `%s` css style property.', name);
  };

  var warnStyleValueIsInfinity = function (name, value) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning$1(false, '`Infinity` is an invalid value for the `%s` css style property.', name);
  };

  warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + hyphenateStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

        delimiter = ';';
      }
    }
    return serialized || null;
  }
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles) {
  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var isCustomProperty = styleName.indexOf('--') === 0;
    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName]);
      }
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
  // NOTE: menuitem's close tag should be omitted, but that causes problems.
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

// TODO: We can remove this if we add invariantWithStack()
// or add stack by default to invariants where possible.
var HTML$1 = '__html';

var ReactDebugCurrentFrame$2 = null;
{
  ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;
}

function assertValidProps(tag, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
  }
  {
    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning$1(false, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
  }
  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  default: 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  for: 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nomodule: 'noModule',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',

  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  in: 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  typeof: 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

var ariaProperties = {
  'aria-current': 0, // state
  'aria-details': 0,
  'aria-disabled': 0, // state
  'aria-hidden': 0, // state
  'aria-invalid': 0, // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function validateProperty(tagName, name) {
  if (hasOwnProperty$2.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (correctName == null) {
      warning$1(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
      warnedProperties[name] = true;
      return true;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== correctName) {
      warning$1(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      warning$1(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning$1(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
  } else if (invalidProps.length > 1) {
    warning$1(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;

function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;
    if (type === 'select' && props.multiple) {
      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
    } else {
      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
    }
  }
}

var validateProperty$1 = function () {};

{
  var warnedProperties$1 = {};
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();
    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning$1(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    }

    // We can't rely on the event system being injected on the server.
    if (canUseEventSystem) {
      if (registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
      if (registrationName != null) {
        warning$1(false, 'Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
        warnedProperties$1[name] = true;
        return true;
      }
      if (EVENT_NAME_REGEX.test(name)) {
        warning$1(false, 'Unknown event handler property `%s`. It will be ignored.', name);
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        warning$1(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Let the ARIA attribute hook validate ARIA attributes
    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning$1(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning$1(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning$1(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning$1(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);
      warnedProperties$1[name] = true;
      return true;
    }

    var propertyInfo = getPropertyInfo(name);
    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;

    // Known attributes should match the casing specified in the property config.
    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];
      if (standardName !== name) {
        warning$1(false, 'Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning$1(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      if (value) {
        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
      } else {
        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Now that we've validated casing, do not validate
    // data types for reserved props
    if (isReserved) {
      return true;
    }

    // Warn when a known attribute is a bad type
    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      warnedProperties$1[name] = true;
      return false;
    }

    // Warn when passing the strings 'false' or 'true' into a boolean prop
    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
      warning$1(false, 'Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
      warnedProperties$1[name] = true;
      return true;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, canUseEventSystem) {
  var unknownProps = [];
  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');
  if (unknownProps.length === 1) {
    warning$1(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
  } else if (unknownProps.length > 1) {
    warning$1(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
  }
};

function validateProperties$2(type, props, canUseEventSystem) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnUnknownProperties(type, props, canUseEventSystem);
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnInvalidHydration = false;
var didWarnShadyDOM = false;

var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML = '__html';

var HTML_NAMESPACE = Namespaces.html;


var warnedUnknownTags = void 0;
var suppressHydrationWarning = void 0;

var validatePropertiesInDevelopment = void 0;
var warnForTextDifference = void 0;
var warnForPropDifference = void 0;
var warnForExtraAttributes = void 0;
var warnForInvalidEventListener = void 0;
var canDiffStyleForHydrationWarning = void 0;

var normalizeMarkupForTextOrAttribute = void 0;
var normalizeHTML = void 0;

{
  warnedUnknownTags = {
    // Chrome is the only major browser not shipping <time>. But as of July
    // 2017 it intends to ship it due to widespread usage. We intentionally
    // *don't* warn for <time> even if it's unrecognized by Chrome because
    // it soon will be, and many apps have been using it anyway.
    time: true,
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true,
    // Electron ships a custom <webview> tag to display external web content in
    // an isolated frame and process.
    // This tag is not present in non Electron environments such as JSDom which
    // is often used for testing purposes.
    // @see https://electronjs.org/docs/api/webview-tag
    webview: true
  };

  validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, /* canUseEventSystem */true);
  };

  // IE 11 parses & normalizes the style attribute as opposed to other
  // browsers. It adds spaces and sorts the properties in some
  // non-alphabetical order. Handling that would require sorting CSS
  // properties in the client & server versions or applying
  // `expectedStyle` to a temporary DOM node to read its `style` attribute
  // normalized. Since it only affects IE, we're skipping style warnings
  // in that browser completely in favor of doing all that work.
  // See https://github.com/facebook/react/issues/11807
  canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;

  // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
    if (normalizedServerText === normalizedClientText) {
      return;
    }
    didWarnInvalidHydration = true;
    warningWithoutStack$1(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
    if (normalizedServerValue === normalizedClientValue) {
      return;
    }
    didWarnInvalidHydration = true;
    warningWithoutStack$1(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });
    warningWithoutStack$1(false, 'Extra attributes from the server: %s', names);
  };

  warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      warning$1(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);
    } else {
      warning$1(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);
    }
  };

  // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

function noop() {}

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = noop;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = nextProps[propKey];
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      // Relies on `updateStylesByID` not mutating `styleUpdates`.
      setValueForStyles(domElement, nextProp);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // We polyfill it separately on the client during commit.
      // We blacklist it here rather than in the property list because we emit it in SSR.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (nextProp != null) {
      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else {
      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
    }
  }
}

function createElement(type, props, rootContainerElement, parentNamespace) {
  var isCustomComponentTag = void 0;

  // We create tags in the namespace of their parent container, except HTML
  // tags get no namespace.
  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement = void 0;
  var namespaceURI = parentNamespace;
  if (namespaceURI === HTML_NAMESPACE) {
    namespaceURI = getIntrinsicNamespace(type);
  }
  if (namespaceURI === HTML_NAMESPACE) {
    {
      isCustomComponentTag = isCustomComponent(type, props);
      // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.
      !(isCustomComponentTag || type === type.toLowerCase()) ? warning$1(false, '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type) : void 0;
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');
      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.
      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, { is: props.is });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type);
      // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple`
      // attribute on `select`s needs to be added before `option`s are inserted. This prevents
      // a bug where the `select` does not scroll to the correct option because singular
      // `select` elements automatically pick the first item.
      // See https://github.com/facebook/react/issues/13222
      if (type === 'select' && props.multiple) {
        var node = domElement;
        node.multiple = true;
      }
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;
        warning$1(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}

function createTextNode(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}

function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);
  {
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning$1(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerNameInDevOrNull() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  var props = void 0;
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent(TOP_LOAD, domElement);
      props = rawProps;
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var i = 0; i < mediaEventTypes.length; i++) {
        trapBubbledEvent(mediaEventTypes[i], domElement);
      }
      props = rawProps;
      break;
    case 'source':
      trapBubbledEvent(TOP_ERROR, domElement);
      props = rawProps;
      break;
    case 'img':
    case 'image':
    case 'link':
      trapBubbledEvent(TOP_ERROR, domElement);
      trapBubbledEvent(TOP_LOAD, domElement);
      props = rawProps;
      break;
    case 'form':
      trapBubbledEvent(TOP_RESET, domElement);
      trapBubbledEvent(TOP_SUBMIT, domElement);
      props = rawProps;
      break;
    case 'details':
      trapBubbledEvent(TOP_TOGGLE, domElement);
      props = rawProps;
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps);
      trapBubbledEvent(TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps);
      trapBubbledEvent(TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps);
      trapBubbledEvent(TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    default:
      props = rawProps;
  }

  assertValidProps(tag, props);

  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, false);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;
    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;
    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }
}

// Calculate the diff between the two objects.
function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;

  var lastProps = void 0;
  var nextProps = void 0;
  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  assertValidProps(tag, nextProps);

  var propKey = void 0;
  var styleName = void 0;
  var styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      var lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

// Apply the diff.
function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
  // Apply the diff.
  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

  // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;
    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;
    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function getPossibleStandardName(propName) {
  {
    var lowerCasedName = propName.toLowerCase();
    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      return null;
    }
    return possibleStandardNames[lowerCasedName] || null;
  }
  return null;
}

function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  var isCustomComponentTag = void 0;
  var extraAttributeNames = void 0;

  {
    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
    isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning$1(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerNameInDevOrNull() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent(TOP_LOAD, domElement);
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var i = 0; i < mediaEventTypes.length; i++) {
        trapBubbledEvent(mediaEventTypes[i], domElement);
      }
      break;
    case 'source':
      trapBubbledEvent(TOP_ERROR, domElement);
      break;
    case 'img':
    case 'image':
    case 'link':
      trapBubbledEvent(TOP_ERROR, domElement);
      trapBubbledEvent(TOP_LOAD, domElement);
      break;
    case 'form':
      trapBubbledEvent(TOP_RESET, domElement);
      trapBubbledEvent(TOP_SUBMIT, domElement);
      break;
    case 'details':
      trapBubbledEvent(TOP_TOGGLE, domElement);
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      trapBubbledEvent(TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      trapBubbledEvent(TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      trapBubbledEvent(TOP_INVALID, domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
  }

  assertValidProps(tag, rawProps);

  {
    extraAttributeNames = new Set();
    var attributes = domElement.attributes;
    for (var _i = 0; _i < attributes.length; _i++) {
      var name = attributes[_i].name.toLowerCase();
      switch (name) {
        // Built-in SSR attribute is whitelisted
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        case 'value':
          break;
        case 'checked':
          break;
        case 'selected':
          break;
        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[_i].name);
      }
    }
  }

  var updatePayload = null;
  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = rawProps[propKey];
    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (true &&
    // Convince Flow we've calculated it (it's DEV-only in this method.)
    typeof isCustomComponentTag === 'boolean') {
      // Validate that the properties correspond to their expected values.
      var serverValue = void 0;
      var propertyInfo = getPropertyInfo(propKey);
      if (suppressHydrationWarning) {
        // Don't bother comparing. We're ignoring all these warnings.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
      // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
        // Noop
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var serverHTML = domElement.innerHTML;
        var nextHtml = nextProp ? nextProp[HTML] : undefined;
        var expectedHTML = normalizeHTML(domElement, nextHtml != null ? nextHtml : '');
        if (expectedHTML !== serverHTML) {
          warnForPropDifference(propKey, serverHTML, expectedHTML);
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey);

        if (canDiffStyleForHydrationWarning) {
          var expectedStyle = createDangerousStringForStyles(nextProp);
          serverValue = domElement.getAttribute('style');
          if (expectedStyle !== serverValue) {
            warnForPropDifference(propKey, serverValue, expectedStyle);
          }
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
        var isMismatchDueToBadCasing = false;
        if (propertyInfo !== null) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames.delete(propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
        } else {
          var ownNamespace = parentNamespace;
          if (ownNamespace === HTML_NAMESPACE) {
            ownNamespace = getIntrinsicNamespace(tag);
          }
          if (ownNamespace === HTML_NAMESPACE) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames.delete(propKey.toLowerCase());
          } else {
            var standardName = getPossibleStandardName(propKey);
            if (standardName !== null && standardName !== propKey) {
              // If an SVG prop is supplied with bad casing, it will
              // be successfully parsed from HTML, but will produce a mismatch
              // (and would be incorrectly rendered on the client).
              // However, we already warn about bad casing elsewhere.
              // So we'll skip the misleading extra mismatch warning in this case.
              isMismatchDueToBadCasing = true;
              // $FlowFixMe - Should be inferred as not undefined.
              extraAttributeNames.delete(standardName);
            }
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames.delete(propKey);
          }
          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, true);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;
    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  return updatePayload;
}

function diffHydratedText(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}

function warnForUnmatchedText(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}

function warnForDeletedHydratableElement(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warningWithoutStack$1(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}

function warnForDeletedHydratableText(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warningWithoutStack$1(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedElement(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warningWithoutStack$1(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedText(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warningWithoutStack$1(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}

function restoreControlledState$1(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState(domElement, props);
      return;
    case 'textarea':
      restoreControlledState$3(domElement, props);
      return;
    case 'select':
      restoreControlledState$2(domElement, props);
      return;
  }
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var validateDOMNesting = function () {};
var updatedAncestorInfo = function () {};

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  updatedAncestorInfo = function (oldInfo, tag) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      !(childTag == null) ? warningWithoutStack$1(false, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;
    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var addendum = getCurrentFiberStackInDev();

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
      }
      warningWithoutStack$1(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
    } else {
      warningWithoutStack$1(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
    }
  };
}

// Renderers that don't support persistence
// can re-export everything from this module.

function shim() {
  invariant(false, 'The current renderer does not support persistence. This error is likely caused by a bug in React. Please file an issue.');
}

// Persistence (when unsupported)
var supportsPersistence = false;
var cloneInstance = shim;
var createContainerChildSet = shim;
var appendChildToContainerChildSet = shim;
var finalizeContainerChildren = shim;
var replaceContainerChildren = shim;

var SUPPRESS_HYDRATION_WARNING = void 0;
{
  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
}

var eventsEnabled = null;
var selectionInformation = null;

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}

function getRootHostContext(rootContainerInstance) {
  var type = void 0;
  var namespace = void 0;
  var nodeType = rootContainerInstance.nodeType;
  switch (nodeType) {
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      {
        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
        var root = rootContainerInstance.documentElement;
        namespace = root ? root.namespaceURI : getChildNamespace(null, '');
        break;
      }
    default:
      {
        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
        var ownNamespace = container.namespaceURI || null;
        type = container.tagName;
        namespace = getChildNamespace(ownNamespace, type);
        break;
      }
  }
  {
    var validatedTag = type.toLowerCase();
    var _ancestorInfo = updatedAncestorInfo(null, validatedTag);
    return { namespace: namespace, ancestorInfo: _ancestorInfo };
  }
  return namespace;
}

function getChildHostContext(parentHostContext, type, rootContainerInstance) {
  {
    var parentHostContextDev = parentHostContext;
    var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
    var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
    return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
  }
  var parentNamespace = parentHostContext;
  return getChildNamespace(parentNamespace, type);
}

function getPublicInstance(instance) {
  return instance;
}

function prepareForCommit(containerInfo) {
  eventsEnabled = isEnabled();
  selectionInformation = getSelectionInformation();
  setEnabled(false);
}

function resetAfterCommit(containerInfo) {
  restoreSelection(selectionInformation);
  selectionInformation = null;
  setEnabled(eventsEnabled);
  eventsEnabled = null;
}

function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  var parentNamespace = void 0;
  {
    // TODO: take namespace into account when validating.
    var hostContextDev = hostContext;
    validateDOMNesting(type, null, hostContextDev.ancestorInfo);
    if (typeof props.children === 'string' || typeof props.children === 'number') {
      var string = '' + props.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }
    parentNamespace = hostContextDev.namespace;
  }
  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
}

function appendInitialChild(parentInstance, child) {
  parentInstance.appendChild(child);
}

function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
  setInitialProperties(domElement, type, props, rootContainerInstance);
  return shouldAutoFocusHostComponent(type, props);
}

function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
  {
    var hostContextDev = hostContext;
    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
      var string = '' + newProps.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }
  }
  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
}

function shouldSetTextContent(type, props) {
  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
}

function shouldDeprioritizeSubtree(type, props) {
  return !!props.hidden;
}

function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
  {
    var hostContextDev = hostContext;
    validateDOMNesting(null, text, hostContextDev.ancestorInfo);
  }
  var textNode = createTextNode(text, rootContainerInstance);
  precacheFiberNode(internalInstanceHandle, textNode);
  return textNode;
}

var isPrimaryRenderer = true;
var scheduleTimeout = setTimeout;
var cancelTimeout = clearTimeout;
var noTimeout = -1;

// -------------------
//     Mutation
// -------------------

var supportsMutation = true;

function commitMount(domElement, type, newProps, internalInstanceHandle) {
  // Despite the naming that might imply otherwise, this method only
  // fires if there is an `Update` effect scheduled during mounting.
  // This happens if `finalizeInitialChildren` returns `true` (which it
  // does to implement the `autoFocus` attribute on the client). But
  // there are also other cases when this might happen (such as patching
  // up text content during hydration mismatch). So we'll check this again.
  if (shouldAutoFocusHostComponent(type, newProps)) {
    domElement.focus();
  }
}

function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
  // Update the props handle so that we know which props are the ones with
  // with current event handlers.
  updateFiberProps(domElement, newProps);
  // Apply the diff to the DOM node.
  updateProperties(domElement, updatePayload, type, oldProps, newProps);
}

function resetTextContent(domElement) {
  setTextContent(domElement, '');
}

function commitTextUpdate(textInstance, oldText, newText) {
  textInstance.nodeValue = newText;
}

function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}

function appendChildToContainer(container, child) {
  var parentNode = void 0;
  if (container.nodeType === COMMENT_NODE) {
    parentNode = container.parentNode;
    parentNode.insertBefore(child, container);
  } else {
    parentNode = container;
    parentNode.appendChild(child);
  }
  // This container might be used for a portal.
  // If something inside a portal is clicked, that click should bubble
  // through the React tree. However, on Mobile Safari the click would
  // never bubble through the *DOM* tree unless an ancestor with onclick
  // event exists. So we wouldn't see it and dispatch it.
  // This is why we ensure that containers have inline onclick defined.
  // https://github.com/facebook/react/issues/11918
  if (parentNode.onclick === null) {
    // TODO: This cast may not be sound for SVG, MathML or custom elements.
    trapClickOnNonInteractiveElement(parentNode);
  }
}

function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}

function insertInContainerBefore(container, child, beforeChild) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.insertBefore(child, beforeChild);
  } else {
    container.insertBefore(child, beforeChild);
  }
}

function removeChild(parentInstance, child) {
  parentInstance.removeChild(child);
}

function removeChildFromContainer(container, child) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.removeChild(child);
  } else {
    container.removeChild(child);
  }
}

// -------------------
//     Hydration
// -------------------

var supportsHydration = true;

function canHydrateInstance(instance, type, props) {
  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
    return null;
  }
  // This has now been refined to an element node.
  return instance;
}

function canHydrateTextInstance(instance, text) {
  if (text === '' || instance.nodeType !== TEXT_NODE) {
    // Empty strings are not parsed by HTML so there won't be a correct match here.
    return null;
  }
  // This has now been refined to a text node.
  return instance;
}

function getNextHydratableSibling(instance) {
  var node = instance.nextSibling;
  // Skip non-hydratable nodes.
  while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
    node = node.nextSibling;
  }
  return node;
}

function getFirstHydratableChild(parentInstance) {
  var next = parentInstance.firstChild;
  // Skip non-hydratable nodes.
  while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
    next = next.nextSibling;
  }
  return next;
}

function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, instance);
  // TODO: Possibly defer this until the commit phase where all the events
  // get attached.
  updateFiberProps(instance, props);
  var parentNamespace = void 0;
  {
    var hostContextDev = hostContext;
    parentNamespace = hostContextDev.namespace;
  }
  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
}

function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, textInstance);
  return diffHydratedText(textInstance, text);
}

function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
  {
    warnForUnmatchedText(textInstance, text);
  }
}

function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
    warnForUnmatchedText(textInstance, text);
  }
}

function didNotHydrateContainerInstance(parentContainer, instance) {
  {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentContainer, instance);
    } else {
      warnForDeletedHydratableText(parentContainer, instance);
    }
  }
}

function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentInstance, instance);
    } else {
      warnForDeletedHydratableText(parentInstance, instance);
    }
  }
}

function didNotFindHydratableContainerInstance(parentContainer, type, props) {
  {
    warnForInsertedHydratedElement(parentContainer, type, props);
  }
}

function didNotFindHydratableContainerTextInstance(parentContainer, text) {
  {
    warnForInsertedHydratedText(parentContainer, text);
  }
}

function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
    warnForInsertedHydratedElement(parentInstance, type, props);
  }
}

function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
    warnForInsertedHydratedText(parentInstance, text);
  }
}

// Exports ReactDOM.createRoot
var enableUserTimingAPI = true;

// Experimental error-boundary API that can recover from errors within a single
// render phase
var enableGetDerivedStateFromCatch = false;
// Suspense
var enableSuspense = false;
// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects = false;

// In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:
var debugRenderPhaseSideEffectsForStrictMode = true;

// To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.
var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;

// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:
var warnAboutDeprecatedLifecycles = false;

// Warn about legacy context API
var warnAboutLegacyContextAPI = false;

// Gather advanced timing metrics for Profiler subtrees.
var enableProfilerTimer = true;

// Track which interactions trigger each commit.
var enableSchedulerTracking = true;

// Only used in www builds.


// Only used in www builds.

// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji = '\u269B';
var warningEmoji = '\u26D4';
var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber = null;
// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase = null;
var currentPhaseFiber = null;
// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting = false;
var hasScheduledUpdateInCurrentCommit = false;
var hasScheduledUpdateInCurrentPhase = false;
var commitCountInCurrentWorkLoop = 0;
var effectCountInCurrentCommit = 0;
var isWaitingForCallback = false;
// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit = new Set();

var formatMarkName = function (markName) {
  return reactEmoji + ' ' + markName;
};

var formatLabel = function (label, warning) {
  var prefix = warning ? warningEmoji + ' ' : reactEmoji + ' ';
  var suffix = warning ? ' Warning: ' + warning : '';
  return '' + prefix + label + suffix;
};

var beginMark = function (markName) {
  performance.mark(formatMarkName(markName));
};

var clearMark = function (markName) {
  performance.clearMarks(formatMarkName(markName));
};

var endMark = function (label, markName, warning) {
  var formattedMarkName = formatMarkName(markName);
  var formattedLabel = formatLabel(label, warning);
  try {
    performance.measure(formattedLabel, formattedMarkName);
  } catch (err) {}
  // If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.

  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);
  performance.clearMeasures(formattedLabel);
};

var getFiberMarkName = function (label, debugID) {
  return label + ' (#' + debugID + ')';
};

var getFiberLabel = function (componentName, isMounted, phase) {
  if (phase === null) {
    // These are composite component total time measurements.
    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
  } else {
    // Composite component methods.
    return componentName + '.' + phase;
  }
};

var beginFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber.type) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);

  if (isCommitting && labelsInCurrentCommit.has(label)) {
    // During the commit phase, we don't show duplicate labels because
    // there is a fixed overhead for every measurement, and we don't
    // want to stretch the commit phase beyond necessary.
    return false;
  }
  labelsInCurrentCommit.add(label);

  var markName = getFiberMarkName(label, debugID);
  beginMark(markName);
  return true;
};

var clearFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber.type) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  clearMark(markName);
};

var endFiberMark = function (fiber, phase, warning) {
  var componentName = getComponentName(fiber.type) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  endMark(label, markName, warning);
};

var shouldIgnoreFiber = function (fiber) {
  // Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch (fiber.tag) {
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
    case Fragment:
    case ContextProvider:
    case ContextConsumer:
    case Mode:
      return true;
    default:
      return false;
  }
};

var clearPendingPhaseMeasurement = function () {
  if (currentPhase !== null && currentPhaseFiber !== null) {
    clearFiberMark(currentPhaseFiber, currentPhase);
  }
  currentPhaseFiber = null;
  currentPhase = null;
  hasScheduledUpdateInCurrentPhase = false;
};

var pauseTimers = function () {
  // Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber = currentFiber;
  while (fiber) {
    if (fiber._debugIsCurrentlyTiming) {
      endFiberMark(fiber, null, null);
    }
    fiber = fiber.return;
  }
};

var resumeTimersRecursively = function (fiber) {
  if (fiber.return !== null) {
    resumeTimersRecursively(fiber.return);
  }
  if (fiber._debugIsCurrentlyTiming) {
    beginFiberMark(fiber, null);
  }
};

var resumeTimers = function () {
  // Resumes all measurements that were active during the last deferred loop.
  if (currentFiber !== null) {
    resumeTimersRecursively(currentFiber);
  }
};

function recordEffect() {
  if (enableUserTimingAPI) {
    effectCountInCurrentCommit++;
  }
}

function recordScheduleUpdate() {
  if (enableUserTimingAPI) {
    if (isCommitting) {
      hasScheduledUpdateInCurrentCommit = true;
    }
    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
      hasScheduledUpdateInCurrentPhase = true;
    }
  }
}

function startRequestCallbackTimer() {
  if (enableUserTimingAPI) {
    if (supportsUserTiming && !isWaitingForCallback) {
      isWaitingForCallback = true;
      beginMark('(Waiting for async callback...)');
    }
  }
}

function stopRequestCallbackTimer(didExpire, expirationTime) {
  if (enableUserTimingAPI) {
    if (supportsUserTiming) {
      isWaitingForCallback = false;
      var warning = didExpire ? 'React was blocked by main thread' : null;
      endMark('(Waiting for async callback... will force flush in ' + expirationTime + ' ms)', '(Waiting for async callback...)', warning);
    }
  }
}

function startWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, this is the fiber to unwind from.
    currentFiber = fiber;
    if (!beginFiberMark(fiber, null)) {
      return;
    }
    fiber._debugIsCurrentlyTiming = true;
  }
}

function cancelWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // Remember we shouldn't complete measurement for this fiber.
    // Otherwise flamechart will be deep even for small updates.
    fiber._debugIsCurrentlyTiming = false;
    clearFiberMark(fiber, null);
  }
}

function stopWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber.return;
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    endFiberMark(fiber, null, null);
  }
}

function stopFailedWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber.return;
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    var warning = 'An error was thrown inside this error boundary';
    endFiberMark(fiber, null, warning);
  }
}

function startPhaseTimer(fiber, phase) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    clearPendingPhaseMeasurement();
    if (!beginFiberMark(fiber, phase)) {
      return;
    }
    currentPhaseFiber = fiber;
    currentPhase = phase;
  }
}

function stopPhaseTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    if (currentPhase !== null && currentPhaseFiber !== null) {
      var warning = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
      endFiberMark(currentPhaseFiber, currentPhase, warning);
    }
    currentPhase = null;
    currentPhaseFiber = null;
  }
}

function startWorkLoopTimer(nextUnitOfWork) {
  if (enableUserTimingAPI) {
    currentFiber = nextUnitOfWork;
    if (!supportsUserTiming) {
      return;
    }
    commitCountInCurrentWorkLoop = 0;
    // This is top level call.
    // Any other measurements are performed within.
    beginMark('(React Tree Reconciliation)');
    // Resume any measurements that were in progress during the last loop.
    resumeTimers();
  }
}

function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var warning = null;
    if (interruptedBy !== null) {
      if (interruptedBy.tag === HostRoot) {
        warning = 'A top-level update interrupted the previous render';
      } else {
        var componentName = getComponentName(interruptedBy.type) || 'Unknown';
        warning = 'An update to ' + componentName + ' interrupted the previous render';
      }
    } else if (commitCountInCurrentWorkLoop > 1) {
      warning = 'There were cascading updates';
    }
    commitCountInCurrentWorkLoop = 0;
    var label = didCompleteRoot ? '(React Tree Reconciliation: Completed Root)' : '(React Tree Reconciliation: Yielded)';
    // Pause any measurements until the next loop.
    pauseTimers();
    endMark(label, '(React Tree Reconciliation)', warning);
  }
}

function startCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    isCommitting = true;
    hasScheduledUpdateInCurrentCommit = false;
    labelsInCurrentCommit.clear();
    beginMark('(Committing Changes)');
  }
}

function stopCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }

    var warning = null;
    if (hasScheduledUpdateInCurrentCommit) {
      warning = 'Lifecycle hook scheduled a cascading update';
    } else if (commitCountInCurrentWorkLoop > 0) {
      warning = 'Caused by a cascading update in earlier commit';
    }
    hasScheduledUpdateInCurrentCommit = false;
    commitCountInCurrentWorkLoop++;
    isCommitting = false;
    labelsInCurrentCommit.clear();

    endMark('(Committing Changes)', '(Committing Changes)', warning);
  }
}

function startCommitSnapshotEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Snapshot Effects)');
  }
}

function stopCommitSnapshotEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Snapshot Effects: ' + count + ' Total)', '(Committing Snapshot Effects)', null);
  }
}

function startCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Host Effects)');
  }
}

function stopCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
  }
}

function startCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Calling Lifecycle Methods)');
  }
}

function stopCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
  }
}

var valueStack = [];

var fiberStack = void 0;

{
  fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}

function pop(cursor, fiber) {
  if (index < 0) {
    {
      warningWithoutStack$1(false, 'Unexpected pop.');
    }
    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      warningWithoutStack$1(false, 'Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];

  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;

  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

function checkThatStackIsEmpty() {
  {
    if (index !== -1) {
      warningWithoutStack$1(false, 'Expected an empty stack. Something was not reset properly.');
    }
  }
}

function resetStackAfterFatalErrorInDev() {
  {
    index = -1;
    valueStack.length = 0;
    fiberStack.length = 0;
  }
}

var warnedAboutMissingGetChildContext = void 0;

{
  warnedAboutMissingGetChildContext = {};
}

var emptyContextObject = {};
{
  Object.freeze(emptyContextObject);
}

// A cursor to the current merged context object on the stack.
var contextStackCursor = createCursor(emptyContextObject);
// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor = createCursor(false);
// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext = emptyContextObject;

function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
  if (didPushOwnContextIfProvider && isContextProvider(Component)) {
    // If the fiber is a context provider itself, when we read its context
    // we may have already pushed its own child context on the stack. A context
    // provider should not "see" its own child context. Therefore we read the
    // previous (parent) context instead for a context provider.
    return previousContext;
  }
  return contextStackCursor.current;
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  var instance = workInProgress.stateNode;
  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
}

function getMaskedContext(workInProgress, unmaskedContext) {
  var type = workInProgress.type;
  var contextTypes = type.contextTypes;
  if (!contextTypes) {
    return emptyContextObject;
  }

  // Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance = workInProgress.stateNode;
  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
    return instance.__reactInternalMemoizedMaskedChildContext;
  }

  var context = {};
  for (var key in contextTypes) {
    context[key] = unmaskedContext[key];
  }

  {
    var name = getComponentName(type) || 'Unknown';
    checkPropTypes(contextTypes, context, 'context', name, getCurrentFiberStackInDev);
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if (instance) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return context;
}

function hasContextChanged() {
  return didPerformWorkStackCursor.current;
}

function isContextProvider(type) {
  var childContextTypes = type.childContextTypes;
  return childContextTypes !== null && childContextTypes !== undefined;
}

function popContext(fiber) {
  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function popTopLevelContextObject(fiber) {
  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function pushTopLevelContextObject(fiber, context, didChange) {
  !(contextStackCursor.current === emptyContextObject) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  push(contextStackCursor, context, fiber);
  push(didPerformWorkStackCursor, didChange, fiber);
}

function processChildContext(fiber, type, parentContext) {
  var instance = fiber.stateNode;
  var childContextTypes = type.childContextTypes;

  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if (typeof instance.getChildContext !== 'function') {
    {
      var componentName = getComponentName(type) || 'Unknown';

      if (!warnedAboutMissingGetChildContext[componentName]) {
        warnedAboutMissingGetChildContext[componentName] = true;
        warningWithoutStack$1(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
      }
    }
    return parentContext;
  }

  var childContext = void 0;
  {
    setCurrentPhase('getChildContext');
  }
  startPhaseTimer(fiber, 'getChildContext');
  childContext = instance.getChildContext();
  stopPhaseTimer();
  {
    setCurrentPhase(null);
  }
  for (var contextKey in childContext) {
    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(type) || 'Unknown', contextKey) : void 0;
  }
  {
    var name = getComponentName(type) || 'Unknown';
    checkPropTypes(childContextTypes, childContext, 'child context', name,
    // In practice, there is one case in which we won't get a stack. It's when
    // somebody calls unstable_renderSubtreeIntoContainer() and we process
    // context from the parent component instance. The stack will be missing
    // because it's outside of the reconciliation, and so the pointer has not
    // been set. This is rare and doesn't matter. We'll also remove that API.
    getCurrentFiberStackInDev);
  }

  return _assign({}, parentContext, childContext);
}

function pushContextProvider(workInProgress) {
  var instance = workInProgress.stateNode;
  // We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;

  // Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext = contextStackCursor.current;
  push(contextStackCursor, memoizedMergedChildContext, workInProgress);
  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

  return true;
}

function invalidateContextProvider(workInProgress, type, didChange) {
  var instance = workInProgress.stateNode;
  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  if (didChange) {
    // Merge parent and own context.
    // Skip this if we're not updating due to sCU.
    // This avoids unnecessarily recomputing memoized values.
    var mergedContext = processChildContext(workInProgress, type, previousContext);
    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

    // Replace the old (or empty) context with the new one.
    // It is important to unwind the context in the reverse order.
    pop(didPerformWorkStackCursor, workInProgress);
    pop(contextStackCursor, workInProgress);
    // Now push the new context and mark that it has changed.
    push(contextStackCursor, mergedContext, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  } else {
    pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
}

function findCurrentUnmaskedContext(fiber) {
  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  !(isFiberMounted(fiber) && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  var node = fiber;
  do {
    switch (node.tag) {
      case HostRoot:
        return node.stateNode.context;
      case ClassComponent:
        {
          var Component = node.type;
          if (isContextProvider(Component)) {
            return node.stateNode.__reactInternalMemoizedMergedChildContext;
          }
          break;
        }
      case ClassComponentLazy:
        {
          var _Component = getResultFromResolvedThenable(node.type);
          if (isContextProvider(_Component)) {
            return node.stateNode.__reactInternalMemoizedMergedChildContext;
          }
          break;
        }
    }
    node = node.return;
  } while (node !== null);
  invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.');
}

var onCommitFiberRoot = null;
var onCommitFiberUnmount = null;
var hasLoggedError = false;

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      if (true && !hasLoggedError) {
        hasLoggedError = true;
        warningWithoutStack$1(false, 'React DevTools encountered an error: %s', err);
      }
    }
  };
}

var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';

function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }
  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }
  if (!hook.supportsFiber) {
    {
      warningWithoutStack$1(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
    }
    // DevTools exists, even though it doesn't support Fiber.
    return true;
  }
  try {
    var rendererID = hook.inject(internals);
    // We have successfully injected, so now it is safe to set up hooks.
    onCommitFiberRoot = catchErrors(function (root) {
      return hook.onCommitFiberRoot(rendererID, root);
    });
    onCommitFiberUnmount = catchErrors(function (fiber) {
      return hook.onCommitFiberUnmount(rendererID, fiber);
    });
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      warningWithoutStack$1(false, 'React DevTools encountered an error: %s.', err);
    }
  }
  // DevTools exists
  return true;
}

function onCommitRoot(root) {
  if (typeof onCommitFiberRoot === 'function') {
    onCommitFiberRoot(root);
  }
}

function onCommitUnmount(fiber) {
  if (typeof onCommitFiberUnmount === 'function') {
    onCommitFiberUnmount(fiber);
  }
}

// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var maxSigned31BitInt = 1073741823;

var NoWork = 0;
var Sync = 1;
var Never = maxSigned31BitInt;

var UNIT_SIZE = 10;
var MAGIC_NUMBER_OFFSET = 2;

// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms) {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
}

function expirationTimeToMs(expirationTime) {
  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
}

function ceiling(num, precision) {
  return ((num / precision | 0) + 1) * precision;
}

function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
  return MAGIC_NUMBER_OFFSET + ceiling(currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
}

var LOW_PRIORITY_EXPIRATION = 5000;
var LOW_PRIORITY_BATCH_SIZE = 250;

function computeAsyncExpiration(currentTime) {
  return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
}

// We intentionally set a higher expiration time for interactive updates in
// dev than in production.
//
// If the main thread is being blocked so long that you hit the expiration,
// it's a problem that could be solved with better scheduling.
//
// People will be more likely to notice this and fix it with the long
// expiration time in development.
//
// In production we opt for better UX at the risk of masking scheduling
// problems, by expiring fast.
var HIGH_PRIORITY_EXPIRATION = 500;
var HIGH_PRIORITY_BATCH_SIZE = 100;

function computeInteractiveExpiration(currentTime) {
  return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
}

var NoContext = 0;
var AsyncMode = 1;
var StrictMode = 2;
var ProfileMode = 4;

var hasBadMapPolyfill = void 0;

{
  hasBadMapPolyfill = false;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    var testMap = new Map([[nonExtensibleObject, null]]);
    var testSet = new Set([nonExtensibleObject]);
    // This is necessary for Rollup to not consider these unused.
    // https://github.com/rollup/rollup/issues/1771
    // TODO: we can remove these if Rollup fixes the bug.
    testMap.set(0, 0);
    testSet.add(0);
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


var debugCounter = void 0;

{
  debugCounter = 1;
}

function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.firstContextDependency = null;

  this.mode = mode;

  // Effects
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = NoWork;
  this.childExpirationTime = NoWork;

  this.alternate = null;

  if (enableProfilerTimer) {
    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }

  {
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugIsCurrentlyTiming = false;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}

// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function (tag, pendingProps, key, mode) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, pendingProps, key, mode);
};

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return typeof prototype === 'object' && prototype !== null && typeof prototype.isReactComponent === 'object' && prototype.isReactComponent !== null;
}

function resolveLazyComponentTag(fiber, Component) {
  if (typeof Component === 'function') {
    return shouldConstruct(Component) ? ClassComponentLazy : FunctionalComponentLazy;
  } else if (Component !== undefined && Component !== null && Component.$$typeof) {
    return ForwardRefLazy;
  }
  return IndeterminateComponent;
}

// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps, expirationTime) {
  var workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;

    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.effectTag = NoEffect;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    if (enableProfilerTimer) {
      // We intentionally reset, rather than copy, actualDuration & actualStartTime.
      // This prevents time from endlessly accumulating in new commits.
      // This has the downside of resetting values for different priority renders,
      // But works for yielding (the common case) and should support resuming.
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  // Don't touching the subtree's expiration time, which has not changed.
  workInProgress.childExpirationTime = current.childExpirationTime;
  if (pendingProps !== current.pendingProps) {
    // This fiber has new props.
    workInProgress.expirationTime = expirationTime;
  } else {
    // This fiber's props have not changed.
    workInProgress.expirationTime = current.expirationTime;
  }

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.firstContextDependency = current.firstContextDependency;

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  if (enableProfilerTimer) {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  return workInProgress;
}

function createHostRootFiber(isAsync) {
  var mode = isAsync ? AsyncMode | StrictMode : NoContext;

  if (enableProfilerTimer && isDevToolsPresent) {
    // Always collect profile timings when DevTools are present.
    // This enables DevTools to start capturing timing at any point–
    // Without some nodes in the tree having empty base times.
    mode |= ProfileMode;
  }

  return createFiber(HostRoot, null, null, mode);
}

function createFiberFromElement(element, mode, expirationTime) {
  var owner = null;
  {
    owner = element._owner;
  }

  var fiber = void 0;
  var type = element.type;
  var key = element.key;
  var pendingProps = element.props;

  var fiberTag = void 0;
  if (typeof type === 'function') {
    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;
  } else if (typeof type === 'string') {
    fiberTag = HostComponent;
  } else {
    getTag: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);
      case REACT_ASYNC_MODE_TYPE:
        fiberTag = Mode;
        mode |= AsyncMode | StrictMode;
        break;
      case REACT_STRICT_MODE_TYPE:
        fiberTag = Mode;
        mode |= StrictMode;
        break;
      case REACT_PROFILER_TYPE:
        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
      case REACT_PLACEHOLDER_TYPE:
        fiberTag = PlaceholderComponent;
        break;
      default:
        {
          if (typeof type === 'object' && type !== null) {
            switch (type.$$typeof) {
              case REACT_PROVIDER_TYPE:
                fiberTag = ContextProvider;
                break getTag;
              case REACT_CONTEXT_TYPE:
                // This is a consumer
                fiberTag = ContextConsumer;
                break getTag;
              case REACT_FORWARD_REF_TYPE:
                fiberTag = ForwardRef;
                break getTag;
              default:
                {
                  if (typeof type.then === 'function') {
                    fiberTag = IndeterminateComponent;
                    break getTag;
                  }
                }
            }
          }
          var info = '';
          {
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
              info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
            }
            var ownerName = owner ? getComponentName(owner.type) : null;
            if (ownerName) {
              info += '\n\nCheck the render method of `' + ownerName + '`.';
            }
          }
          invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
        }
    }
  }

  fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.type = type;
  fiber.expirationTime = expirationTime;

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  return fiber;
}

function createFiberFromFragment(elements, mode, expirationTime, key) {
  var fiber = createFiber(Fragment, elements, key, mode);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
  {
    if (typeof pendingProps.id !== 'string' || typeof pendingProps.onRender !== 'function') {
      warningWithoutStack$1(false, 'Profiler must specify an "id" string and "onRender" function as props');
    }
  }

  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
  fiber.type = REACT_PROFILER_TYPE;
  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromText(content, mode, expirationTime) {
  var fiber = createFiber(HostText, content, null, mode);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, null, NoContext);
  fiber.type = 'DELETED';
  return fiber;
}

function createFiberFromPortal(portal, mode, expirationTime) {
  var pendingProps = portal.children !== null ? portal.children : [];
  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
  fiber.expirationTime = expirationTime;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null, // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}

// Used for stashing WIP properties to replay failed work in DEV.
function assignFiberPropertiesInDEV(target, source) {
  if (target === null) {
    // This Fiber's initial properties will always be overwritten.
    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
    target = createFiber(IndeterminateComponent, null, null, NoContext);
  }

  // This is intentionally written as a list of all properties.
  // We tried to use Object.assign() instead but this is called in
  // the hottest path, and Object.assign() was too slow:
  // https://github.com/facebook/react/issues/12502
  // This code is DEV-only so size is not a concern.

  target.tag = source.tag;
  target.key = source.key;
  target.type = source.type;
  target.stateNode = source.stateNode;
  target.return = source.return;
  target.child = source.child;
  target.sibling = source.sibling;
  target.index = source.index;
  target.ref = source.ref;
  target.pendingProps = source.pendingProps;
  target.memoizedProps = source.memoizedProps;
  target.updateQueue = source.updateQueue;
  target.memoizedState = source.memoizedState;
  target.firstContextDependency = source.firstContextDependency;
  target.mode = source.mode;
  target.effectTag = source.effectTag;
  target.nextEffect = source.nextEffect;
  target.firstEffect = source.firstEffect;
  target.lastEffect = source.lastEffect;
  target.expirationTime = source.expirationTime;
  target.childExpirationTime = source.childExpirationTime;
  target.alternate = source.alternate;
  if (enableProfilerTimer) {
    target.actualDuration = source.actualDuration;
    target.actualStartTime = source.actualStartTime;
    target.selfBaseDuration = source.selfBaseDuration;
    target.treeBaseDuration = source.treeBaseDuration;
  }
  target._debugID = source._debugID;
  target._debugSource = source._debugSource;
  target._debugOwner = source._debugOwner;
  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
  return target;
}

// TODO: This should be lifted into the renderer.


// The following attributes are only used by interaction tracking builds.
// They enable interactions to be associated with their async work,
// And expose interaction metadata to the React DevTools Profiler plugin.
// Note that these attributes are only defined when the enableSchedulerTracking flag is enabled.


// Exported FiberRoot type includes all properties,
// To avoid requiring potentially error-prone :any casts throughout the project.
// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracking is true).
// The types are defined separately within this file to ensure they stay in sync.
// (We don't have to use an inline :any cast when enableSchedulerTracking is disabled.)


function createFiberRoot(containerInfo, isAsync, hydrate) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostRootFiber(isAsync);

  var root = void 0;
  if (enableSchedulerTracking) {
    root = {
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      earliestPendingTime: NoWork,
      latestPendingTime: NoWork,
      earliestSuspendedTime: NoWork,
      latestSuspendedTime: NoWork,
      latestPingedTime: NoWork,

      didError: false,

      pendingCommitExpirationTime: NoWork,
      finishedWork: null,
      timeoutHandle: noTimeout,
      context: null,
      pendingContext: null,
      hydrate: hydrate,
      nextExpirationTimeToWorkOn: NoWork,
      expirationTime: NoWork,
      firstBatch: null,
      nextScheduledRoot: null,

      interactionThreadID: tracking.unstable_getThreadID(),
      memoizedInteractions: new Set(),
      pendingInteractionMap: new Map()
    };
  } else {
    root = {
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      earliestPendingTime: NoWork,
      latestPendingTime: NoWork,
      earliestSuspendedTime: NoWork,
      latestSuspendedTime: NoWork,
      latestPingedTime: NoWork,

      didError: false,

      pendingCommitExpirationTime: NoWork,
      finishedWork: null,
      timeoutHandle: noTimeout,
      context: null,
      pendingContext: null,
      hydrate: hydrate,
      nextExpirationTimeToWorkOn: NoWork,
      expirationTime: NoWork,
      firstBatch: null,
      nextScheduledRoot: null
    };
  }

  uninitializedFiber.stateNode = root;

  // The reason for the way the Flow types are structured in this file,
  // Is to avoid needing :any casts everywhere interaction tracking fields are used.
  // Unfortunately that requires an :any cast for non-interaction tracking capable builds.
  // $FlowFixMe Remove this :any cast and replace it with something better.
  return root;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var ReactStrictModeWarnings = {
  discardPendingWarnings: function () {},
  flushPendingDeprecationWarnings: function () {},
  flushPendingUnsafeLifecycleWarnings: function () {},
  recordDeprecationWarnings: function (fiber, instance) {},
  recordUnsafeLifecycleWarnings: function (fiber, instance) {},
  recordLegacyContextWarning: function (fiber, instance) {},
  flushLegacyContextWarning: function () {}
};

{
  var LIFECYCLE_SUGGESTIONS = {
    UNSAFE_componentWillMount: 'componentDidMount',
    UNSAFE_componentWillReceiveProps: 'static getDerivedStateFromProps',
    UNSAFE_componentWillUpdate: 'componentDidUpdate'
  };

  var pendingComponentWillMountWarnings = [];
  var pendingComponentWillReceivePropsWarnings = [];
  var pendingComponentWillUpdateWarnings = [];
  var pendingUnsafeLifecycleWarnings = new Map();
  var pendingLegacyContextWarning = new Map();

  // Tracks components we have already warned about.
  var didWarnAboutDeprecatedLifecycles = new Set();
  var didWarnAboutUnsafeLifecycles = new Set();
  var didWarnAboutLegacyContext = new Set();

  var setToSortedString = function (set) {
    var array = [];
    set.forEach(function (value) {
      array.push(value);
    });
    return array.sort().join(', ');
  };

  ReactStrictModeWarnings.discardPendingWarnings = function () {
    pendingComponentWillMountWarnings = [];
    pendingComponentWillReceivePropsWarnings = [];
    pendingComponentWillUpdateWarnings = [];
    pendingUnsafeLifecycleWarnings = new Map();
    pendingLegacyContextWarning = new Map();
  };

  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
    pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {
      var lifecyclesWarningMesages = [];

      Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {
        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];
        if (lifecycleWarnings.length > 0) {
          var componentNames = new Set();
          lifecycleWarnings.forEach(function (fiber) {
            componentNames.add(getComponentName(fiber.type) || 'Component');
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          });

          var formatted = lifecycle.replace('UNSAFE_', '');
          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
          var sortedComponentNames = setToSortedString(componentNames);

          lifecyclesWarningMesages.push(formatted + ': Please update the following components to use ' + (suggestion + ' instead: ' + sortedComponentNames));
        }
      });

      if (lifecyclesWarningMesages.length > 0) {
        var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);

        warningWithoutStack$1(false, 'Unsafe lifecycle methods were found within a strict-mode tree:%s' + '\n\n%s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, lifecyclesWarningMesages.join('\n\n'));
      }
    });

    pendingUnsafeLifecycleWarnings = new Map();
  };

  var findStrictRoot = function (fiber) {
    var maybeStrictRoot = null;

    var node = fiber;
    while (node !== null) {
      if (node.mode & StrictMode) {
        maybeStrictRoot = node;
      }
      node = node.return;
    }

    return maybeStrictRoot;
  };

  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {
    if (pendingComponentWillMountWarnings.length > 0) {
      var uniqueNames = new Set();
      pendingComponentWillMountWarnings.forEach(function (fiber) {
        uniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutDeprecatedLifecycles.add(fiber.type);
      });

      var sortedNames = setToSortedString(uniqueNames);

      lowPriorityWarning$1(false, 'componentWillMount is deprecated and will be removed in the next major version. ' + 'Use componentDidMount instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillMount.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-async-component-lifecycle-hooks', sortedNames);

      pendingComponentWillMountWarnings = [];
    }

    if (pendingComponentWillReceivePropsWarnings.length > 0) {
      var _uniqueNames = new Set();
      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
        _uniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutDeprecatedLifecycles.add(fiber.type);
      });

      var _sortedNames = setToSortedString(_uniqueNames);

      lowPriorityWarning$1(false, 'componentWillReceiveProps is deprecated and will be removed in the next major version. ' + 'Use static getDerivedStateFromProps instead.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames);

      pendingComponentWillReceivePropsWarnings = [];
    }

    if (pendingComponentWillUpdateWarnings.length > 0) {
      var _uniqueNames2 = new Set();
      pendingComponentWillUpdateWarnings.forEach(function (fiber) {
        _uniqueNames2.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutDeprecatedLifecycles.add(fiber.type);
      });

      var _sortedNames2 = setToSortedString(_uniqueNames2);

      lowPriorityWarning$1(false, 'componentWillUpdate is deprecated and will be removed in the next major version. ' + 'Use componentDidUpdate instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillUpdate.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames2);

      pendingComponentWillUpdateWarnings = [];
    }
  };

  ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {
    // Dedup strategy: Warn once per component.
    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {
      return;
    }

    // Don't warn about react-lifecycles-compat polyfilled components.
    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
      pendingComponentWillMountWarnings.push(fiber);
    }
    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
      pendingComponentWillReceivePropsWarnings.push(fiber);
    }
    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
      pendingComponentWillUpdateWarnings.push(fiber);
    }
  };

  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
    var strictRoot = findStrictRoot(fiber);
    if (strictRoot === null) {
      warningWithoutStack$1(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');
      return;
    }

    // Dedup strategy: Warn once per component.
    // This is difficult to track any other way since component names
    // are often vague and are likely to collide between 3rd party libraries.
    // An expand property is probably okay to use here since it's DEV-only,
    // and will only be set in the event of serious warnings.
    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
      return;
    }

    var warningsForRoot = void 0;
    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {
      warningsForRoot = {
        UNSAFE_componentWillMount: [],
        UNSAFE_componentWillReceiveProps: [],
        UNSAFE_componentWillUpdate: []
      };

      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);
    } else {
      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);
    }

    var unsafeLifecycles = [];
    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === 'function') {
      unsafeLifecycles.push('UNSAFE_componentWillMount');
    }
    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
      unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');
    }
    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === 'function') {
      unsafeLifecycles.push('UNSAFE_componentWillUpdate');
    }

    if (unsafeLifecycles.length > 0) {
      unsafeLifecycles.forEach(function (lifecycle) {
        warningsForRoot[lifecycle].push(fiber);
      });
    }
  };

  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
    var strictRoot = findStrictRoot(fiber);
    if (strictRoot === null) {
      warningWithoutStack$1(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');
      return;
    }

    // Dedup strategy: Warn once per component.
    if (didWarnAboutLegacyContext.has(fiber.type)) {
      return;
    }

    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
      if (warningsForRoot === undefined) {
        warningsForRoot = [];
        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
      }
      warningsForRoot.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushLegacyContextWarning = function () {
    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
      var uniqueNames = new Set();
      fiberArray.forEach(function (fiber) {
        uniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutLegacyContext.add(fiber.type);
      });

      var sortedNames = setToSortedString(uniqueNames);
      var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);

      warningWithoutStack$1(false, 'Legacy context API has been detected within a strict-mode tree: %s' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here:' + '\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, sortedNames);
    });
  };
}

// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation = {
  debugTool: null
};

var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

// TODO: Offscreen updates should never suspend. However, a promise that
// suspended inside an offscreen subtree should be able to ping at the priority
// of the outer render.

function markPendingPriorityLevel(root, expirationTime) {
  // If there's a gap between completing a failed root and retrying it,
  // additional updates may be scheduled. Clear `didError`, in case the update
  // is sufficient to fix the error.
  root.didError = false;

  // Update the latest and earliest pending times
  var earliestPendingTime = root.earliestPendingTime;
  if (earliestPendingTime === NoWork) {
    // No other pending updates.
    root.earliestPendingTime = root.latestPendingTime = expirationTime;
  } else {
    if (earliestPendingTime > expirationTime) {
      // This is the earliest pending update.
      root.earliestPendingTime = expirationTime;
    } else {
      var latestPendingTime = root.latestPendingTime;
      if (latestPendingTime < expirationTime) {
        // This is the latest pending update
        root.latestPendingTime = expirationTime;
      }
    }
  }
  findNextExpirationTimeToWorkOn(expirationTime, root);
}

function markCommittedPriorityLevels(root, earliestRemainingTime) {
  root.didError = false;

  if (earliestRemainingTime === NoWork) {
    // Fast path. There's no remaining work. Clear everything.
    root.earliestPendingTime = NoWork;
    root.latestPendingTime = NoWork;
    root.earliestSuspendedTime = NoWork;
    root.latestSuspendedTime = NoWork;
    root.latestPingedTime = NoWork;
    findNextExpirationTimeToWorkOn(NoWork, root);
    return;
  }

  // Let's see if the previous latest known pending level was just flushed.
  var latestPendingTime = root.latestPendingTime;
  if (latestPendingTime !== NoWork) {
    if (latestPendingTime < earliestRemainingTime) {
      // We've flushed all the known pending levels.
      root.earliestPendingTime = root.latestPendingTime = NoWork;
    } else {
      var earliestPendingTime = root.earliestPendingTime;
      if (earliestPendingTime < earliestRemainingTime) {
        // We've flushed the earliest known pending level. Set this to the
        // latest pending time.
        root.earliestPendingTime = root.latestPendingTime;
      }
    }
  }

  // Now let's handle the earliest remaining level in the whole tree. We need to
  // decide whether to treat it as a pending level or as suspended. Check
  // it falls within the range of known suspended levels.

  var earliestSuspendedTime = root.earliestSuspendedTime;
  if (earliestSuspendedTime === NoWork) {
    // There's no suspended work. Treat the earliest remaining level as a
    // pending level.
    markPendingPriorityLevel(root, earliestRemainingTime);
    findNextExpirationTimeToWorkOn(NoWork, root);
    return;
  }

  var latestSuspendedTime = root.latestSuspendedTime;
  if (earliestRemainingTime > latestSuspendedTime) {
    // The earliest remaining level is later than all the suspended work. That
    // means we've flushed all the suspended work.
    root.earliestSuspendedTime = NoWork;
    root.latestSuspendedTime = NoWork;
    root.latestPingedTime = NoWork;

    // There's no suspended work. Treat the earliest remaining level as a
    // pending level.
    markPendingPriorityLevel(root, earliestRemainingTime);
    findNextExpirationTimeToWorkOn(NoWork, root);
    return;
  }

  if (earliestRemainingTime < earliestSuspendedTime) {
    // The earliest remaining time is earlier than all the suspended work.
    // Treat it as a pending update.
    markPendingPriorityLevel(root, earliestRemainingTime);
    findNextExpirationTimeToWorkOn(NoWork, root);
    return;
  }

  // The earliest remaining time falls within the range of known suspended
  // levels. We should treat this as suspended work.
  findNextExpirationTimeToWorkOn(NoWork, root);
}

function hasLowerPriorityWork(root, erroredExpirationTime) {
  var latestPendingTime = root.latestPendingTime;
  var latestSuspendedTime = root.latestSuspendedTime;
  var latestPingedTime = root.latestPingedTime;
  return latestPendingTime !== NoWork && latestPendingTime > erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime > erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime;
}

function isPriorityLevelSuspended(root, expirationTime) {
  var earliestSuspendedTime = root.earliestSuspendedTime;
  var latestSuspendedTime = root.latestSuspendedTime;
  return earliestSuspendedTime !== NoWork && expirationTime >= earliestSuspendedTime && expirationTime <= latestSuspendedTime;
}

function markSuspendedPriorityLevel(root, suspendedTime) {
  root.didError = false;
  clearPing(root, suspendedTime);

  // First, check the known pending levels and update them if needed.
  var earliestPendingTime = root.earliestPendingTime;
  var latestPendingTime = root.latestPendingTime;
  if (earliestPendingTime === suspendedTime) {
    if (latestPendingTime === suspendedTime) {
      // Both known pending levels were suspended. Clear them.
      root.earliestPendingTime = root.latestPendingTime = NoWork;
    } else {
      // The earliest pending level was suspended. Clear by setting it to the
      // latest pending level.
      root.earliestPendingTime = latestPendingTime;
    }
  } else if (latestPendingTime === suspendedTime) {
    // The latest pending level was suspended. Clear by setting it to the
    // latest pending level.
    root.latestPendingTime = earliestPendingTime;
  }

  // Finally, update the known suspended levels.
  var earliestSuspendedTime = root.earliestSuspendedTime;
  var latestSuspendedTime = root.latestSuspendedTime;
  if (earliestSuspendedTime === NoWork) {
    // No other suspended levels.
    root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
  } else {
    if (earliestSuspendedTime > suspendedTime) {
      // This is the earliest suspended level.
      root.earliestSuspendedTime = suspendedTime;
    } else if (latestSuspendedTime < suspendedTime) {
      // This is the latest suspended level
      root.latestSuspendedTime = suspendedTime;
    }
  }

  findNextExpirationTimeToWorkOn(suspendedTime, root);
}

function markPingedPriorityLevel(root, pingedTime) {
  root.didError = false;

  // TODO: When we add back resuming, we need to ensure the progressed work
  // is thrown out and not reused during the restarted render. One way to
  // invalidate the progressed work is to restart at expirationTime + 1.
  var latestPingedTime = root.latestPingedTime;
  if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {
    root.latestPingedTime = pingedTime;
  }
  findNextExpirationTimeToWorkOn(pingedTime, root);
}

function clearPing(root, completedTime) {
  // TODO: Track whether the root was pinged during the render phase. If so,
  // we need to make sure we don't lose track of it.
  var latestPingedTime = root.latestPingedTime;
  if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {
    root.latestPingedTime = NoWork;
  }
}

function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
  var earliestExpirationTime = renderExpirationTime;

  var earliestPendingTime = root.earliestPendingTime;
  var earliestSuspendedTime = root.earliestSuspendedTime;
  if (earliestExpirationTime === NoWork || earliestPendingTime !== NoWork && earliestPendingTime < earliestExpirationTime) {
    earliestExpirationTime = earliestPendingTime;
  }
  if (earliestExpirationTime === NoWork || earliestSuspendedTime !== NoWork && earliestSuspendedTime < earliestExpirationTime) {
    earliestExpirationTime = earliestSuspendedTime;
  }
  return earliestExpirationTime;
}

function didExpireAtExpirationTime(root, currentTime) {
  var expirationTime = root.expirationTime;
  if (expirationTime !== NoWork && currentTime >= expirationTime) {
    // The root has expired. Flush all work up to the current time.
    root.nextExpirationTimeToWorkOn = currentTime;
  }
}

function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
  var earliestSuspendedTime = root.earliestSuspendedTime;
  var latestSuspendedTime = root.latestSuspendedTime;
  var earliestPendingTime = root.earliestPendingTime;
  var latestPingedTime = root.latestPingedTime;

  // Work on the earliest pending time. Failing that, work on the latest
  // pinged time.
  var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;

  // If there is no pending or pinged work, check if there's suspended work
  // that's lower priority than what we just completed.
  if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime > completedExpirationTime)) {
    // The lowest priority suspended work is the work most likely to be
    // committed next. Let's start rendering it again, so that if it times out,
    // it's ready to commit.
    nextExpirationTimeToWorkOn = latestSuspendedTime;
  }

  var expirationTime = nextExpirationTimeToWorkOn;
  if (expirationTime !== NoWork && earliestSuspendedTime !== NoWork && earliestSuspendedTime < expirationTime) {
    // Expire using the earliest known expiration time.
    expirationTime = earliestSuspendedTime;
  }

  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;
  root.expirationTime = expirationTime;
}

// UpdateQueue is a linked list of prioritized updates.
//
// Like fibers, update queues come in pairs: a current queue, which represents
// the visible state of the screen, and a work-in-progress queue, which is
// can be mutated and processed asynchronously before it is committed — a form
// of double buffering. If a work-in-progress render is discarded before
// finishing, we create a new work-in-progress by cloning the current queue.
//
// Both queues share a persistent, singly-linked list structure. To schedule an
// update, we append it to the end of both queues. Each queue maintains a
// pointer to first update in the persistent list that hasn't been processed.
// The work-in-progress pointer always has a position equal to or greater than
// the current queue, since we always work on that one. The current queue's
// pointer is only updated during the commit phase, when we swap in the
// work-in-progress.
//
// For example:
//
//   Current pointer:           A - B - C - D - E - F
//   Work-in-progress pointer:              D - E - F
//                                          ^
//                                          The work-in-progress queue has
//                                          processed more updates than current.
//
// The reason we append to both queues is because otherwise we might drop
// updates without ever processing them. For example, if we only add updates to
// the work-in-progress queue, some updates could be lost whenever a work-in
// -progress render restarts by cloning from current. Similarly, if we only add
// updates to the current queue, the updates will be lost whenever an already
// in-progress queue commits and swaps with the current queue. However, by
// adding to both queues, we guarantee that the update will be part of the next
// work-in-progress. (And because the work-in-progress queue becomes the
// current queue once it commits, there's no danger of applying the same
// update twice.)
//
// Prioritization
// --------------
//
// Updates are not sorted by priority, but by insertion; new updates are always
// appended to the end of the list.
//
// The priority is still important, though. When processing the update queue
// during the render phase, only the updates with sufficient priority are
// included in the result. If we skip an update because it has insufficient
// priority, it remains in the queue to be processed later, during a lower
// priority render. Crucially, all updates subsequent to a skipped update also
// remain in the queue *regardless of their priority*. That means high priority
// updates are sometimes processed twice, at two separate priorities. We also
// keep track of a base state, that represents the state before the first
// update in the queue is applied.
//
// For example:
//
//   Given a base state of '', and the following queue of updates
//
//     A1 - B2 - C1 - D2
//
//   where the number indicates the priority, and the update is applied to the
//   previous state by appending a letter, React will process these updates as
//   two separate renders, one per distinct priority level:
//
//   First render, at priority 1:
//     Base state: ''
//     Updates: [A1, C1]
//     Result state: 'AC'
//
//   Second render, at priority 2:
//     Base state: 'A'            <-  The base state does not include C1,
//                                    because B2 was skipped.
//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2
//     Result state: 'ABCD'
//
// Because we process updates in insertion order, and rebase high priority
// updates when preceding updates are skipped, the final result is deterministic
// regardless of priority. Intermediate state may vary according to system
// resources, but the final state is always the same.

var UpdateState = 0;
var ReplaceState = 1;
var ForceUpdate = 2;
var CaptureUpdate = 3;

// Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.
var hasForceUpdate = false;

var didWarnUpdateInsideUpdate = void 0;
var currentlyProcessingQueue = void 0;
var resetCurrentlyProcessingQueue = void 0;
{
  didWarnUpdateInsideUpdate = false;
  currentlyProcessingQueue = null;
  resetCurrentlyProcessingQueue = function () {
    currentlyProcessingQueue = null;
  };
}

function createUpdateQueue(baseState) {
  var queue = {
    baseState: baseState,
    firstUpdate: null,
    lastUpdate: null,
    firstCapturedUpdate: null,
    lastCapturedUpdate: null,
    firstEffect: null,
    lastEffect: null,
    firstCapturedEffect: null,
    lastCapturedEffect: null
  };
  return queue;
}

function cloneUpdateQueue(currentQueue) {
  var queue = {
    baseState: currentQueue.baseState,
    firstUpdate: currentQueue.firstUpdate,
    lastUpdate: currentQueue.lastUpdate,

    // TODO: With resuming, if we bail out and resuse the child tree, we should
    // keep these effects.
    firstCapturedUpdate: null,
    lastCapturedUpdate: null,

    firstEffect: null,
    lastEffect: null,

    firstCapturedEffect: null,
    lastCapturedEffect: null
  };
  return queue;
}

function createUpdate(expirationTime) {
  return {
    expirationTime: expirationTime,

    tag: UpdateState,
    payload: null,
    callback: null,

    next: null,
    nextEffect: null
  };
}

function appendUpdateToQueue(queue, update) {
  // Append the update to the end of the list.
  if (queue.lastUpdate === null) {
    // Queue is empty
    queue.firstUpdate = queue.lastUpdate = update;
  } else {
    queue.lastUpdate.next = update;
    queue.lastUpdate = update;
  }
}

function enqueueUpdate(fiber, update) {
  // Update queues are created lazily.
  var alternate = fiber.alternate;
  var queue1 = void 0;
  var queue2 = void 0;
  if (alternate === null) {
    // There's only one fiber.
    queue1 = fiber.updateQueue;
    queue2 = null;
    if (queue1 === null) {
      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
    }
  } else {
    // There are two owners.
    queue1 = fiber.updateQueue;
    queue2 = alternate.updateQueue;
    if (queue1 === null) {
      if (queue2 === null) {
        // Neither fiber has an update queue. Create new ones.
        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
        queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);
      } else {
        // Only one fiber has an update queue. Clone to create a new one.
        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
      }
    } else {
      if (queue2 === null) {
        // Only one fiber has an update queue. Clone to create a new one.
        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
      } else {
        // Both owners have an update queue.
      }
    }
  }
  if (queue2 === null || queue1 === queue2) {
    // There's only a single queue.
    appendUpdateToQueue(queue1, update);
  } else {
    // There are two queues. We need to append the update to both queues,
    // while accounting for the persistent structure of the list — we don't
    // want the same update to be added multiple times.
    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
      // One of the queues is not empty. We must add the update to both queues.
      appendUpdateToQueue(queue1, update);
      appendUpdateToQueue(queue2, update);
    } else {
      // Both queues are non-empty. The last update is the same in both lists,
      // because of structural sharing. So, only append to one of the lists.
      appendUpdateToQueue(queue1, update);
      // But we still need to update the `lastUpdate` pointer of queue2.
      queue2.lastUpdate = update;
    }
  }

  {
    if ((fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {
      warningWithoutStack$1(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
      didWarnUpdateInsideUpdate = true;
    }
  }
}

function enqueueCapturedUpdate(workInProgress, update) {
  // Captured updates go into a separate list, and only on the work-in-
  // progress queue.
  var workInProgressQueue = workInProgress.updateQueue;
  if (workInProgressQueue === null) {
    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);
  } else {
    // TODO: I put this here rather than createWorkInProgress so that we don't
    // clone the queue unnecessarily. There's probably a better way to
    // structure this.
    workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
  }

  // Append the update to the end of the list.
  if (workInProgressQueue.lastCapturedUpdate === null) {
    // This is the first render phase update
    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;
  } else {
    workInProgressQueue.lastCapturedUpdate.next = update;
    workInProgressQueue.lastCapturedUpdate = update;
  }
}

function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
  var current = workInProgress.alternate;
  if (current !== null) {
    // If the work-in-progress queue is equal to the current queue,
    // we need to clone it first.
    if (queue === current.updateQueue) {
      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);
    }
  }
  return queue;
}

function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
  switch (update.tag) {
    case ReplaceState:
      {
        var _payload = update.payload;
        if (typeof _payload === 'function') {
          // Updater function
          {
            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
              _payload.call(instance, prevState, nextProps);
            }
          }
          return _payload.call(instance, prevState, nextProps);
        }
        // State object
        return _payload;
      }
    case CaptureUpdate:
      {
        workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;
      }
    // Intentional fallthrough
    case UpdateState:
      {
        var _payload2 = update.payload;
        var partialState = void 0;
        if (typeof _payload2 === 'function') {
          // Updater function
          {
            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
              _payload2.call(instance, prevState, nextProps);
            }
          }
          partialState = _payload2.call(instance, prevState, nextProps);
        } else {
          // Partial state object
          partialState = _payload2;
        }
        if (partialState === null || partialState === undefined) {
          // Null and undefined are treated as no-ops.
          return prevState;
        }
        // Merge the partial state and the previous state.
        return _assign({}, prevState, partialState);
      }
    case ForceUpdate:
      {
        hasForceUpdate = true;
        return prevState;
      }
  }
  return prevState;
}

function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
  hasForceUpdate = false;

  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);

  {
    currentlyProcessingQueue = queue;
  }

  // These values may change as we process the queue.
  var newBaseState = queue.baseState;
  var newFirstUpdate = null;
  var newExpirationTime = NoWork;

  // Iterate through the list of updates to compute the result.
  var update = queue.firstUpdate;
  var resultState = newBaseState;
  while (update !== null) {
    var updateExpirationTime = update.expirationTime;
    if (updateExpirationTime > renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      if (newFirstUpdate === null) {
        // This is the first skipped update. It will be the first update in
        // the new list.
        newFirstUpdate = update;
        // Since this is the first update that was skipped, the current result
        // is the new base state.
        newBaseState = resultState;
      }
      // Since this update will remain in the list, update the remaining
      // expiration time.
      if (newExpirationTime === NoWork || newExpirationTime > updateExpirationTime) {
        newExpirationTime = updateExpirationTime;
      }
    } else {
      // This update does have sufficient priority. Process it and compute
      // a new result.
      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
      var _callback = update.callback;
      if (_callback !== null) {
        workInProgress.effectTag |= Callback;
        // Set this to null, in case it was mutated during an aborted render.
        update.nextEffect = null;
        if (queue.lastEffect === null) {
          queue.firstEffect = queue.lastEffect = update;
        } else {
          queue.lastEffect.nextEffect = update;
          queue.lastEffect = update;
        }
      }
    }
    // Continue to the next update.
    update = update.next;
  }

  // Separately, iterate though the list of captured updates.
  var newFirstCapturedUpdate = null;
  update = queue.firstCapturedUpdate;
  while (update !== null) {
    var _updateExpirationTime = update.expirationTime;
    if (_updateExpirationTime > renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      if (newFirstCapturedUpdate === null) {
        // This is the first skipped captured update. It will be the first
        // update in the new list.
        newFirstCapturedUpdate = update;
        // If this is the first update that was skipped, the current result is
        // the new base state.
        if (newFirstUpdate === null) {
          newBaseState = resultState;
        }
      }
      // Since this update will remain in the list, update the remaining
      // expiration time.
      if (newExpirationTime === NoWork || newExpirationTime > _updateExpirationTime) {
        newExpirationTime = _updateExpirationTime;
      }
    } else {
      // This update does have sufficient priority. Process it and compute
      // a new result.
      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
      var _callback2 = update.callback;
      if (_callback2 !== null) {
        workInProgress.effectTag |= Callback;
        // Set this to null, in case it was mutated during an aborted render.
        update.nextEffect = null;
        if (queue.lastCapturedEffect === null) {
          queue.firstCapturedEffect = queue.lastCapturedEffect = update;
        } else {
          queue.lastCapturedEffect.nextEffect = update;
          queue.lastCapturedEffect = update;
        }
      }
    }
    update = update.next;
  }

  if (newFirstUpdate === null) {
    queue.lastUpdate = null;
  }
  if (newFirstCapturedUpdate === null) {
    queue.lastCapturedUpdate = null;
  } else {
    workInProgress.effectTag |= Callback;
  }
  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {
    // We processed every update, without skipping. That means the new base
    // state is the same as the result state.
    newBaseState = resultState;
  }

  queue.baseState = newBaseState;
  queue.firstUpdate = newFirstUpdate;
  queue.firstCapturedUpdate = newFirstCapturedUpdate;

  // Set the remaining expiration time to be whatever is remaining in the queue.
  // This should be fine because the only two other things that contribute to
  // expiration time are props and context. We're already in the middle of the
  // begin phase by the time we start processing the queue, so we've already
  // dealt with the props. Context in components that specify
  // shouldComponentUpdate is tricky; but we'll have to account for
  // that regardless.
  workInProgress.expirationTime = newExpirationTime;
  workInProgress.memoizedState = resultState;

  {
    currentlyProcessingQueue = null;
  }
}

function callCallback(callback, context) {
  !(typeof callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', callback) : void 0;
  callback.call(context);
}

function resetHasForceUpdateBeforeProcessing() {
  hasForceUpdate = false;
}

function checkHasForceUpdateAfterProcessing() {
  return hasForceUpdate;
}

function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {
  // If the finished render included captured updates, and there are still
  // lower priority updates left over, we need to keep the captured updates
  // in the queue so that they are rebased and not dropped once we process the
  // queue again at the lower priority.
  if (finishedQueue.firstCapturedUpdate !== null) {
    // Join the captured update list to the end of the normal list.
    if (finishedQueue.lastUpdate !== null) {
      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;
      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;
    }
    // Clear the list of captured updates.
    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;
  }

  // Commit the effects
  commitUpdateEffects(finishedQueue.firstEffect, instance);
  finishedQueue.firstEffect = finishedQueue.lastEffect = null;

  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
}

function commitUpdateEffects(effect, instance) {
  while (effect !== null) {
    var _callback3 = effect.callback;
    if (_callback3 !== null) {
      effect.callback = null;
      callCallback(_callback3, instance);
    }
    effect = effect.nextEffect;
  }
}

function createCapturedValue(value, source) {
  // If the value is an error, call this function immediately after it is thrown
  // so the stack is accurate.
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}

var valueCursor = createCursor(null);

var rendererSigil = void 0;
{
  // Use this to detect multiple renderers using the same context
  rendererSigil = {};
}

var currentlyRenderingFiber = null;
var lastContextDependency = null;
var lastContextWithAllBitsObserved = null;

function resetContextDependences() {
  // This is called right before React yields execution, to ensure `readContext`
  // cannot be called outside the render phase.
  currentlyRenderingFiber = null;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;
}

function pushProvider(providerFiber, nextValue) {
  var context = providerFiber.type._context;

  if (isPrimaryRenderer) {
    push(valueCursor, context._currentValue, providerFiber);

    context._currentValue = nextValue;
    {
      !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;
      context._currentRenderer = rendererSigil;
    }
  } else {
    push(valueCursor, context._currentValue2, providerFiber);

    context._currentValue2 = nextValue;
    {
      !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warningWithoutStack$1(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;
      context._currentRenderer2 = rendererSigil;
    }
  }
}

function popProvider(providerFiber) {
  var currentValue = valueCursor.current;

  pop(valueCursor, providerFiber);

  var context = providerFiber.type._context;
  if (isPrimaryRenderer) {
    context._currentValue = currentValue;
  } else {
    context._currentValue2 = currentValue;
  }
}

function calculateChangedBits(context, newValue, oldValue) {
  // Use Object.is to compare the new context value to the old value. Inlined
  // Object.is polyfill.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue // eslint-disable-line no-self-compare
  ) {
      // No change
      return 0;
    } else {
    var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;

    {
      !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits) : void 0;
    }
    return changedBits | 0;
  }
}

function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {
  var fiber = workInProgress.child;
  if (fiber !== null) {
    // Set the return pointer of the child to the work-in-progress fiber.
    fiber.return = workInProgress;
  }
  while (fiber !== null) {
    var nextFiber = void 0;

    // Visit this fiber.
    var dependency = fiber.firstContextDependency;
    if (dependency !== null) {
      do {
        // Check if the context matches.
        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
          // Match! Schedule an update on this fiber.

          if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {
            // Schedule a force update on the work-in-progress.
            var update = createUpdate(renderExpirationTime);
            update.tag = ForceUpdate;
            // TODO: Because we don't have a work-in-progress, this will add the
            // update to the current fiber, too, which means it will persist even if
            // this render is thrown away. Since it's a race condition, not sure it's
            // worth fixing.
            enqueueUpdate(fiber, update);
          }

          if (fiber.expirationTime === NoWork || fiber.expirationTime > renderExpirationTime) {
            fiber.expirationTime = renderExpirationTime;
          }
          var alternate = fiber.alternate;
          if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {
            alternate.expirationTime = renderExpirationTime;
          }
          // Update the child expiration time of all the ancestors, including
          // the alternates.
          var node = fiber.return;
          while (node !== null) {
            alternate = node.alternate;
            if (node.childExpirationTime === NoWork || node.childExpirationTime > renderExpirationTime) {
              node.childExpirationTime = renderExpirationTime;
              if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {
                alternate.childExpirationTime = renderExpirationTime;
              }
            } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {
              alternate.childExpirationTime = renderExpirationTime;
            } else {
              // Neither alternate was updated, which means the rest of the
              // ancestor path already has sufficient priority.
              break;
            }
            node = node.return;
          }
        }
        nextFiber = fiber.child;
        dependency = dependency.next;
      } while (dependency !== null);
    } else if (fiber.tag === ContextProvider) {
      // Don't scan deeper if this is a matching provider
      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
    } else {
      // Traverse down.
      nextFiber = fiber.child;
    }

    if (nextFiber !== null) {
      // Set the return pointer of the child to the work-in-progress fiber.
      nextFiber.return = fiber;
    } else {
      // No child. Traverse to next sibling.
      nextFiber = fiber;
      while (nextFiber !== null) {
        if (nextFiber === workInProgress) {
          // We're back to the root of this subtree. Exit.
          nextFiber = null;
          break;
        }
        var sibling = nextFiber.sibling;
        if (sibling !== null) {
          // Set the return pointer of the sibling to the work-in-progress fiber.
          sibling.return = nextFiber.return;
          nextFiber = sibling;
          break;
        }
        // No more siblings. Traverse up.
        nextFiber = nextFiber.return;
      }
    }
    fiber = nextFiber;
  }
}

function prepareToReadContext(workInProgress, renderExpirationTime) {
  currentlyRenderingFiber = workInProgress;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;

  // Reset the work-in-progress list
  workInProgress.firstContextDependency = null;
}

function readContext(context, observedBits) {
  if (lastContextWithAllBitsObserved === context) {
    // Nothing to do. We already observe everything in this context.
  } else if (observedBits === false || observedBits === 0) {
    // Do not observe any updates.
  } else {
    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.
    if (typeof observedBits !== 'number' || observedBits === maxSigned31BitInt) {
      // Observe all updates.
      lastContextWithAllBitsObserved = context;
      resolvedObservedBits = maxSigned31BitInt;
    } else {
      resolvedObservedBits = observedBits;
    }

    var contextItem = {
      context: context,
      observedBits: resolvedObservedBits,
      next: null
    };

    if (lastContextDependency === null) {
      !(currentlyRenderingFiber !== null) ? invariant(false, 'Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps.') : void 0;
      // This is the first dependency in the list
      currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;
    } else {
      // Append a new context item.
      lastContextDependency = lastContextDependency.next = contextItem;
    }
  }
  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
}

var NO_CONTEXT = {};

var contextStackCursor$1 = createCursor(NO_CONTEXT);
var contextFiberStackCursor = createCursor(NO_CONTEXT);
var rootInstanceStackCursor = createCursor(NO_CONTEXT);

function requiredContext(c) {
  !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  return c;
}

function getRootHostContainer() {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  return rootInstance;
}

function pushHostContainer(fiber, nextRootInstance) {
  // Push current root instance onto the stack;
  // This allows us to reset root when portals are popped.
  push(rootInstanceStackCursor, nextRootInstance, fiber);
  // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.
  push(contextFiberStackCursor, fiber, fiber);

  // Finally, we need to push the host context to the stack.
  // However, we can't just call getRootHostContext() and push it because
  // we'd have a different number of entries on the stack depending on
  // whether getRootHostContext() throws somewhere in renderer code or not.
  // So we push an empty value first. This lets us safely unwind on errors.
  push(contextStackCursor$1, NO_CONTEXT, fiber);
  var nextRootContext = getRootHostContext(nextRootInstance);
  // Now that we know this function doesn't throw, replace it.
  pop(contextStackCursor$1, fiber);
  push(contextStackCursor$1, nextRootContext, fiber);
}

function popHostContainer(fiber) {
  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
  pop(rootInstanceStackCursor, fiber);
}

function getHostContext() {
  var context = requiredContext(contextStackCursor$1.current);
  return context;
}

function pushHostContext(fiber) {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  var context = requiredContext(contextStackCursor$1.current);
  var nextContext = getChildHostContext(context, fiber.type, rootInstance);

  // Don't push this Fiber's context unless it's unique.
  if (context === nextContext) {
    return;
  }

  // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.
  push(contextFiberStackCursor, fiber, fiber);
  push(contextStackCursor$1, nextContext, fiber);
}

function popHostContext(fiber) {
  // Do not pop unless this Fiber provided the current context.
  // pushHostContext() only pushes Fibers that provide unique contexts.
  if (contextFiberStackCursor.current !== fiber) {
    return;
  }

  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
}

var commitTime = 0;
var profilerStartTime = -1;

function getCommitTime() {
  return commitTime;
}

function recordCommitTime() {
  if (!enableProfilerTimer) {
    return;
  }
  commitTime = schedule.unstable_now();
}

function startProfilerTimer(fiber) {
  if (!enableProfilerTimer) {
    return;
  }

  profilerStartTime = schedule.unstable_now();

  if (fiber.actualStartTime < 0) {
    fiber.actualStartTime = schedule.unstable_now();
  }
}

function stopProfilerTimerIfRunning(fiber) {
  if (!enableProfilerTimer) {
    return;
  }
  profilerStartTime = -1;
}

function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
  if (!enableProfilerTimer) {
    return;
  }

  if (profilerStartTime >= 0) {
    var elapsedTime = schedule.unstable_now() - profilerStartTime;
    fiber.actualDuration += elapsedTime;
    if (overrideBaseTime) {
      fiber.selfBaseDuration = elapsedTime;
    }
    profilerStartTime = -1;
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray;

// React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.
var emptyRefsObject = new React.Component().refs;

var didWarnAboutStateAssignmentForComponent = void 0;
var didWarnAboutUninitializedState = void 0;
var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
var didWarnAboutUndefinedDerivedState = void 0;
var warnOnUndefinedDerivedState = void 0;
var warnOnInvalidCallback$1 = void 0;
var didWarnAboutDirectlyAssigningPropsToState = void 0;

{
  didWarnAboutStateAssignmentForComponent = new Set();
  didWarnAboutUninitializedState = new Set();
  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
  didWarnAboutDirectlyAssigningPropsToState = new Set();
  didWarnAboutUndefinedDerivedState = new Set();

  var didWarnOnInvalidCallback = new Set();

  warnOnInvalidCallback$1 = function (callback, callerName) {
    if (callback === null || typeof callback === 'function') {
      return;
    }
    var key = callerName + '_' + callback;
    if (!didWarnOnInvalidCallback.has(key)) {
      didWarnOnInvalidCallback.add(key);
      warningWithoutStack$1(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  };

  warnOnUndefinedDerivedState = function (type, partialState) {
    if (partialState === undefined) {
      var componentName = getComponentName(type) || 'Component';
      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
        didWarnAboutUndefinedDerivedState.add(componentName);
        warningWithoutStack$1(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);
      }
    }
  };

  // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
    }
  });
  Object.freeze(fakeInternalInstance);
}

function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
  var prevState = workInProgress.memoizedState;

  {
    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
      // Invoke the function an extra time to help detect side-effects.
      getDerivedStateFromProps(nextProps, prevState);
    }
  }

  var partialState = getDerivedStateFromProps(nextProps, prevState);

  {
    warnOnUndefinedDerivedState(ctor, partialState);
  }
  // Merge the partial state and the previous state.
  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);
  workInProgress.memoizedState = memoizedState;

  // Once the update queue is empty, persist the derived state onto the
  // base state.
  var updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
    updateQueue.baseState = memoizedState;
  }
}

var classComponentUpdater = {
  isMounted: isMounted,
  enqueueSetState: function (inst, payload, callback) {
    var fiber = get(inst);
    var currentTime = requestCurrentTime();
    var expirationTime = computeExpirationForFiber(currentTime, fiber);

    var update = createUpdate(expirationTime);
    update.payload = payload;
    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback$1(callback, 'setState');
      }
      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleWork(fiber, expirationTime);
  },
  enqueueReplaceState: function (inst, payload, callback) {
    var fiber = get(inst);
    var currentTime = requestCurrentTime();
    var expirationTime = computeExpirationForFiber(currentTime, fiber);

    var update = createUpdate(expirationTime);
    update.tag = ReplaceState;
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback$1(callback, 'replaceState');
      }
      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleWork(fiber, expirationTime);
  },
  enqueueForceUpdate: function (inst, callback) {
    var fiber = get(inst);
    var currentTime = requestCurrentTime();
    var expirationTime = computeExpirationForFiber(currentTime, fiber);

    var update = createUpdate(expirationTime);
    update.tag = ForceUpdate;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback$1(callback, 'forceUpdate');
      }
      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleWork(fiber, expirationTime);
  }
};

function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext) {
  var instance = workInProgress.stateNode;
  if (typeof instance.shouldComponentUpdate === 'function') {
    startPhaseTimer(workInProgress, 'shouldComponentUpdate');
    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextLegacyContext);
    stopPhaseTimer();

    {
      !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component') : void 0;
    }

    return shouldUpdate;
  }

  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
  }

  return true;
}

function checkClassInstance(workInProgress, ctor, newProps) {
  var instance = workInProgress.stateNode;
  {
    var name = getComponentName(ctor) || 'Component';
    var renderPresent = instance.render;

    if (!renderPresent) {
      if (ctor.prototype && typeof ctor.prototype.render === 'function') {
        warningWithoutStack$1(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
      } else {
        warningWithoutStack$1(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
      }
    }

    var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
    !noGetInitialStateOnES6 ? warningWithoutStack$1(false, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name) : void 0;
    var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
    !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name) : void 0;
    var noInstancePropTypes = !instance.propTypes;
    !noInstancePropTypes ? warningWithoutStack$1(false, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name) : void 0;
    var noInstanceContextTypes = !instance.contextTypes;
    !noInstanceContextTypes ? warningWithoutStack$1(false, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name) : void 0;
    var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
    !noComponentShouldUpdate ? warningWithoutStack$1(false, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name) : void 0;
    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
      warningWithoutStack$1(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');
    }
    var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
    !noComponentDidUnmount ? warningWithoutStack$1(false, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name) : void 0;
    var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
    !noComponentDidReceiveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name) : void 0;
    var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
    !noComponentWillRecieveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name) : void 0;
    var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== 'function';
    !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name) : void 0;
    var hasMutatedProps = instance.props !== newProps;
    !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name) : void 0;
    var noInstanceDefaultProps = !instance.defaultProps;
    !noInstanceDefaultProps ? warningWithoutStack$1(false, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name) : void 0;

    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
      warningWithoutStack$1(false, '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));
    }

    var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== 'function';
    !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, '%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;
    var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromCatch !== 'function';
    !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, '%s: getDerivedStateFromCatch() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;
    var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== 'function';
    !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, '%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name) : void 0;
    var _state = instance.state;
    if (_state && (typeof _state !== 'object' || isArray(_state))) {
      warningWithoutStack$1(false, '%s.state: must be set to an object or null', name);
    }
    if (typeof instance.getChildContext === 'function') {
      !(typeof ctor.childContextTypes === 'object') ? warningWithoutStack$1(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name) : void 0;
    }
  }
}

function adoptClassInstance(workInProgress, instance) {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance;
  // The instance needs access to the fiber so that it can schedule updates
  set(instance, workInProgress);
  {
    instance._reactInternalInstance = fakeInternalInstance;
  }
}

function constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {
  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
  var contextTypes = ctor.contextTypes;
  var isContextConsumer = contextTypes !== null && contextTypes !== undefined;
  var context = isContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;

  // Instantiate twice to help detect side-effects.
  {
    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
      new ctor(props, context); // eslint-disable-line no-new
    }
  }

  var instance = new ctor(props, context);
  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
  adoptClassInstance(workInProgress, instance);

  {
    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
      var componentName = getComponentName(ctor) || 'Component';
      if (!didWarnAboutUninitializedState.has(componentName)) {
        didWarnAboutUninitializedState.add(componentName);
        warningWithoutStack$1(false, '`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);
      }
    }

    // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Warn about these lifecycles if they are present.
    // Don't warn about react-lifecycles-compat polyfilled methods though.
    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
      var foundWillMountName = null;
      var foundWillReceivePropsName = null;
      var foundWillUpdateName = null;
      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
        foundWillMountName = 'componentWillMount';
      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {
        foundWillMountName = 'UNSAFE_componentWillMount';
      }
      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
        foundWillReceivePropsName = 'componentWillReceiveProps';
      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
      }
      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
        foundWillUpdateName = 'componentWillUpdate';
      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        foundWillUpdateName = 'UNSAFE_componentWillUpdate';
      }
      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        var _componentName = getComponentName(ctor) || 'Component';
        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
          warningWithoutStack$1(false, 'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n' + 'The above lifecycles should be removed. Learn more about this warning here:\n' + 'https://fb.me/react-async-component-lifecycle-hooks', _componentName, newApiName, foundWillMountName !== null ? '\n  ' + foundWillMountName : '', foundWillReceivePropsName !== null ? '\n  ' + foundWillReceivePropsName : '', foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '');
        }
      }
    }
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // ReactFiberContext usually updates this cache but can't for newly-created instances.
  if (isContextConsumer) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return instance;
}

function callComponentWillMount(workInProgress, instance) {
  startPhaseTimer(workInProgress, 'componentWillMount');
  var oldState = instance.state;

  if (typeof instance.componentWillMount === 'function') {
    instance.componentWillMount();
  }
  if (typeof instance.UNSAFE_componentWillMount === 'function') {
    instance.UNSAFE_componentWillMount();
  }

  stopPhaseTimer();

  if (oldState !== instance.state) {
    {
      warningWithoutStack$1(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');
    }
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}

function callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext) {
  var oldState = instance.state;
  startPhaseTimer(workInProgress, 'componentWillReceiveProps');
  if (typeof instance.componentWillReceiveProps === 'function') {
    instance.componentWillReceiveProps(newProps, nextLegacyContext);
  }
  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
    instance.UNSAFE_componentWillReceiveProps(newProps, nextLegacyContext);
  }
  stopPhaseTimer();

  if (instance.state !== oldState) {
    {
      var componentName = getComponentName(workInProgress.type) || 'Component';
      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
        didWarnAboutStateAssignmentForComponent.add(componentName);
        warningWithoutStack$1(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
      }
    }
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}

// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
  {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  var instance = workInProgress.stateNode;
  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);

  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;
  instance.context = getMaskedContext(workInProgress, unmaskedContext);

  {
    if (instance.state === newProps) {
      var componentName = getComponentName(ctor) || 'Component';
      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
        didWarnAboutDirectlyAssigningPropsToState.add(componentName);
        warningWithoutStack$1(false, '%s: It is not recommended to assign props directly to state ' + "because updates to props won't be reflected in state. " + 'In most cases, it is better to use props directly.', componentName);
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);

      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
    }

    if (warnAboutDeprecatedLifecycles) {
      ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);
    }
  }

  var updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
    instance.state = workInProgress.memoizedState;
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    instance.state = workInProgress.memoizedState;
  }

  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
    callComponentWillMount(workInProgress, instance);
    // If we had additional state updates during this life-cycle, let's
    // process them now.
    updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
      instance.state = workInProgress.memoizedState;
    }
  }

  if (typeof instance.componentDidMount === 'function') {
    workInProgress.effectTag |= Update;
  }
}

function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
  var instance = workInProgress.stateNode;

  var oldProps = workInProgress.memoizedProps;
  instance.props = oldProps;

  var oldContext = instance.context;
  var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
  var nextLegacyContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';

  // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.

  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (oldProps !== newProps || oldContext !== nextLegacyContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();

  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  var updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
    newState = workInProgress.memoizedState;
  }
  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }
    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
      startPhaseTimer(workInProgress, 'componentWillMount');
      if (typeof instance.componentWillMount === 'function') {
        instance.componentWillMount();
      }
      if (typeof instance.UNSAFE_componentWillMount === 'function') {
        instance.UNSAFE_componentWillMount();
      }
      stopPhaseTimer();
    }
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }

    // If shouldComponentUpdate returned false, we should still update the
    // memoized state to indicate that this work can be reused.
    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  }

  // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.
  instance.props = newProps;
  instance.state = newState;
  instance.context = nextLegacyContext;

  return shouldUpdate;
}

// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
  var instance = workInProgress.stateNode;

  var oldProps = workInProgress.memoizedProps;
  instance.props = oldProps;

  var oldContext = instance.context;
  var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
  var nextLegacyContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';

  // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.

  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.
  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (oldProps !== newProps || oldContext !== nextLegacyContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();

  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  var updateQueue = workInProgress.updateQueue;
  if (updateQueue !== null) {
    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
    newState = workInProgress.memoizedState;
  }

  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.effectTag |= Update;
      }
    }
    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.effectTag |= Snapshot;
      }
    }
    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
      startPhaseTimer(workInProgress, 'componentWillUpdate');
      if (typeof instance.componentWillUpdate === 'function') {
        instance.componentWillUpdate(newProps, newState, nextLegacyContext);
      }
      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        instance.UNSAFE_componentWillUpdate(newProps, newState, nextLegacyContext);
      }
      stopPhaseTimer();
    }
    if (typeof instance.componentDidUpdate === 'function') {
      workInProgress.effectTag |= Update;
    }
    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      workInProgress.effectTag |= Snapshot;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.effectTag |= Update;
      }
    }
    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.effectTag |= Snapshot;
      }
    }

    // If shouldComponentUpdate returned false, we should still update the
    // memoized props/state to indicate that this work can be reused.
    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  }

  // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.
  instance.props = newProps;
  instance.state = newState;
  instance.context = nextLegacyContext;

  return shouldUpdate;
}

var didWarnAboutMaps = void 0;
var didWarnAboutGenerators = void 0;
var didWarnAboutStringRefInStrictMode = void 0;
var ownerHasKeyUseWarning = void 0;
var ownerHasFunctionTypeWarning = void 0;
var warnForMissingKey = function (child) {};

{
  didWarnAboutMaps = false;
  didWarnAboutGenerators = false;
  didWarnAboutStringRefInStrictMode = {};

  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  ownerHasKeyUseWarning = {};
  ownerHasFunctionTypeWarning = {};

  warnForMissingKey = function (child) {
    if (child === null || typeof child !== 'object') {
      return;
    }
    if (!child._store || child._store.validated || child.key != null) {
      return;
    }
    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    child._store.validated = true;

    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + getCurrentFiberStackInDev();
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    warning$1(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.');
  };
}

var isArray$1 = Array.isArray;

function coerceRef(returnFiber, current$$1, element) {
  var mixedRef = element.ref;
  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
    {
      if (returnFiber.mode & StrictMode) {
        var componentName = getComponentName(returnFiber.type) || 'Component';
        if (!didWarnAboutStringRefInStrictMode[componentName]) {
          warningWithoutStack$1(false, 'A string ref, "%s", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using createRef() instead.' + '\n%s' + '\n\nLearn more about using refs safely here:' + '\nhttps://fb.me/react-strict-mode-string-ref', mixedRef, getStackByFiberInDevAndProd(returnFiber));
          didWarnAboutStringRefInStrictMode[componentName] = true;
        }
      }
    }

    if (element._owner) {
      var owner = element._owner;
      var inst = void 0;
      if (owner) {
        var ownerFiber = owner;
        !(ownerFiber.tag === ClassComponent || ownerFiber.tag === ClassComponentLazy) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
        inst = ownerFiber.stateNode;
      }
      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
      var stringRef = '' + mixedRef;
      // Check if previous string ref matches new string ref
      if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === 'function' && current$$1.ref._stringRef === stringRef) {
        return current$$1.ref;
      }
      var ref = function (value) {
        var refs = inst.refs;
        if (refs === emptyRefsObject) {
          // This is a lazy pooled frozen object, so we need to initialize.
          refs = inst.refs = {};
        }
        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };
      ref._stringRef = stringRef;
      return ref;
    } else {
      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function, a string, an object returned by React.createRef(), or null.') : void 0;
      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a functional component\n2. You may be adding a ref to a component that was not created inside a component\'s render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information.', mixedRef) : void 0;
    }
  }
  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    var addendum = '';
    {
      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + getCurrentFiberStackInDev();
    }
    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
  }
}

function warnOnFunctionType() {
  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + getCurrentFiberStackInDev();

  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

  warning$1(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');
}

// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.
    var childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    var existingChildren = new Map();

    var existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

  function useFiber(fiber, pendingProps, expirationTime) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    var current$$1 = newFiber.alternate;
    if (current$$1 !== null) {
      var oldIndex = current$$1.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = Placement;
    }
    return newFiber;
  }

  function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {
    if (current$$1 === null || current$$1.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current$$1, textContent, expirationTime);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current$$1, element, expirationTime) {
    if (current$$1 !== null && current$$1.type === element.type) {
      // Move based on index
      var existing = useFiber(current$$1, element.props, expirationTime);
      existing.ref = coerceRef(returnFiber, current$$1, element);
      existing.return = returnFiber;
      {
        existing._debugSource = element._source;
        existing._debugOwner = element._owner;
      }
      return existing;
    } else {
      // Insert
      var created = createFiberFromElement(element, returnFiber.mode, expirationTime);
      created.ref = coerceRef(returnFiber, current$$1, element);
      created.return = returnFiber;
      return created;
    }
  }

  function updatePortal(returnFiber, current$$1, portal, expirationTime) {
    if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current$$1, portal.children || [], expirationTime);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {
    if (current$$1 === null || current$$1.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current$$1, fragment, expirationTime);
      existing.return = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);
            _created.ref = coerceRef(returnFiber, null, newChild);
            _created.return = returnFiber;
            return _created;
          }
        case REACT_PORTAL_TYPE:
          {
            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);
            _created2.return = returnFiber;
            return _created2;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);
        _created3.return = returnFiber;
        return _created3;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
    // Update the fiber if the keys match, otherwise return null.

    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
              }
              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
            }
            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
          }
        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber3 = existingChildren.get(newIdx) || null;
        return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  /**
   * Warns if there is a duplicate or missing key
   */
  function warnOnInvalidKey(child, knownKeys) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child);
          var key = child.key;
          if (typeof key !== 'string') {
            break;
          }
          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          warning$1(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);
          break;
        default:
          break;
      }
    }
    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
    // This algorithm can't optimize by searching from boths ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.

    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.

    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.

    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.

    {
      // First, validate keys.
      var knownKeys = null;
      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
        if (!_newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }
        previousNewFiber = _newFiber;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
      if (_newFiber2) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }
        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.

    var iteratorFn = getIteratorFn(newChildrenIterable);
    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    {
      // We don't support rendering Generators because it's a mutation.
      // See https://github.com/facebook/react/issues/12995
      if (typeof Symbol === 'function' &&
      // $FlowFixMe Flow doesn't know about toStringTag
      newChildrenIterable[Symbol.toStringTag] === 'Generator') {
        !didWarnAboutGenerators ? warning$1(false, 'Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.') : void 0;
        didWarnAboutGenerators = true;
      }

      // Warn about using Maps as children
      if (newChildrenIterable.entries === iteratorFn) {
        !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
        didWarnAboutMaps = true;
      }

      // First, validate keys.
      // We'll get a different iterator later for the main pass.
      var _newChildren = iteratorFn.call(newChildrenIterable);
      if (_newChildren) {
        var knownKeys = null;
        var _step = _newChildren.next();
        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);
    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    var step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (!oldFiber) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
        if (_newFiber3 === null) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }
        previousNewFiber = _newFiber3;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }
        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing.return = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
    created.return = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
    var key = element.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
          existing.ref = coerceRef(returnFiber, child, element);
          existing.return = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);
      created.return = returnFiber;
      return created;
    } else {
      var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);
      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
      _created4.return = returnFiber;
      return _created4;
    }
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
    var key = portal.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || [], expirationTime);
          existing.return = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
    created.return = returnFiber;
    return created;
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
    }

    // Handle object types
    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }
    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
        case ClassComponentLazy:
          {
            {
              var instance = returnFiber.stateNode;
              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case FunctionalComponent:
          {
            var Component = returnFiber.type;
            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
          }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

function cloneChildFibers(current$$1, workInProgress) {
  !(current$$1 === null || workInProgress.child === current$$1.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
  workInProgress.child = newChild;

  newChild.return = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    newChild.return = workInProgress;
  }
  newChild.sibling = null;
}

// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber = null;
var nextHydratableInstance = null;
var isHydrating = false;

function enterHydrationState(fiber) {
  if (!supportsHydration) {
    return false;
  }

  var parentInstance = fiber.stateNode.containerInfo;
  nextHydratableInstance = getFirstHydratableChild(parentInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  return true;
}

function deleteHydratableInstance(returnFiber, instance) {
  {
    switch (returnFiber.tag) {
      case HostRoot:
        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
        break;
      case HostComponent:
        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
        break;
    }
  }

  var childToDelete = createFiberFromHostInstanceForDeletion();
  childToDelete.stateNode = instance;
  childToDelete.return = returnFiber;
  childToDelete.effectTag = Deletion;

  // This might seem like it belongs on progressedFirstDeletion. However,
  // these children are not part of the reconciliation list of children.
  // Even if we abort and rereconcile the children, that will try to hydrate
  // again and the nodes are still in the host tree so these will be
  // recreated.
  if (returnFiber.lastEffect !== null) {
    returnFiber.lastEffect.nextEffect = childToDelete;
    returnFiber.lastEffect = childToDelete;
  } else {
    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
  }
}

function insertNonHydratedInstance(returnFiber, fiber) {
  fiber.effectTag |= Placement;
  {
    switch (returnFiber.tag) {
      case HostRoot:
        {
          var parentContainer = returnFiber.stateNode.containerInfo;
          switch (fiber.tag) {
            case HostComponent:
              var type = fiber.type;
              var props = fiber.pendingProps;
              didNotFindHydratableContainerInstance(parentContainer, type, props);
              break;
            case HostText:
              var text = fiber.pendingProps;
              didNotFindHydratableContainerTextInstance(parentContainer, text);
              break;
          }
          break;
        }
      case HostComponent:
        {
          var parentType = returnFiber.type;
          var parentProps = returnFiber.memoizedProps;
          var parentInstance = returnFiber.stateNode;
          switch (fiber.tag) {
            case HostComponent:
              var _type = fiber.type;
              var _props = fiber.pendingProps;
              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
              break;
            case HostText:
              var _text = fiber.pendingProps;
              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
              break;
          }
          break;
        }
      default:
        return;
    }
  }
}

function tryHydrate(fiber, nextInstance) {
  switch (fiber.tag) {
    case HostComponent:
      {
        var type = fiber.type;
        var props = fiber.pendingProps;
        var instance = canHydrateInstance(nextInstance, type, props);
        if (instance !== null) {
          fiber.stateNode = instance;
          return true;
        }
        return false;
      }
    case HostText:
      {
        var text = fiber.pendingProps;
        var textInstance = canHydrateTextInstance(nextInstance, text);
        if (textInstance !== null) {
          fiber.stateNode = textInstance;
          return true;
        }
        return false;
      }
    default:
      return false;
  }
}

function tryToClaimNextHydratableInstance(fiber) {
  if (!isHydrating) {
    return;
  }
  var nextInstance = nextHydratableInstance;
  if (!nextInstance) {
    // Nothing to hydrate. Make it an insertion.
    insertNonHydratedInstance(hydrationParentFiber, fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }
  var firstAttemptedInstance = nextInstance;
  if (!tryHydrate(fiber, nextInstance)) {
    // If we can't hydrate this instance let's try the next one.
    // We use this as a heuristic. It's based on intuition and not data so it
    // might be flawed or unnecessary.
    nextInstance = getNextHydratableSibling(firstAttemptedInstance);
    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    }
    // We matched the next one, we'll now assume that the first one was
    // superfluous and we'll delete it. Since we can't eagerly delete it
    // we'll have to schedule a deletion. To do that, this node needs a dummy
    // fiber associated with it.
    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
  }
  hydrationParentFiber = fiber;
  nextHydratableInstance = getFirstHydratableChild(nextInstance);
}

function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
  if (!supportsHydration) {
    invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
  }

  var instance = fiber.stateNode;
  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
  // TODO: Type this specific to this type of component.
  fiber.updateQueue = updatePayload;
  // If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update.
  if (updatePayload !== null) {
    return true;
  }
  return false;
}

function prepareToHydrateHostTextInstance(fiber) {
  if (!supportsHydration) {
    invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
  }

  var textInstance = fiber.stateNode;
  var textContent = fiber.memoizedProps;
  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
  {
    if (shouldUpdate) {
      // We assume that prepareToHydrateHostTextInstance is called in a context where the
      // hydration parent is the parent host component of this host text.
      var returnFiber = hydrationParentFiber;
      if (returnFiber !== null) {
        switch (returnFiber.tag) {
          case HostRoot:
            {
              var parentContainer = returnFiber.stateNode.containerInfo;
              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
              break;
            }
          case HostComponent:
            {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
              break;
            }
        }
      }
    }
  }
  return shouldUpdate;
}

function popToNextHostParent(fiber) {
  var parent = fiber.return;
  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
    parent = parent.return;
  }
  hydrationParentFiber = parent;
}

function popHydrationState(fiber) {
  if (!supportsHydration) {
    return false;
  }
  if (fiber !== hydrationParentFiber) {
    // We're deeper than the current hydration context, inside an inserted
    // tree.
    return false;
  }
  if (!isHydrating) {
    // If we're not currently hydrating but we're in a hydration context, then
    // we were an insertion and now need to pop up reenter hydration of our
    // siblings.
    popToNextHostParent(fiber);
    isHydrating = true;
    return false;
  }

  var type = fiber.type;

  // If we have any remaining hydratable nodes, we need to delete them now.
  // We only do this deeper than head and body since they tend to have random
  // other nodes in them. We also ignore components with pure text content in
  // side of them.
  // TODO: Better heuristic.
  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
    var nextInstance = nextHydratableInstance;
    while (nextInstance) {
      deleteHydratableInstance(fiber, nextInstance);
      nextInstance = getNextHydratableSibling(nextInstance);
    }
  }

  popToNextHostParent(fiber);
  nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
  return true;
}

function resetHydrationState() {
  if (!supportsHydration) {
    return;
  }

  hydrationParentFiber = null;
  nextHydratableInstance = null;
  isHydrating = false;
}

function readLazyComponentType(thenable) {
  var status = thenable._reactStatus;
  switch (status) {
    case Resolved:
      var Component = thenable._reactResult;
      return Component;
    case Rejected:
      throw thenable._reactResult;
    case Pending:
      throw thenable;
    default:
      {
        thenable._reactStatus = Pending;
        thenable.then(function (resolvedValue) {
          if (thenable._reactStatus === Pending) {
            thenable._reactStatus = Resolved;
            if (typeof resolvedValue === 'object' && resolvedValue !== null) {
              // If the `default` property is not empty, assume it's the result
              // of an async import() and use that. Otherwise, use the
              // resolved value itself.
              var defaultExport = resolvedValue.default;
              resolvedValue = defaultExport !== undefined && defaultExport !== null ? defaultExport : resolvedValue;
            } else {
              resolvedValue = resolvedValue;
            }
            thenable._reactResult = resolvedValue;
          }
        }, function (error) {
          if (thenable._reactStatus === Pending) {
            thenable._reactStatus = Rejected;
            thenable._reactResult = error;
          }
        });
        throw thenable;
      }
  }
}

var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;

var didWarnAboutBadClass = void 0;
var didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;
var didWarnAboutStatelessRefs = void 0;

{
  didWarnAboutBadClass = {};
  didWarnAboutGetDerivedStateOnFunctionalComponent = {};
  didWarnAboutStatelessRefs = {};
}

function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {
  if (current$$1 === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.

    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);
  }
}

function updateForwardRef(current$$1, workInProgress, type, nextProps, renderExpirationTime) {
  var render = type.render;
  var ref = workInProgress.ref;
  if (hasContextChanged()) {
    // Normally we can bail out on props equality but if context has changed
    // we don't do the bailout and we have to reuse existing props instead.
  } else if (workInProgress.memoizedProps === nextProps) {
    var currentRef = current$$1 !== null ? current$$1.ref : null;
    if (ref === currentRef) {
      return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
    }
  }

  var nextChildren = void 0;
  {
    ReactCurrentOwner$3.current = workInProgress;
    setCurrentPhase('render');
    nextChildren = render(nextProps, ref);
    setCurrentPhase(null);
  }

  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
  memoizeProps(workInProgress, nextProps);
  return workInProgress.child;
}

function updateFragment(current$$1, workInProgress, renderExpirationTime) {
  var nextChildren = workInProgress.pendingProps;
  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
  memoizeProps(workInProgress, nextChildren);
  return workInProgress.child;
}

function updateMode(current$$1, workInProgress, renderExpirationTime) {
  var nextChildren = workInProgress.pendingProps.children;
  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
  memoizeProps(workInProgress, nextChildren);
  return workInProgress.child;
}

function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
  if (enableProfilerTimer) {
    workInProgress.effectTag |= Update;
  }
  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
  memoizeProps(workInProgress, nextProps);
  return workInProgress.child;
}

function markRef(current$$1, workInProgress) {
  var ref = workInProgress.ref;
  if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {
    // Schedule a Ref effect
    workInProgress.effectTag |= Ref;
  }
}

function updateFunctionalComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
  var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
  var context = getMaskedContext(workInProgress, unmaskedContext);

  var nextChildren = void 0;
  prepareToReadContext(workInProgress, renderExpirationTime);
  {
    ReactCurrentOwner$3.current = workInProgress;
    setCurrentPhase('render');
    nextChildren = Component(nextProps, context);
    setCurrentPhase(null);
  }

  // React DevTools reads this flag.
  workInProgress.effectTag |= PerformedWork;
  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
  memoizeProps(workInProgress, nextProps);
  return workInProgress.child;
}

function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
  // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.
  var hasContext = void 0;
  if (isContextProvider(Component)) {
    hasContext = true;
    pushContextProvider(workInProgress);
  } else {
    hasContext = false;
  }
  prepareToReadContext(workInProgress, renderExpirationTime);

  var shouldUpdate = void 0;
  if (current$$1 === null) {
    if (workInProgress.stateNode === null) {
      // In the initial pass we might need to construct the instance.
      constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
      mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
      shouldUpdate = true;
    } else {
      // In a resume, we'll already have an instance we can reuse.
      shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
    }
  } else {
    shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
  }
  return finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);
}

function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
  // Refs should update even if shouldComponentUpdate returns false
  markRef(current$$1, workInProgress);

  var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;

  if (!shouldUpdate && !didCaptureError) {
    // Context providers should defer to sCU for rendering
    if (hasContext) {
      invalidateContextProvider(workInProgress, Component, false);
    }

    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
  }

  var instance = workInProgress.stateNode;

  // Rerender
  ReactCurrentOwner$3.current = workInProgress;
  var nextChildren = void 0;
  if (didCaptureError && (!enableGetDerivedStateFromCatch || typeof Component.getDerivedStateFromCatch !== 'function')) {
    // If we captured an error, but getDerivedStateFrom catch is not defined,
    // unmount all the children. componentDidCatch will schedule an update to
    // re-render a fallback. This is temporary until we migrate everyone to
    // the new API.
    // TODO: Warn in a future release.
    nextChildren = null;

    if (enableProfilerTimer) {
      stopProfilerTimerIfRunning(workInProgress);
    }
  } else {
    {
      setCurrentPhase('render');
      nextChildren = instance.render();
      if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
        instance.render();
      }
      setCurrentPhase(null);
    }
  }

  // React DevTools reads this flag.
  workInProgress.effectTag |= PerformedWork;
  if (current$$1 !== null && didCaptureError) {
    // If we're recovering from an error, reconcile twice: first to delete
    // all the existing children.
    reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);
    workInProgress.child = null;
    // Now we can continue reconciling like normal. This has the effect of
    // remounting all children regardless of whether their their
    // identity matches.
  }
  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
  // Memoize props and state using the values we just used to render.
  // TODO: Restructure so we never read values from the instance.
  memoizeState(workInProgress, instance.state);
  memoizeProps(workInProgress, instance.props);

  // The context might have changed so we need to recalculate it.
  if (hasContext) {
    invalidateContextProvider(workInProgress, Component, true);
  }

  return workInProgress.child;
}

function pushHostRootContext(workInProgress) {
  var root = workInProgress.stateNode;
  if (root.pendingContext) {
    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
  } else if (root.context) {
    // Should always be set
    pushTopLevelContextObject(workInProgress, root.context, false);
  }
  pushHostContainer(workInProgress, root.containerInfo);
}

function updateHostRoot(current$$1, workInProgress, renderExpirationTime) {
  pushHostRootContext(workInProgress);
  var updateQueue = workInProgress.updateQueue;
  !(updateQueue !== null) ? invariant(false, 'If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var nextProps = workInProgress.pendingProps;
  var prevState = workInProgress.memoizedState;
  var prevChildren = prevState !== null ? prevState.element : null;
  processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);
  var nextState = workInProgress.memoizedState;
  // Caution: React DevTools currently depends on this property
  // being called "element".
  var nextChildren = nextState.element;
  if (nextChildren === prevChildren) {
    // If the state is the same as before, that's a bailout because we had
    // no work that expires at this time.
    resetHydrationState();
    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
  }
  var root = workInProgress.stateNode;
  if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
    // If we don't have any current children this might be the first pass.
    // We always try to hydrate. If this isn't a hydration pass there won't
    // be any children to hydrate which is effectively the same thing as
    // not hydrating.

    // This is a bit of a hack. We track the host root as a placement to
    // know that we're currently in a mounting state. That way isMounted
    // works as expected. We must reset this before committing.
    // TODO: Delete this when we delete isMounted and findDOMNode.
    workInProgress.effectTag |= Placement;

    // Ensure that children mount into this root without tracking
    // side-effects. This ensures that we don't store Placement effects on
    // nodes that will be hydrated.
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
  } else {
    // Otherwise reset hydration state in case we aborted and resumed another
    // root.
    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
    resetHydrationState();
  }
  return workInProgress.child;
}

function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
  pushHostContext(workInProgress);

  if (current$$1 === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }

  var type = workInProgress.type;
  var nextProps = workInProgress.pendingProps;
  var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;

  var nextChildren = nextProps.children;
  var isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also have access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.effectTag |= ContentReset;
  }

  markRef(current$$1, workInProgress);

  // Check the host config to see if the children are offscreen/hidden.
  if (renderExpirationTime !== Never && workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps)) {
    // Schedule this fiber to re-render at offscreen priority. Then bailout.
    workInProgress.expirationTime = Never;
    workInProgress.memoizedProps = nextProps;
    return null;
  }

  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
  memoizeProps(workInProgress, nextProps);
  return workInProgress.child;
}

function updateHostText(current$$1, workInProgress) {
  if (current$$1 === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }
  var nextProps = workInProgress.pendingProps;
  memoizeProps(workInProgress, nextProps);
  // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.
  return null;
}

function resolveDefaultProps(Component, baseProps) {
  if (Component && Component.defaultProps) {
    // Resolve default props. Taken from ReactElement
    var props = _assign({}, baseProps);
    var defaultProps = Component.defaultProps;
    for (var propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
    return props;
  }
  return baseProps;
}

function mountIndeterminateComponent(current$$1, workInProgress, Component, renderExpirationTime) {
  !(current$$1 === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  var props = workInProgress.pendingProps;
  if (typeof Component === 'object' && Component !== null && typeof Component.then === 'function') {
    Component = readLazyComponentType(Component);
    var resolvedTag = workInProgress.tag = resolveLazyComponentTag(workInProgress, Component);
    var resolvedProps = resolveDefaultProps(Component, props);
    switch (resolvedTag) {
      case FunctionalComponentLazy:
        {
          return updateFunctionalComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);
        }
      case ClassComponentLazy:
        {
          return updateClassComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);
        }
      case ForwardRefLazy:
        {
          return updateForwardRef(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);
        }
      default:
        {
          // This message intentionally doesn't metion ForwardRef because the
          // fact that it's a separate type of work is an implementation detail.
          invariant(false, 'Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.', Component);
        }
    }
  }

  var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
  var context = getMaskedContext(workInProgress, unmaskedContext);

  prepareToReadContext(workInProgress, renderExpirationTime);

  var value = void 0;

  {
    if (Component.prototype && typeof Component.prototype.render === 'function') {
      var componentName = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutBadClass[componentName]) {
        warningWithoutStack$1(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
        didWarnAboutBadClass[componentName] = true;
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
    }

    ReactCurrentOwner$3.current = workInProgress;
    value = Component(props, context);
  }
  // React DevTools reads this flag.
  workInProgress.effectTag |= PerformedWork;

  if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
    // Proceed under the assumption that this is a class instance
    workInProgress.tag = ClassComponent;

    // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.
    var hasContext = false;
    if (isContextProvider(Component)) {
      hasContext = true;
      pushContextProvider(workInProgress);
    } else {
      hasContext = false;
    }

    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;

    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
    if (typeof getDerivedStateFromProps === 'function') {
      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
    }

    adoptClassInstance(workInProgress, value);
    mountClassInstance(workInProgress, Component, props, renderExpirationTime);
    return finishClassComponent(current$$1, workInProgress, Component, true, hasContext, renderExpirationTime);
  } else {
    // Proceed under the assumption that this is a functional component
    workInProgress.tag = FunctionalComponent;
    {
      if (Component) {
        !!Component.childContextTypes ? warningWithoutStack$1(false, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
      }
      if (workInProgress.ref !== null) {
        var info = '';
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        if (ownerName) {
          info += '\n\nCheck the render method of `' + ownerName + '`.';
        }

        var warningKey = ownerName || workInProgress._debugID || '';
        var debugSource = workInProgress._debugSource;
        if (debugSource) {
          warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
        }
        if (!didWarnAboutStatelessRefs[warningKey]) {
          didWarnAboutStatelessRefs[warningKey] = true;
          warning$1(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s', info);
        }
      }

      if (typeof Component.getDerivedStateFromProps === 'function') {
        var _componentName = getComponentName(Component) || 'Unknown';

        if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {
          warningWithoutStack$1(false, '%s: Stateless functional components do not support getDerivedStateFromProps.', _componentName);
          didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName] = true;
        }
      }
    }
    reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);
    memoizeProps(workInProgress, props);
    return workInProgress.child;
  }
}

function updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime) {
  if (enableSuspense) {
    var nextProps = workInProgress.pendingProps;

    // Check if we already attempted to render the normal state. If we did,
    // and we timed out, render the placeholder state.
    var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;

    var nextDidTimeout = void 0;
    if (current$$1 !== null && workInProgress.updateQueue !== null) {
      // We're outside strict mode. Something inside this Placeholder boundary
      // suspended during the last commit. Switch to the placholder.
      workInProgress.updateQueue = null;
      nextDidTimeout = true;
      // If we're recovering from an error, reconcile twice: first to delete
      // all the existing children.
      reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);
      current$$1.child = null;
      // Now we can continue reconciling like normal. This has the effect of
      // remounting all children regardless of whether their their
      // identity matches.
    } else {
      nextDidTimeout = !alreadyCaptured;
    }

    if ((workInProgress.mode & StrictMode) !== NoEffect) {
      if (nextDidTimeout) {
        // If the timed-out view commits, schedule an update effect to record
        // the committed time.
        workInProgress.effectTag |= Update;
      } else {
        // The state node points to the time at which placeholder timed out.
        // We can clear it once we switch back to the normal children.
        workInProgress.stateNode = null;
      }
    }

    // If the `children` prop is a function, treat it like a render prop.
    // TODO: This is temporary until we finalize a lower level API.
    var children = nextProps.children;
    var nextChildren = void 0;
    if (typeof children === 'function') {
      nextChildren = children(nextDidTimeout);
    } else {
      nextChildren = nextDidTimeout ? nextProps.fallback : children;
    }

    workInProgress.memoizedProps = nextProps;
    workInProgress.memoizedState = nextDidTimeout;
    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
    return workInProgress.child;
  } else {
    return null;
  }
}

function updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {
  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
  var nextChildren = workInProgress.pendingProps;
  if (current$$1 === null) {
    // Portals are special because we don't append the children during mount
    // but at commit. Therefore we need to track insertions which the normal
    // flow doesn't do during mount. This doesn't happen at the root because
    // the root always starts with a "current" with a null child.
    // TODO: Consider unifying this with how the root works.
    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
    memoizeProps(workInProgress, nextChildren);
  } else {
    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
    memoizeProps(workInProgress, nextChildren);
  }
  return workInProgress.child;
}

function updateContextProvider(current$$1, workInProgress, renderExpirationTime) {
  var providerType = workInProgress.type;
  var context = providerType._context;

  var newProps = workInProgress.pendingProps;
  var oldProps = workInProgress.memoizedProps;

  var newValue = newProps.value;
  workInProgress.memoizedProps = newProps;

  {
    var providerPropTypes = workInProgress.type.propTypes;

    if (providerPropTypes) {
      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider', getCurrentFiberStackInDev);
    }
  }

  pushProvider(workInProgress, newValue);

  if (oldProps !== null) {
    var oldValue = oldProps.value;
    var changedBits = calculateChangedBits(context, newValue, oldValue);
    if (changedBits === 0) {
      // No change. Bailout early if children are the same.
      if (oldProps.children === newProps.children && !hasContextChanged()) {
        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
      }
    } else {
      // The context value changed. Search for matching consumers and schedule
      // them to update.
      propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);
    }
  }

  var newChildren = newProps.children;
  reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
  return workInProgress.child;
}

function updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {
  var context = workInProgress.type;
  var newProps = workInProgress.pendingProps;
  var render = newProps.children;

  {
    !(typeof render === 'function') ? warningWithoutStack$1(false, 'A context consumer was rendered with multiple children, or a child ' + "that isn't a function. A context consumer expects a single child " + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.') : void 0;
  }

  prepareToReadContext(workInProgress, renderExpirationTime);
  var newValue = readContext(context, newProps.unstable_observedBits);
  var newChildren = void 0;
  {
    ReactCurrentOwner$3.current = workInProgress;
    setCurrentPhase('render');
    newChildren = render(newValue);
    setCurrentPhase(null);
  }

  // React DevTools reads this flag.
  workInProgress.effectTag |= PerformedWork;
  reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
  workInProgress.memoizedProps = newProps;
  return workInProgress.child;
}

/*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */

function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {
  cancelWorkTimer(workInProgress);

  if (current$$1 !== null) {
    // Reuse previous context list
    workInProgress.firstContextDependency = current$$1.firstContextDependency;
  }

  if (enableProfilerTimer) {
    // Don't update "base" render times for bailouts.
    stopProfilerTimerIfRunning(workInProgress);
  }

  // Check if the children have any pending work.
  var childExpirationTime = workInProgress.childExpirationTime;
  if (childExpirationTime === NoWork || childExpirationTime > renderExpirationTime) {
    // The children don't have any work either. We can skip them.
    // TODO: Once we add back resuming, we should check if the children are
    // a work-in-progress set. If so, we need to transfer their effects.
    return null;
  } else {
    // This fiber doesn't have work, but its subtree does. Clone the child
    // fibers and continue.
    cloneChildFibers(current$$1, workInProgress);
    return workInProgress.child;
  }
}

// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
function memoizeProps(workInProgress, nextProps) {
  workInProgress.memoizedProps = nextProps;
}

function memoizeState(workInProgress, nextState) {
  workInProgress.memoizedState = nextState;
  // Don't reset the updateQueue, in case there are pending updates. Resetting
  // is handled by processUpdateQueue.
}

function beginWork(current$$1, workInProgress, renderExpirationTime) {
  var updateExpirationTime = workInProgress.expirationTime;
  if (!hasContextChanged() && (updateExpirationTime === NoWork || updateExpirationTime > renderExpirationTime)) {
    // This fiber does not have any pending work. Bailout without entering
    // the begin phase. There's still some bookkeeping we that needs to be done
    // in this optimized path, mostly pushing stuff onto the stack.
    switch (workInProgress.tag) {
      case HostRoot:
        pushHostRootContext(workInProgress);
        resetHydrationState();
        break;
      case HostComponent:
        pushHostContext(workInProgress);
        break;
      case ClassComponent:
        {
          var Component = workInProgress.type;
          if (isContextProvider(Component)) {
            pushContextProvider(workInProgress);
          }
          break;
        }
      case ClassComponentLazy:
        {
          var thenable = workInProgress.type;
          var _Component = getResultFromResolvedThenable(thenable);
          if (isContextProvider(_Component)) {
            pushContextProvider(workInProgress);
          }
          break;
        }
      case HostPortal:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
      case ContextProvider:
        {
          var newValue = workInProgress.memoizedProps.value;
          pushProvider(workInProgress, newValue);
          break;
        }
      case Profiler:
        if (enableProfilerTimer) {
          workInProgress.effectTag |= Update;
        }
        break;
    }
    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
  }

  // Before entering the begin phase, clear the expiration time.
  workInProgress.expirationTime = NoWork;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
      {
        var _Component3 = workInProgress.type;
        return mountIndeterminateComponent(current$$1, workInProgress, _Component3, renderExpirationTime);
      }
    case FunctionalComponent:
      {
        var _Component4 = workInProgress.type;
        var _unresolvedProps = workInProgress.pendingProps;
        return updateFunctionalComponent(current$$1, workInProgress, _Component4, _unresolvedProps, renderExpirationTime);
      }
    case FunctionalComponentLazy:
      {
        var _thenable2 = workInProgress.type;
        var _Component5 = getResultFromResolvedThenable(_thenable2);
        var _unresolvedProps2 = workInProgress.pendingProps;
        var _child = updateFunctionalComponent(current$$1, workInProgress, _Component5, resolveDefaultProps(_Component5, _unresolvedProps2), renderExpirationTime);
        workInProgress.memoizedProps = _unresolvedProps2;
        return _child;
      }
    case ClassComponent:
      {
        var _Component6 = workInProgress.type;
        var _unresolvedProps3 = workInProgress.pendingProps;
        return updateClassComponent(current$$1, workInProgress, _Component6, _unresolvedProps3, renderExpirationTime);
      }
    case ClassComponentLazy:
      {
        var _thenable3 = workInProgress.type;
        var _Component7 = getResultFromResolvedThenable(_thenable3);
        var _unresolvedProps4 = workInProgress.pendingProps;
        var _child2 = updateClassComponent(current$$1, workInProgress, _Component7, resolveDefaultProps(_Component7, _unresolvedProps4), renderExpirationTime);
        workInProgress.memoizedProps = _unresolvedProps4;
        return _child2;
      }
    case HostRoot:
      return updateHostRoot(current$$1, workInProgress, renderExpirationTime);
    case HostComponent:
      return updateHostComponent(current$$1, workInProgress, renderExpirationTime);
    case HostText:
      return updateHostText(current$$1, workInProgress);
    case PlaceholderComponent:
      return updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime);
    case HostPortal:
      return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);
    case ForwardRef:
      {
        var type = workInProgress.type;
        return updateForwardRef(current$$1, workInProgress, type, workInProgress.pendingProps, renderExpirationTime);
      }
    case ForwardRefLazy:
      var _thenable = workInProgress.type;
      var _Component2 = getResultFromResolvedThenable(_thenable);
      var unresolvedProps = workInProgress.pendingProps;
      var child = updateForwardRef(current$$1, workInProgress, _Component2, resolveDefaultProps(_Component2, unresolvedProps), renderExpirationTime);
      workInProgress.memoizedProps = unresolvedProps;
      return child;
    case Fragment:
      return updateFragment(current$$1, workInProgress, renderExpirationTime);
    case Mode:
      return updateMode(current$$1, workInProgress, renderExpirationTime);
    case Profiler:
      return updateProfiler(current$$1, workInProgress, renderExpirationTime);
    case ContextProvider:
      return updateContextProvider(current$$1, workInProgress, renderExpirationTime);
    case ContextConsumer:
      return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);
    default:
      invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
  }
}

function markUpdate(workInProgress) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.effectTag |= Update;
}

function markRef$1(workInProgress) {
  workInProgress.effectTag |= Ref;
}

function appendAllChildren(parent, workInProgress) {
  // We only have the top Fiber that was created but we need recurse down its
  // children to find all the terminal nodes.
  var node = workInProgress.child;
  while (node !== null) {
    if (node.tag === HostComponent || node.tag === HostText) {
      appendInitialChild(parent, node.stateNode);
    } else if (node.tag === HostPortal) {
      // If we have a portal child, then we don't want to traverse
      // down its children. Instead, we'll get insertions from each child in
      // the portal directly.
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === workInProgress) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === workInProgress) {
        return;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}

var updateHostContainer = void 0;
var updateHostComponent$1 = void 0;
var updateHostText$1 = void 0;
if (supportsMutation) {
  // Mutation mode

  updateHostContainer = function (workInProgress) {
    // Noop
  };
  updateHostComponent$1 = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {
    // TODO: Type this specific to this type of component.
    workInProgress.updateQueue = updatePayload;
    // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update. All the work is done in commitWork.
    if (updatePayload) {
      markUpdate(workInProgress);
    }
  };
  updateHostText$1 = function (current, workInProgress, oldText, newText) {
    // If the text differs, mark it as an update. All the work in done in commitWork.
    if (oldText !== newText) {
      markUpdate(workInProgress);
    }
  };
} else if (supportsPersistence) {
  // Persistent host tree mode

  // An unfortunate fork of appendAllChildren because we have two different parent types.
  var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendChildToContainerChildSet(containerChildSet, node.stateNode);
      } else if (node.tag === HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress) {
          return;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  };
  updateHostContainer = function (workInProgress) {
    var portalOrRoot = workInProgress.stateNode;
    var childrenUnchanged = workInProgress.firstEffect === null;
    if (childrenUnchanged) {
      // No changes, just reuse the existing instance.
    } else {
      var container = portalOrRoot.containerInfo;
      var newChildSet = createContainerChildSet(container);
      // If children might have changed, we have to add them all to the set.
      appendAllChildrenToContainer(newChildSet, workInProgress);
      portalOrRoot.pendingChildren = newChildSet;
      // Schedule an update on the container to swap out the container.
      markUpdate(workInProgress);
      finalizeContainerChildren(container, newChildSet);
    }
  };
  updateHostComponent$1 = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {
    // If there are no effects associated with this node, then none of our children had any updates.
    // This guarantees that we can reuse all of them.
    var childrenUnchanged = workInProgress.firstEffect === null;
    var currentInstance = current.stateNode;
    if (childrenUnchanged && updatePayload === null) {
      // No changes, just reuse the existing instance.
      // Note that this might release a previous clone.
      workInProgress.stateNode = currentInstance;
    } else {
      var recyclableInstance = workInProgress.stateNode;
      var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
      if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {
        markUpdate(workInProgress);
      }
      workInProgress.stateNode = newInstance;
      if (childrenUnchanged) {
        // If there are no other effects in this tree, we need to flag this node as having one.
        // Even though we're not going to use it for anything.
        // Otherwise parents won't know that there are new children to propagate upwards.
        markUpdate(workInProgress);
      } else {
        // If children might have changed, we have to add them all to the set.
        appendAllChildren(newInstance, workInProgress);
      }
    }
  };
  updateHostText$1 = function (current, workInProgress, oldText, newText) {
    if (oldText !== newText) {
      // If the text content differs, we'll create a new text instance for it.
      var rootContainerInstance = getRootHostContainer();
      var currentHostContext = getHostContext();
      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
      // We'll have to mark it as having an effect, even though we won't use the effect for anything.
      // This lets the parents know that at least one of their children has changed.
      markUpdate(workInProgress);
    }
  };
} else {
  // No host operations
  updateHostContainer = function (workInProgress) {
    // Noop
  };
  updateHostComponent$1 = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext) {
    // Noop
  };
  updateHostText$1 = function (current, workInProgress, oldText, newText) {
    // Noop
  };
}

function completeWork(current, workInProgress, renderExpirationTime) {
  var newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case FunctionalComponent:
    case FunctionalComponentLazy:
      break;
    case ClassComponent:
      {
        var Component = workInProgress.type;
        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }
        break;
      }
    case ClassComponentLazy:
      {
        var _Component = getResultFromResolvedThenable(workInProgress.type);
        if (isContextProvider(_Component)) {
          popContext(workInProgress);
        }
        break;
      }
    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        var fiberRoot = workInProgress.stateNode;
        if (fiberRoot.pendingContext) {
          fiberRoot.context = fiberRoot.pendingContext;
          fiberRoot.pendingContext = null;
        }
        if (current === null || current.child === null) {
          // If we hydrated, pop so that we can delete any remaining children
          // that weren't hydrated.
          popHydrationState(workInProgress);
          // This resets the hacky state to fix isMounted before committing.
          // TODO: Delete this when we delete isMounted and findDOMNode.
          workInProgress.effectTag &= ~Placement;
        }
        updateHostContainer(workInProgress);
        break;
      }
    case HostComponent:
      {
        popHostContext(workInProgress);
        var rootContainerInstance = getRootHostContainer();
        var type = workInProgress.type;
        if (current !== null && workInProgress.stateNode != null) {
          // If we have an alternate, that means this is an update and we need to
          // schedule a side-effect to do the updates.
          var oldProps = current.memoizedProps;
          if (oldProps !== newProps) {
            // If we get updated because one of our children updated, we don't
            // have newProps so we'll have to reuse them.
            // TODO: Split the update API as separate for the props vs. children.
            var instance = workInProgress.stateNode;
            var currentHostContext = getHostContext();
            // TODO: Experiencing an error where oldProps is null. Suggests a host
            // component is hitting the resume path. Figure out why. Possibly
            // related to `hidden`.
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

            updateHostComponent$1(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          }

          if (current.ref !== workInProgress.ref) {
            markRef$1(workInProgress);
          }
        } else {
          if (!newProps) {
            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
            // This can happen when we abort work.
            break;
          }

          var _currentHostContext = getHostContext();
          // TODO: Move createInstance to beginWork and keep it on a context
          // "stack" as the parent. Then append children as we go in beginWork
          // or completeWork depending on we want to add then top->down or
          // bottom->up. Top->down is faster in IE11.
          var wasHydrated = popHydrationState(workInProgress);
          if (wasHydrated) {
            // TODO: Move this and createInstance step into the beginPhase
            // to consolidate.
            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
              // If changes to the hydrated node needs to be applied at the
              // commit-phase we mark this as such.
              markUpdate(workInProgress);
            }
          } else {
            var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

            appendAllChildren(_instance, workInProgress);

            // Certain renderers require commit-time effects for initial mount.
            // (eg DOM renderer supports auto-focus for certain elements).
            // Make sure such renderers get scheduled for later work.
            if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance, _currentHostContext)) {
              markUpdate(workInProgress);
            }
            workInProgress.stateNode = _instance;
          }

          if (workInProgress.ref !== null) {
            // If there is a ref on a host node we need to schedule a callback
            markRef$1(workInProgress);
          }
        }
        break;
      }
    case HostText:
      {
        var newText = newProps;
        if (current && workInProgress.stateNode != null) {
          var oldText = current.memoizedProps;
          // If we have an alternate, that means this is an update and we need
          // to schedule a side-effect to do the updates.
          updateHostText$1(current, workInProgress, oldText, newText);
        } else {
          if (typeof newText !== 'string') {
            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
            // This can happen when we abort work.
          }
          var _rootContainerInstance = getRootHostContainer();
          var _currentHostContext2 = getHostContext();
          var _wasHydrated = popHydrationState(workInProgress);
          if (_wasHydrated) {
            if (prepareToHydrateHostTextInstance(workInProgress)) {
              markUpdate(workInProgress);
            }
          } else {
            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
          }
        }
        break;
      }
    case ForwardRef:
    case ForwardRefLazy:
      break;
    case PlaceholderComponent:
      break;
    case Fragment:
      break;
    case Mode:
      break;
    case Profiler:
      break;
    case HostPortal:
      popHostContainer(workInProgress);
      updateHostContainer(workInProgress);
      break;
    case ContextProvider:
      // Pop provider fiber
      popProvider(workInProgress);
      break;
    case ContextConsumer:
      break;
    // Error cases
    case IndeterminateComponent:
      invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
    // eslint-disable-next-line no-fallthrough
    default:
      invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
  }

  return null;
}

// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(capturedError) {
  return true;
}

function logCapturedError(capturedError) {
  var logError = showErrorDialog(capturedError);

  // Allow injected showErrorDialog() to prevent default console.error logging.
  // This enables renderers like ReactNative to better manage redbox behavior.
  if (logError === false) {
    return;
  }

  var error = capturedError.error;
  {
    var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;

    // Browsers support silencing uncaught errors by calling
    // `preventDefault()` in window `error` handler.
    // We record this information as an expando on the error.

    if (error != null && error._suppressLogging) {
      if (errorBoundaryFound && willRetry) {
        // The error is recoverable and was silenced.
        // Ignore it and don't print the stack addendum.
        // This is handy for testing error boundaries without noise.
        return;
      }
      // The error is fatal. Since the silencing might have
      // been accidental, we'll surface it anyway.
      // However, the browser would have silenced the original error
      // so we'll print it first, and then print the stack addendum.
      console.error(error);
      // For a more detailed description of this block, see:
      // https://github.com/facebook/react/pull/13384
    }

    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

    var errorBoundaryMessage = void 0;
    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
    if (errorBoundaryFound && errorBoundaryName) {
      if (willRetry) {
        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
      } else {
        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
      }
    } else {
      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
    }
    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

    // In development, we provide our own message with just the component stack.
    // We don't include the original error message and JS stack because the browser
    // has already printed it. Even if the application swallows the error, it is still
    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
    console.error(combinedMessage);
  }
}

var emptyObject = {};

var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
{
  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
}

function logError(boundary, errorInfo) {
  var source = errorInfo.source;
  var stack = errorInfo.stack;
  if (stack === null && source !== null) {
    stack = getStackByFiberInDevAndProd(source);
  }

  var capturedError = {
    componentName: source !== null ? getComponentName(source.type) : null,
    componentStack: stack !== null ? stack : '',
    error: errorInfo.value,
    errorBoundary: null,
    errorBoundaryName: null,
    errorBoundaryFound: false,
    willRetry: false
  };

  if (boundary !== null && boundary.tag === ClassComponent) {
    capturedError.errorBoundary = boundary.stateNode;
    capturedError.errorBoundaryName = getComponentName(boundary.type);
    capturedError.errorBoundaryFound = true;
    capturedError.willRetry = true;
  }

  try {
    logCapturedError(capturedError);
  } catch (e) {
    // This method must not throw, or React internal state will get messed up.
    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
    // we want to report this error outside of the normal stack as a last resort.
    // https://github.com/facebook/react/issues/13188
    setTimeout(function () {
      throw e;
    });
  }
}

var callComponentWillUnmountWithTimer = function (current$$1, instance) {
  startPhaseTimer(current$$1, 'componentWillUnmount');
  instance.props = current$$1.memoizedProps;
  instance.state = current$$1.memoizedState;
  instance.componentWillUnmount();
  stopPhaseTimer();
};

// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current$$1, instance) {
  {
    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);
    if (hasCaughtError()) {
      var unmountError = clearCaughtError();
      captureCommitPhaseError(current$$1, unmountError);
    }
  }
}

function safelyDetachRef(current$$1) {
  var ref = current$$1.ref;
  if (ref !== null) {
    if (typeof ref === 'function') {
      {
        invokeGuardedCallback(null, ref, null, null);
        if (hasCaughtError()) {
          var refError = clearCaughtError();
          captureCommitPhaseError(current$$1, refError);
        }
      }
    } else {
      ref.current = null;
    }
  }
}

function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
  switch (finishedWork.tag) {
    case ClassComponent:
    case ClassComponentLazy:
      {
        if (finishedWork.effectTag & Snapshot) {
          if (current$$1 !== null) {
            var prevProps = current$$1.memoizedProps;
            var prevState = current$$1.memoizedState;
            startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');
            var instance = finishedWork.stateNode;
            instance.props = finishedWork.memoizedProps;
            instance.state = finishedWork.memoizedState;
            var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);
            {
              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                didWarnSet.add(finishedWork.type);
                warningWithoutStack$1(false, '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));
              }
            }
            instance.__reactInternalSnapshotBeforeUpdate = snapshot;
            stopPhaseTimer();
          }
        }
        return;
      }
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
      // Nothing to do for these component types
      return;
    default:
      {
        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
      }
  }
}

function commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {
  switch (finishedWork.tag) {
    case ClassComponent:
    case ClassComponentLazy:
      {
        var instance = finishedWork.stateNode;
        if (finishedWork.effectTag & Update) {
          if (current$$1 === null) {
            startPhaseTimer(finishedWork, 'componentDidMount');
            instance.props = finishedWork.memoizedProps;
            instance.state = finishedWork.memoizedState;
            instance.componentDidMount();
            stopPhaseTimer();
          } else {
            var prevProps = current$$1.memoizedProps;
            var prevState = current$$1.memoizedState;
            startPhaseTimer(finishedWork, 'componentDidUpdate');
            instance.props = finishedWork.memoizedProps;
            instance.state = finishedWork.memoizedState;
            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
            stopPhaseTimer();
          }
        }
        var updateQueue = finishedWork.updateQueue;
        if (updateQueue !== null) {
          instance.props = finishedWork.memoizedProps;
          instance.state = finishedWork.memoizedState;
          commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);
        }
        return;
      }
    case HostRoot:
      {
        var _updateQueue = finishedWork.updateQueue;
        if (_updateQueue !== null) {
          var _instance = null;
          if (finishedWork.child !== null) {
            switch (finishedWork.child.tag) {
              case HostComponent:
                _instance = getPublicInstance(finishedWork.child.stateNode);
                break;
              case ClassComponent:
              case ClassComponentLazy:
                _instance = finishedWork.child.stateNode;
                break;
            }
          }
          commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);
        }
        return;
      }
    case HostComponent:
      {
        var _instance2 = finishedWork.stateNode;

        // Renderers may schedule work to be done after host components are mounted
        // (eg DOM renderer may schedule auto-focus for inputs and form controls).
        // These effects should only be committed when components are first mounted,
        // aka when there is no current/alternate.
        if (current$$1 === null && finishedWork.effectTag & Update) {
          var type = finishedWork.type;
          var props = finishedWork.memoizedProps;
          commitMount(_instance2, type, props, finishedWork);
        }

        return;
      }
    case HostText:
      {
        // We have no life-cycles associated with text.
        return;
      }
    case HostPortal:
      {
        // We have no life-cycles associated with portals.
        return;
      }
    case Profiler:
      {
        if (enableProfilerTimer) {
          var onRender = finishedWork.memoizedProps.onRender;

          if (enableSchedulerTracking) {
            onRender(finishedWork.memoizedProps.id, current$$1 === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);
          } else {
            onRender(finishedWork.memoizedProps.id, current$$1 === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());
          }
        }
        return;
      }
    case PlaceholderComponent:
      {
        if (enableSuspense) {
          if ((finishedWork.mode & StrictMode) === NoEffect) {
            // In loose mode, a placeholder times out by scheduling a synchronous
            // update in the commit phase. Use `updateQueue` field to signal that
            // the Timeout needs to switch to the placeholder. We don't need an
            // entire queue. Any non-null value works.
            // $FlowFixMe - Intentionally using a value other than an UpdateQueue.
            finishedWork.updateQueue = emptyObject;
            scheduleWork(finishedWork, Sync);
          } else {
            // In strict mode, the Update effect is used to record the time at
            // which the placeholder timed out.
            var currentTime = requestCurrentTime();
            finishedWork.stateNode = { timedOutAt: currentTime };
          }
        }
        return;
      }
    default:
      {
        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
      }
  }
}

function commitAttachRef(finishedWork) {
  var ref = finishedWork.ref;
  if (ref !== null) {
    var instance = finishedWork.stateNode;
    var instanceToUse = void 0;
    switch (finishedWork.tag) {
      case HostComponent:
        instanceToUse = getPublicInstance(instance);
        break;
      default:
        instanceToUse = instance;
    }
    if (typeof ref === 'function') {
      ref(instanceToUse);
    } else {
      {
        if (!ref.hasOwnProperty('current')) {
          warningWithoutStack$1(false, 'Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));
        }
      }

      ref.current = instanceToUse;
    }
  }
}

function commitDetachRef(current$$1) {
  var currentRef = current$$1.ref;
  if (currentRef !== null) {
    if (typeof currentRef === 'function') {
      currentRef(null);
    } else {
      currentRef.current = null;
    }
  }
}

// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current$$1) {
  onCommitUnmount(current$$1);

  switch (current$$1.tag) {
    case ClassComponent:
    case ClassComponentLazy:
      {
        safelyDetachRef(current$$1);
        var instance = current$$1.stateNode;
        if (typeof instance.componentWillUnmount === 'function') {
          safelyCallComponentWillUnmount(current$$1, instance);
        }
        return;
      }
    case HostComponent:
      {
        safelyDetachRef(current$$1);
        return;
      }
    case HostPortal:
      {
        // TODO: this is recursive.
        // We are also not using this parent because
        // the portal will get pushed immediately.
        if (supportsMutation) {
          unmountHostComponents(current$$1);
        } else if (supportsPersistence) {
          emptyPortalContainer(current$$1);
        }
        return;
      }
  }
}

function commitNestedUnmounts(root) {
  // While we're inside a removed host node we don't want to call
  // removeChild on the inner nodes because they're removed by the top
  // call anyway. We also want to call componentWillUnmount on all
  // composites before this host node is removed from the tree. Therefore
  var node = root;
  while (true) {
    commitUnmount(node);
    // Visit children because they may contain more composite or host nodes.
    // Skip portals because commitUnmount() currently visits them recursively.
    if (node.child !== null && (
    // If we use mutation we drill down into portals using commitUnmount above.
    // If we don't use mutation we drill down into portals here instead.
    !supportsMutation || node.tag !== HostPortal)) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === root) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === root) {
        return;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function detachFiber(current$$1) {
  // Cut off the return pointers to disconnect it from the tree. Ideally, we
  // should clear the child pointer of the parent alternate to let this
  // get GC:ed but we don't know which for sure which parent is the current
  // one so we'll settle for GC:ing the subtree of this child. This child
  // itself will be GC:ed when the parent updates the next time.
  current$$1.return = null;
  current$$1.child = null;
  if (current$$1.alternate) {
    current$$1.alternate.child = null;
    current$$1.alternate.return = null;
  }
}

function emptyPortalContainer(current$$1) {
  if (!supportsPersistence) {
    return;
  }

  var portal = current$$1.stateNode;
  var containerInfo = portal.containerInfo;

  var emptyChildSet = createContainerChildSet(containerInfo);
  replaceContainerChildren(containerInfo, emptyChildSet);
}

function commitContainer(finishedWork) {
  if (!supportsPersistence) {
    return;
  }

  switch (finishedWork.tag) {
    case ClassComponent:
    case ClassComponentLazy:
      {
        return;
      }
    case HostComponent:
      {
        return;
      }
    case HostText:
      {
        return;
      }
    case HostRoot:
    case HostPortal:
      {
        var portalOrRoot = finishedWork.stateNode;
        var containerInfo = portalOrRoot.containerInfo,
            _pendingChildren = portalOrRoot.pendingChildren;

        replaceContainerChildren(containerInfo, _pendingChildren);
        return;
      }
    default:
      {
        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
      }
  }
}

function getHostParentFiber(fiber) {
  var parent = fiber.return;
  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }
    parent = parent.return;
  }
  invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
}

function isHostParent(fiber) {
  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
}

function getHostSibling(fiber) {
  // We're going to search forward into the tree until we find a sibling host
  // node. Unfortunately, if multiple insertions are done in a row we have to
  // search past them. This leads to exponential search for the next sibling.
  var node = fiber;
  siblings: while (true) {
    // If we didn't find anything, let's try the next sibling.
    while (node.sibling === null) {
      if (node.return === null || isHostParent(node.return)) {
        // If we pop out of the root or hit the parent the fiber we are the
        // last sibling.
        return null;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
    while (node.tag !== HostComponent && node.tag !== HostText) {
      // If it is not host node and, we might have a host node inside it.
      // Try to search down until we find one.
      if (node.effectTag & Placement) {
        // If we don't have a child, try the siblings instead.
        continue siblings;
      }
      // If we don't have a child, try the siblings instead.
      // We also skip portals because they are not part of this host tree.
      if (node.child === null || node.tag === HostPortal) {
        continue siblings;
      } else {
        node.child.return = node;
        node = node.child;
      }
    }
    // Check if this host node is stable or about to be placed.
    if (!(node.effectTag & Placement)) {
      // Found it!
      return node.stateNode;
    }
  }
}

function commitPlacement(finishedWork) {
  if (!supportsMutation) {
    return;
  }

  // Recursively insert all host nodes into the parent.
  var parentFiber = getHostParentFiber(finishedWork);

  // Note: these two variables *must* always be updated together.
  var parent = void 0;
  var isContainer = void 0;

  switch (parentFiber.tag) {
    case HostComponent:
      parent = parentFiber.stateNode;
      isContainer = false;
      break;
    case HostRoot:
      parent = parentFiber.stateNode.containerInfo;
      isContainer = true;
      break;
    case HostPortal:
      parent = parentFiber.stateNode.containerInfo;
      isContainer = true;
      break;
    default:
      invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
  }
  if (parentFiber.effectTag & ContentReset) {
    // Reset the text content of the parent before doing any insertions
    resetTextContent(parent);
    // Clear ContentReset from the effect tag
    parentFiber.effectTag &= ~ContentReset;
  }

  var before = getHostSibling(finishedWork);
  // We only have the top Fiber that was inserted but we need recurse down its
  // children to find all the terminal nodes.
  var node = finishedWork;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      if (before) {
        if (isContainer) {
          insertInContainerBefore(parent, node.stateNode, before);
        } else {
          insertBefore(parent, node.stateNode, before);
        }
      } else {
        if (isContainer) {
          appendChildToContainer(parent, node.stateNode);
        } else {
          appendChild(parent, node.stateNode);
        }
      }
    } else if (node.tag === HostPortal) {
      // If the insertion itself is a portal, then we don't want to traverse
      // down its children. Instead, we'll get insertions from each child in
      // the portal directly.
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === finishedWork) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === finishedWork) {
        return;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function unmountHostComponents(current$$1) {
  // We only have the top Fiber that was deleted but we need recurse down its
  var node = current$$1;

  // Each iteration, currentParent is populated with node's host parent if not
  // currentParentIsValid.
  var currentParentIsValid = false;

  // Note: these two variables *must* always be updated together.
  var currentParent = void 0;
  var currentParentIsContainer = void 0;

  while (true) {
    if (!currentParentIsValid) {
      var parent = node.return;
      findParent: while (true) {
        !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        switch (parent.tag) {
          case HostComponent:
            currentParent = parent.stateNode;
            currentParentIsContainer = false;
            break findParent;
          case HostRoot:
            currentParent = parent.stateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;
          case HostPortal:
            currentParent = parent.stateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;
        }
        parent = parent.return;
      }
      currentParentIsValid = true;
    }

    if (node.tag === HostComponent || node.tag === HostText) {
      commitNestedUnmounts(node);
      // After all the children have unmounted, it is now safe to remove the
      // node from the tree.
      if (currentParentIsContainer) {
        removeChildFromContainer(currentParent, node.stateNode);
      } else {
        removeChild(currentParent, node.stateNode);
      }
      // Don't visit children because we already visited them.
    } else if (node.tag === HostPortal) {
      // When we go into a portal, it becomes the parent to remove from.
      // We will reassign it back when we pop the portal on the way up.
      currentParent = node.stateNode.containerInfo;
      currentParentIsContainer = true;
      // Visit children because portals might contain host components.
      if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
    } else {
      commitUnmount(node);
      // Visit children because we may find more host components below.
      if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
    }
    if (node === current$$1) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === current$$1) {
        return;
      }
      node = node.return;
      if (node.tag === HostPortal) {
        // When we go out of the portal, we need to restore the parent.
        // Since we don't keep a stack of them, we will search for it.
        currentParentIsValid = false;
      }
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function commitDeletion(current$$1) {
  if (supportsMutation) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(current$$1);
  } else {
    // Detach refs and call componentWillUnmount() on the whole subtree.
    commitNestedUnmounts(current$$1);
  }
  detachFiber(current$$1);
}

function commitWork(current$$1, finishedWork) {
  if (!supportsMutation) {
    commitContainer(finishedWork);
    return;
  }

  switch (finishedWork.tag) {
    case ClassComponent:
    case ClassComponentLazy:
      {
        return;
      }
    case HostComponent:
      {
        var instance = finishedWork.stateNode;
        if (instance != null) {
          // Commit the work prepared earlier.
          var newProps = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;
          var type = finishedWork.type;
          // TODO: Type the updateQueue to be specific to host components.
          var updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
          }
        }
        return;
      }
    case HostText:
      {
        !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        var textInstance = finishedWork.stateNode;
        var newText = finishedWork.memoizedProps;
        // For hydration we reuse the update path but we treat the oldProps
        // as the newProps. The updatePayload will contain the real change in
        // this case.
        var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;
        commitTextUpdate(textInstance, oldText, newText);
        return;
      }
    case HostRoot:
      {
        return;
      }
    case Profiler:
      {
        return;
      }
    case PlaceholderComponent:
      {
        return;
      }
    default:
      {
        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
      }
  }
}

function commitResetTextContent(current$$1) {
  if (!supportsMutation) {
    return;
  }
  resetTextContent(current$$1.stateNode);
}

function NoopComponent() {
  return null;
}

function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
  var update = createUpdate(expirationTime);
  // Unmount the root by rendering null.
  update.tag = CaptureUpdate;
  // Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload = { element: null };
  var error = errorInfo.value;
  update.callback = function () {
    onUncaughtError(error);
    logError(fiber, errorInfo);
  };
  return update;
}

function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
  var update = createUpdate(expirationTime);
  update.tag = CaptureUpdate;
  var getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;
  if (enableGetDerivedStateFromCatch && typeof getDerivedStateFromCatch === 'function') {
    var error = errorInfo.value;
    update.payload = function () {
      return getDerivedStateFromCatch(error);
    };
  }

  var inst = fiber.stateNode;
  if (inst !== null && typeof inst.componentDidCatch === 'function') {
    update.callback = function callback() {
      if (!enableGetDerivedStateFromCatch || getDerivedStateFromCatch !== 'function') {
        // To preserve the preexisting retry behavior of error boundaries,
        // we keep track of which ones already failed during this batch.
        // This gets reset before we yield back to the browser.
        // TODO: Warn in strict mode if getDerivedStateFromCatch is
        // not defined.
        markLegacyErrorBoundaryAsFailed(this);
      }
      var error = errorInfo.value;
      var stack = errorInfo.stack;
      logError(fiber, errorInfo);
      this.componentDidCatch(error, {
        componentStack: stack !== null ? stack : ''
      });
    };
  }
  return update;
}

function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {
  // The source fiber did not complete.
  sourceFiber.effectTag |= Incomplete;
  // Its effect list is no longer valid.
  sourceFiber.firstEffect = sourceFiber.lastEffect = null;

  if (enableSuspense && value !== null && typeof value === 'object' && typeof value.then === 'function') {
    // This is a thenable.
    var thenable = value;

    // Find the earliest timeout threshold of all the placeholders in the
    // ancestor path. We could avoid this traversal by storing the thresholds on
    // the stack, but we choose not to because we only hit this path if we're
    // IO-bound (i.e. if something suspends). Whereas the stack is used even in
    // the non-IO- bound case.
    var _workInProgress = returnFiber;
    var earliestTimeoutMs = -1;
    var startTimeMs = -1;
    do {
      if (_workInProgress.tag === PlaceholderComponent) {
        var current = _workInProgress.alternate;
        if (current !== null && current.memoizedState === true && current.stateNode !== null) {
          // Reached a placeholder that already timed out. Each timed out
          // placeholder acts as the root of a new suspense boundary.

          // Use the time at which the placeholder timed out as the start time
          // for the current render.
          var timedOutAt = current.stateNode.timedOutAt;
          startTimeMs = expirationTimeToMs(timedOutAt);

          // Do not search any further.
          break;
        }
        var timeoutPropMs = _workInProgress.pendingProps.delayMs;
        if (typeof timeoutPropMs === 'number') {
          if (timeoutPropMs <= 0) {
            earliestTimeoutMs = 0;
          } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {
            earliestTimeoutMs = timeoutPropMs;
          }
        }
      }
      _workInProgress = _workInProgress.return;
    } while (_workInProgress !== null);

    // Schedule the nearest Placeholder to re-render the timed out view.
    _workInProgress = returnFiber;
    do {
      if (_workInProgress.tag === PlaceholderComponent) {
        var didTimeout = _workInProgress.memoizedState;
        if (!didTimeout) {
          // Found the nearest boundary.

          // If the boundary is not in async mode, we should not suspend, and
          // likewise, when the promise resolves, we should ping synchronously.
          var pingTime = (_workInProgress.mode & AsyncMode) === NoEffect ? Sync : renderExpirationTime;

          // Attach a listener to the promise to "ping" the root and retry.
          var onResolveOrReject = retrySuspendedRoot.bind(null, root, _workInProgress, pingTime);
          thenable.then(onResolveOrReject, onResolveOrReject);

          // If the boundary is outside of strict mode, we should *not* suspend
          // the commit. Pretend as if the suspended component rendered null and
          // keep rendering. In the commit phase, we'll schedule a subsequent
          // synchronous update to re-render the Placeholder.
          //
          // Note: It doesn't matter whether the component that suspended was
          // inside a strict mode tree. If the Placeholder is outside of it, we
          // should *not* suspend the commit.
          if ((_workInProgress.mode & StrictMode) === NoEffect) {
            _workInProgress.effectTag |= Update;

            // Unmount the source fiber's children
            var nextChildren = null;
            reconcileChildren(sourceFiber.alternate, sourceFiber, nextChildren, renderExpirationTime);
            sourceFiber.effectTag &= ~Incomplete;
            if (sourceFiber.tag === IndeterminateComponent) {
              // Let's just assume it's a functional component. This fiber will
              // be unmounted in the immediate next commit, anyway.
              sourceFiber.tag = FunctionalComponent;
            }

            if (sourceFiber.tag === ClassComponent || sourceFiber.tag === ClassComponentLazy) {
              // We're going to commit this fiber even though it didn't
              // complete. But we shouldn't call any lifecycle methods or
              // callbacks. Remove all lifecycle effect tags.
              sourceFiber.effectTag &= ~LifecycleEffectMask;
              if (sourceFiber.alternate === null) {
                // We're about to mount a class component that doesn't have an
                // instance. Turn this into a dummy functional component instead,
                // to prevent type errors. This is a bit weird but it's an edge
                // case and we're about to synchronously delete this
                // component, anyway.
                sourceFiber.tag = FunctionalComponent;
                sourceFiber.type = NoopComponent;
              }
            }

            // Exit without suspending.
            return;
          }

          // Confirmed that the boundary is in a strict mode tree. Continue with
          // the normal suspend path.

          var absoluteTimeoutMs = void 0;
          if (earliestTimeoutMs === -1) {
            // If no explicit threshold is given, default to an abitrarily large
            // value. The actual size doesn't matter because the threshold for the
            // whole tree will be clamped to the expiration time.
            absoluteTimeoutMs = maxSigned31BitInt;
          } else {
            if (startTimeMs === -1) {
              // This suspend happened outside of any already timed-out
              // placeholders. We don't know exactly when the update was scheduled,
              // but we can infer an approximate start time from the expiration
              // time. First, find the earliest uncommitted expiration time in the
              // tree, including work that is suspended. Then subtract the offset
              // used to compute an async update's expiration time. This will cause
              // high priority (interactive) work to expire earlier than necessary,
              // but we can account for this by adjusting for the Just Noticeable
              // Difference.
              var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);
              var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
              startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
            }
            absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
          }

          // Mark the earliest timeout in the suspended fiber's ancestor path.
          // After completing the root, we'll take the largest of all the
          // suspended fiber's timeouts and use it to compute a timeout for the
          // whole tree.
          renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);

          _workInProgress.effectTag |= ShouldCapture;
          _workInProgress.expirationTime = renderExpirationTime;
          return;
        }
        // This boundary already captured during this render. Continue to the
        // next boundary.
      }
      _workInProgress = _workInProgress.return;
    } while (_workInProgress !== null);
    // No boundary was found. Fallthrough to error mode.
    value = new Error('An update was suspended, but no placeholder UI was provided.');
  }

  // We didn't find a boundary that could handle this type of exception. Start
  // over and traverse parent path again, this time treating the exception
  // as an error.
  renderDidError();
  value = createCapturedValue(value, sourceFiber);
  var workInProgress = returnFiber;
  do {
    switch (workInProgress.tag) {
      case HostRoot:
        {
          var _errorInfo = value;
          workInProgress.effectTag |= ShouldCapture;
          workInProgress.expirationTime = renderExpirationTime;
          var update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);
          enqueueCapturedUpdate(workInProgress, update);
          return;
        }
      case ClassComponent:
      case ClassComponentLazy:
        // Capture and retry
        var errorInfo = value;
        var ctor = workInProgress.type;
        var instance = workInProgress.stateNode;
        if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromCatch === 'function' && enableGetDerivedStateFromCatch || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
          workInProgress.effectTag |= ShouldCapture;
          workInProgress.expirationTime = renderExpirationTime;
          // Schedule the error boundary to re-render using updated state
          var _update = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);
          enqueueCapturedUpdate(workInProgress, _update);
          return;
        }
        break;
      default:
        break;
    }
    workInProgress = workInProgress.return;
  } while (workInProgress !== null);
}

function unwindWork(workInProgress, renderExpirationTime) {
  switch (workInProgress.tag) {
    case ClassComponent:
      {
        var Component = workInProgress.type;
        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }
        var effectTag = workInProgress.effectTag;
        if (effectTag & ShouldCapture) {
          workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;
          return workInProgress;
        }
        return null;
      }
    case ClassComponentLazy:
      {
        var _Component = workInProgress.type._reactResult;
        if (isContextProvider(_Component)) {
          popContext(workInProgress);
        }
        var _effectTag = workInProgress.effectTag;
        if (_effectTag & ShouldCapture) {
          workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;
          return workInProgress;
        }
        return null;
      }
    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        var _effectTag2 = workInProgress.effectTag;
        !((_effectTag2 & DidCapture) === NoEffect) ? invariant(false, 'The root failed to unmount after an error. This is likely a bug in React. Please file an issue.') : void 0;
        workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;
        return workInProgress;
      }
    case HostComponent:
      {
        popHostContext(workInProgress);
        return null;
      }
    case PlaceholderComponent:
      {
        var _effectTag3 = workInProgress.effectTag;
        if (_effectTag3 & ShouldCapture) {
          workInProgress.effectTag = _effectTag3 & ~ShouldCapture | DidCapture;
          return workInProgress;
        }
        return null;
      }
    case HostPortal:
      popHostContainer(workInProgress);
      return null;
    case ContextProvider:
      popProvider(workInProgress);
      return null;
    default:
      return null;
  }
}

function unwindInterruptedWork(interruptedWork) {
  switch (interruptedWork.tag) {
    case ClassComponent:
      {
        var childContextTypes = interruptedWork.type.childContextTypes;
        if (childContextTypes !== null && childContextTypes !== undefined) {
          popContext(interruptedWork);
        }
        break;
      }
    case ClassComponentLazy:
      {
        var _childContextTypes = interruptedWork.type._reactResult.childContextTypes;
        if (_childContextTypes !== null && _childContextTypes !== undefined) {
          popContext(interruptedWork);
        }
        break;
      }
    case HostRoot:
      {
        popHostContainer(interruptedWork);
        popTopLevelContextObject(interruptedWork);
        break;
      }
    case HostComponent:
      {
        popHostContext(interruptedWork);
        break;
      }
    case HostPortal:
      popHostContainer(interruptedWork);
      break;
    case ContextProvider:
      popProvider(interruptedWork);
      break;
    default:
      break;
  }
}

var Dispatcher = {
  readContext: readContext
};

var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;


var didWarnAboutStateTransition = void 0;
var didWarnSetStateChildContext = void 0;
var warnAboutUpdateOnUnmounted = void 0;
var warnAboutInvalidUpdates = void 0;

{
  didWarnAboutStateTransition = false;
  didWarnSetStateChildContext = false;
  var didWarnStateUpdateForUnmountedComponent = {};

  warnAboutUpdateOnUnmounted = function (fiber) {
    // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.
    var componentName = getComponentName(fiber.type) || 'ReactClass';
    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
      return;
    }
    warningWithoutStack$1(false, "Can't call setState (or forceUpdate) on an unmounted component. This " + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in the ' + 'componentWillUnmount method.%s', getStackByFiberInDevAndProd(fiber));
    didWarnStateUpdateForUnmountedComponent[componentName] = true;
  };

  warnAboutInvalidUpdates = function (instance) {
    switch (phase) {
      case 'getChildContext':
        if (didWarnSetStateChildContext) {
          return;
        }
        warningWithoutStack$1(false, 'setState(...): Cannot call setState() inside getChildContext()');
        didWarnSetStateChildContext = true;
        break;
      case 'render':
        if (didWarnAboutStateTransition) {
          return;
        }
        warningWithoutStack$1(false, 'Cannot update during an existing state transition (such as within ' + '`render`). Render methods should be a pure function of props and state.');
        didWarnAboutStateTransition = true;
        break;
    }
  };
}

// Used to ensure computeUniqueAsyncExpiration is monotonically increasing.
var lastUniqueAsyncExpiration = 0;

// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
var expirationContext = NoWork;

var isWorking = false;

// The next work in progress fiber that we're currently working on.
var nextUnitOfWork = null;
var nextRoot = null;
// The time at which we're currently rendering work.
var nextRenderExpirationTime = NoWork;
var nextLatestAbsoluteTimeoutMs = -1;
var nextRenderDidError = false;

// The next fiber with an effect that we're currently committing.
var nextEffect = null;

var isCommitting$1 = false;

var legacyErrorBoundariesThatAlreadyFailed = null;

// Used for performance tracking.
var interruptedBy = null;

// Do not decrement interaction counts in the event of suspense timeouts.
// This would lead to prematurely calling the interaction-complete hook.
var suspenseDidTimeout = false;

var stashedWorkInProgressProperties = void 0;
var replayUnitOfWork = void 0;
var isReplayingFailedUnitOfWork = void 0;
var originalReplayError = void 0;
var rethrowOriginalError = void 0;
if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
  stashedWorkInProgressProperties = null;
  isReplayingFailedUnitOfWork = false;
  originalReplayError = null;
  replayUnitOfWork = function (failedUnitOfWork, thrownValue, isYieldy) {
    if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {
      // Don't replay promises. Treat everything else like an error.
      // TODO: Need to figure out a different strategy if/when we add
      // support for catching other types.
      return;
    }

    // Restore the original state of the work-in-progress
    if (stashedWorkInProgressProperties === null) {
      // This should never happen. Don't throw because this code is DEV-only.
      warningWithoutStack$1(false, 'Could not replay rendering after an error. This is likely a bug in React. ' + 'Please file an issue.');
      return;
    }
    assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);

    switch (failedUnitOfWork.tag) {
      case HostRoot:
        popHostContainer(failedUnitOfWork);
        popTopLevelContextObject(failedUnitOfWork);
        break;
      case HostComponent:
        popHostContext(failedUnitOfWork);
        break;
      case ClassComponent:
        {
          var Component = failedUnitOfWork.type;
          if (isContextProvider(Component)) {
            popContext(failedUnitOfWork);
          }
          break;
        }
      case ClassComponentLazy:
        {
          var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);
          if (isContextProvider(_Component)) {
            popContext(failedUnitOfWork);
          }
          break;
        }
      case HostPortal:
        popHostContainer(failedUnitOfWork);
        break;
      case ContextProvider:
        popProvider(failedUnitOfWork);
        break;
    }
    // Replay the begin phase.
    isReplayingFailedUnitOfWork = true;
    originalReplayError = thrownValue;
    invokeGuardedCallback(null, workLoop, null, isYieldy);
    isReplayingFailedUnitOfWork = false;
    originalReplayError = null;
    if (hasCaughtError()) {
      var replayError = clearCaughtError();
      if (replayError != null && thrownValue != null) {
        try {
          // Reading the expando property is intentionally
          // inside `try` because it might be a getter or Proxy.
          if (replayError._suppressLogging) {
            // Also suppress logging for the original error.
            thrownValue._suppressLogging = true;
          }
        } catch (inner) {
          // Ignore.
        }
      }
    } else {
      // If the begin phase did not fail the second time, set this pointer
      // back to the original value.
      nextUnitOfWork = failedUnitOfWork;
    }
  };
  rethrowOriginalError = function () {
    throw originalReplayError;
  };
}

function resetStack() {
  if (nextUnitOfWork !== null) {
    var interruptedWork = nextUnitOfWork.return;
    while (interruptedWork !== null) {
      unwindInterruptedWork(interruptedWork);
      interruptedWork = interruptedWork.return;
    }
  }

  {
    ReactStrictModeWarnings.discardPendingWarnings();
    checkThatStackIsEmpty();
  }

  nextRoot = null;
  nextRenderExpirationTime = NoWork;
  nextLatestAbsoluteTimeoutMs = -1;
  nextRenderDidError = false;
  nextUnitOfWork = null;
}

function commitAllHostEffects() {
  while (nextEffect !== null) {
    {
      setCurrentFiber(nextEffect);
    }
    recordEffect();

    var effectTag = nextEffect.effectTag;

    if (effectTag & ContentReset) {
      commitResetTextContent(nextEffect);
    }

    if (effectTag & Ref) {
      var current$$1 = nextEffect.alternate;
      if (current$$1 !== null) {
        commitDetachRef(current$$1);
      }
    }

    // The following switch statement is only concerned about placement,
    // updates, and deletions. To avoid needing to add a case for every
    // possible bitmap value, we remove the secondary effects from the
    // effect tag and switch on that value.
    var primaryEffectTag = effectTag & (Placement | Update | Deletion);
    switch (primaryEffectTag) {
      case Placement:
        {
          commitPlacement(nextEffect);
          // Clear the "placement" from effect tag so that we know that this is inserted, before
          // any life-cycles like componentDidMount gets called.
          // TODO: findDOMNode doesn't rely on this any more but isMounted
          // does and isMounted is deprecated anyway so we should be able
          // to kill this.
          nextEffect.effectTag &= ~Placement;
          break;
        }
      case PlacementAndUpdate:
        {
          // Placement
          commitPlacement(nextEffect);
          // Clear the "placement" from effect tag so that we know that this is inserted, before
          // any life-cycles like componentDidMount gets called.
          nextEffect.effectTag &= ~Placement;

          // Update
          var _current = nextEffect.alternate;
          commitWork(_current, nextEffect);
          break;
        }
      case Update:
        {
          var _current2 = nextEffect.alternate;
          commitWork(_current2, nextEffect);
          break;
        }
      case Deletion:
        {
          commitDeletion(nextEffect);
          break;
        }
    }
    nextEffect = nextEffect.nextEffect;
  }

  {
    resetCurrentFiber();
  }
}

function commitBeforeMutationLifecycles() {
  while (nextEffect !== null) {
    {
      setCurrentFiber(nextEffect);
    }

    var effectTag = nextEffect.effectTag;
    if (effectTag & Snapshot) {
      recordEffect();
      var current$$1 = nextEffect.alternate;
      commitBeforeMutationLifeCycles(current$$1, nextEffect);
    }

    // Don't cleanup effects yet;
    // This will be done by commitAllLifeCycles()
    nextEffect = nextEffect.nextEffect;
  }

  {
    resetCurrentFiber();
  }
}

function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
  {
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();

    if (warnAboutDeprecatedLifecycles) {
      ReactStrictModeWarnings.flushPendingDeprecationWarnings();
    }

    if (warnAboutLegacyContextAPI) {
      ReactStrictModeWarnings.flushLegacyContextWarning();
    }
  }
  while (nextEffect !== null) {
    var effectTag = nextEffect.effectTag;

    if (effectTag & (Update | Callback)) {
      recordEffect();
      var current$$1 = nextEffect.alternate;
      commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);
    }

    if (effectTag & Ref) {
      recordEffect();
      commitAttachRef(nextEffect);
    }

    var next = nextEffect.nextEffect;
    // Ensure that we clean these up so that we don't accidentally keep them.
    // I'm not actually sure this matters because we can't reset firstEffect
    // and lastEffect since they're on every node, not just the effectful
    // ones. So we have to clean everything as we reuse nodes anyway.
    nextEffect.nextEffect = null;
    // Ensure that we reset the effectTag here so that we can rely on effect
    // tags to reason about the current life-cycle.
    nextEffect = next;
  }
}

function isAlreadyFailedLegacyErrorBoundary(instance) {
  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
}

function markLegacyErrorBoundaryAsFailed(instance) {
  if (legacyErrorBoundariesThatAlreadyFailed === null) {
    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
  } else {
    legacyErrorBoundariesThatAlreadyFailed.add(instance);
  }
}

function commitRoot(root, finishedWork) {
  isWorking = true;
  isCommitting$1 = true;
  startCommitTimer();

  !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var committedExpirationTime = root.pendingCommitExpirationTime;
  !(committedExpirationTime !== NoWork) ? invariant(false, 'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  root.pendingCommitExpirationTime = NoWork;

  // Update the pending priority levels to account for the work that we are
  // about to commit. This needs to happen before calling the lifecycles, since
  // they may schedule additional updates.
  var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
  var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
  var earliestRemainingTimeBeforeCommit = updateExpirationTimeBeforeCommit === NoWork || childExpirationTimeBeforeCommit !== NoWork && childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;
  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);

  var prevInteractions = null;
  var committedInteractions = enableSchedulerTracking ? [] : null;
  if (enableSchedulerTracking) {
    // Restore any pending interactions at this point,
    // So that cascading work triggered during the render phase will be accounted for.
    prevInteractions = tracking.__interactionsRef.current;
    tracking.__interactionsRef.current = root.memoizedInteractions;

    // We are potentially finished with the current batch of interactions.
    // So we should clear them out of the pending interaction map.
    // We do this at the start of commit in case cascading work is scheduled by commit phase lifecycles.
    // In that event, interaction data may be added back into the pending map for a future commit.
    // We also store the interactions we are about to commit so that we can notify subscribers after we're done.
    // These are stored as an Array rather than a Set,
    // Because the same interaction may be pending for multiple expiration times,
    // In which case it's important that we decrement the count the right number of times after finishing.
    root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
      if (scheduledExpirationTime <= committedExpirationTime) {
        committedInteractions.push.apply(committedInteractions, Array.from(scheduledInteractions));
        root.pendingInteractionMap.delete(scheduledExpirationTime);
      }
    });
  }

  // Reset this to null before calling lifecycles
  ReactCurrentOwner$2.current = null;

  var firstEffect = void 0;
  if (finishedWork.effectTag > PerformedWork) {
    // A fiber's effect list consists only of its children, not itself. So if
    // the root has an effect, we need to add it to the end of the list. The
    // resulting list is the set that would belong to the root's parent, if
    // it had one; that is, all the effects in the tree including the root.
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // There is no effect on the root.
    firstEffect = finishedWork.firstEffect;
  }

  prepareForCommit(root.containerInfo);

  // Invoke instances of getSnapshotBeforeUpdate before mutation.
  nextEffect = firstEffect;
  startCommitSnapshotEffectsTimer();
  while (nextEffect !== null) {
    var didError = false;
    var error = void 0;
    {
      invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);
      if (hasCaughtError()) {
        didError = true;
        error = clearCaughtError();
      }
    }
    if (didError) {
      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      captureCommitPhaseError(nextEffect, error);
      // Clean-up
      if (nextEffect !== null) {
        nextEffect = nextEffect.nextEffect;
      }
    }
  }
  stopCommitSnapshotEffectsTimer();

  if (enableProfilerTimer) {
    // Mark the current commit time to be shared by all Profilers in this batch.
    // This enables them to be grouped later.
    recordCommitTime();
  }

  // Commit all the side-effects within a tree. We'll do this in two passes.
  // The first pass performs all the host insertions, updates, deletions and
  // ref unmounts.
  nextEffect = firstEffect;
  startCommitHostEffectsTimer();
  while (nextEffect !== null) {
    var _didError = false;
    var _error = void 0;
    {
      invokeGuardedCallback(null, commitAllHostEffects, null);
      if (hasCaughtError()) {
        _didError = true;
        _error = clearCaughtError();
      }
    }
    if (_didError) {
      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      captureCommitPhaseError(nextEffect, _error);
      // Clean-up
      if (nextEffect !== null) {
        nextEffect = nextEffect.nextEffect;
      }
    }
  }
  stopCommitHostEffectsTimer();

  resetAfterCommit(root.containerInfo);

  // The work-in-progress tree is now the current tree. This must come after
  // the first pass of the commit phase, so that the previous tree is still
  // current during componentWillUnmount, but before the second pass, so that
  // the finished work is current during componentDidMount/Update.
  root.current = finishedWork;

  // In the second pass we'll perform all life-cycles and ref callbacks.
  // Life-cycles happen as a separate pass so that all placements, updates,
  // and deletions in the entire tree have already been invoked.
  // This pass also triggers any renderer-specific initial effects.
  nextEffect = firstEffect;
  startCommitLifeCyclesTimer();
  while (nextEffect !== null) {
    var _didError2 = false;
    var _error2 = void 0;
    {
      invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);
      if (hasCaughtError()) {
        _didError2 = true;
        _error2 = clearCaughtError();
      }
    }
    if (_didError2) {
      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      captureCommitPhaseError(nextEffect, _error2);
      if (nextEffect !== null) {
        nextEffect = nextEffect.nextEffect;
      }
    }
  }

  isCommitting$1 = false;
  isWorking = false;
  stopCommitLifeCyclesTimer();
  stopCommitTimer();
  onCommitRoot(finishedWork.stateNode);
  if (true && ReactFiberInstrumentation_1.debugTool) {
    ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
  }

  var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
  var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
  var earliestRemainingTimeAfterCommit = updateExpirationTimeAfterCommit === NoWork || childExpirationTimeAfterCommit !== NoWork && childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;
  if (earliestRemainingTimeAfterCommit === NoWork) {
    // If there's no remaining work, we can clear the set of already failed
    // error boundaries.
    legacyErrorBoundariesThatAlreadyFailed = null;
  }
  onCommit(root, earliestRemainingTimeAfterCommit);

  if (enableSchedulerTracking) {
    tracking.__interactionsRef.current = prevInteractions;

    var subscriber = void 0;

    try {
      subscriber = tracking.__subscriberRef.current;
      if (subscriber !== null && root.memoizedInteractions.size > 0) {
        var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);
        subscriber.onWorkStopped(root.memoizedInteractions, threadID);
      }
    } catch (error) {
      // It's not safe for commitRoot() to throw.
      // Store the error for now and we'll re-throw in finishRendering().
      if (!hasUnhandledError) {
        hasUnhandledError = true;
        unhandledError = error;
      }
    } finally {
      // Don't update interaction counts if we're frozen due to suspense.
      // In this case, we can skip the completed-work check entirely.
      if (!suspenseDidTimeout) {
        // Now that we're done, check the completed batch of interactions.
        // If no more work is outstanding for a given interaction,
        // We need to notify the subscribers that it's finished.
        committedInteractions.forEach(function (interaction) {
          interaction.__count--;
          if (subscriber !== null && interaction.__count === 0) {
            try {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            } catch (error) {
              // It's not safe for commitRoot() to throw.
              // Store the error for now and we'll re-throw in finishRendering().
              if (!hasUnhandledError) {
                hasUnhandledError = true;
                unhandledError = error;
              }
            }
          }
        });
      }
    }
  }
}

function resetChildExpirationTime(workInProgress, renderTime) {
  if (renderTime !== Never && workInProgress.childExpirationTime === Never) {
    // The children of this component are hidden. Don't bubble their
    // expiration times.
    return;
  }

  var newChildExpirationTime = NoWork;

  // Bubble up the earliest expiration time.
  if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
    // We're in profiling mode.
    // Let's use this same traversal to update the render durations.
    var actualDuration = workInProgress.actualDuration;
    var treeBaseDuration = workInProgress.selfBaseDuration;

    // When a fiber is cloned, its actualDuration is reset to 0.
    // This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).
    // When work is done, it should bubble to the parent's actualDuration.
    // If the fiber has not been cloned though, (meaning no work was done),
    // Then this value will reflect the amount of time spent working on a previous render.
    // In that case it should not bubble.
    // We determine whether it was cloned by comparing the child pointer.
    var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;

    var child = workInProgress.child;
    while (child !== null) {
      var childUpdateExpirationTime = child.expirationTime;
      var childChildExpirationTime = child.childExpirationTime;
      if (newChildExpirationTime === NoWork || childUpdateExpirationTime !== NoWork && childUpdateExpirationTime < newChildExpirationTime) {
        newChildExpirationTime = childUpdateExpirationTime;
      }
      if (newChildExpirationTime === NoWork || childChildExpirationTime !== NoWork && childChildExpirationTime < newChildExpirationTime) {
        newChildExpirationTime = childChildExpirationTime;
      }
      if (shouldBubbleActualDurations) {
        actualDuration += child.actualDuration;
      }
      treeBaseDuration += child.treeBaseDuration;
      child = child.sibling;
    }
    workInProgress.actualDuration = actualDuration;
    workInProgress.treeBaseDuration = treeBaseDuration;
  } else {
    var _child = workInProgress.child;
    while (_child !== null) {
      var _childUpdateExpirationTime = _child.expirationTime;
      var _childChildExpirationTime = _child.childExpirationTime;
      if (newChildExpirationTime === NoWork || _childUpdateExpirationTime !== NoWork && _childUpdateExpirationTime < newChildExpirationTime) {
        newChildExpirationTime = _childUpdateExpirationTime;
      }
      if (newChildExpirationTime === NoWork || _childChildExpirationTime !== NoWork && _childChildExpirationTime < newChildExpirationTime) {
        newChildExpirationTime = _childChildExpirationTime;
      }
      _child = _child.sibling;
    }
  }

  workInProgress.childExpirationTime = newChildExpirationTime;
}

function completeUnitOfWork(workInProgress) {
  // Attempt to complete the current unit of work, then move to the
  // next sibling. If there are no more siblings, return to the
  // parent fiber.
  while (true) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current$$1 = workInProgress.alternate;
    {
      setCurrentFiber(workInProgress);
    }

    var returnFiber = workInProgress.return;
    var siblingFiber = workInProgress.sibling;

    if ((workInProgress.effectTag & Incomplete) === NoEffect) {
      // This fiber completed.
      if (enableProfilerTimer) {
        if (workInProgress.mode & ProfileMode) {
          startProfilerTimer(workInProgress);
        }

        nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);

        if (workInProgress.mode & ProfileMode) {
          // Update render duration assuming we didn't error.
          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
        }
      } else {
        nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);
      }
      var next = nextUnitOfWork;
      stopWorkTimer(workInProgress);
      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
      {
        resetCurrentFiber();
      }

      if (next !== null) {
        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        return next;
      }

      if (returnFiber !== null &&
      // Do not append effects to parents if a sibling failed to complete
      (returnFiber.effectTag & Incomplete) === NoEffect) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }

        // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if
        // needed, by doing multiple passes over the effect list. We don't want
        // to schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.
        var effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }

      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        return null;
      }
    } else {
      if (workInProgress.mode & ProfileMode) {
        // Record the render duration for the fiber that errored.
        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
      }

      // This fiber did not complete because something threw. Pop values off
      // the stack without entering the complete phase. If this is a boundary,
      // capture values if possible.
      var _next = unwindWork(workInProgress, nextRenderExpirationTime);
      // Because this fiber did not complete, don't reset its expiration time.
      if (workInProgress.effectTag & DidCapture) {
        // Restarting an error boundary
        stopFailedWorkTimer(workInProgress);
      } else {
        stopWorkTimer(workInProgress);
      }

      {
        resetCurrentFiber();
      }

      if (_next !== null) {
        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }

        if (enableProfilerTimer) {
          // Include the time spent working on failed children before continuing.
          if (_next.mode & ProfileMode) {
            var actualDuration = _next.actualDuration;
            var child = _next.child;
            while (child !== null) {
              actualDuration += child.actualDuration;
              child = child.sibling;
            }
            _next.actualDuration = actualDuration;
          }
        }

        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        // Since we're restarting, remove anything that is not a host effect
        // from the effect tag.
        _next.effectTag &= HostEffectMask;
        return _next;
      }

      if (returnFiber !== null) {
        // Mark the parent fiber as incomplete and clear its effect list.
        returnFiber.firstEffect = returnFiber.lastEffect = null;
        returnFiber.effectTag |= Incomplete;
      }

      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        return null;
      }
    }
  }

  // Without this explicit null return Flow complains of invalid return type
  // TODO Remove the above while(true) loop
  // eslint-disable-next-line no-unreachable
  return null;
}

function performUnitOfWork(workInProgress) {
  // The current, flushed, state of this fiber is the alternate.
  // Ideally nothing should rely on this, but relying on it here
  // means that we don't need an additional field on the work in
  // progress.
  var current$$1 = workInProgress.alternate;

  // See if beginning this work spawns more work.
  startWorkTimer(workInProgress);
  {
    setCurrentFiber(workInProgress);
  }

  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
    stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);
  }

  var next = void 0;
  if (enableProfilerTimer) {
    if (workInProgress.mode & ProfileMode) {
      startProfilerTimer(workInProgress);
    }

    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);

    if (workInProgress.mode & ProfileMode) {
      // Record the render duration assuming we didn't bailout (or error).
      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
    }
  } else {
    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
  }

  {
    resetCurrentFiber();
    if (isReplayingFailedUnitOfWork) {
      // Currently replaying a failed unit of work. This should be unreachable,
      // because the render phase is meant to be idempotent, and it should
      // have thrown again. Since it didn't, rethrow the original error, so
      // React's internal stack is not misaligned.
      rethrowOriginalError();
    }
  }
  if (true && ReactFiberInstrumentation_1.debugTool) {
    ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
  }

  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    next = completeUnitOfWork(workInProgress);
  }

  ReactCurrentOwner$2.current = null;

  return next;
}

function workLoop(isYieldy) {
  if (!isYieldy) {
    // Flush work without yielding
    while (nextUnitOfWork !== null) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  } else {
    // Flush asynchronous work until the deadline runs out of time.
    while (nextUnitOfWork !== null && !shouldYield()) {
      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    }
  }
}

function renderRoot(root, isYieldy, isExpired) {
  !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  isWorking = true;
  ReactCurrentOwner$2.currentDispatcher = Dispatcher;

  var expirationTime = root.nextExpirationTimeToWorkOn;

  var prevInteractions = null;
  if (enableSchedulerTracking) {
    // We're about to start new tracked work.
    // Restore pending interactions so cascading work triggered during the render phase will be accounted for.
    prevInteractions = tracking.__interactionsRef.current;
    tracking.__interactionsRef.current = root.memoizedInteractions;
  }

  // Check if we're starting from a fresh stack, or if we're resuming from
  // previously yielded work.
  if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {
    // Reset the stack and start working from the root.
    resetStack();
    nextRoot = root;
    nextRenderExpirationTime = expirationTime;
    nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);
    root.pendingCommitExpirationTime = NoWork;

    if (enableSchedulerTracking) {
      // Determine which interactions this batch of work currently includes,
      // So that we can accurately attribute time spent working on it,
      var interactions = new Set();
      root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
        if (scheduledExpirationTime <= expirationTime) {
          scheduledInteractions.forEach(function (interaction) {
            return interactions.add(interaction);
          });
        }
      });

      // Store the current set of interactions on the FiberRoot for a few reasons:
      // We can re-use it in hot functions like renderRoot() without having to recalculate it.
      // We will also use it in commitWork() to pass to any Profiler onRender() hooks.
      // This also provides DevTools with a way to access it when the onCommitRoot() hook is called.
      root.memoizedInteractions = interactions;

      if (interactions.size > 0) {
        var subscriber = tracking.__subscriberRef.current;
        if (subscriber !== null) {
          var threadID = computeThreadID(expirationTime, root.interactionThreadID);
          try {
            subscriber.onWorkStarted(interactions, threadID);
          } catch (error) {
            // Work thrown by an interaction tracking subscriber should be rethrown,
            // But only once it's safe (to avoid leaveing the scheduler in an invalid state).
            // Store the error for now and we'll re-throw in finishRendering().
            if (!hasUnhandledError) {
              hasUnhandledError = true;
              unhandledError = error;
            }
          }
        }
      }
    }
  }

  var didFatal = false;

  startWorkLoopTimer(nextUnitOfWork);

  do {
    try {
      workLoop(isYieldy);
    } catch (thrownValue) {
      if (nextUnitOfWork === null) {
        // This is a fatal error.
        didFatal = true;
        onUncaughtError(thrownValue);
      } else {
        {
          // Reset global debug state
          // We assume this is defined in DEV
          resetCurrentlyProcessingQueue();
        }

        var failedUnitOfWork = nextUnitOfWork;
        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
          replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
        }

        // TODO: we already know this isn't true in some cases.
        // At least this shows a nicer error message until we figure out the cause.
        // https://github.com/facebook/react/issues/12449#issuecomment-386727431
        !(nextUnitOfWork !== null) ? invariant(false, 'Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.') : void 0;

        var sourceFiber = nextUnitOfWork;
        var returnFiber = sourceFiber.return;
        if (returnFiber === null) {
          // This is the root. The root could capture its own errors. However,
          // we don't know if it errors before or after we pushed the host
          // context. This information is needed to avoid a stack mismatch.
          // Because we're not sure, treat this as a fatal error. We could track
          // which phase it fails in, but doesn't seem worth it. At least
          // for now.
          didFatal = true;
          onUncaughtError(thrownValue);
        } else {
          throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);
          nextUnitOfWork = completeUnitOfWork(sourceFiber);
          continue;
        }
      }
    }
    break;
  } while (true);

  if (enableSchedulerTracking) {
    // Tracked work is done for now; restore the previous interactions.
    tracking.__interactionsRef.current = prevInteractions;
  }

  // We're done performing work. Time to clean up.
  isWorking = false;
  ReactCurrentOwner$2.currentDispatcher = null;
  resetContextDependences();

  // Yield back to main thread.
  if (didFatal) {
    var _didCompleteRoot = false;
    stopWorkLoopTimer(interruptedBy, _didCompleteRoot);
    interruptedBy = null;
    // There was a fatal error.
    {
      resetStackAfterFatalErrorInDev();
    }
    // `nextRoot` points to the in-progress root. A non-null value indicates
    // that we're in the middle of an async render. Set it to null to indicate
    // there's no more work to be done in the current batch.
    nextRoot = null;
    onFatal(root);
    return;
  }

  if (nextUnitOfWork !== null) {
    // There's still remaining async work in this tree, but we ran out of time
    // in the current frame. Yield back to the renderer. Unless we're
    // interrupted by a higher priority update, we'll continue later from where
    // we left off.
    var _didCompleteRoot2 = false;
    stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);
    interruptedBy = null;
    onYield(root);
    return;
  }

  // We completed the whole tree.
  var didCompleteRoot = true;
  stopWorkLoopTimer(interruptedBy, didCompleteRoot);
  var rootWorkInProgress = root.current.alternate;
  !(rootWorkInProgress !== null) ? invariant(false, 'Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  // `nextRoot` points to the in-progress root. A non-null value indicates
  // that we're in the middle of an async render. Set it to null to indicate
  // there's no more work to be done in the current batch.
  nextRoot = null;
  interruptedBy = null;

  if (nextRenderDidError) {
    // There was an error
    if (hasLowerPriorityWork(root, expirationTime)) {
      // There's lower priority work. If so, it may have the effect of fixing
      // the exception that was just thrown. Exit without committing. This is
      // similar to a suspend, but without a timeout because we're not waiting
      // for a promise to resolve. React will restart at the lower
      // priority level.
      markSuspendedPriorityLevel(root, expirationTime);
      var suspendedExpirationTime = expirationTime;
      var rootExpirationTime = root.expirationTime;
      onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1 // Indicates no timeout
      );
      return;
    } else if (
    // There's no lower priority work, but we're rendering asynchronously.
    // Synchronsouly attempt to render the same level one more time. This is
    // similar to a suspend, but without a timeout because we're not waiting
    // for a promise to resolve.
    !root.didError && !isExpired) {
      root.didError = true;
      var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;
      var _rootExpirationTime = root.expirationTime = Sync;
      onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1 // Indicates no timeout
      );
      return;
    }
  }

  if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {
    // The tree was suspended.
    var _suspendedExpirationTime2 = expirationTime;
    markSuspendedPriorityLevel(root, _suspendedExpirationTime2);

    // Find the earliest uncommitted expiration time in the tree, including
    // work that is suspended. The timeout threshold cannot be longer than
    // the overall expiration.
    var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);
    var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
    if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
      nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
    }

    // Subtract the current time from the absolute timeout to get the number
    // of milliseconds until the timeout. In other words, convert an absolute
    // timestamp to a relative time. This is the value that is passed
    // to `setTimeout`.
    var currentTimeMs = expirationTimeToMs(requestCurrentTime());
    var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
    msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;

    // TODO: Account for the Just Noticeable Difference

    var _rootExpirationTime2 = root.expirationTime;
    onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);
    return;
  }

  // Ready to commit.
  onComplete(root, rootWorkInProgress, expirationTime);
}

function dispatch(sourceFiber, value, expirationTime) {
  !(!isWorking || isCommitting$1) ? invariant(false, 'dispatch: Cannot dispatch during the render phase.') : void 0;

  var fiber = sourceFiber.return;
  while (fiber !== null) {
    switch (fiber.tag) {
      case ClassComponent:
      case ClassComponentLazy:
        var ctor = fiber.type;
        var instance = fiber.stateNode;
        if (typeof ctor.getDerivedStateFromCatch === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
          var errorInfo = createCapturedValue(value, sourceFiber);
          var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);
          enqueueUpdate(fiber, update);
          scheduleWork(fiber, expirationTime);
          return;
        }
        break;
      case HostRoot:
        {
          var _errorInfo = createCapturedValue(value, sourceFiber);
          var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);
          enqueueUpdate(fiber, _update);
          scheduleWork(fiber, expirationTime);
          return;
        }
    }
    fiber = fiber.return;
  }

  if (sourceFiber.tag === HostRoot) {
    // Error was thrown at the root. There is no parent, so the root
    // itself should capture it.
    var rootFiber = sourceFiber;
    var _errorInfo2 = createCapturedValue(value, rootFiber);
    var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);
    enqueueUpdate(rootFiber, _update2);
    scheduleWork(rootFiber, expirationTime);
  }
}

function captureCommitPhaseError(fiber, error) {
  return dispatch(fiber, error, Sync);
}

function computeThreadID(expirationTime, interactionThreadID) {
  // Interaction threads are unique per root and expiration time.
  return expirationTime * 1000 + interactionThreadID;
}

// Creates a unique async expiration time.
function computeUniqueAsyncExpiration() {
  var currentTime = requestCurrentTime();
  var result = computeAsyncExpiration(currentTime);
  if (result <= lastUniqueAsyncExpiration) {
    // Since we assume the current time monotonically increases, we only hit
    // this branch when computeUniqueAsyncExpiration is fired multiple times
    // within a 200ms window (or whatever the async bucket size is).
    result = lastUniqueAsyncExpiration + 1;
  }
  lastUniqueAsyncExpiration = result;
  return lastUniqueAsyncExpiration;
}

function computeExpirationForFiber(currentTime, fiber) {
  var expirationTime = void 0;
  if (expirationContext !== NoWork) {
    // An explicit expiration context was set;
    expirationTime = expirationContext;
  } else if (isWorking) {
    if (isCommitting$1) {
      // Updates that occur during the commit phase should have sync priority
      // by default.
      expirationTime = Sync;
    } else {
      // Updates during the render phase should expire at the same time as
      // the work that is being rendered.
      expirationTime = nextRenderExpirationTime;
    }
  } else {
    // No explicit expiration context was set, and we're not currently
    // performing work. Calculate a new expiration time.
    if (fiber.mode & AsyncMode) {
      if (isBatchingInteractiveUpdates) {
        // This is an interactive update
        expirationTime = computeInteractiveExpiration(currentTime);
      } else {
        // This is an async update
        expirationTime = computeAsyncExpiration(currentTime);
      }
      // If we're in the middle of rendering a tree, do not update at the same
      // expiration time that is already rendering.
      if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
        expirationTime += 1;
      }
    } else {
      // This is a sync update
      expirationTime = Sync;
    }
  }
  if (isBatchingInteractiveUpdates) {
    // This is an interactive update. Keep track of the lowest pending
    // interactive expiration time. This allows us to synchronously flush
    // all interactive updates when needed.
    if (lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime > lowestPriorityPendingInteractiveExpirationTime) {
      lowestPriorityPendingInteractiveExpirationTime = expirationTime;
    }
  }
  return expirationTime;
}

function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {
  // Schedule the timeout.
  if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {
    nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;
  }
}

function renderDidError() {
  nextRenderDidError = true;
}

function retrySuspendedRoot(root, fiber, suspendedTime) {
  if (enableSuspense) {
    var retryTime = void 0;

    if (isPriorityLevelSuspended(root, suspendedTime)) {
      // Ping at the original level
      retryTime = suspendedTime;
      markPingedPriorityLevel(root, retryTime);
    } else {
      // Placeholder already timed out. Compute a new expiration time
      var currentTime = requestCurrentTime();
      retryTime = computeExpirationForFiber(currentTime, fiber);
      markPendingPriorityLevel(root, retryTime);
    }

    scheduleWorkToRoot(fiber, retryTime);
    var rootExpirationTime = root.expirationTime;
    if (rootExpirationTime !== NoWork) {
      if (enableSchedulerTracking) {
        // Restore previous interactions so that new work is associated with them.
        var prevInteractions = tracking.__interactionsRef.current;
        tracking.__interactionsRef.current = root.memoizedInteractions;
        // Because suspense timeouts do not decrement the interaction count,
        // Continued suspense work should also not increment the count.
        storeInteractionsForExpirationTime(root, rootExpirationTime, false);
        requestWork(root, rootExpirationTime);
        tracking.__interactionsRef.current = prevInteractions;
      } else {
        requestWork(root, rootExpirationTime);
      }
    }
  }
}

function scheduleWorkToRoot(fiber, expirationTime) {
  // Update the source fiber's expiration time
  if (fiber.expirationTime === NoWork || fiber.expirationTime > expirationTime) {
    fiber.expirationTime = expirationTime;
  }
  var alternate = fiber.alternate;
  if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > expirationTime)) {
    alternate.expirationTime = expirationTime;
  }
  // Walk the parent path to the root and update the child expiration time.
  var node = fiber.return;
  if (node === null && fiber.tag === HostRoot) {
    return fiber.stateNode;
  }
  while (node !== null) {
    alternate = node.alternate;
    if (node.childExpirationTime === NoWork || node.childExpirationTime > expirationTime) {
      node.childExpirationTime = expirationTime;
      if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {
        alternate.childExpirationTime = expirationTime;
      }
    } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {
      alternate.childExpirationTime = expirationTime;
    }
    if (node.return === null && node.tag === HostRoot) {
      return node.stateNode;
    }
    node = node.return;
  }
  return null;
}

function storeInteractionsForExpirationTime(root, expirationTime, updateInteractionCounts) {
  if (!enableSchedulerTracking) {
    return;
  }

  var interactions = tracking.__interactionsRef.current;
  if (interactions.size > 0) {
    var pendingInteractions = root.pendingInteractionMap.get(expirationTime);
    if (pendingInteractions != null) {
      interactions.forEach(function (interaction) {
        if (updateInteractionCounts && !pendingInteractions.has(interaction)) {
          // Update the pending async work count for previously unscheduled interaction.
          interaction.__count++;
        }

        pendingInteractions.add(interaction);
      });
    } else {
      root.pendingInteractionMap.set(expirationTime, new Set(interactions));

      // Update the pending async work count for the current interactions.
      if (updateInteractionCounts) {
        interactions.forEach(function (interaction) {
          interaction.__count++;
        });
      }
    }

    var subscriber = tracking.__subscriberRef.current;
    if (subscriber !== null) {
      var threadID = computeThreadID(expirationTime, root.interactionThreadID);
      subscriber.onWorkScheduled(interactions, threadID);
    }
  }
}

function scheduleWork(fiber, expirationTime) {
  recordScheduleUpdate();

  {
    if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {
      var instance = fiber.stateNode;
      warnAboutInvalidUpdates(instance);
    }
  }

  var root = scheduleWorkToRoot(fiber, expirationTime);
  if (root === null) {
    if (true && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)) {
      warnAboutUpdateOnUnmounted(fiber);
    }
    return;
  }

  if (enableSchedulerTracking) {
    storeInteractionsForExpirationTime(root, expirationTime, true);
  }

  if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime < nextRenderExpirationTime) {
    // This is an interruption. (Used for performance tracking.)
    interruptedBy = fiber;
    resetStack();
  }
  markPendingPriorityLevel(root, expirationTime);
  if (
  // If we're in the render phase, we don't need to schedule this root
  // for an update, because we'll do it before we exit...
  !isWorking || isCommitting$1 ||
  // ...unless this is a different root than the one we're rendering.
  nextRoot !== root) {
    var rootExpirationTime = root.expirationTime;
    requestWork(root, rootExpirationTime);
  }
  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
    // Reset this back to zero so subsequent updates don't throw.
    nestedUpdateCount = 0;
    invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
  }
}

function syncUpdates(fn, a, b, c, d) {
  var previousExpirationContext = expirationContext;
  expirationContext = Sync;
  try {
    return fn(a, b, c, d);
  } finally {
    expirationContext = previousExpirationContext;
  }
}

// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.

// Linked-list of roots
var firstScheduledRoot = null;
var lastScheduledRoot = null;

var callbackExpirationTime = NoWork;
var callbackID = void 0;
var isRendering = false;
var nextFlushedRoot = null;
var nextFlushedExpirationTime = NoWork;
var lowestPriorityPendingInteractiveExpirationTime = NoWork;
var deadlineDidExpire = false;
var hasUnhandledError = false;
var unhandledError = null;
var deadline = null;

var isBatchingUpdates = false;
var isUnbatchingUpdates = false;
var isBatchingInteractiveUpdates = false;

var completedBatches = null;

var originalStartTimeMs = schedule.unstable_now();
var currentRendererTime = msToExpirationTime(originalStartTimeMs);
var currentSchedulerTime = currentRendererTime;

// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT = 50;
var nestedUpdateCount = 0;
var lastCommittedRootDuringThisBatch = null;

var timeHeuristicForUnitOfWork = 1;

function recomputeCurrentRendererTime() {
  var currentTimeMs = schedule.unstable_now() - originalStartTimeMs;
  currentRendererTime = msToExpirationTime(currentTimeMs);
}

function scheduleCallbackWithExpirationTime(root, expirationTime) {
  if (callbackExpirationTime !== NoWork) {
    // A callback is already scheduled. Check its expiration time (timeout).
    if (expirationTime > callbackExpirationTime) {
      // Existing callback has sufficient timeout. Exit.
      return;
    } else {
      if (callbackID !== null) {
        // Existing callback has insufficient timeout. Cancel and schedule a
        // new one.
        schedule.unstable_cancelScheduledWork(callbackID);
      }
    }
    // The request callback timer is already running. Don't start a new one.
  } else {
    startRequestCallbackTimer();
  }

  callbackExpirationTime = expirationTime;
  var currentMs = schedule.unstable_now() - originalStartTimeMs;
  var expirationTimeMs = expirationTimeToMs(expirationTime);
  var timeout = expirationTimeMs - currentMs;
  callbackID = schedule.unstable_scheduleWork(performAsyncWork, { timeout: timeout });
}

// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and
// onYield is called upon exiting. We use these in lieu of returning a tuple.
// I've also chosen not to inline them into renderRoot because these will
// eventually be lifted into the renderer.
function onFatal(root) {
  root.finishedWork = null;
}

function onComplete(root, finishedWork, expirationTime) {
  root.pendingCommitExpirationTime = expirationTime;
  root.finishedWork = finishedWork;
}

function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
  root.expirationTime = rootExpirationTime;
  if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {
    // Don't wait an additional tick. Commit the tree immediately.
    root.pendingCommitExpirationTime = suspendedExpirationTime;
    root.finishedWork = finishedWork;
  } else if (msUntilTimeout > 0) {
    // Wait `msUntilTimeout` milliseconds before committing.
    root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);
  }
}

function onYield(root) {
  root.finishedWork = null;
}

function onTimeout(root, finishedWork, suspendedExpirationTime) {
  if (enableSuspense) {
    // The root timed out. Commit it.
    root.pendingCommitExpirationTime = suspendedExpirationTime;
    root.finishedWork = finishedWork;
    // Read the current time before entering the commit phase. We can be
    // certain this won't cause tearing related to batching of event updates
    // because we're at the top of a timer event.
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;

    if (enableSchedulerTracking) {
      // Don't update pending interaction counts for suspense timeouts,
      // Because we know we still need to do more work in this case.
      suspenseDidTimeout = true;
      flushRoot(root, suspendedExpirationTime);
      suspenseDidTimeout = false;
    } else {
      flushRoot(root, suspendedExpirationTime);
    }
  }
}

function onCommit(root, expirationTime) {
  root.expirationTime = expirationTime;
  root.finishedWork = null;
}

function requestCurrentTime() {
  // requestCurrentTime is called by the scheduler to compute an expiration
  // time.
  //
  // Expiration times are computed by adding to the current time (the start
  // time). However, if two updates are scheduled within the same event, we
  // should treat their start times as simultaneous, even if the actual clock
  // time has advanced between the first and second call.

  // In other words, because expiration times determine how updates are batched,
  // we want all updates of like priority that occur within the same event to
  // receive the same expiration time. Otherwise we get tearing.
  //
  // We keep track of two separate times: the current "renderer" time and the
  // current "scheduler" time. The renderer time can be updated whenever; it
  // only exists to minimize the calls performance.now.
  //
  // But the scheduler time can only be updated if there's no pending work, or
  // if we know for certain that we're not in the middle of an event.

  if (isRendering) {
    // We're already rendering. Return the most recently read time.
    return currentSchedulerTime;
  }
  // Check if there's pending work.
  findHighestPriorityRoot();
  if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {
    // If there's no pending work, or if the pending work is offscreen, we can
    // read the current time without risk of tearing.
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;
    return currentSchedulerTime;
  }
  // There's already pending work. We might be in the middle of a browser
  // event. If we were to read the current time, it could cause multiple updates
  // within the same event to receive different expiration times, leading to
  // tearing. Return the last read time. During the next idle callback, the
  // time will be updated.
  return currentSchedulerTime;
}

// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root, expirationTime) {
  addRootToSchedule(root, expirationTime);
  if (isRendering) {
    // Prevent reentrancy. Remaining work will be scheduled at the end of
    // the currently rendering batch.
    return;
  }

  if (isBatchingUpdates) {
    // Flush work at the end of the batch.
    if (isUnbatchingUpdates) {
      // ...unless we're inside unbatchedUpdates, in which case we should
      // flush it now.
      nextFlushedRoot = root;
      nextFlushedExpirationTime = Sync;
      performWorkOnRoot(root, Sync, true);
    }
    return;
  }

  // TODO: Get rid of Sync and use current time?
  if (expirationTime === Sync) {
    performSyncWork();
  } else {
    scheduleCallbackWithExpirationTime(root, expirationTime);
  }
}

function addRootToSchedule(root, expirationTime) {
  // Add the root to the schedule.
  // Check if this root is already part of the schedule.
  if (root.nextScheduledRoot === null) {
    // This root is not already scheduled. Add it.
    root.expirationTime = expirationTime;
    if (lastScheduledRoot === null) {
      firstScheduledRoot = lastScheduledRoot = root;
      root.nextScheduledRoot = root;
    } else {
      lastScheduledRoot.nextScheduledRoot = root;
      lastScheduledRoot = root;
      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
    }
  } else {
    // This root is already scheduled, but its priority may have increased.
    var remainingExpirationTime = root.expirationTime;
    if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
      // Update the priority.
      root.expirationTime = expirationTime;
    }
  }
}

function findHighestPriorityRoot() {
  var highestPriorityWork = NoWork;
  var highestPriorityRoot = null;
  if (lastScheduledRoot !== null) {
    var previousScheduledRoot = lastScheduledRoot;
    var root = firstScheduledRoot;
    while (root !== null) {
      var remainingExpirationTime = root.expirationTime;
      if (remainingExpirationTime === NoWork) {
        // This root no longer has work. Remove it from the scheduler.

        // TODO: This check is redudant, but Flow is confused by the branch
        // below where we set lastScheduledRoot to null, even though we break
        // from the loop right after.
        !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        if (root === root.nextScheduledRoot) {
          // This is the only root in the list.
          root.nextScheduledRoot = null;
          firstScheduledRoot = lastScheduledRoot = null;
          break;
        } else if (root === firstScheduledRoot) {
          // This is the first root in the list.
          var next = root.nextScheduledRoot;
          firstScheduledRoot = next;
          lastScheduledRoot.nextScheduledRoot = next;
          root.nextScheduledRoot = null;
        } else if (root === lastScheduledRoot) {
          // This is the last root in the list.
          lastScheduledRoot = previousScheduledRoot;
          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
          root.nextScheduledRoot = null;
          break;
        } else {
          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
          root.nextScheduledRoot = null;
        }
        root = previousScheduledRoot.nextScheduledRoot;
      } else {
        if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
          // Update the priority, if it's higher
          highestPriorityWork = remainingExpirationTime;
          highestPriorityRoot = root;
        }
        if (root === lastScheduledRoot) {
          break;
        }
        if (highestPriorityWork === Sync) {
          // Sync is highest priority by definition so
          // we can stop searching.
          break;
        }
        previousScheduledRoot = root;
        root = root.nextScheduledRoot;
      }
    }
  }

  nextFlushedRoot = highestPriorityRoot;
  nextFlushedExpirationTime = highestPriorityWork;
}

function performAsyncWork(dl) {
  if (dl.didTimeout) {
    // The callback timed out. That means at least one update has expired.
    // Iterate through the root schedule. If they contain expired work, set
    // the next render expiration time to the current time. This has the effect
    // of flushing all expired work in a single batch, instead of flushing each
    // level one at a time.
    if (firstScheduledRoot !== null) {
      recomputeCurrentRendererTime();
      var root = firstScheduledRoot;
      do {
        didExpireAtExpirationTime(root, currentRendererTime);
        // The root schedule is circular, so this is never null.
        root = root.nextScheduledRoot;
      } while (root !== firstScheduledRoot);
    }
  }
  performWork(NoWork, dl);
}

function performSyncWork() {
  performWork(Sync, null);
}

function performWork(minExpirationTime, dl) {
  deadline = dl;

  // Keep working on roots until there's no more work, or until we reach
  // the deadline.
  findHighestPriorityRoot();

  if (deadline !== null) {
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;

    if (enableUserTimingAPI) {
      var didExpire = nextFlushedExpirationTime < currentRendererTime;
      var timeout = expirationTimeToMs(nextFlushedExpirationTime);
      stopRequestCallbackTimer(didExpire, timeout);
    }

    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime) && (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime >= nextFlushedExpirationTime);
      findHighestPriorityRoot();
      recomputeCurrentRendererTime();
      currentSchedulerTime = currentRendererTime;
    }
  } else {
    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime)) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);
      findHighestPriorityRoot();
    }
  }

  // We're done flushing work. Either we ran out of time in this callback,
  // or there's no more work left with sufficient priority.

  // If we're inside a callback, set this to false since we just completed it.
  if (deadline !== null) {
    callbackExpirationTime = NoWork;
    callbackID = null;
  }
  // If there's work left over, schedule a new callback.
  if (nextFlushedExpirationTime !== NoWork) {
    scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
  }

  // Clean-up.
  deadline = null;
  deadlineDidExpire = false;

  finishRendering();
}

function flushRoot(root, expirationTime) {
  !!isRendering ? invariant(false, 'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.') : void 0;
  // Perform work on root as if the given expiration time is the current time.
  // This has the effect of synchronously flushing all work up to and
  // including the given time.
  nextFlushedRoot = root;
  nextFlushedExpirationTime = expirationTime;
  performWorkOnRoot(root, expirationTime, true);
  // Flush any sync work that was scheduled by lifecycles
  performSyncWork();
}

function finishRendering() {
  nestedUpdateCount = 0;
  lastCommittedRootDuringThisBatch = null;

  if (completedBatches !== null) {
    var batches = completedBatches;
    completedBatches = null;
    for (var i = 0; i < batches.length; i++) {
      var batch = batches[i];
      try {
        batch._onComplete();
      } catch (error) {
        if (!hasUnhandledError) {
          hasUnhandledError = true;
          unhandledError = error;
        }
      }
    }
  }

  if (hasUnhandledError) {
    var error = unhandledError;
    unhandledError = null;
    hasUnhandledError = false;
    throw error;
  }
}

function performWorkOnRoot(root, expirationTime, isExpired) {
  !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  isRendering = true;

  // Check if this is async work or sync/expired work.
  if (deadline === null || isExpired) {
    // Flush work without yielding.
    // TODO: Non-yieldy work does not necessarily imply expired work. A renderer
    // may want to perform some work without yielding, but also without
    // requiring the root to complete (by triggering placeholders).

    var finishedWork = root.finishedWork;
    if (finishedWork !== null) {
      // This root is already complete. We can commit it.
      completeRoot(root, finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      // If this root previously suspended, clear its existing timeout, since
      // we're about to try rendering again.
      var timeoutHandle = root.timeoutHandle;
      if (enableSuspense && timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
        cancelTimeout(timeoutHandle);
      }
      var isYieldy = false;
      renderRoot(root, isYieldy, isExpired);
      finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        // We've completed the root. Commit it.
        completeRoot(root, finishedWork, expirationTime);
      }
    }
  } else {
    // Flush async work.
    var _finishedWork = root.finishedWork;
    if (_finishedWork !== null) {
      // This root is already complete. We can commit it.
      completeRoot(root, _finishedWork, expirationTime);
    } else {
      root.finishedWork = null;
      // If this root previously suspended, clear its existing timeout, since
      // we're about to try rendering again.
      var _timeoutHandle = root.timeoutHandle;
      if (enableSuspense && _timeoutHandle !== noTimeout) {
        root.timeoutHandle = noTimeout;
        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
        cancelTimeout(_timeoutHandle);
      }
      var _isYieldy = true;
      renderRoot(root, _isYieldy, isExpired);
      _finishedWork = root.finishedWork;
      if (_finishedWork !== null) {
        // We've completed the root. Check the deadline one more time
        // before committing.
        if (!shouldYield()) {
          // Still time left. Commit the root.
          completeRoot(root, _finishedWork, expirationTime);
        } else {
          // There's no time left. Mark this root as complete. We'll come
          // back and commit it later.
          root.finishedWork = _finishedWork;
        }
      }
    }
  }

  isRendering = false;
}

function completeRoot(root, finishedWork, expirationTime) {
  // Check if there's a batch that matches this expiration time.
  var firstBatch = root.firstBatch;
  if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {
    if (completedBatches === null) {
      completedBatches = [firstBatch];
    } else {
      completedBatches.push(firstBatch);
    }
    if (firstBatch._defer) {
      // This root is blocked from committing by a batch. Unschedule it until
      // we receive another update.
      root.finishedWork = finishedWork;
      root.expirationTime = NoWork;
      return;
    }
  }

  // Commit the root.
  root.finishedWork = null;

  // Check if this is a nested update (a sync update scheduled during the
  // commit phase).
  if (root === lastCommittedRootDuringThisBatch) {
    // If the next root is the same as the previous root, this is a nested
    // update. To prevent an infinite loop, increment the nested update count.
    nestedUpdateCount++;
  } else {
    // Reset whenever we switch roots.
    lastCommittedRootDuringThisBatch = root;
    nestedUpdateCount = 0;
  }
  commitRoot(root, finishedWork);
}

// When working on async work, the reconciler asks the renderer if it should
// yield execution. For DOM, we implement this with requestIdleCallback.
function shouldYield() {
  if (deadlineDidExpire) {
    return true;
  }
  if (deadline === null || deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
    // Disregard deadline.didTimeout. Only expired work should be flushed
    // during a timeout. This path is only hit for non-expired work.
    return false;
  }
  deadlineDidExpire = true;
  return true;
}

function onUncaughtError(error) {
  !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  // Unschedule this root so we don't work on it again until there's
  // another update.
  nextFlushedRoot.expirationTime = NoWork;
  if (!hasUnhandledError) {
    hasUnhandledError = true;
    unhandledError = error;
  }
}

// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates$1(fn, a) {
  var previousIsBatchingUpdates = isBatchingUpdates;
  isBatchingUpdates = true;
  try {
    return fn(a);
  } finally {
    isBatchingUpdates = previousIsBatchingUpdates;
    if (!isBatchingUpdates && !isRendering) {
      performSyncWork();
    }
  }
}

// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn, a) {
  if (isBatchingUpdates && !isUnbatchingUpdates) {
    isUnbatchingUpdates = true;
    try {
      return fn(a);
    } finally {
      isUnbatchingUpdates = false;
    }
  }
  return fn(a);
}

// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn, a) {
  !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
  var previousIsBatchingUpdates = isBatchingUpdates;
  isBatchingUpdates = true;
  try {
    return syncUpdates(fn, a);
  } finally {
    isBatchingUpdates = previousIsBatchingUpdates;
    performSyncWork();
  }
}

function interactiveUpdates$1(fn, a, b) {
  if (isBatchingInteractiveUpdates) {
    return fn(a, b);
  }
  // If there are any pending interactive updates, synchronously flush them.
  // This needs to happen before we read any handlers, because the effect of
  // the previous event may influence which handlers are called during
  // this event.
  if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
    // Synchronously flush pending interactive updates.
    performWork(lowestPriorityPendingInteractiveExpirationTime, null);
    lowestPriorityPendingInteractiveExpirationTime = NoWork;
  }
  var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;
  var previousIsBatchingUpdates = isBatchingUpdates;
  isBatchingInteractiveUpdates = true;
  isBatchingUpdates = true;
  try {
    return fn(a, b);
  } finally {
    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;
    isBatchingUpdates = previousIsBatchingUpdates;
    if (!isBatchingUpdates && !isRendering) {
      performSyncWork();
    }
  }
}

function flushInteractiveUpdates$1() {
  if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
    // Synchronously flush pending interactive updates.
    performWork(lowestPriorityPendingInteractiveExpirationTime, null);
    lowestPriorityPendingInteractiveExpirationTime = NoWork;
  }
}

function flushControlled(fn) {
  var previousIsBatchingUpdates = isBatchingUpdates;
  isBatchingUpdates = true;
  try {
    syncUpdates(fn);
  } finally {
    isBatchingUpdates = previousIsBatchingUpdates;
    if (!isBatchingUpdates && !isRendering) {
      performWork(Sync, null);
    }
  }
}

// 0 is PROD, 1 is DEV.
// Might add PROFILE later.


var didWarnAboutNestedUpdates = void 0;

{
  didWarnAboutNestedUpdates = false;
}

function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyContextObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);

  if (fiber.tag === ClassComponent) {
    var Component = fiber.type;
    if (isContextProvider(Component)) {
      return processChildContext(fiber, Component, parentContext);
    }
  } else if (fiber.tag === ClassComponentLazy) {
    var _Component = getResultFromResolvedThenable(fiber.type);
    if (isContextProvider(_Component)) {
      return processChildContext(fiber, _Component, parentContext);
    }
  }

  return parentContext;
}

function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
  {
    if (phase === 'render' && current !== null && !didWarnAboutNestedUpdates) {
      didWarnAboutNestedUpdates = true;
      warningWithoutStack$1(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown');
    }
  }

  var update = createUpdate(expirationTime);
  // Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload = { element: element };

  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    !(typeof callback === 'function') ? warningWithoutStack$1(false, 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback) : void 0;
    update.callback = callback;
  }
  enqueueUpdate(current$$1, update);

  scheduleWork(current$$1, expirationTime);
  return expirationTime;
}

function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
  // TODO: If this is a nested container, this won't be the root.
  var current$$1 = container.current;

  {
    if (ReactFiberInstrumentation_1.debugTool) {
      if (current$$1.alternate === null) {
        ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
      } else if (element === null) {
        ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
      } else {
        ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
      }
    }
  }

  var context = getContextForSubtree(parentComponent);
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  return scheduleRootUpdate(current$$1, element, expirationTime, callback);
}

function findHostInstance(component) {
  var fiber = get(component);
  if (fiber === undefined) {
    if (typeof component.render === 'function') {
      invariant(false, 'Unable to find node on an unmounted component.');
    } else {
      invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));
    }
  }
  var hostFiber = findCurrentHostFiber(fiber);
  if (hostFiber === null) {
    return null;
  }
  return hostFiber.stateNode;
}

function createContainer(containerInfo, isAsync, hydrate) {
  return createFiberRoot(containerInfo, isAsync, hydrate);
}

function updateContainer(element, container, parentComponent, callback) {
  var current$$1 = container.current;
  var currentTime = requestCurrentTime();
  var expirationTime = computeExpirationForFiber(currentTime, current$$1);
  return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
}

function getPublicRootInstance(container) {
  var containerFiber = container.current;
  if (!containerFiber.child) {
    return null;
  }
  switch (containerFiber.child.tag) {
    case HostComponent:
      return getPublicInstance(containerFiber.child.stateNode);
    default:
      return containerFiber.child.stateNode;
  }
}

function findHostInstanceWithNoPortals(fiber) {
  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
  if (hostFiber === null) {
    return null;
  }
  return hostFiber.stateNode;
}

function injectIntoDevTools(devToolsConfig) {
  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

  return injectInternals(_assign({}, devToolsConfig, {
    findHostInstanceByFiber: function (fiber) {
      var hostFiber = findCurrentHostFiber(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    },
    findFiberByHostInstance: function (instance) {
      if (!findFiberByHostInstance) {
        // Might not be implemented by the renderer.
        return null;
      }
      return findFiberByHostInstance(instance);
    }
  }));
}

// This file intentionally does *not* have the Flow annotation.
// Don't add it. See `./inline-typed.js` for an explanation.

function createPortal$1(children, containerInfo,
// TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.5.0';

// TODO: This type is shared between the reconciler and ReactDOM, but will
// eventually be lifted out to the renderer.
var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;

var topLevelUpdateWarnings = void 0;
var warnOnInvalidCallback = void 0;
var didWarnAboutUnstableCreatePortal = false;

{
  if (typeof Map !== 'function' ||
  // $FlowIssue Flow incorrectly thinks Map has no prototype
  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' ||
  // $FlowIssue Flow incorrectly thinks Set has no prototype
  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    warningWithoutStack$1(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
  }

  topLevelUpdateWarnings = function (container) {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
      if (hostInstance) {
        !(hostInstance.parentNode === container) ? warningWithoutStack$1(false, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.') : void 0;
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

    !(!hasNonRootReactChild || isRootRenderedBySomeReact) ? warningWithoutStack$1(false, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

    !(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY') ? warningWithoutStack$1(false, 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
  };

  warnOnInvalidCallback = function (callback, callerName) {
    !(callback === null || typeof callback === 'function') ? warningWithoutStack$1(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback) : void 0;
  };
}

setRestoreImplementation(restoreControlledState$1);

function ReactBatch(root) {
  var expirationTime = computeUniqueAsyncExpiration();
  this._expirationTime = expirationTime;
  this._root = root;
  this._next = null;
  this._callbacks = null;
  this._didComplete = false;
  this._hasChildren = false;
  this._children = null;
  this._defer = true;
}
ReactBatch.prototype.render = function (children) {
  !this._defer ? invariant(false, 'batch.render: Cannot render a batch that already committed.') : void 0;
  this._hasChildren = true;
  this._children = children;
  var internalRoot = this._root._internalRoot;
  var expirationTime = this._expirationTime;
  var work = new ReactWork();
  updateContainerAtExpirationTime(children, internalRoot, null, expirationTime, work._onCommit);
  return work;
};
ReactBatch.prototype.then = function (onComplete) {
  if (this._didComplete) {
    onComplete();
    return;
  }
  var callbacks = this._callbacks;
  if (callbacks === null) {
    callbacks = this._callbacks = [];
  }
  callbacks.push(onComplete);
};
ReactBatch.prototype.commit = function () {
  var internalRoot = this._root._internalRoot;
  var firstBatch = internalRoot.firstBatch;
  !(this._defer && firstBatch !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;

  if (!this._hasChildren) {
    // This batch is empty. Return.
    this._next = null;
    this._defer = false;
    return;
  }

  var expirationTime = this._expirationTime;

  // Ensure this is the first batch in the list.
  if (firstBatch !== this) {
    // This batch is not the earliest batch. We need to move it to the front.
    // Update its expiration time to be the expiration time of the earliest
    // batch, so that we can flush it without flushing the other batches.
    if (this._hasChildren) {
      expirationTime = this._expirationTime = firstBatch._expirationTime;
      // Rendering this batch again ensures its children will be the final state
      // when we flush (updates are processed in insertion order: last
      // update wins).
      // TODO: This forces a restart. Should we print a warning?
      this.render(this._children);
    }

    // Remove the batch from the list.
    var previous = null;
    var batch = firstBatch;
    while (batch !== this) {
      previous = batch;
      batch = batch._next;
    }
    !(previous !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;
    previous._next = batch._next;

    // Add it to the front.
    this._next = firstBatch;
    firstBatch = internalRoot.firstBatch = this;
  }

  // Synchronously flush all the work up to this batch's expiration time.
  this._defer = false;
  flushRoot(internalRoot, expirationTime);

  // Pop the batch from the list.
  var next = this._next;
  this._next = null;
  firstBatch = internalRoot.firstBatch = next;

  // Append the next earliest batch's children to the update queue.
  if (firstBatch !== null && firstBatch._hasChildren) {
    firstBatch.render(firstBatch._children);
  }
};
ReactBatch.prototype._onComplete = function () {
  if (this._didComplete) {
    return;
  }
  this._didComplete = true;
  var callbacks = this._callbacks;
  if (callbacks === null) {
    return;
  }
  // TODO: Error handling.
  for (var i = 0; i < callbacks.length; i++) {
    var _callback = callbacks[i];
    _callback();
  }
};

function ReactWork() {
  this._callbacks = null;
  this._didCommit = false;
  // TODO: Avoid need to bind by replacing callbacks in the update queue with
  // list of Work objects.
  this._onCommit = this._onCommit.bind(this);
}
ReactWork.prototype.then = function (onCommit) {
  if (this._didCommit) {
    onCommit();
    return;
  }
  var callbacks = this._callbacks;
  if (callbacks === null) {
    callbacks = this._callbacks = [];
  }
  callbacks.push(onCommit);
};
ReactWork.prototype._onCommit = function () {
  if (this._didCommit) {
    return;
  }
  this._didCommit = true;
  var callbacks = this._callbacks;
  if (callbacks === null) {
    return;
  }
  // TODO: Error handling.
  for (var i = 0; i < callbacks.length; i++) {
    var _callback2 = callbacks[i];
    !(typeof _callback2 === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback2) : void 0;
    _callback2();
  }
};

function ReactRoot(container, isAsync, hydrate) {
  var root = createContainer(container, isAsync, hydrate);
  this._internalRoot = root;
}
ReactRoot.prototype.render = function (children, callback) {
  var root = this._internalRoot;
  var work = new ReactWork();
  callback = callback === undefined ? null : callback;
  {
    warnOnInvalidCallback(callback, 'render');
  }
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(children, root, null, work._onCommit);
  return work;
};
ReactRoot.prototype.unmount = function (callback) {
  var root = this._internalRoot;
  var work = new ReactWork();
  callback = callback === undefined ? null : callback;
  {
    warnOnInvalidCallback(callback, 'render');
  }
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(null, root, null, work._onCommit);
  return work;
};
ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function (parentComponent, children, callback) {
  var root = this._internalRoot;
  var work = new ReactWork();
  callback = callback === undefined ? null : callback;
  {
    warnOnInvalidCallback(callback, 'render');
  }
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(children, root, parentComponent, work._onCommit);
  return work;
};
ReactRoot.prototype.createBatch = function () {
  var batch = new ReactBatch(this);
  var expirationTime = batch._expirationTime;

  var internalRoot = this._internalRoot;
  var firstBatch = internalRoot.firstBatch;
  if (firstBatch === null) {
    internalRoot.firstBatch = batch;
    batch._next = null;
  } else {
    // Insert sorted by expiration time then insertion order
    var insertAfter = null;
    var insertBefore = firstBatch;
    while (insertBefore !== null && insertBefore._expirationTime <= expirationTime) {
      insertAfter = insertBefore;
      insertBefore = insertBefore._next;
    }
    batch._next = insertBefore;
    if (insertAfter !== null) {
      insertAfter._next = batch;
    }
  }

  return batch;
};

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

setBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);

var warnedAboutHydrateAPI = false;

function legacyCreateRootFromDOMContainer(container, forceHydrate) {
  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
  // First clear any existing content.
  if (!shouldHydrate) {
    var warned = false;
    var rootSibling = void 0;
    while (rootSibling = container.lastChild) {
      {
        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
          warned = true;
          warningWithoutStack$1(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
        }
      }
      container.removeChild(rootSibling);
    }
  }
  {
    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
      warnedAboutHydrateAPI = true;
      lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
    }
  }
  // Legacy roots are not async by default.
  var isAsync = false;
  return new ReactRoot(container, isAsync, shouldHydrate);
}

function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  // TODO: Ensure all entry points contain this check
  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;

  {
    topLevelUpdateWarnings(container);
  }

  // TODO: Without `any` type, Flow says "Property cannot be accessed on any
  // member of intersection type." Whyyyyyy.
  var root = container._reactRootContainer;
  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
    if (typeof callback === 'function') {
      var originalCallback = callback;
      callback = function () {
        var instance = getPublicRootInstance(root._internalRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
    unbatchedUpdates(function () {
      if (parentComponent != null) {
        root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
      } else {
        root.render(children, callback);
      }
    });
  } else {
    if (typeof callback === 'function') {
      var _originalCallback = callback;
      callback = function () {
        var instance = getPublicRootInstance(root._internalRoot);
        _originalCallback.call(instance);
      };
    }
    // Update
    if (parentComponent != null) {
      root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);
    } else {
      root.render(children, callback);
    }
  }
  return getPublicRootInstance(root._internalRoot);
}

function createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
  // TODO: pass ReactDOM portal implementation as third argument
  return createPortal$1(children, container, null, key);
}

var ReactDOM = {
  createPortal: createPortal,

  findDOMNode: function (componentOrElement) {
    {
      var owner = ReactCurrentOwner.current;
      if (owner !== null && owner.stateNode !== null) {
        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
        !warnedAboutRefsInRender ? warningWithoutStack$1(false, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component') : void 0;
        owner.stateNode._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === ELEMENT_NODE) {
      return componentOrElement;
    }

    return findHostInstance(componentOrElement);
  },
  hydrate: function (element, container, callback) {
    // TODO: throw or warn if we couldn't hydrate?
    return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
  },
  render: function (element, container, callback) {
    return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
  },
  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
    return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
  },
  unmountComponentAtNode: function (container) {
    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

    if (container._reactRootContainer) {
      {
        var rootEl = getReactRootElementInContainer(container);
        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
        !!renderedByDifferentReact ? warningWithoutStack$1(false, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
      }

      // Unmount should not be batched.
      unbatchedUpdates(function () {
        legacyRenderSubtreeIntoContainer(null, null, container, false, function () {
          container._reactRootContainer = null;
        });
      });
      // If you call unmountComponentAtNode twice in quick succession, you'll
      // get `true` twice. That's probably fine?
      return true;
    } else {
      {
        var _rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

        !!hasNonRootReactChild ? warningWithoutStack$1(false, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
      }

      return false;
    }
  },


  // Temporary alias since we already shipped React 16 RC with it.
  // TODO: remove in React 17.
  unstable_createPortal: function () {
    if (!didWarnAboutUnstableCreatePortal) {
      didWarnAboutUnstableCreatePortal = true;
      lowPriorityWarning$1(false, 'The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the "unstable_" prefix.');
    }
    return createPortal.apply(undefined, arguments);
  },


  unstable_batchedUpdates: batchedUpdates$1,

  unstable_interactiveUpdates: interactiveUpdates$1,

  flushSync: flushSync,

  unstable_flushControlled: flushControlled,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    // Keep in sync with ReactDOMUnstableNativeDependencies.js
    // and ReactTestUtils.js. This is an array for better minification.
    Events: [getInstanceFromNode$1, getNodeFromInstance$1, getFiberCurrentPropsFromNode$1, eventNameDispatchConfigs, accumulateTwoPhaseDispatches, accumulateDirectDispatches, enqueueStateRestore, restoreStateIfNeeded, dispatchEvent, runEventsInBatch]
  }
};

ReactDOM.unstable_createRoot = function createRoot(container, options) {
  !isValidContainer(container) ? invariant(false, 'unstable_createRoot(...): Target container is not a DOM element.') : void 0;
  var hydrate = options != null && options.hydrate === true;
  return new ReactRoot(container, true, hydrate);
};

var foundDevTools = injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType: 1,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol;
      // Don't warn in exotic cases like chrome-extension://.
      if (/^(https?|file):$/.test(protocol)) {
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}



var ReactDOM$2 = Object.freeze({
	default: ReactDOM
});

var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom = ReactDOM$3.default || ReactDOM$3;

module.exports = reactDom;
  })();
}


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js ***!
  \****************************************************************************/
/*! exports provided: polyfill */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyfill", function() { return polyfill; });
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function componentWillMount() {
  // Call this.constructor.gDSFP to support sub-classes.
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== undefined) {
    this.setState(state);
  }
}

function componentWillReceiveProps(nextProps) {
  // Call this.constructor.gDSFP to support sub-classes.
  // Use the setState() updater to ensure state isn't stale in certain edge cases.
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== undefined ? state : null;
  }
  // Binding "this" is important for shallow renderer support.
  this.setState(updater.bind(this));
}

function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      prevProps,
      prevState
    );
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}

// React may warn about cWM/cWRP/cWU methods being deprecated.
// Add a flag to suppress these warnings for this special case.
componentWillMount.__suppressDeprecationWarning = true;
componentWillReceiveProps.__suppressDeprecationWarning = true;
componentWillUpdate.__suppressDeprecationWarning = true;

function polyfill(Component) {
  var prototype = Component.prototype;

  if (!prototype || !prototype.isReactComponent) {
    throw new Error('Can only polyfill class components');
  }

  if (
    typeof Component.getDerivedStateFromProps !== 'function' &&
    typeof prototype.getSnapshotBeforeUpdate !== 'function'
  ) {
    return Component;
  }

  // If new component APIs are defined, "unsafe" lifecycles won't be called.
  // Error if any of these lifecycles are present,
  // Because they would work differently between older and newer (16.3+) versions of React.
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === 'function') {
    foundWillMountName = 'componentWillMount';
  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
    foundWillMountName = 'UNSAFE_componentWillMount';
  }
  if (typeof prototype.componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'componentWillReceiveProps';
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
  }
  if (typeof prototype.componentWillUpdate === 'function') {
    foundWillUpdateName = 'componentWillUpdate';
  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
    foundWillUpdateName = 'UNSAFE_componentWillUpdate';
  }
  if (
    foundWillMountName !== null ||
    foundWillReceivePropsName !== null ||
    foundWillUpdateName !== null
  ) {
    var componentName = Component.displayName || Component.name;
    var newApiName =
      typeof Component.getDerivedStateFromProps === 'function'
        ? 'getDerivedStateFromProps()'
        : 'getSnapshotBeforeUpdate()';

    throw Error(
      'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
        componentName +
        ' uses ' +
        newApiName +
        ' but also contains the following legacy lifecycles:' +
        (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
        (foundWillReceivePropsName !== null
          ? '\n  ' + foundWillReceivePropsName
          : '') +
        (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
        '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
        'https://fb.me/react-async-component-lifecycle-hooks'
    );
  }

  // React <= 16.2 does not support static getDerivedStateFromProps.
  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
  // Newer versions of React will ignore these lifecycles if gDSFP exists.
  if (typeof Component.getDerivedStateFromProps === 'function') {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }

  // React <= 16.2 does not support getSnapshotBeforeUpdate.
  // As a workaround, use cWU to invoke the new lifecycle.
  // Newer versions of React will ignore that lifecycle if gSBU exists.
  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
    if (typeof prototype.componentDidUpdate !== 'function') {
      throw new Error(
        'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
      );
    }

    prototype.componentWillUpdate = componentWillUpdate;

    var componentDidUpdate = prototype.componentDidUpdate;

    prototype.componentDidUpdate = function componentDidUpdatePolyfill(
      prevProps,
      prevState,
      maybeSnapshot
    ) {
      // 16.3+ will not execute our will-update method;
      // It will pass a snapshot value to did-update though.
      // Older versions will require our polyfilled will-update value.
      // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
      // Because for <= 15.x versions this might be a "prevContext" object.
      // We also can't just check "__reactInternalSnapshot",
      // Because get-snapshot might return a falsy value.
      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
      var snapshot = this.__reactInternalSnapshotFlag
        ? this.__reactInternalSnapshot
        : maybeSnapshot;

      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }

  return Component;
}




/***/ }),

/***/ "./node_modules/react-pose/dist/react-pose.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-pose/dist/react-pose.es.js ***!
  \*******************************************************/
/*! exports provided: default, PoseGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PoseGroup", function() { return PoseGroup; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var popmotion_pose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! popmotion-pose */ "./node_modules/popmotion-pose/dist/popmotion-pose.es.js");
/* harmony import */ var _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/is-prop-valid */ "./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js");
/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! hey-listen */ "./node_modules/hey-listen/dist/hey-listen.es.js");






var hasChanged = function (prev, next) {
    if (prev === next)
        return false;
    var prevIsArray = Array.isArray(prev);
    var nextIsArray = Array.isArray(next);
    if (prevIsArray !== nextIsArray || (!prevIsArray && !nextIsArray)) {
        return true;
    }
    else if (prevIsArray && nextIsArray) {
        var numPrev = prev.length;
        var numNext = next.length;
        if (numPrev !== numNext)
            return true;
        for (var i = numPrev; i < numPrev; i++) {
            if (prev[i] !== next[i])
                return true;
        }
    }
    return false;
};

var pickAssign = function (shouldPick, sources) {
    return sources.reduce(function (picked, source) {
        for (var key in source) {
            if (shouldPick(key)) {
                picked[key] = source[key];
            }
        }
        return picked;
    }, {});
};

var PoseParentContext = Object(react__WEBPACK_IMPORTED_MODULE_1__["createContext"])({});
var calcPopFromFlowStyle = function (el) {
    var offsetTop = el.offsetTop, offsetLeft = el.offsetLeft, offsetWidth = el.offsetWidth, offsetHeight = el.offsetHeight;
    return {
        position: 'absolute',
        top: offsetTop,
        left: offsetLeft,
        width: offsetWidth,
        height: offsetHeight
    };
};
var hasPose = function (pose, key) {
    return Array.isArray(pose) ? pose.indexOf(key) !== -1 : pose === key;
};
var objectToMap = function (obj) {
    return Object.keys(obj).reduce(function (map, key) {
        map.set(key, { raw: obj[key] });
        return map;
    }, new Map());
};
var testAlwaysTrue = function () { return true; };
var PoseElement = (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PoseElement, _super);
    function PoseElement(props) {
        var _this = _super.call(this, props) || this;
        _this.children = new Set();
        _this.childrenHandlers = {
            registerChild: function (props) {
                _this.children.add(props);
                if (_this.poser)
                    _this.flushChildren();
            },
            onUnmount: function (child) { return _this.poser.removeChild(child); },
            getParentPoseConfig: function () { return _this.props.poseConfig; },
            getInitialPoseFromParent: function () { return _this.getInitialPose(); }
        };
        _this.getRefs = function () {
            var refs = {};
            var elementType = _this.props.elementType;
            if (typeof elementType === 'string') {
                refs.ref = _this.setRef;
            }
            else {
                refs.innerRef = _this.setRef;
                refs.hostRef = _this.setRef;
            }
            return refs;
        };
        _this.setRef = function (ref) {
            if (ref instanceof Element || (_this.ref && ref === null)) {
                var innerRef = _this.props.innerRef;
                if (innerRef)
                    innerRef(ref);
                _this.ref = ref;
            }
        };
        _this.shouldForwardProp =
            typeof _this.props.elementType === 'string' ? _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_3__["default"] : testAlwaysTrue;
        return _this;
    }
    PoseElement.prototype.getInitialPose = function () {
        var _a = this.props, getInitialPoseFromParent = _a.getInitialPoseFromParent, pose = _a.pose, _pose = _a._pose, initialPose = _a.initialPose;
        if (initialPose) {
            return initialPose;
        }
        else {
            var parentPose = getInitialPoseFromParent && getInitialPoseFromParent();
            var thisPose = Array.isArray(pose) ? pose : [pose];
            var thisInternalPose = Array.isArray(_pose) ? _pose : [_pose];
            var initialPoses = Array.isArray(parentPose)
                ? parentPose.concat(thisPose, thisInternalPose) : [parentPose].concat(thisPose, thisInternalPose);
            var filteredInitialPoses = initialPoses.filter(Boolean);
            return filteredInitialPoses.length ? filteredInitialPoses : undefined;
        }
    };
    PoseElement.prototype.getFirstPose = function () {
        var _a = this.props, initialPose = _a.initialPose, pose = _a.pose, _pose = _a._pose;
        if (!initialPose)
            return;
        var thisPose = Array.isArray(pose) ? pose : [pose];
        var thisInternalPose = Array.isArray(_pose) ? _pose : [_pose];
        return thisPose.concat(thisInternalPose);
    };
    PoseElement.prototype.getSetProps = function () {
        var _a = this.props, elementType = _a.elementType, poseConfig = _a.poseConfig, onValueChange = _a.onValueChange, innerRef = _a.innerRef, _pose = _a._pose, pose = _a.pose, initialPose = _a.initialPose, poseKey = _a.poseKey, onPoseComplete = _a.onPoseComplete, getParentPoseConfig = _a.getParentPoseConfig, registerChild = _a.registerChild, onUnmount = _a.onUnmount, getInitialPoseFromParent = _a.getInitialPoseFromParent, popFromFlow = _a.popFromFlow, values = _a.values, parentValues = _a.parentValues, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onPressStart = _a.onPressStart, onPressEnd = _a.onPressEnd, props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["elementType", "poseConfig", "onValueChange", "innerRef", "_pose", "pose", "initialPose", "poseKey", "onPoseComplete", "getParentPoseConfig", "registerChild", "onUnmount", "getInitialPoseFromParent", "popFromFlow", "values", "parentValues", "onDragStart", "onDragEnd", "onPressStart", "onPressEnd"]);
        if (popFromFlow && this.ref && this.ref instanceof HTMLElement) {
            if (!this.popStyle) {
                props.style = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, props.style, calcPopFromFlowStyle(this.ref));
                this.popStyle = props.style;
            }
            else {
                props.style = this.popStyle;
            }
        }
        else {
            this.popStyle = null;
        }
        return props;
    };
    PoseElement.prototype.componentDidMount = function () {
        var _this = this;
        Object(hey_listen__WEBPACK_IMPORTED_MODULE_4__["invariant"])(typeof this.ref !== 'undefined', "No DOM ref found. If you're converting an existing component via posed(Component), you must ensure you're passing the hostRef prop to your underlying DOM element.");
        var _a = this.props, poseConfig = _a.poseConfig, onValueChange = _a.onValueChange, registerChild = _a.registerChild, values = _a.values, parentValues = _a.parentValues, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onPressStart = _a.onPressStart, onPressEnd = _a.onPressEnd;
        var config = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, poseConfig, { initialPose: this.getInitialPose(), values: values || poseConfig.values, parentValues: parentValues ? objectToMap(parentValues) : undefined, props: this.getSetProps(), onDragStart: onDragStart,
            onDragEnd: onDragEnd,
            onPressStart: onPressStart,
            onPressEnd: onPressEnd, onChange: onValueChange });
        if (!registerChild) {
            this.initPoser(Object(popmotion_pose__WEBPACK_IMPORTED_MODULE_2__["default"])(this.ref, config));
        }
        else {
            registerChild({
                element: this.ref,
                poseConfig: config,
                onRegistered: function (poser) { return _this.initPoser(poser); }
            });
        }
    };
    PoseElement.prototype.UNSAFE_componentWillUpdate = function (_a) {
        var pose = _a.pose, _pose = _a._pose;
        if (hasPose(pose, 'flip') || hasPose(_pose, 'flip'))
            this.poser.measure();
    };
    PoseElement.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, pose = _a.pose, _pose = _a._pose, poseKey = _a.poseKey;
        this.poser.setProps(this.getSetProps());
        if (poseKey !== prevProps.poseKey ||
            hasChanged(prevProps.pose, pose) ||
            pose === 'flip') {
            this.setPose(pose);
        }
        if (_pose !== prevProps._pose || _pose === 'flip')
            this.setPose(_pose);
    };
    PoseElement.prototype.componentWillUnmount = function () {
        if (!this.poser)
            return;
        var onUnmount = this.props.onUnmount;
        if (onUnmount)
            onUnmount(this.poser);
        this.poser.destroy();
    };
    PoseElement.prototype.initPoser = function (poser) {
        this.poser = poser;
        this.flushChildren();
        var firstPose = this.getFirstPose();
        if (firstPose)
            this.setPose(firstPose);
    };
    PoseElement.prototype.setPose = function (pose) {
        var _this = this;
        var onPoseComplete = this.props.onPoseComplete;
        var poseList = Array.isArray(pose) ? pose : [pose];
        Promise.all(poseList.map(function (key) { return key && _this.poser.set(key); })).then(function () { return onPoseComplete && onPoseComplete(); });
    };
    PoseElement.prototype.flushChildren = function () {
        var _this = this;
        this.children.forEach(function (_a) {
            var element = _a.element, poseConfig = _a.poseConfig, onRegistered = _a.onRegistered;
            return onRegistered(_this.poser.addChild(element, poseConfig));
        });
        this.children.clear();
    };
    PoseElement.prototype.render = function () {
        var elementType = this.props.elementType;
        return (Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(PoseParentContext.Provider, { value: this.childrenHandlers }, Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(elementType, pickAssign(this.shouldForwardProp, [
            this.getSetProps(),
            this.getRefs()
        ]))));
    };
    return PoseElement;
}(react__WEBPACK_IMPORTED_MODULE_1__["PureComponent"]));

var supportedElements = [
    'a',
    'article',
    'aside',
    'audio',
    'b',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dialog',
    'div',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'i',
    'iframe',
    'img',
    'input',
    'label',
    'legend',
    'li',
    'nav',
    'object',
    'ol',
    'option',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'section',
    'select',
    'span',
    'strong',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'ul',
    'video',
    'circle',
    'clipPath',
    'defs',
    'ellipse',
    'g',
    'image',
    'line',
    'linearGradient',
    'mask',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'stop',
    'svg',
    'text',
    'tspan'
];

var componentCache = new Map();
var createComponentFactory = function (key) {
    var componentFactory = function (poseConfig) {
        if (poseConfig === void 0) { poseConfig = {}; }
        var config;
        return function (_a) {
            var _b = _a.withParent, withParent = _b === void 0 ? true : _b, props = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__rest"])(_a, ["withParent"]);
            config =
                config ||
                    (typeof poseConfig === 'function' ? poseConfig(props) : poseConfig);
            return !withParent || props.parentValues ? (Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(PoseElement, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ poseConfig: config, elementType: key }, props))) : (Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(PoseParentContext.Consumer, null, function (parentCtx) { return (Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(PoseElement, Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({ poseConfig: config, elementType: key }, props, parentCtx))); }));
        };
    };
    componentCache.set(key, componentFactory);
    return componentFactory;
};
var getComponentFactory = function (key) {
    return componentCache.has(key)
        ? componentCache.get(key)
        : createComponentFactory(key);
};
var posed = (function (component) {
    return getComponentFactory(component);
});
supportedElements.reduce(function (acc, key) {
    acc[key] = getComponentFactory(key);
    return acc;
}, posed);

var Children$1 = react__WEBPACK_IMPORTED_MODULE_1__["Children"], cloneElement$1 = react__WEBPACK_IMPORTED_MODULE_1__["cloneElement"];
var getKey = function (child) { return child.key; };
var animateChildrenList = function (incomingChildren, pose, initialPose) {
    var children = [];
    Children$1.forEach(incomingChildren, function (child) {
        return children.push(cloneElement$1(child, { pose: pose, initialPose: initialPose }));
    });
    return children;
};
var mergeChildren = function (_a) {
    var incomingChildren = _a.incomingChildren, displayedChildren = _a.displayedChildren, isLeaving = _a.isLeaving, removeFromTree = _a.removeFromTree, preEnterPose = _a.preEnterPose, enterPose = _a.enterPose, exitPose = _a.exitPose, flipMove = _a.flipMove;
    var children = [];
    var prevKeys = displayedChildren.map(getKey);
    var nextKeys = incomingChildren.map(getKey);
    var entering = new Set(nextKeys.filter(function (key) { return isLeaving.has(key) || prevKeys.indexOf(key) === -1; }));
    entering.forEach(function (key) { return isLeaving.delete(key); });
    var leaving = prevKeys.filter(function (key) {
        return !entering.has(key) && (isLeaving.has(key) || nextKeys.indexOf(key) === -1);
    });
    leaving.forEach(function (key) { return isLeaving.add(key); });
    var moving = new Set(prevKeys.filter(function (key, i) {
        var nextIndex = nextKeys.indexOf(key);
        return !entering.has(key) && nextIndex !== -1 && i !== nextIndex;
    }));
    incomingChildren.forEach(function (child) {
        var newChildProps = entering.has(child.key)
            ? { initialPose: preEnterPose, _pose: enterPose }
            : moving.has(child.key) && flipMove
                ? { _pose: [enterPose, 'flip'] }
                : { _pose: enterPose };
        children.push(cloneElement$1(child, newChildProps));
    });
    leaving.forEach(function (key) {
        var child = displayedChildren.find(function (c) { return c.key === key; });
        var newChild = cloneElement$1(child, {
            _pose: exitPose,
            onPoseComplete: removeFromTree(key),
            popFromFlow: flipMove
        });
        var insertionIndex = prevKeys.indexOf(key);
        children.splice(insertionIndex, 0, newChild);
    });
    return children;
};
var handleIncomingChildren = function (props) {
    var displayedChildren = props.displayedChildren, incomingChildren = props.incomingChildren, animateOnMount = props.animateOnMount, preEnterPose = props.preEnterPose, enterPose = props.enterPose;
    if (!displayedChildren && animateOnMount) {
        return animateChildrenList(incomingChildren, enterPose, preEnterPose);
    }
    else if (displayedChildren) {
        return mergeChildren(props);
    }
    else {
        return animateChildrenList(incomingChildren, enterPose);
    }
};
var makeChildList = function (children) {
    var list = [];
    Children$1.forEach(children, function (child) { return child && list.push(child); });
    return list;
};
var removeFromChildren = function (children, key) { return children.filter(function (child) { return child.key !== key; }); };

var PoseGroup = (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__extends"])(PoseGroup, _super);
    function PoseGroup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            incomingChildren: [],
            isLeaving: new Set(),
            removeFromTree: function (key) { return function () {
                var isLeaving = _this.state.isLeaving;
                isLeaving.delete(key);
                _this.removeFromChildren(key);
            }; }
        };
        return _this;
    }
    PoseGroup.prototype.removeFromChildren = function (key) {
        var children = this.state.children;
        this.setState({
            children: removeFromChildren(children, key)
        });
    };
    PoseGroup.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        return this.state !== nextState;
    };
    PoseGroup.prototype.render = function () {
        return Object(react__WEBPACK_IMPORTED_MODULE_1__["createElement"])(react__WEBPACK_IMPORTED_MODULE_1__["Fragment"], null, this.state.children);
    };
    PoseGroup.defaultProps = {
        flipMove: true,
        preEnterPose: 'exit',
        enterPose: 'enter',
        exitPose: 'exit',
        singleChildOnly: false
    };
    PoseGroup.getDerivedStateFromProps = function (props, _a) {
        var isLeaving = _a.isLeaving, removeFromTree = _a.removeFromTree, children = _a.children;
        var incomingChildren = makeChildList(props.children);
        return {
            incomingChildren: incomingChildren,
            children: handleIncomingChildren({
                incomingChildren: incomingChildren,
                displayedChildren: children,
                isLeaving: isLeaving,
                removeFromTree: removeFromTree,
                enterPose: props.enterPose,
                exitPose: props.exitPose,
                flipMove: props.flipMove,
                animateOnMount: props.animateOnMount,
                preEnterPose: props.preEnterPose
            })
        };
    };
    return PoseGroup;
}(react__WEBPACK_IMPORTED_MODULE_1__["Component"]));

/* harmony default export */ __webpack_exports__["default"] = (posed);



/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.5.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.5.0';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for('react.placeholder') : 0xead1;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function () {};

{
  validateFormat = function (format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error = void 0;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

// Relying on the `invariant()` implementation lets us
// preserve the format and params in the www builds.

// Exports ReactDOM.createRoot


// Experimental error-boundary API that can recover from errors within a single
// render phase

// Suspense
var enableSuspense = false;
// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:


// In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:


// To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.


// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:


// Warn about legacy context API


// Gather advanced timing metrics for Profiler subtrees.


// Track which interactions trigger each commit.


// Only used in www builds.


// Only used in www builds.

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warningWithoutStack = function () {};

{
  warningWithoutStack = function (condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (condition) {
      return;
    }
    if (typeof console !== 'undefined') {
      var _console;

      var stringArgs = args.map(function (item) {
        return '' + item;
      });
      (_console = console).error.apply(_console, ['Warning: ' + format].concat(stringArgs));
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      throw new Error(message);
    } catch (x) {}
  };
}

var warningWithoutStack$1 = warningWithoutStack;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warningWithoutStack$1(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};
{
  Object.freeze(emptyObject);
}

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  // If a component has string refs, we will assign a different object later.
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;

/**
 * Convenience component with default shallow equality check for sCU.
 */
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  // If a component has string refs, we will assign a different object later.
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };
  {
    Object.seal(refObject);
  }
  return refObject;
}

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null,
  currentDispatcher: null
};

var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

var describeComponentFrame = function (name, source, ownerName) {
  var sourceInfo = '';
  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');
    {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);
        if (match) {
          var pathBeforeSlash = match[1];
          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }
    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }
  return '\n    in ' + (name || 'Unknown') + sourceInfo;
};

var Resolved = 1;




function refineResolvedThenable(thenable) {
  return thenable._reactStatus === Resolved ? thenable._reactResult : null;
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }
  {
    if (typeof type.tag === 'number') {
      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }
  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }
  if (typeof type === 'string') {
    return type;
  }
  switch (type) {
    case REACT_ASYNC_MODE_TYPE:
      return 'AsyncMode';
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';
    case REACT_PORTAL_TYPE:
      return 'Portal';
    case REACT_PROFILER_TYPE:
      return 'Profiler';
    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';
    case REACT_PLACEHOLDER_TYPE:
      return 'Placeholder';
  }
  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return 'Context.Consumer';
      case REACT_PROVIDER_TYPE:
        return 'Context.Provider';
      case REACT_FORWARD_REF_TYPE:
        var renderFn = type.render;
        var functionName = renderFn.displayName || renderFn.name || '';
        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
    }
    if (typeof type.then === 'function') {
      var thenable = type;
      var resolvedThenable = refineResolvedThenable(thenable);
      if (resolvedThenable) {
        return getComponentName(resolvedThenable);
      }
    }
  }
  return null;
}

var ReactDebugCurrentFrame = {};

var currentlyValidatingElement = null;

function setCurrentlyValidatingElement(element) {
  {
    currentlyValidatingElement = element;
  }
}

{
  // Stack implementation injected by the current renderer.
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = '';

    // Add an extra top frame while an element is being validated
    if (currentlyValidatingElement) {
      var name = getComponentName(currentlyValidatingElement.type);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
    }

    // Delegate to the injected renderer-specific implementation
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

var ReactSharedInternals = {
  ReactCurrentOwner: ReactCurrentOwner,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  _assign(ReactSharedInternals, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = warningWithoutStack$1;

{
  warning = function (condition, format) {
    if (condition) {
      return;
    }
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();
    // eslint-disable-next-line react-internal/warning-and-invariant-args

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));
  };
}

var warning$1 = warning;

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown = void 0;
var specialPropRefWarningShown = void 0;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName = void 0;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }
      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;

  var propName = void 0;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps = void 0;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child = void 0;
  var nextName = void 0;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step = void 0;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
      return c;
    });
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children) {
  return traverseAllChildren(children, function () {
    return null;
  }, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
    return child;
  });
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

function readContext(context, observedBits) {
  var dispatcher = ReactCurrentOwner.currentDispatcher;
  !(dispatcher !== null) ? invariant(false, 'Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps.') : void 0;
  return dispatcher.readContext(context, observedBits);
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // These are circular
    Provider: null,
    Consumer: null,
    unstable_read: null
  };

  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  context.Consumer = context;
  context.unstable_read = readContext.bind(null, context);

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

function lazy(ctor) {
  var thenable = null;
  return {
    then: function (resolve, reject) {
      if (thenable === null) {
        // Lazily create thenable by wrapping in an extra thenable.
        thenable = ctor();
        ctor = null;
      }
      return thenable.then(resolve, reject);
    },

    // React uses these fields to store the result.
    _reactStatus: -1,
    _reactResult: null
  };
}

function forwardRef(render) {
  {
    if (typeof render !== 'function') {
      warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      !(render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept two parameters: props and ref. ' + 'Did you forget to use the ref parameter?') : void 0;
    }

    if (render != null) {
      !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
    }
  }

  return {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
}

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' ||
  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_PLACEHOLDER_TYPE || typeof type === 'object' && type !== null && (typeof type.then === 'function' || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

var propTypesMisspellWarningShown = void 0;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner.type) + '.';
  }

  setCurrentlyValidatingElement(element);
  {
    warning$1(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
  }
  setCurrentlyValidatingElement(null);
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step = void 0;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var type = element.type;
  var name = void 0,
      propTypes = void 0;
  if (typeof type === 'function') {
    // Class or functional component
    name = type.displayName || type.name;
    propTypes = type.propTypes;
  } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {
    // ForwardRef
    var functionName = type.render.displayName || type.render.name || '';
    name = functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
    propTypes = type.propTypes;
  } else {
    return;
  }
  if (propTypes) {
    setCurrentlyValidatingElement(element);
    checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
    setCurrentlyValidatingElement(null);
  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof type.getDefaultProps === 'function') {
    !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  setCurrentlyValidatingElement(fragment);

  var keys = Object.keys(fragment.props);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key !== 'children' && key !== 'key') {
      warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
      break;
    }
  }

  if (fragment.ref !== null) {
    warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');
  }

  setCurrentlyValidatingElement(null);
}

function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type);

  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString = void 0;
    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = '<' + (getComponentName(type.type) || 'Unknown') + ' />';
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;
  // Legacy hook: remove it
  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  createRef: createRef,
  Component: Component,
  PureComponent: PureComponent,

  createContext: createContext,
  forwardRef: forwardRef,

  Fragment: REACT_FRAGMENT_TYPE,
  StrictMode: REACT_STRICT_MODE_TYPE,
  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,
  unstable_Profiler: REACT_PROFILER_TYPE,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals
};

if (enableSuspense) {
  React.Placeholder = REACT_PLACEHOLDER_TYPE;
  React.lazy = lazy;
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3.default || React$3;

module.exports = react;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/schedule/cjs/schedule-tracking.development.js":
/*!********************************************************************!*\
  !*** ./node_modules/schedule/cjs/schedule-tracking.development.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.5.0
 * schedule-tracking.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

{
  
}

// Relying on the `invariant()` implementation lets us
// preserve the format and params in the www builds.

// Exports ReactDOM.createRoot


// Experimental error-boundary API that can recover from errors within a single
// render phase

// Suspense

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:


// In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:


// To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.


// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:


// Warn about legacy context API


// Gather advanced timing metrics for Profiler subtrees.


// Track which interactions trigger each commit.
var enableSchedulerTracking = true;

// Only used in www builds.


// Only used in www builds.

var DEFAULT_THREAD_ID = 0;

// Counters used to generate unique IDs.
var interactionIDCounter = 0;
var threadIDCounter = 0;

// Set of currently tracked interactions.
// Interactions "stack"–
// Meaning that newly tracked interactions are appended to the previously active set.
// When an interaction goes out of scope, the previous set (if any) is restored.
exports.__interactionsRef = null;

// Listener(s) to notify when interactions begin and end.
exports.__subscriberRef = null;

if (enableSchedulerTracking) {
  exports.__interactionsRef = {
    current: new Set()
  };
  exports.__subscriberRef = {
    current: null
  };
}

function unstable_clear(callback) {
  if (!enableSchedulerTracking) {
    return callback();
  }

  var prevInteractions = exports.__interactionsRef.current;
  exports.__interactionsRef.current = new Set();

  try {
    return callback();
  } finally {
    exports.__interactionsRef.current = prevInteractions;
  }
}

function unstable_getCurrent() {
  if (!enableSchedulerTracking) {
    return null;
  } else {
    return exports.__interactionsRef.current;
  }
}

function unstable_getThreadID() {
  return ++threadIDCounter;
}

function unstable_track(name, timestamp, callback) {
  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

  if (!enableSchedulerTracking) {
    return callback();
  }

  var interaction = {
    __count: 1,
    id: interactionIDCounter++,
    name: name,
    timestamp: timestamp
  };

  var prevInteractions = exports.__interactionsRef.current;

  // Tracked interactions should stack/accumulate.
  // To do that, clone the current interactions.
  // The previous set will be restored upon completion.
  var interactions = new Set(prevInteractions);
  interactions.add(interaction);
  exports.__interactionsRef.current = interactions;

  var subscriber = exports.__subscriberRef.current;
  var returnValue = void 0;

  try {
    if (subscriber !== null) {
      subscriber.onInteractionTracked(interaction);
    }
  } finally {
    try {
      if (subscriber !== null) {
        subscriber.onWorkStarted(interactions, threadID);
      }
    } finally {
      try {
        returnValue = callback();
      } finally {
        exports.__interactionsRef.current = prevInteractions;

        try {
          if (subscriber !== null) {
            subscriber.onWorkStopped(interactions, threadID);
          }
        } finally {
          interaction.__count--;

          // If no async work was scheduled for this interaction,
          // Notify subscribers that it's completed.
          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        }
      }
    }
  }

  return returnValue;
}

function unstable_wrap(callback) {
  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

  if (!enableSchedulerTracking) {
    return callback;
  }

  var wrappedInteractions = exports.__interactionsRef.current;

  var subscriber = exports.__subscriberRef.current;
  if (subscriber !== null) {
    subscriber.onWorkScheduled(wrappedInteractions, threadID);
  }

  // Update the pending async work count for the current interactions.
  // Update after calling subscribers in case of error.
  wrappedInteractions.forEach(function (interaction) {
    interaction.__count++;
  });

  var hasRun = false;

  function wrapped() {
    var prevInteractions = exports.__interactionsRef.current;
    exports.__interactionsRef.current = wrappedInteractions;

    subscriber = exports.__subscriberRef.current;

    try {
      var returnValue = void 0;

      try {
        if (subscriber !== null) {
          subscriber.onWorkStarted(wrappedInteractions, threadID);
        }
      } finally {
        try {
          returnValue = callback.apply(undefined, arguments);
        } finally {
          exports.__interactionsRef.current = prevInteractions;

          if (subscriber !== null) {
            subscriber.onWorkStopped(wrappedInteractions, threadID);
          }
        }
      }

      return returnValue;
    } finally {
      if (!hasRun) {
        // We only expect a wrapped function to be executed once,
        // But in the event that it's executed more than once–
        // Only decrement the outstanding interaction counts once.
        hasRun = true;

        // Update pending async counts for all wrapped interactions.
        // If this was the last scheduled async work for any of them,
        // Mark them as completed.
        wrappedInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        });
      }
    }
  }

  wrapped.cancel = function cancel() {
    subscriber = exports.__subscriberRef.current;

    try {
      if (subscriber !== null) {
        subscriber.onWorkCanceled(wrappedInteractions, threadID);
      }
    } finally {
      // Update pending async counts for all wrapped interactions.
      // If this was the last scheduled async work for any of them,
      // Mark them as completed.
      wrappedInteractions.forEach(function (interaction) {
        interaction.__count--;

        if (subscriber && interaction.__count === 0) {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        }
      });
    }
  };

  return wrapped;
}

var subscribers = null;
if (enableSchedulerTracking) {
  subscribers = new Set();
}

function unstable_subscribe(subscriber) {
  if (enableSchedulerTracking) {
    subscribers.add(subscriber);

    if (subscribers.size === 1) {
      exports.__subscriberRef.current = {
        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
        onInteractionTracked: onInteractionTracked,
        onWorkCanceled: onWorkCanceled,
        onWorkScheduled: onWorkScheduled,
        onWorkStarted: onWorkStarted,
        onWorkStopped: onWorkStopped
      };
    }
  }
}

function unstable_unsubscribe(subscriber) {
  if (enableSchedulerTracking) {
    subscribers.delete(subscriber);

    if (subscribers.size === 0) {
      exports.__subscriberRef.current = null;
    }
  }
}

function onInteractionTracked(interaction) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionTracked(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onInteractionScheduledWorkCompleted(interaction) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionScheduledWorkCompleted(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkScheduled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkScheduled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStarted(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStarted(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStopped(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStopped(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkCanceled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;

  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkCanceled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

exports.unstable_clear = unstable_clear;
exports.unstable_getCurrent = unstable_getCurrent;
exports.unstable_getThreadID = unstable_getThreadID;
exports.unstable_track = unstable_track;
exports.unstable_wrap = unstable_wrap;
exports.unstable_subscribe = unstable_subscribe;
exports.unstable_unsubscribe = unstable_unsubscribe;
  })();
}


/***/ }),

/***/ "./node_modules/schedule/cjs/schedule.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/schedule/cjs/schedule.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.5.0
 * schedule.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * A scheduling library to allow scheduling work with more granular priority and
 * control than requestAnimationFrame and requestIdleCallback.
 * Current TODO items:
 * X- Pull out the scheduleWork polyfill built into React
 * X- Initial test coverage
 * X- Support for multiple callbacks
 * - Support for two priorities; serial and deferred
 * - Better test coverage
 * - Better docblock
 * - Polish documentation, API
 */

// This is a built-in polyfill for requestIdleCallback. It works by scheduling
// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.

// We capture a local reference to any global, in case it gets polyfilled after
// this module is initially evaluated.
// We want to be using a consistent implementation.
var localDate = Date;

// This initialization code may run even on server environments
// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.
// However, we always expect them to be defined on the client.
// https://github.com/facebook/react/pull/13088
var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;

// We don't expect either of these to necessarily be defined,
// but we will error later if they are missing on the client.
var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;
var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;

var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

exports.unstable_now = void 0;
if (hasNativePerformanceNow) {
  var Performance = performance;
  exports.unstable_now = function () {
    return Performance.now();
  };
} else {
  exports.unstable_now = function () {
    return localDate.now();
  };
}

exports.unstable_scheduleWork = void 0;
exports.unstable_cancelScheduledWork = void 0;

if (!canUseDOM) {
  var timeoutIds = new Map();

  exports.unstable_scheduleWork = function (callback, options) {
    // keeping return type consistent
    var callbackConfig = {
      scheduledCallback: callback,
      timeoutTime: 0,
      next: null,
      prev: null
    };
    var timeoutId = localSetTimeout(function () {
      callback({
        timeRemaining: function () {
          return Infinity;
        },

        didTimeout: false
      });
    });
    timeoutIds.set(callback, timeoutId);
    return callbackConfig;
  };
  exports.unstable_cancelScheduledWork = function (callbackId) {
    var callback = callbackId.scheduledCallback;
    var timeoutId = timeoutIds.get(callback);
    timeoutIds.delete(callbackId);
    localClearTimeout(timeoutId);
  };
} else {
  {
    if (typeof console !== 'undefined') {
      if (typeof localRequestAnimationFrame !== 'function') {
        console.error("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
      }
      if (typeof localCancelAnimationFrame !== 'function') {
        console.error("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
      }
    }
  }

  var headOfPendingCallbacksLinkedList = null;
  var tailOfPendingCallbacksLinkedList = null;

  // We track what the next soonest timeoutTime is, to be able to quickly tell
  // if none of the scheduled callbacks have timed out.
  var nextSoonestTimeoutTime = -1;

  var isIdleScheduled = false;
  var isAnimationFrameScheduled = false;

  // requestAnimationFrame does not run when the tab is in the background.
  // if we're backgrounded we prefer for that work to happen so that the page
  // continues	to load in the background.
  // so we also schedule a 'setTimeout' as a fallback.
  var animationFrameTimeout = 100;
  var rafID = void 0;
  var timeoutID = void 0;
  var scheduleAnimationFrameWithFallbackSupport = function (callback) {
    // schedule rAF and also a setTimeout
    rafID = localRequestAnimationFrame(function (timestamp) {
      // cancel the setTimeout
      localClearTimeout(timeoutID);
      callback(timestamp);
    });
    timeoutID = localSetTimeout(function () {
      // cancel the requestAnimationFrame
      localCancelAnimationFrame(rafID);
      callback(exports.unstable_now());
    }, animationFrameTimeout);
  };

  var frameDeadline = 0;
  // We start out assuming that we run at 30fps but then the heuristic tracking
  // will adjust this value to a faster fps if we get more frequent animation
  // frames.
  var previousFrameTime = 33;
  var activeFrameTime = 33;

  var frameDeadlineObject = {
    didTimeout: false,
    timeRemaining: function () {
      var remaining = frameDeadline - exports.unstable_now();
      return remaining > 0 ? remaining : 0;
    }
  };

  /**
   * Handles the case where a callback errors:
   * - don't catch the error, because this changes debugging behavior
   * - do start a new postMessage callback, to call any remaining callbacks,
   * - but only if there is an error, so there is not extra overhead.
   */
  var callUnsafely = function (callbackConfig, arg) {
    var callback = callbackConfig.scheduledCallback;
    var finishedCalling = false;
    try {
      callback(arg);
      finishedCalling = true;
    } finally {
      // always remove it from linked list
      exports.unstable_cancelScheduledWork(callbackConfig);

      if (!finishedCalling) {
        // an error must have been thrown
        isIdleScheduled = true;
        window.postMessage(messageKey, '*');
      }
    }
  };

  /**
   * Checks for timed out callbacks, runs them, and then checks again to see if
   * any more have timed out.
   * Keeps doing this until there are none which have currently timed out.
   */
  var callTimedOutCallbacks = function () {
    if (headOfPendingCallbacksLinkedList === null) {
      return;
    }

    var currentTime = exports.unstable_now();
    // TODO: this would be more efficient if deferred callbacks are stored in
    // min heap.
    // Or in a linked list with links for both timeoutTime order and insertion
    // order.
    // For now an easy compromise is the current approach:
    // Keep a pointer to the soonest timeoutTime, and check that first.
    // If it has not expired, we can skip traversing the whole list.
    // If it has expired, then we step through all the callbacks.
    if (nextSoonestTimeoutTime === -1 || nextSoonestTimeoutTime > currentTime) {
      // We know that none of them have timed out yet.
      return;
    }
    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until
    // after successfully calling any timed out callbacks.
    // If a timed out callback throws an error, we could get stuck in a state
    // where the nextSoonestTimeoutTime was set wrong.
    var updatedNextSoonestTimeoutTime = -1; // we will update nextSoonestTimeoutTime below
    var timedOutCallbacks = [];

    // iterate once to find timed out callbacks and find nextSoonestTimeoutTime
    var currentCallbackConfig = headOfPendingCallbacksLinkedList;
    while (currentCallbackConfig !== null) {
      var _timeoutTime = currentCallbackConfig.timeoutTime;
      if (_timeoutTime !== -1 && _timeoutTime <= currentTime) {
        // it has timed out!
        timedOutCallbacks.push(currentCallbackConfig);
      } else {
        if (_timeoutTime !== -1 && (updatedNextSoonestTimeoutTime === -1 || _timeoutTime < updatedNextSoonestTimeoutTime)) {
          updatedNextSoonestTimeoutTime = _timeoutTime;
        }
      }
      currentCallbackConfig = currentCallbackConfig.next;
    }

    if (timedOutCallbacks.length > 0) {
      frameDeadlineObject.didTimeout = true;
      for (var i = 0, len = timedOutCallbacks.length; i < len; i++) {
        callUnsafely(timedOutCallbacks[i], frameDeadlineObject);
      }
    }

    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until
    // after successfully calling any timed out callbacks.
    nextSoonestTimeoutTime = updatedNextSoonestTimeoutTime;
  };

  // We use the postMessage trick to defer idle work until after the repaint.
  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
  var idleTick = function (event) {
    if (event.source !== window || event.data !== messageKey) {
      return;
    }
    isIdleScheduled = false;

    if (headOfPendingCallbacksLinkedList === null) {
      return;
    }

    // First call anything which has timed out, until we have caught up.
    callTimedOutCallbacks();

    var currentTime = exports.unstable_now();
    // Next, as long as we have idle time, try calling more callbacks.
    while (frameDeadline - currentTime > 0 && headOfPendingCallbacksLinkedList !== null) {
      var latestCallbackConfig = headOfPendingCallbacksLinkedList;
      frameDeadlineObject.didTimeout = false;
      // callUnsafely will remove it from the head of the linked list
      callUnsafely(latestCallbackConfig, frameDeadlineObject);
      currentTime = exports.unstable_now();
    }
    if (headOfPendingCallbacksLinkedList !== null) {
      if (!isAnimationFrameScheduled) {
        // Schedule another animation callback so we retry later.
        isAnimationFrameScheduled = true;
        scheduleAnimationFrameWithFallbackSupport(animationTick);
      }
    }
  };
  // Assumes that we have addEventListener in this environment. Might need
  // something better for old IE.
  window.addEventListener('message', idleTick, false);

  var animationTick = function (rafTime) {
    isAnimationFrameScheduled = false;
    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
      if (nextFrameTime < 8) {
        // Defensive coding. We don't support higher frame rates than 120hz.
        // If we get lower than that, it is probably a bug.
        nextFrameTime = 8;
      }
      // If one frame goes long, then the next one can be short to catch up.
      // If two frames are short in a row, then that's an indication that we
      // actually have a higher frame rate than what we're currently optimizing.
      // We adjust our heuristic dynamically accordingly. For example, if we're
      // running on 120hz display or 90hz VR display.
      // Take the max of the two in case one of them was an anomaly due to
      // missed frame deadlines.
      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
    } else {
      previousFrameTime = nextFrameTime;
    }
    frameDeadline = rafTime + activeFrameTime;
    if (!isIdleScheduled) {
      isIdleScheduled = true;
      window.postMessage(messageKey, '*');
    }
  };

  exports.unstable_scheduleWork = function (callback, options) /* CallbackConfigType */{
    var timeoutTime = -1;
    if (options != null && typeof options.timeout === 'number') {
      timeoutTime = exports.unstable_now() + options.timeout;
    }
    if (nextSoonestTimeoutTime === -1 || timeoutTime !== -1 && timeoutTime < nextSoonestTimeoutTime) {
      nextSoonestTimeoutTime = timeoutTime;
    }

    var scheduledCallbackConfig = {
      scheduledCallback: callback,
      timeoutTime: timeoutTime,
      prev: null,
      next: null
    };
    if (headOfPendingCallbacksLinkedList === null) {
      // Make this callback the head and tail of our list
      headOfPendingCallbacksLinkedList = scheduledCallbackConfig;
      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;
    } else {
      // Add latest callback as the new tail of the list
      scheduledCallbackConfig.prev = tailOfPendingCallbacksLinkedList;
      // renaming for clarity
      var oldTailOfPendingCallbacksLinkedList = tailOfPendingCallbacksLinkedList;
      if (oldTailOfPendingCallbacksLinkedList !== null) {
        oldTailOfPendingCallbacksLinkedList.next = scheduledCallbackConfig;
      }
      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;
    }

    if (!isAnimationFrameScheduled) {
      // If rAF didn't already schedule one, we need to schedule a frame.
      // TODO: If this rAF doesn't materialize because the browser throttles, we
      // might want to still have setTimeout trigger scheduleWork as a backup to ensure
      // that we keep performing work.
      isAnimationFrameScheduled = true;
      scheduleAnimationFrameWithFallbackSupport(animationTick);
    }
    return scheduledCallbackConfig;
  };

  exports.unstable_cancelScheduledWork = function (callbackConfig /* CallbackConfigType */
  ) {
    if (callbackConfig.prev === null && headOfPendingCallbacksLinkedList !== callbackConfig) {
      // this callbackConfig has already been cancelled.
      // cancelScheduledWork should be idempotent, a no-op after first call.
      return;
    }

    /**
     * There are four possible cases:
     * - Head/nodeToRemove/Tail -> null
     *   In this case we set Head and Tail to null.
     * - Head -> ... middle nodes... -> Tail/nodeToRemove
     *   In this case we point the middle.next to null and put middle as the new
     *   Tail.
     * - Head/nodeToRemove -> ...middle nodes... -> Tail
     *   In this case we point the middle.prev at null and move the Head to
     *   middle.
     * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail
     *   In this case we point the Head.next to the Tail and the Tail.prev to
     *   the Head.
     */
    var next = callbackConfig.next;
    var prev = callbackConfig.prev;
    callbackConfig.next = null;
    callbackConfig.prev = null;
    if (next !== null) {
      // we have a next

      if (prev !== null) {
        // we have a prev

        // callbackConfig is somewhere in the middle of a list of 3 or more nodes.
        prev.next = next;
        next.prev = prev;
        return;
      } else {
        // there is a next but not a previous one;
        // callbackConfig is the head of a list of 2 or more other nodes.
        next.prev = null;
        headOfPendingCallbacksLinkedList = next;
        return;
      }
    } else {
      // there is no next callback config; this must the tail of the list

      if (prev !== null) {
        // we have a prev

        // callbackConfig is the tail of a list of 2 or more other nodes.
        prev.next = null;
        tailOfPendingCallbacksLinkedList = prev;
        return;
      } else {
        // there is no previous callback config;
        // callbackConfig is the only thing in the linked list,
        // so both head and tail point to it.
        headOfPendingCallbacksLinkedList = null;
        tailOfPendingCallbacksLinkedList = null;
        return;
      }
    }
  };
}
  })();
}


/***/ }),

/***/ "./node_modules/schedule/index.js":
/*!****************************************!*\
  !*** ./node_modules/schedule/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/schedule.development.js */ "./node_modules/schedule/cjs/schedule.development.js");
}


/***/ }),

/***/ "./node_modules/schedule/tracking.js":
/*!*******************************************!*\
  !*** ./node_modules/schedule/tracking.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/schedule-tracking.development.js */ "./node_modules/schedule/cjs/schedule-tracking.development.js");
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/style-value-types/dist/style-value-types.es.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-value-types/dist/style-value-types.es.js ***!
  \*********************************************************************/
/*! exports provided: number, scale, alpha, degrees, percent, px, vw, vh, rgba, rgbUnit, hex, hsla, color, complex */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "number", function() { return number; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alpha", function() { return alpha; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "percent", function() { return percent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "px", function() { return px; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vw", function() { return vw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vh", function() { return vh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgba", function() { return rgba; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbUnit", function() { return rgbUnit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hex", function() { return hex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsla", function() { return hsla; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "color", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "complex", function() { return complex; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var clamp = function (min, max) { return function (v) {
    return Math.max(Math.min(v, max), min);
}; };
var isFirstChars = function (term) { return function (v) {
    return typeof v === 'string' && v.indexOf(term) === 0;
}; };
var getValueFromFunctionString = function (value) {
    return value.substring(value.indexOf('(') + 1, value.lastIndexOf(')'));
};
var splitCommaDelimited = function (value) {
    return typeof value === 'string' ? value.split(/,\s*/) : [value];
};
var sanitize = function (v) { return (v % 1 ? Number(v.toFixed(5)) : v); };

var number = {
    test: function (v) { return typeof v === 'number'; },
    parse: parseFloat,
    transform: function (v) { return v; }
};
var alpha = __assign({}, number, { transform: clamp(0, 1) });
var scale = __assign({}, number, { default: 1 });

var createUnitType = function (unit) { return ({
    test: function (v) {
        return typeof v === 'string' && v.endsWith(unit) && v.split(' ').length === 1;
    },
    parse: parseFloat,
    transform: function (v) { return "" + v + unit; }
}); };
var degrees = createUnitType('deg');
var percent = createUnitType('%');
var px = createUnitType('px');
var vh = createUnitType('vh');
var vw = createUnitType('vw');

var clampRgbUnit = clamp(0, 255);
var onlyColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))$/i;
var isRgba = function (v) { return v.red !== undefined; };
var isHsla = function (v) { return v.hue !== undefined; };
var splitColorValues = function (terms) {
    var numTerms = terms.length;
    return function (v) {
        if (typeof v !== 'string')
            return v;
        var values = {};
        var valuesArray = splitCommaDelimited(getValueFromFunctionString(v));
        for (var i = 0; i < numTerms; i++) {
            values[terms[i]] =
                valuesArray[i] !== undefined ? parseFloat(valuesArray[i]) : 1;
        }
        return values;
    };
};
var rgbaTemplate = function (_a) {
    var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;
    return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha$$1 + ")";
};
var hslaTemplate = function (_a) {
    var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$$1 = _b === void 0 ? 1 : _b;
    return "hsla(" + hue + ", " + saturation + ", " + lightness + ", " + alpha$$1 + ")";
};
var rgbUnit = __assign({}, number, { transform: function (v) { return Math.round(clampRgbUnit(v)); } });
var testRgbaString = isFirstChars('rgb');
var rgba = {
    test: function (v) { return (typeof v === 'string' ? testRgbaString(v) : isRgba(v)); },
    parse: splitColorValues(['red', 'green', 'blue', 'alpha']),
    transform: function (_a) {
        var red = _a.red, green = _a.green, blue = _a.blue, alpha$$1 = _a.alpha;
        return rgbaTemplate({
            red: rgbUnit.transform(red),
            green: rgbUnit.transform(green),
            blue: rgbUnit.transform(blue),
            alpha: sanitize(alpha$$1)
        });
    }
};
var testHslaString = isFirstChars('hsl');
var hsla = {
    test: function (v) { return (typeof v === 'string' ? testHslaString(v) : isHsla(v)); },
    parse: splitColorValues(['hue', 'saturation', 'lightness', 'alpha']),
    transform: function (_a) {
        var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, alpha$$1 = _a.alpha;
        return hslaTemplate({
            hue: Math.round(hue),
            saturation: percent.transform(sanitize(saturation)),
            lightness: percent.transform(sanitize(lightness)),
            alpha: sanitize(alpha$$1)
        });
    }
};
var hex = __assign({}, rgba, { test: isFirstChars('#'), parse: function (v) {
        var r = '';
        var g = '';
        var b = '';
        if (v.length > 4) {
            r = v.substr(1, 2);
            g = v.substr(3, 2);
            b = v.substr(5, 2);
        }
        else {
            r = v.substr(1, 1);
            g = v.substr(2, 1);
            b = v.substr(3, 1);
            r += r;
            g += g;
            b += b;
        }
        return {
            red: parseInt(r, 16),
            green: parseInt(g, 16),
            blue: parseInt(b, 16),
            alpha: 1
        };
    } });
var color = {
    test: function (v) {
        return (typeof v === 'string' && onlyColorRegex.test(v)) ||
            rgba.test(v) ||
            hsla.test(v) ||
            hex.test(v);
    },
    parse: function (v) {
        if (rgba.test(v)) {
            return rgba.parse(v);
        }
        else if (hsla.test(v)) {
            return hsla.parse(v);
        }
        else if (hex.test(v)) {
            return hex.parse(v);
        }
        return v;
    },
    transform: function (v) {
        if (isRgba(v)) {
            return rgba.transform(v);
        }
        else if (isHsla(v)) {
            return hsla.transform(v);
        }
        return v;
    }
};

var floatRegex = /(-)?(\d[\d\.]*)/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var COLOR_TOKEN = '${c}';
var NUMBER_TOKEN = '${n}';
var complex = {
    test: function (v) {
        if (typeof v !== 'string' || !isNaN(v))
            return false;
        var numValues = 0;
        var foundNumbers = v.match(floatRegex);
        var foundColors = v.match(colorRegex);
        if (foundNumbers)
            numValues += foundNumbers.length;
        if (foundColors)
            numValues += foundColors.length;
        return numValues > 0;
    },
    parse: function (v) {
        var input = v;
        var parsed = [];
        var foundColors = input.match(colorRegex);
        if (foundColors) {
            input = input.replace(colorRegex, COLOR_TOKEN);
            parsed.push.apply(parsed, foundColors.map(color.parse));
        }
        var foundNumbers = input.match(floatRegex);
        if (foundNumbers) {
            parsed.push.apply(parsed, foundNumbers.map(number.parse));
        }
        return parsed;
    },
    createTransformer: function (prop) {
        var template = prop;
        var token = 0;
        var foundColors = prop.match(colorRegex);
        var numColors = foundColors ? foundColors.length : 0;
        if (foundColors) {
            for (var i = 0; i < numColors; i++) {
                template = template.replace(foundColors[i], COLOR_TOKEN);
                token++;
            }
        }
        var foundNumbers = template.match(floatRegex);
        var numNumbers = foundNumbers ? foundNumbers.length : 0;
        if (foundNumbers) {
            for (var i = 0; i < numNumbers; i++) {
                template = template.replace(foundNumbers[i], NUMBER_TOKEN);
                token++;
            }
        }
        return function (v) {
            var output = template;
            for (var i = 0; i < token; i++) {
                output = output.replace(i < numColors ? COLOR_TOKEN : NUMBER_TOKEN, i < numColors ? color.transform(v[i]) : sanitize(v[i]));
            }
            return output;
        };
    }
};




/***/ }),

/***/ "./node_modules/stylefire/dist/stylefire.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/stylefire/dist/stylefire.es.js ***!
  \*****************************************************/
/*! exports provided: default, createStylerFactory, buildStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStylerFactory", function() { return createStyler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildStyles", function() { return buildStylePropertyString; });
/* harmony import */ var framesync__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! framesync */ "./node_modules/framesync/dist/framesync.es.js");
/* harmony import */ var style_value_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! style-value-types */ "./node_modules/style-value-types/dist/style-value-types.es.js");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var hey_listen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hey-listen */ "./node_modules/hey-listen/dist/hey-listen.es.js");





var createStyler = function (_a) {
    var onRead = _a.onRead,
        onRender = _a.onRender,
        _b = _a.aliasMap,
        aliasMap = _b === void 0 ? {} : _b,
        _c = _a.useCache,
        useCache = _c === void 0 ? true : _c;
    return function (props) {
        var state = {};
        var changedValues = [];
        var hasChanged = false;
        var setValue = function (unmappedKey, value) {
            var key = aliasMap[unmappedKey] || unmappedKey;
            var currentValue = state[key];
            state[key] = value;
            if (state[key] !== currentValue) {
                if (changedValues.indexOf(key) === -1) {
                    changedValues.push(key);
                }
                if (!hasChanged) {
                    hasChanged = true;
                    Object(framesync__WEBPACK_IMPORTED_MODULE_0__["onFrameRender"])(render);
                }
            }
        };
        function render(forceRender) {
            if (forceRender === void 0) {
                forceRender = false;
            }
            if (forceRender || hasChanged) {
                onRender(state, props, changedValues);
                hasChanged = false;
                changedValues.length = 0;
            }
            return this;
        }
        return {
            get: function (unmappedKey) {
                var key = aliasMap[unmappedKey] || unmappedKey;
                return key ? useCache && state[key] !== undefined ? state[key] : onRead(key, props) : state;
            },
            set: function (values, value) {
                if (typeof values === 'string') {
                    if (value !== undefined) {
                        setValue(values, value);
                    } else {
                        return function (v) {
                            return setValue(values, v);
                        };
                    }
                } else {
                    for (var key in values) {
                        if (values.hasOwnProperty(key)) {
                            setValue(key, values[key]);
                        }
                    }
                }
                return this;
            },
            render: render
        };
    };
};

var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = '$1-$2';
var camelToDash = function (str) {
    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};
var setDomAttrs = function (element, attrs) {
    for (var key in attrs) {
        if (attrs.hasOwnProperty(key)) {
            element.setAttribute(key, attrs[key]);
        }
    }
};

var camelCache = /*#__PURE__*/new Map();
var dashCache = /*#__PURE__*/new Map();
var prefixes = ['Webkit', 'Moz', 'O', 'ms', ''];
var numPrefixes = prefixes.length;
var testElement;
var testPrefix = function (key) {
    if (typeof document === 'undefined') return;
    testElement = testElement || document.createElement('div');
    for (var i = 0; i < numPrefixes; i++) {
        var prefix = prefixes[i];
        var noPrefix = prefix === '';
        var prefixedPropertyName = noPrefix ? key : prefix + key.charAt(0).toUpperCase() + key.slice(1);
        if (prefixedPropertyName in testElement.style) {
            camelCache.set(key, prefixedPropertyName);
            dashCache.set(key, "" + (noPrefix ? '' : '-') + camelToDash(prefixedPropertyName));
        }
    }
};
var prefixer = function (key, asDashCase) {
    if (asDashCase === void 0) {
        asDashCase = false;
    }
    var cache = asDashCase ? dashCache : camelCache;
    if (!cache.has(key)) testPrefix(key);
    return cache.get(key) || key;
};

var axes = ['', 'X', 'Y', 'Z'];
var order = ['translate', 'scale', 'rotate', 'skew', 'transformPerspective'];
var TRANSFORM_ORIGIN_X = 'transformOriginX';
var TRANSFORM_ORIGIN_Y = 'transformOriginY';
var transformProps = /*#__PURE__*/order.reduce(function (acc, key) {
    return axes.reduce(function (axesAcc, axesKey) {
        axesAcc.push(key + axesKey);
        return axesAcc;
    }, acc);
}, ['x', 'y', 'z']);
var transformPropDictionary = /*#__PURE__*/transformProps.reduce(function (dict, key) {
    dict[key] = true;
    return dict;
}, {});
var isTransformProp = function (key) {
    return transformPropDictionary[key] === true;
};
var sortTransformProps = function (a, b) {
    return transformProps.indexOf(a) - transformProps.indexOf(b);
};
var isTransformOriginProp = function (key) {
    return key === TRANSFORM_ORIGIN_X || key === TRANSFORM_ORIGIN_Y;
};

var valueTypes = {
    color: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    backgroundColor: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    outlineColor: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    fill: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    stroke: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    borderColor: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    borderTopColor: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    borderRightColor: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    borderBottomColor: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    borderLeftColor: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    borderRadius: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    width: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    maxWidth: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    height: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    maxHeight: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    top: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    left: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    bottom: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    right: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    rotate: style_value_types__WEBPACK_IMPORTED_MODULE_1__["degrees"],
    rotateX: style_value_types__WEBPACK_IMPORTED_MODULE_1__["degrees"],
    rotateY: style_value_types__WEBPACK_IMPORTED_MODULE_1__["degrees"],
    rotateZ: style_value_types__WEBPACK_IMPORTED_MODULE_1__["degrees"],
    scale: style_value_types__WEBPACK_IMPORTED_MODULE_1__["scale"],
    scaleX: style_value_types__WEBPACK_IMPORTED_MODULE_1__["scale"],
    scaleY: style_value_types__WEBPACK_IMPORTED_MODULE_1__["scale"],
    scaleZ: style_value_types__WEBPACK_IMPORTED_MODULE_1__["scale"],
    skewX: style_value_types__WEBPACK_IMPORTED_MODULE_1__["degrees"],
    skewY: style_value_types__WEBPACK_IMPORTED_MODULE_1__["degrees"],
    distance: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    translateX: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    translateY: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    translateZ: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    perspective: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"],
    opacity: style_value_types__WEBPACK_IMPORTED_MODULE_1__["alpha"],
    transformOriginX: style_value_types__WEBPACK_IMPORTED_MODULE_1__["percent"],
    transformOriginY: style_value_types__WEBPACK_IMPORTED_MODULE_1__["percent"],
    transformOriginZ: style_value_types__WEBPACK_IMPORTED_MODULE_1__["px"]
};
var getValueType = function (key) {
    return valueTypes[key];
};

var aliasMap = {
    x: 'translateX',
    y: 'translateY',
    z: 'translateZ',
    originX: 'transformOriginX',
    originY: 'transformOriginY',
    originZ: 'transformOriginZ'
};
var NUMBER = 'number';
var OBJECT = 'object';
var COLON = ':';
var SEMI_COLON = ';';
var TRANSFORM_ORIGIN = 'transform-origin';
var TRANSFORM = 'transform';
var TRANSLATE_Z = 'translateZ';
var TRANSFORM_NONE = ';transform: none';
var styleRule = function (key, value) {
    return "" + SEMI_COLON + key + COLON + value;
};
function buildStylePropertyString(state, changedValues, enableHardwareAcceleration, blacklist) {
    if (changedValues === void 0) {
        changedValues = true;
    }
    if (enableHardwareAcceleration === void 0) {
        enableHardwareAcceleration = true;
    }
    var valuesToChange = changedValues === true ? Object.keys(state) : changedValues;
    var propertyString = '';
    var transformString = '';
    var hasTransformOrigin = false;
    var transformIsDefault = true;
    var hasTransform = false;
    var transformHasZ = false;
    var numChangedValues = valuesToChange.length;
    for (var i = 0; i < numChangedValues; i++) {
        var key = valuesToChange[i];
        if (isTransformProp(key)) {
            hasTransform = true;
            for (var stateKey in state) {
                if (isTransformProp(stateKey) && valuesToChange.indexOf(stateKey) === -1) {
                    valuesToChange.push(stateKey);
                }
            }
            break;
        }
    }
    valuesToChange.sort(sortTransformProps);
    var totalNumChangedValues = valuesToChange.length;
    for (var i = 0; i < totalNumChangedValues; i++) {
        var key = valuesToChange[i];
        if (blacklist.has(key)) continue;
        var isTransformKey = isTransformProp(key);
        var value = state[key];
        var valueType = getValueType(key);
        if (isTransformKey) {
            if (valueType.default && value !== valueType.default || !valueType.default && value !== 0) {
                transformIsDefault = false;
            }
        }
        if (valueType && (typeof value === NUMBER || typeof value === OBJECT) && valueType.transform) {
            value = valueType.transform(value);
        }
        if (isTransformKey) {
            transformString += key + '(' + value + ') ';
            transformHasZ = key === TRANSLATE_Z ? true : transformHasZ;
        } else if (isTransformOriginProp(key)) {
            state[key] = value;
            hasTransformOrigin = true;
        } else {
            propertyString += styleRule(prefixer(key, true), value);
        }
    }
    if (hasTransformOrigin) {
        propertyString += styleRule(TRANSFORM_ORIGIN, (state.transformOriginX || 0) + " " + (state.transformOriginY || 0) + " " + (state.transformOriginZ || 0));
    }
    if (hasTransform) {
        if (!transformHasZ && enableHardwareAcceleration) {
            transformString += TRANSLATE_Z + "(0)";
        }
        propertyString += styleRule(TRANSFORM, transformIsDefault ? TRANSFORM_NONE : transformString);
    }
    return propertyString;
}

var SCROLL_LEFT = 'scrollLeft';
var SCROLL_TOP = 'scrollTop';
var scrollValues = /*#__PURE__*/new Set([SCROLL_LEFT, SCROLL_TOP]);
var cssStyler = /*#__PURE__*/createStyler({
    onRead: function (key, _a) {
        var element = _a.element,
            preparseOutput = _a.preparseOutput;
        var valueType = getValueType(key);
        if (isTransformProp(key)) {
            return valueType ? valueType.default || 0 : 0;
        } else if (scrollValues.has(key)) {
            return element[key];
        } else {
            var domValue = window.getComputedStyle(element, null).getPropertyValue(prefixer(key, true)) || 0;
            return preparseOutput && valueType && valueType.parse ? valueType.parse(domValue) : domValue;
        }
    },
    onRender: function (state, _a, changedValues) {
        var element = _a.element,
            enableHardwareAcceleration = _a.enableHardwareAcceleration;
        element.style.cssText += buildStylePropertyString(state, changedValues, enableHardwareAcceleration, scrollValues);
        if (changedValues.indexOf(SCROLL_LEFT) !== -1) element.scrollLeft = state.scrollLeft;
        if (changedValues.indexOf(SCROLL_TOP) !== -1) element.scrollTop = state.scrollTop;
    },
    aliasMap: aliasMap,
    uncachedValues: scrollValues
});
var css = function (element, props) {
    return cssStyler(Object(tslib__WEBPACK_IMPORTED_MODULE_2__["__assign"])({ element: element, enableHardwareAcceleration: true, preparseOutput: true }, props));
};

var ZERO_NOT_ZERO = 0.0000001;
var percentToPixels = function (percent$$1, length) {
    return percent$$1 / 100 * length + 'px';
};
var build = function (state, dimensions, isPath, pathLength) {
    var hasTransform = false;
    var hasDashArray = false;
    var props = {};
    var dashArrayStyles = isPath ? {
        pathLength: '0',
        pathSpacing: "" + pathLength
    } : undefined;
    var scale$$1 = state.scale !== undefined ? state.scale || ZERO_NOT_ZERO : state.scaleX || 1;
    var scaleY = state.scaleY !== undefined ? state.scaleY || ZERO_NOT_ZERO : scale$$1 || 1;
    var transformOriginX = dimensions.width * ((state.originX || 50) / 100) + dimensions.x;
    var transformOriginY = dimensions.height * ((state.originY || 50) / 100) + dimensions.y;
    var scaleTransformX = -transformOriginX * (scale$$1 * 1);
    var scaleTransformY = -transformOriginY * (scaleY * 1);
    var scaleReplaceX = transformOriginX / scale$$1;
    var scaleReplaceY = transformOriginY / scaleY;
    var transform = {
        translate: "translate(" + state.translateX + ", " + state.translateY + ") ",
        scale: "translate(" + scaleTransformX + ", " + scaleTransformY + ") scale(" + scale$$1 + ", " + scaleY + ") translate(" + scaleReplaceX + ", " + scaleReplaceY + ") ",
        rotate: "rotate(" + state.rotate + ", " + transformOriginX + ", " + transformOriginY + ") ",
        skewX: "skewX(" + state.skewX + ") ",
        skewY: "skewY(" + state.skewY + ") "
    };
    for (var key in state) {
        if (state.hasOwnProperty(key)) {
            var value = state[key];
            if (isTransformProp(key)) {
                hasTransform = true;
            } else if (isPath && (key === 'pathLength' || key === 'pathSpacing') && typeof value === 'number') {
                hasDashArray = true;
                dashArrayStyles[key] = percentToPixels(value, pathLength);
            } else if (isPath && key === 'pathOffset') {
                props['stroke-dashoffset'] = percentToPixels(-value, pathLength);
            } else {
                props[camelToDash(key)] = value;
            }
        }
    }
    if (hasDashArray) {
        props['stroke-dasharray'] = dashArrayStyles.pathLength + ' ' + dashArrayStyles.pathSpacing;
    }
    if (hasTransform) {
        props.transform = '';
        for (var key in transform) {
            if (transform.hasOwnProperty(key)) {
                var defaultValue = key === 'scale' ? '1' : '0';
                props.transform += transform[key].replace(/undefined/g, defaultValue);
            }
        }
    }
    return props;
};

var valueTypes$1 = {
    fill: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    stroke: style_value_types__WEBPACK_IMPORTED_MODULE_1__["color"],
    scale: style_value_types__WEBPACK_IMPORTED_MODULE_1__["scale"],
    scaleX: style_value_types__WEBPACK_IMPORTED_MODULE_1__["scale"],
    scaleY: style_value_types__WEBPACK_IMPORTED_MODULE_1__["scale"],
    opacity: style_value_types__WEBPACK_IMPORTED_MODULE_1__["alpha"],
    fillOpacity: style_value_types__WEBPACK_IMPORTED_MODULE_1__["alpha"],
    strokeOpacity: style_value_types__WEBPACK_IMPORTED_MODULE_1__["alpha"]
};
var getValueType$1 = function (key) {
    return valueTypes$1[key];
};

var svgStyler = /*#__PURE__*/createStyler({
    onRead: function (key, _a) {
        var element = _a.element;
        if (!isTransformProp(key)) {
            return element.getAttribute(key);
        } else {
            var valueType = getValueType$1(key);
            return valueType ? valueType.default : 0;
        }
    },
    onRender: function (state, _a, changedValues) {
        var dimensions = _a.dimensions,
            element = _a.element,
            isPath = _a.isPath,
            pathLength = _a.pathLength;
        setDomAttrs(element, build(state, dimensions, isPath, pathLength));
    },
    aliasMap: {
        x: 'translateX',
        y: 'translateY',
        background: 'fill'
    }
});
var svg = function (element) {
    var _a = element.getBBox(),
        x = _a.x,
        y = _a.y,
        width = _a.width,
        height = _a.height;
    var props = {
        element: element,
        dimensions: { x: x, y: y, width: width, height: height },
        isPath: false
    };
    if (element.tagName === 'path') {
        props.isPath = true;
        props.pathLength = element.getTotalLength();
    }
    return svgStyler(props);
};

var viewport = /*#__PURE__*/createStyler({
    useCache: false,
    onRead: function (key) {
        return key === 'scrollTop' ? window.pageYOffset : window.pageXOffset;
    },
    onRender: function (_a) {
        var _b = _a.scrollTop,
            scrollTop = _b === void 0 ? 0 : _b,
            _c = _a.scrollLeft,
            scrollLeft = _c === void 0 ? 0 : _c;
        return window.scrollTo(scrollLeft, scrollTop);
    }
});

var cache = /*#__PURE__*/new WeakMap();
var createDOMStyler = function (node, props) {
    var styler;
    if (node instanceof HTMLElement) {
        styler = css(node, props);
    } else if (node instanceof SVGElement) {
        styler = svg(node);
    } else if (typeof window !== 'undefined' && node === window) {
        styler = viewport(node);
    }
    Object(hey_listen__WEBPACK_IMPORTED_MODULE_3__["invariant"])(styler !== undefined, 'No valid node provided. Node must be HTMLElement, SVGElement or window.');
    cache.set(node, styler);
    return styler;
};
var getStyler = function (node, props) {
    return cache.has(node) ? cache.get(node) : createDOMStyler(node, props);
};
function index(nodeOrSelector, props) {
    var node = typeof nodeOrSelector === 'string' ? document.querySelector(nodeOrSelector) : nodeOrSelector;
    return getStyler(node, props);
}

/* harmony default export */ __webpack_exports__["default"] = (index);



/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),

/***/ "./node_modules/unstated/lib/unstated.es.js":
/*!**************************************************!*\
  !*** ./node_modules/unstated/lib/unstated.es.js ***!
  \**************************************************/
/*! exports provided: Container, Subscribe, Provider, __SUPER_SECRET_CONTAINER_DEBUG_HOOK__ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Container", function() { return Container; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subscribe", function() { return Subscribe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return Provider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__SUPER_SECRET_CONTAINER_DEBUG_HOOK__", function() { return __SUPER_SECRET_CONTAINER_DEBUG_HOOK__; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var create_react_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! create-react-context */ "./node_modules/unstated/node_modules/create-react-context/lib/index.js");
/* harmony import */ var create_react_context__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(create_react_context__WEBPACK_IMPORTED_MODULE_1__);



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StateContext = create_react_context__WEBPACK_IMPORTED_MODULE_1___default()(null);

var Container = function () {
  function Container() {
    var _this = this;

    _classCallCheck(this, Container);

    this._listeners = [];

    CONTAINER_DEBUG_CALLBACKS.forEach(function (cb) {
      return cb(_this);
    });
  }

  Container.prototype.setState = function setState(updater, callback) {
    var _this2 = this;

    return Promise.resolve().then(function () {
      var nextState = void 0;

      if (typeof updater === 'function') {
        nextState = updater(_this2.state);
      } else {
        nextState = updater;
      }

      if (nextState == null) {
        if (callback) callback();
        return;
      }

      _this2.state = Object.assign({}, _this2.state, nextState);

      var promises = _this2._listeners.map(function (listener) {
        return listener();
      });

      return Promise.all(promises).then(function () {
        if (callback) {
          return callback();
        }
      });
    });
  };

  Container.prototype.subscribe = function subscribe(fn) {
    this._listeners.push(fn);
  };

  Container.prototype.unsubscribe = function unsubscribe(fn) {
    this._listeners = this._listeners.filter(function (f) {
      return f !== fn;
    });
  };

  return Container;
}();

var DUMMY_STATE = {};

var Subscribe = function (_React$Component) {
  _inherits(Subscribe, _React$Component);

  function Subscribe() {
    var _temp, _this3, _ret;

    _classCallCheck(this, Subscribe);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this3 = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this3), _this3.state = {}, _this3.instances = [], _this3.unmounted = false, _this3.onUpdate = function () {
      return new Promise(function (resolve) {
        if (!_this3.unmounted) {
          _this3.setState(DUMMY_STATE, resolve);
        } else {
          resolve();
        }
      });
    }, _temp), _possibleConstructorReturn(_this3, _ret);
  }

  Subscribe.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unmounted = true;
    this._unsubscribe();
  };

  Subscribe.prototype._unsubscribe = function _unsubscribe() {
    var _this4 = this;

    this.instances.forEach(function (container) {
      container.unsubscribe(_this4.onUpdate);
    });
  };

  Subscribe.prototype._createInstances = function _createInstances(map, containers) {
    var _this5 = this;

    this._unsubscribe();

    if (map === null) {
      throw new Error('You must wrap your <Subscribe> components with a <Provider>');
    }

    var safeMap = map;
    var instances = containers.map(function (ContainerItem) {
      var instance = void 0;

      if ((typeof ContainerItem === 'undefined' ? 'undefined' : _typeof(ContainerItem)) === 'object' && ContainerItem instanceof Container) {
        instance = ContainerItem;
      } else {
        instance = safeMap.get(ContainerItem);

        if (!instance) {
          instance = new ContainerItem();
          safeMap.set(ContainerItem, instance);
        }
      }

      instance.unsubscribe(_this5.onUpdate);
      instance.subscribe(_this5.onUpdate);

      return instance;
    });

    this.instances = instances;
    return instances;
  };

  Subscribe.prototype.render = function render() {
    var _this6 = this;

    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
      StateContext.Consumer,
      null,
      function (map) {
        return _this6.props.children.apply(null, _this6._createInstances(map, _this6.props.to));
      }
    );
  };

  return Subscribe;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

function Provider(props) {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
    StateContext.Consumer,
    null,
    function (parentMap) {
      var childMap = new Map(parentMap);

      if (props.inject) {
        props.inject.forEach(function (instance) {
          childMap.set(instance.constructor, instance);
        });
      }

      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(
        StateContext.Provider,
        { value: childMap },
        props.children
      );
    }
  );
}

var CONTAINER_DEBUG_CALLBACKS = [];

// If your name isn't Sindre, this is not for you.
// I might ruin your day suddenly if you depend on this without talking to me.
function __SUPER_SECRET_CONTAINER_DEBUG_HOOK__(callback) {
  CONTAINER_DEBUG_CALLBACKS.push(callback);
}




/***/ }),

/***/ "./node_modules/unstated/node_modules/create-react-context/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/unstated/node_modules/create-react-context/lib/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

var uniqueId = 0;

function createReactContext(defaultValue) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + uniqueId++ + '__';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    function Provider() {
      var _temp, _this, _ret;

      _classCallCheck(this, Provider);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);
    }

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        this.emitter.set(nextProps.value);
      }
    };

    Provider.prototype.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(_react.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);

  var Consumer = function (_Component2) {
    _inherits(Consumer, _Component2);

    function Consumer() {
      var _temp2, _this2, _ret2;

      _classCallCheck(this, Consumer);

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
        value: _this2.getValue()
      }, _this2.onUpdate = function () {
        _this2.setState({
          value: _this2.getValue()
        });
      }, _temp2), _possibleConstructorReturn(_this2, _ret2);
    }

    Consumer.prototype.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
    };

    Consumer.prototype.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    Consumer.prototype.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    Consumer.prototype.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(_react.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);


  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

exports.default = createReactContext;
module.exports = exports['default'];

/***/ }),

/***/ "./node_modules/warning/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/warning/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (true) {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/css/main.css":
/*!**************************!*\
  !*** ./src/css/main.css ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader??ref--5-1!../../node_modules/postcss-loader/src!./main.css */ "./node_modules/css-loader/index.js?!./node_modules/postcss-loader/src/index.js!./src/css/main.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/js/components/BackLink.js":
/*!***************************************!*\
  !*** ./src/js/components/BackLink.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _reach_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/router */ "./node_modules/@reach/router/es/index.js");



let BackLink = ({
  to
}) => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_reach_router__WEBPACK_IMPORTED_MODULE_1__["Link"], {
  to: to,
  className: "inline-flex items-center no-underline text-purple-dark",
  "data-back": true
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
  width: 24,
  height: 24,
  className: "fill-current mr-2"
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
  d: "M21 11H6.83l3.58-3.59L9 6l-6 6 6 6 1.41-1.41L6.83 13H21z"
})), "Back");

/* harmony default export */ __webpack_exports__["default"] = (BackLink);

/***/ }),

/***/ "./src/js/components/EditableOptions.js":
/*!**********************************************!*\
  !*** ./src/js/components/EditableOptions.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditableOptions; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var unstated__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unstated */ "./node_modules/unstated/lib/unstated.es.js");
/* harmony import */ var _BackLink_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BackLink.js */ "./src/js/components/BackLink.js");
 // import Slider from './slider.js';




class EditableProp extends react__WEBPACK_IMPORTED_MODULE_0___default.a.Component {
  render() {
    let set = this.props.set;

    switch (this.props.type) {
      case 'text':
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {
          type: "text",
          defaultValue: this.props.value || '',
          onInput: e => set(e.target.value),
          className: "appearance-none block w-full bg-transparent focus:bg-white border border-purple-dark rounded h-7 focus:outline-none",
          style: {
            padding: '0 12px'
          }
        });
        break;
      // case 'number':
      //   return (
      //     <Slider
      //       defaultValue={this.props.value || 0}
      //       onChange={val => set(val)}
      //     />
      //   );
      //   break;

      case 'select':
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", {
          id: this.props.id,
          onChange: e => set(e.target.value)
        }, this.props.options.map((option, i) => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
          value: option,
          key: i
        }, option)));
        break;

      case 'boolean':
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {
          type: "checkbox",
          id: this.props.id,
          defaultChecked: typeof this.props.value !== 'undefined' ? this.props.value : typeof this.props.default !== 'undefined' ? this.props.default : false,
          onChange: e => {
            set(e.target.checked);
          },
          className: "sr-only"
        }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          className: "checkbox absolute pin-r border border-purple-dark rounded-sm",
          style: {
            width: 20,
            height: 20,
            top: '50%',
            marginTop: -10
          }
        }));
        break;

      case 'color':
        return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", {
          className: "list-reset flex flex-wrap",
          style: {
            margin: '-10px -5px 0'
          }
        }, this.props.options.map(option => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
          style: {
            margin: '10px 5px 0'
          }
        }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
          type: "button",
          className: "appearance-none block w-6 h-6 border-0 rounded relative",
          style: {
            background: option
          },
          onClick: () => {
            set(option);
          }
        }, this.props.value === option ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          className: "absolute rounded-full bg-purple-dark border border-white",
          style: {
            top: -4,
            right: -4,
            width: 9,
            height: 9
          }
        }) : null))));
    }
  }

}

class EditableOptions extends react__WEBPACK_IMPORTED_MODULE_0___default.a.Component {
  render() {
    let props = this.props.editables[this.props.loc];
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(unstated__WEBPACK_IMPORTED_MODULE_1__["Subscribe"], {
      to: [createContainer(props.stateContainer)]
    }, s => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "expose-editable-props p-8"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_BackLink_js__WEBPACK_IMPORTED_MODULE_2__["default"], {
      to: "/"
    }), Object.keys(props.options).map((prop, i) => {
      let p = props.options[prop];
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        key: `${s.location}.${prop}`,
        className: "relative mt-5"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", {
        htmlFor: `${s.location}.${prop}`,
        className: "relative block mb-3 z-10"
      }, p.displayName || camelToSentence(prop)), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(EditableProp, {
        id: `${s.location}.${prop}`,
        type: p.type,
        value: s.state.value[prop],
        default: p.default,
        set: x => s.set(prop, x),
        options: p.options
      }));
    })));
  }

}

function camelToSentence(string) {
  return string.replace(/([a-z])([A-Z])/g, (m, p1, p2) => p1 + ' ' + p2.toLowerCase()).replace(/^([a-z])/, m => m.toUpperCase());
}

function createContainer(container) {
  return function () {
    return container;
  };
}

/***/ }),

/***/ "./src/js/components/Router.js":
/*!*************************************!*\
  !*** ./src/js/components/Router.js ***!
  \*************************************/
/*! exports provided: default, history, navigate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Router; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "history", function() { return history; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "navigate", function() { return navigate; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _reach_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reach/router */ "./node_modules/@reach/router/es/index.js");
/* harmony import */ var react_pose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-pose */ "./node_modules/react-pose/dist/react-pose.es.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




let source = Object(_reach_router__WEBPACK_IMPORTED_MODULE_1__["createMemorySource"])('/');
let history = Object(_reach_router__WEBPACK_IMPORTED_MODULE_1__["createHistory"])(source);
let navigate;
let transition = {
  type: 'spring',
  stiffness: 200,
  damping: 20
};
let RouteContainer = react_pose__WEBPACK_IMPORTED_MODULE_2__["default"].div({
  enter: {
    x: '0%',
    transition
  },
  preEnter: {
    x: '100%',
    transition
  },
  exit: {
    x: '-100%',
    transition
  }
});
class Router extends react__WEBPACK_IMPORTED_MODULE_0___default.a.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      preEnterPose: 'preEnter',
      exitPose: 'exit' // static getDerivedStateFromProps({ dir }) {
      //   if (dir === 'back') {
      //     return {
      //       preEnterPose: 'exit',
      //       exitPose: 'preEnter'
      //     }
      //   }
      //   return { preEnterPose: 'preEnter', exitPose: 'exit' }
      // }

    });

    _defineProperty(this, "handleClick", e => {
      let a = e.target.closest('a');
      if (!a) return;

      if (a.getAttribute('data-back')) {
        this.setState({
          preEnterPose: 'exit',
          exitPose: 'preEnter'
        });
      } else {
        this.setState({
          preEnterPose: 'preEnter',
          exitPose: 'exit'
        });
      }
    });
  }

  componentDidMount() {
    navigate = (to, back = false) => {
      let state = back ? {
        preEnterPose: 'exit',
        exitPose: 'preEnter'
      } : {
        preEnterPose: 'preEnter',
        exitPose: 'exit'
      };
      this.setState(state, () => {
        history.navigate(to);
      });
    };
  }

  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "flex-none bg-grey-lighter flex flex-col relative",
      style: {
        width: 304
      },
      onClickCapture: this.handleClick
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "logo-container mt-9 absolute z-10 pin-t pin-l w-full pointer-events-none"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "mx-auto mb-9",
      style: {
        width: 110
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "relative aspect-ratio-logo"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
      viewBox: "0 0 867.23 208.84",
      className: "absolute pin w-full h-full"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("g", {
      fill: "#333"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
      d: "M316.6 138.32c-5.33 18.11-22 33.24-47.73 33.24-28.76 0-54.12-20.67-54.12-56 0-33.45 24.72-55.18 51.56-55.18 32.39 0 51.78 20.67 51.78 54.33 0 4-.43 8.31-.43 8.74h-75c.64 13.85 12.36 23.86 26.42 23.86 13.21 0 20.46-6.6 23.87-16zM290.18 104c-.43-10.44-7.25-20.67-23.44-20.67-14.7 0-22.8 11.08-23.44 20.67zM355.5 115.74l-37.29-52.2h33.66c3.63 5.75 17.26 25.35 20.88 31.11l20.67-31.11h32.17L389 114.89l37.92 53.47h-33.29l-21.94-32.17c-3.84 5.75-17.9 26.42-21.52 32.17h-32zM437 208.84V63.54h27.48v12.78c4.69-8.09 16.41-15.13 32.17-15.13 30.68 0 48.37 23.44 48.37 54.55 0 31.74-19.82 55.18-49.43 55.18-14.49 0-25.14-5.75-30.26-12.78v50.7zm54.06-122.29c-14.48 0-26.2 10.87-26.2 29.4s11.72 29.62 26.2 29.62 26-10.87 26-29.62c0-18.53-11.51-29.4-26-29.4zM663.85 116c0 32.17-23.65 55.61-55 55.61s-55-23.44-55-55.61c0-32.38 23.65-55.61 55-55.61s55 23.18 55 55.61zm-28.33 0c0-19.81-12.79-29.83-26.64-29.83s-26.63 10-26.63 29.83c0 19.6 12.78 29.83 26.63 29.83s26.64-10.06 26.64-29.83zM695.36 133.85c.64 8.31 6.82 16 19.18 16 9.37 0 13.85-4.9 13.85-10.44 0-4.69-3.2-8.52-11.3-10.23L703.24 126c-20.24-4.47-29.4-16.61-29.4-31.31 0-18.75 16.62-34.31 39.21-34.31 29.82 0 39.84 19 41.12 30.26l-23.65 5.32c-.86-6.18-5.33-14.06-17.26-14.06-7.46 0-13.42 4.48-13.42 10.44 0 5.12 3.83 8.31 9.58 9.38l14.92 3.19c20.66 4.26 31.1 16.83 31.1 32.17 0 17.05-13.21 34.52-40.69 34.52-31.53 0-42.4-20.45-43.68-32.39zM865.74 138.32c-5.32 18.11-21.94 33.24-47.72 33.24-28.77 0-54.12-20.67-54.12-56 0-33.45 24.72-55.18 51.56-55.18 32.39 0 51.77 20.67 51.77 54.33 0 4-.42 8.31-.42 8.74h-75c.64 13.85 12.36 23.86 26.42 23.86 13.21 0 20.45-6.6 23.86-16zM839.32 104c-.42-10.44-7.24-20.67-23.43-20.67-14.7 0-22.8 11.08-23.44 20.67z"
    })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("circle", {
      cx: "110.69",
      cy: "72.59",
      r: "72.59",
      transform: "rotate(-6.9 110.659 72.596)",
      fill: "#cebeec"
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ellipse", {
      cx: "67.14",
      cy: "119.61",
      rx: "67.17",
      ry: "67.11",
      transform: "rotate(-45.03 67.144 119.61)",
      fill: "#8360d6"
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("circle", {
      cx: "134.28",
      cy: "152.43",
      r: "32.82",
      fill: "#3c374e"
    }))))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "overflow-auto overflow-x-hidden",
      style: {
        paddingTop: 160
      }
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_reach_router__WEBPACK_IMPORTED_MODULE_1__["LocationProvider"], {
      history: history
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_reach_router__WEBPACK_IMPORTED_MODULE_1__["Location"], null, ({
      location
    }) => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_pose__WEBPACK_IMPORTED_MODULE_2__["PoseGroup"], {
      preEnterPose: this.state.preEnterPose,
      exitPose: this.state.exitPose
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(RouteContainer, {
      key: location.pathname
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_reach_router__WEBPACK_IMPORTED_MODULE_1__["Router"], {
      location: location
    }, this.props.children)))))));
  }

}


/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _reach_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reach/router */ "./node_modules/@reach/router/es/index.js");
/* harmony import */ var _components_Router_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/Router.js */ "./src/js/components/Router.js");
/* harmony import */ var _components_EditableOptions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/EditableOptions.js */ "./src/js/components/EditableOptions.js");
/* harmony import */ var unstated__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unstated */ "./node_modules/unstated/lib/unstated.es.js");
/* harmony import */ var _components_BackLink_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/BackLink.js */ "./src/js/components/BackLink.js");
/* harmony import */ var _css_main_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../css/main.css */ "./src/css/main.css");
/* harmony import */ var _css_main_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_css_main_css__WEBPACK_IMPORTED_MODULE_7__);
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









window.Expose = {};

let MenuLink = ({
  to,
  children
}) => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_reach_router__WEBPACK_IMPORTED_MODULE_2__["Link"], {
  to: to,
  className: "menu-link no-underline flex items-center h-8 rounded text-purple-dark px-6 mb-4",
  style: {
    transition: 'background 0.3s'
  }
}, children);

let Home = () => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
  className: "p-6"
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MenuLink, {
  to: "/page-options"
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
  width: 20,
  height: 20,
  className: "fill-current mr-4"
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
  d: "M15.95 10.78c.03-.25.05-.51.05-.78s-.02-.53-.06-.78l1.69-1.32c.15-.12.19-.34.1-.51l-1.6-2.77c-.1-.18-.31-.24-.49-.18l-1.99.8c-.42-.32-.86-.58-1.35-.78L12 2.34c-.03-.2-.2-.34-.4-.34H8.4c-.2 0-.36.14-.39.34l-.3 2.12c-.49.2-.94.47-1.35.78l-1.99-.8c-.18-.07-.39 0-.49.18l-1.6 2.77c-.1.18-.06.39.1.51l1.69 1.32c-.04.25-.07.52-.07.78s.02.53.06.78L2.37 12.1c-.15.12-.19.34-.1.51l1.6 2.77c.1.18.31.24.49.18l1.99-.8c.42.32.86.58 1.35.78l.3 2.12c.04.2.2.34.4.34h3.2c.2 0 .37-.14.39-.34l.3-2.12c.49-.2.94-.47 1.35-.78l1.99.8c.18.07.39 0 .49-.18l1.6-2.77c.1-.18.06-.39-.1-.51l-1.67-1.32zM10 13c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3z"
})), "Page Options"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(MenuLink, {
  to: "/blog-posts"
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("svg", {
  width: 20,
  height: 20,
  className: "fill-current mr-4",
  viewBox: "0 0 24 24"
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
})), "Blog Posts"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
  className: "btn-group flex border border-purple-dark rounded"
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
  className: "-ml-px flex",
  style: {
    height: 35,
    width: 'calc(100% + 2px)'
  }
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
  type: "button",
  className: "appearance-none relative w-1/6 border-0 rounded-none p-0 bg-transparent"
}), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
  type: "button",
  className: "appearance-none relative w-1/6 border-0 rounded-none p-0 bg-transparent"
}), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
  type: "button",
  className: "appearance-none relative w-1/6 border-0 rounded-none p-0 bg-transparent"
}), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
  type: "button",
  className: "appearance-none relative w-1/6 border-0 rounded-none p-0 bg-transparent"
}), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
  type: "button",
  className: "appearance-none relative w-1/6 border-0 rounded-none p-0 bg-transparent"
}), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
  type: "button",
  className: "appearance-none relative w-1/6 border-0 rounded-none p-0 bg-transparent"
}))));

let PageOptions = () => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
  className: "p-6"
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_BackLink_js__WEBPACK_IMPORTED_MODULE_6__["default"], {
  to: "/"
}), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h2", null, "Page Options"));

let BlogPosts = () => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
  className: "p-6"
}, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_BackLink_js__WEBPACK_IMPORTED_MODULE_6__["default"], {
  to: "/"
}), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h2", null, "Blog Posts"));

class App extends react__WEBPACK_IMPORTED_MODULE_0___default.a.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      editables: {},
      editableOptions: [],
      editableStateContainer: null
    });

    _defineProperty(this, "showEditableOptions", ({
      location,
      options,
      stateContainer
    }) => {
      this.setState(state => ({
        editables: _objectSpread({}, state.editables, {
          [location]: {
            options,
            stateContainer
          }
        })
      }), () => {
        Object(_components_Router_js__WEBPACK_IMPORTED_MODULE_3__["navigate"])('/editable-options/' + location);
      }); // this.setState(
      //   { editableOptions: options, editableStateContainer: stateContainer },
      //   () => {
      //     navigate('/editable-options')
      //   }
      // )
    });
  }

  componentDidMount() {
    window.Expose.showEditableOptions = this.showEditableOptions;
  }

  render() {
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(unstated__WEBPACK_IMPORTED_MODULE_5__["Provider"], null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
      className: "flex h-screen"
    }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Router_js__WEBPACK_IMPORTED_MODULE_3__["default"], null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Home, {
      path: "/"
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(PageOptions, {
      path: "/page-options"
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(BlogPosts, {
      path: "/blog-posts"
    }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_EditableOptions_js__WEBPACK_IMPORTED_MODULE_4__["default"], {
      path: "/editable-options/:loc",
      editables: this.state.editables // props={this.state.editableOptions}
      // stateContainer={this.state.editableStateContainer}

    })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("iframe", {
      src: "/nocache",
      className: "relative border-0 w-full"
    })));
  }

}

react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.render(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(App, null), document.getElementById('app'));

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BlbW90aW9uL2lzLXByb3AtdmFsaWQvZGlzdC9pcy1wcm9wLXZhbGlkLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGVtb3Rpb24vbWVtb2l6ZS9kaXN0L21lbW9pemUuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wbW90aW9uL2Vhc2luZy9kaXN0L2Vhc2luZy5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJlYWNoL3JvdXRlci9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJlYWNoL3JvdXRlci9lcy9saWIvaGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJlYWNoL3JvdXRlci9lcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jb250ZXh0L2xpYi9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLXJlYWN0LWNvbnRleHQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9jc3MvbWFpbi5jc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mcmFtZXN5bmMvZGlzdC9mcmFtZXN5bmMuZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2d1ZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGV5LWxpc3Rlbi9kaXN0L2hleS1saXN0ZW4uZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24tcG9zZS9kaXN0L3BvcG1vdGlvbi1wb3NlLmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9wb3Btb3Rpb24uZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bvc2UtY29yZS9kaXN0L3Bvc2UtY29yZS5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0L3JlYWN0LWxpZmVjeWNsZXMtY29tcGF0LmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1wb3NlL2Rpc3QvcmVhY3QtcG9zZS5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGUvY2pzL3NjaGVkdWxlLXRyYWNraW5nLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZS9janMvc2NoZWR1bGUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZS90cmFja2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9zdHlsZS12YWx1ZS10eXBlcy5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGVmaXJlL2Rpc3Qvc3R5bGVmaXJlLmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Vuc3RhdGVkL2xpYi91bnN0YXRlZC5lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5zdGF0ZWQvbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jb250ZXh0L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Nzcy9tYWluLmNzcz85N2EyIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL0JhY2tMaW5rLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL0VkaXRhYmxlT3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL21haW4uanMiXSwibmFtZXMiOlsiQmFja0xpbmsiLCJ0byIsIkVkaXRhYmxlUHJvcCIsIkNvbXBvbmVudCIsInJlbmRlciIsInNldCIsInByb3BzIiwidHlwZSIsInZhbHVlIiwiZSIsInRhcmdldCIsInBhZGRpbmciLCJpZCIsIm9wdGlvbnMiLCJtYXAiLCJvcHRpb24iLCJpIiwiZGVmYXVsdCIsImNoZWNrZWQiLCJ3aWR0aCIsImhlaWdodCIsInRvcCIsIm1hcmdpblRvcCIsIm1hcmdpbiIsImJhY2tncm91bmQiLCJyaWdodCIsIkVkaXRhYmxlT3B0aW9ucyIsImVkaXRhYmxlcyIsImxvYyIsImNyZWF0ZUNvbnRhaW5lciIsInN0YXRlQ29udGFpbmVyIiwicyIsIk9iamVjdCIsImtleXMiLCJwcm9wIiwicCIsImxvY2F0aW9uIiwiZGlzcGxheU5hbWUiLCJjYW1lbFRvU2VudGVuY2UiLCJzdGF0ZSIsIngiLCJzdHJpbmciLCJyZXBsYWNlIiwibSIsInAxIiwicDIiLCJ0b0xvd2VyQ2FzZSIsInRvVXBwZXJDYXNlIiwiY29udGFpbmVyIiwic291cmNlIiwiaGlzdG9yeSIsIm5hdmlnYXRlIiwidHJhbnNpdGlvbiIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJSb3V0ZUNvbnRhaW5lciIsImRpdiIsImVudGVyIiwicHJlRW50ZXIiLCJleGl0IiwiUm91dGVyIiwicHJlRW50ZXJQb3NlIiwiZXhpdFBvc2UiLCJhIiwiY2xvc2VzdCIsImdldEF0dHJpYnV0ZSIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkTW91bnQiLCJiYWNrIiwiaGFuZGxlQ2xpY2siLCJwYWRkaW5nVG9wIiwicGF0aG5hbWUiLCJjaGlsZHJlbiIsIndpbmRvdyIsIkV4cG9zZSIsIk1lbnVMaW5rIiwiSG9tZSIsIlBhZ2VPcHRpb25zIiwiQmxvZ1Bvc3RzIiwiQXBwIiwiZWRpdGFibGVPcHRpb25zIiwiZWRpdGFibGVTdGF0ZUNvbnRhaW5lciIs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LFdBQVcsaUJBQWlCLEdBQUcsV0FBVyxpQkFBaUIsR0FBRyxXQUFXLGtCQUFrQixHQUFHLFdBQVcsa0JBQWtCLEdBQUcsV0FBVyxrQkFBa0IsR0FBRyxXQUFXLGtCQUFrQixHQUFHLFdBQVcsa0JBQWtCLEdBQUcsV0FBVyxrQkFBa0IsR0FBRyxZQUFZLGtCQUFrQixHQUFHLGNBQWMsa0JBQWtCLEdBQUcsY0FBYyxrQkFBa0IsR0FBRyxZQUFZLGlCQUFpQixHQUFHLGVBQWUsMkJBQTJCLEdBQUcsWUFBWSxrQkFBa0IscUJBQXFCLEdBQUcsWUFBWSxtQkFBbUIsb0JBQW9CLEdBQUcsWUFBWSxxQkFBcUIsd0JBQXdCLEdBQUcsWUFBWSxzQkFBc0IsdUJBQXVCLEdBQUcsWUFBWSxxQkFBcUIsd0JBQXdCLEdBQUcsWUFBWSxzQkFBc0IsdUJBQXVCLEdBQUcsWUFBWSxxQkFBcUIsd0JBQXdCLEdBQUcsWUFBWSxzQkFBc0IsdUJBQXVCLEdBQUcsWUFBWSxzQkFBc0IseUJBQXlCLEdBQUcsWUFBWSx1QkFBdUIsd0JBQXdCLEdBQUcsWUFBWSxzQkFBc0IseUJBQXlCLEdBQUcsWUFBWSx1QkFBdUIsd0JBQXdCLEdBQUcsWUFBWSxzQkFBc0IseUJBQXlCLEdBQUcsWUFBWSx1QkFBdUIsd0JBQXdCLEdBQUcsWUFBWSxzQkFBc0IseUJBQXlCLEdBQUcsWUFBWSx1QkFBdUIsd0JBQXdCLEdBQUcsWUFBWSxzQkFBc0IseUJBQXlCLEdBQUcsWUFBWSx1QkFBdUIsd0JBQXdCLEdBQUcsWUFBWSxzQkFBc0IseUJBQXlCLEdBQUcsWUFBWSx1QkFBdUIsd0JBQXdCLEdBQUcsYUFBYSxzQkFBc0IseUJBQXlCLEdBQUcsYUFBYSx1QkFBdUIsd0JBQXdCLEdBQUcsZUFBZSxzQkFBc0IseUJBQXlCLEdBQUcsZUFBZSx1QkFBdUIsd0JBQXdCLEdBQUcsZUFBZSxzQkFBc0IseUJBQXlCLEdBQUcsZUFBZSx1QkFBdUIsd0JBQXdCLEdBQUcsYUFBYSxxQkFBcUIsd0JBQXdCLEdBQUcsYUFBYSxzQkFBc0IsdUJBQXVCLEdBQUcsZ0JBQWdC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QW1CLHVCQUF1QixLQUFLLG1CQUFtQix5QkFBeUIsS0FBSyxtQkFBbUIsMEJBQTBCLEtBQUssbUJBQW1CLHdCQUF3QixLQUFLLG1CQUFtQix1QkFBdUIsS0FBSyxtQkFBbUIseUJBQXlCLEtBQUssbUJBQW1CLDBCQUEwQixLQUFLLG1CQUFtQix3QkFBd0IsS0FBSyxtQkFBbUIsdUJBQXVCLEtBQUssbUJBQW1CLHlCQUF5QixLQUFLLG1CQUFtQiwwQkFBMEIsS0FBSyxtQkFBbUIsd0JBQXdCLEtBQUssbUJBQW1CLHdCQUF3QixLQUFLLG1CQUFtQiwwQkFBMEIsS0FBSyxtQkFBbUIsMkJBQTJCLEtBQUssbUJBQW1CLHlCQUF5QixLQUFLLG1CQUFtQix3QkFBd0IsS0FBSyxtQkFBbUIsMEJBQTBCLEtBQUssbUJBQW1CLDJCQUEyQixLQUFLLG1CQUFtQix5QkFBeUIsS0FBSyxtQkFBbUIsd0JBQXdCLEtBQUssbUJBQW1CLDBCQUEwQixLQUFLLG1CQUFtQiwyQkFBMkIsS0FBSyxtQkFBbUIseUJBQXlCLEtBQUssbUJBQW1CLHdCQUF3QixLQUFLLG1CQUFtQiwwQkFBMEIsS0FBSyxtQkFBbUIsMkJBQTJCLEtBQUssbUJBQW1CLHlCQUF5QixLQUFLLG1CQUFtQix3QkFBd0IsS0FBSyxtQkFBbUIsMEJBQTBCLEtBQUssbUJBQW1CLDJCQUEyQixLQUFLLG1CQUFtQix5QkFBeUIsS0FBSyxtQkFBbUIsd0JBQXdCLEtBQUssbUJBQW1CLDBCQUEwQixLQUFLLG1CQUFtQiwyQkFBMkIsS0FBSyxtQkFBbUIseUJBQXlCLEtBQUssb0JBQW9CLHdCQUF3QixLQUFLLG9CQUFvQiwwQkFBMEIsS0FBSyxvQkFBb0IsMkJBQTJCLEtBQUssb0JBQW9CLHlCQUF5QixLQUFLLHNCQUFzQix3QkFBd0IsS0FBSyxzQkFBc0IsMEJBQTBCLEtBQUssc0JBQXNCLDJCQUEyQixLQUFLLHNCQUFzQix5QkFBeUIsS0FBSyxzQkFBc0Isd0JBQXdCLEtBQUssc0JBQXNCLDBCQUEwQixLQUFLLHNCQUFzQiwyQkFBMkIsS0FBSyxzQkFBc0IseUJB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a0Isd0JBQXdCLEtBQUssa0JBQWtCLHVCQUF1QixLQUFLLGtCQUFrQix5QkFBeUIsS0FBSyxrQkFBa0IsMEJBQTBCLEtBQUssa0JBQWtCLHdCQUF3QixLQUFLLGtCQUFrQix3QkFBd0IsS0FBSyxrQkFBa0IsMEJBQTBCLEtBQUssa0JBQWtCLDJCQUEyQixLQUFLLGtCQUFrQix5QkFBeUIsS0FBSyxrQkFBa0Isd0JBQXdCLEtBQUssa0JBQWtCLDBCQUEwQixLQUFLLGtCQUFrQiwyQkFBMkIsS0FBSyxrQkFBa0IseUJBQXlCLEtBQUssa0JBQWtCLHdCQUF3QixLQUFLLGtCQUFrQiwwQkFBMEIsS0FBSyxrQkFBa0IsMkJBQTJCLEtBQUssa0JBQWtCLHlCQUF5QixLQUFLLGtCQUFrQix3QkFBd0IsS0FBSyxrQkFBa0IsMEJBQTBCLEtBQUssa0JBQWtCLDJCQUEyQixLQUFLLGtCQUFrQix5QkFBeUIsS0FBSyxrQkFBa0Isd0JBQXdCLEtBQUssa0JBQWtCLDBCQUEwQixLQUFLLGtCQUFrQiwyQkFBMkIsS0FBSyxrQkFBa0IseUJBQXlCLEtBQUssa0JBQWtCLHdCQUF3QixLQUFLLGtCQUFrQiwwQkFBMEIsS0FBSyxrQkFBa0IsMkJBQTJCLEtBQUssa0JBQWtCLHlCQUF5QixLQUFLLG1CQUFtQix3QkFBd0IsS0FBSyxtQkFBbUIsMEJBQTBCLEtBQUssbUJBQW1CLDJCQUEyQixLQUFLLG1CQUFtQix5QkFBeUIsS0FBSyxxQkFBcUIsd0JBQXdCLEtBQUsscUJBQXFCLDBCQUEwQixLQUFLLHFCQUFxQiwyQkFBMkIsS0FBSyxxQkFBcUIseUJBQXlCLEtBQUsscUJBQXFCLHdCQUF3QixLQUFLLHFCQUFxQiwwQkFBMEIsS0FBSyxxQkFBcUIsMkJBQTJCLEtBQUsscUJBQXFCLHlCQUF5QixLQUFLLG1CQUFtQix1QkFBdUIsS0FBSyxtQkFBbUIseUJBQXlCLEtBQUssbUJBQW1CLDBCQUEwQixLQUFLLG1CQUFtQix3QkFBd0IsS0FBSyxzQkFBc0IsaUNBQWlDLEtBQUssc0JBQXNCLG1DQUFtQyxLQUFLLHNCQUFzQixvQ0FB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QixxQkFBcUIsS0FBSyxrQkFBa0IsdUJBQXVCLEtBQUssa0JBQWtCLHdCQUF3QixLQUFLLGtCQUFrQixzQkFBc0IsS0FBSyxrQkFBa0IsdUJBQXVCLEtBQUssa0JBQWtCLHlCQUF5QixLQUFLLGtCQUFrQiwwQkFBMEIsS0FBSyxrQkFBa0Isd0JBQXdCLEtBQUssa0JBQWtCLHVCQUF1QixLQUFLLGtCQUFrQix5QkFBeUIsS0FBSyxrQkFBa0IsMEJBQTBCLEtBQUssa0JBQWtCLHdCQUF3QixLQUFLLGtCQUFrQix1QkFBdUIsS0FBSyxrQkFBa0IseUJBQXlCLEtBQUssa0JBQWtCLDBCQUEwQixLQUFLLGtCQUFrQix3QkFBd0IsS0FBSyxrQkFBa0Isd0JBQXdCLEtBQUssa0JBQWtCLDBCQUEwQixLQUFLLGtCQUFrQiwyQkFBMkIsS0FBSyxrQkFBa0IseUJBQXlCLEtBQUssa0JBQWtCLHdCQUF3QixLQUFLLGtCQUFrQiwwQkFBMEIsS0FBSyxrQkFBa0IsMkJBQTJCLEtBQUssa0JBQWtCLHlCQUF5QixLQUFLLGtCQUFrQix3QkFBd0IsS0FBSyxrQkFBa0IsMEJBQTBCLEtBQUssa0JBQWtCLDJCQUEyQixLQUFLLGtCQUFrQix5QkFBeUIsS0FBSyxrQkFBa0Isd0JBQXdCLEtBQUssa0JBQWtCLDBCQUEwQixLQUFLLGtCQUFrQiwyQkFBMkIsS0FBSyxrQkFBa0IseUJBQXlCLEtBQUssa0JBQWtCLHdCQUF3QixLQUFLLGtCQUFrQiwwQkFBMEIsS0FBSyxrQkFBa0IsMkJBQTJCLEtBQUssa0JBQWtCLHlCQUF5QixLQUFLLGtCQUFrQix3QkFBd0IsS0FBSyxrQkFBa0IsMEJBQTBCLEtBQUssa0JBQWtCLDJCQUEyQixLQUFLLGtCQUFrQix5QkFBeUIsS0FBSyxtQkFBbUIsd0JBQXdCLEtBQUssbUJBQW1CLDBCQUEwQixLQUFLLG1CQUFtQiwyQkFBMkIsS0FBSyxtQkFBbUIseUJBQXlCLEtBQUsscUJBQXFCLHdCQUF3QixLQUFLLHFCQUFxQiwwQkFBMEIsS0FBSyxxQkFBcUIsMkJBQTJCLEtBQUsscUJBQXFCLHlCQUF5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QTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEIseURBQU87QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdEQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3REFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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OztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsdURBQUs7QUFDcEQsMkNBQTJDLHVEQUFLO0FBQ2hELGtCQUFrQixzREFBUSxHQUFHO0FBQzdCLDBFQUEwRSxzREFBSTtBQUM5RTtBQUNBLGtCQUFrQixzREFBUSxHQUFHO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsc0RBQVEsR0FBRyxTQUFTLDRHQUE0RztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQVM7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0RBQVEsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVLGFBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLHdGQUF3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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYixXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIO0FBQ3ZILHlIQUF5SDtBQUN6SDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtQ0FBbUM7QUFDbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNGQUFzRixhQUFhO0FBQ25HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx1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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEtBQThLLFlBQVk7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1TEFBdUwsK0JBQStCO0FBQ3ROOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlLQUFpSyxpQkFBaUI7QUFDbEwsT0FBTztBQUNQLGlLQUFpSyxpQkFBaUIsd0RBQXdELG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQzNTO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0dBQStHLEdBQUc7QUFDbEg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNElBQTRJLG1CQUFtQixnQkFBZ0IsOEJBQThCO0FBQzdNLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQyxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGVBQWU7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QyxpREFBaUQ7QUFDakQscURBQXFEO0FBQ3JELDBEQUEwRDtBQUMxRCw4REFBOEQ7QUFDOUQsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtLQUFrSyx5Q0FBeUM7QUFDM007QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0RBQWtEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxtQkFBbUI7QUFDcEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7QUN2cWpCYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLEtBQXFDLEVBQUUsRUFLMUM7QUFDRCxtQkFBbUIsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDM0Q7Ozs7Ozs7Ozs7Ozs7QUNyQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsY0FBYztBQUN6QixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7OztBQ3hiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7O0FBSWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLDhDQUE4QyxjQUFjOztBQUU1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7Ozs7Ozs7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O0FBQUE7O0FBeUJoQytCLG1CQUFpQixHQUFHO0FBQ2xCTSxVQUFNLENBQUNDLE1BQVAsQ0FBY1EsbUJBQWQsR0FBb0MsS0FBS0EsbUJBQXpDO0FBQ0Q7O0FBQ0Q5RSxRQUFNLEdBQUc7QUFDUCxXQUNFLDJEQUFDLGlEQUFELFFBQ0U7QUFBSyxlQUFTLEVBQUM7QUFBZixPQUNFLDJEQUFDLDZEQUFELFFBQ0UsMkRBQUMsSUFBRDtBQUFNLFVBQUksRUFBQztBQUFYLE1BREYsRUFFRSwyREFBQyxXQUFEO0FBQWEsVUFBSSxFQUFDO0FBQWxCLE1BRkYsRUFHRSwyREFBQyxTQUFEO0FBQVcsVUFBSSxFQUFDO0FBQWhCLE1BSEYsRUFJRSwyREFBQyxzRUFBRDtBQUNFLFVBQUksRUFBQyx3QkFEUDtBQUVFLGVBQVMsRUFBRSxLQUFLbUMsS0FBTCxDQUFXWixTQUZ4QixDQUdFO0FBQ0E7O0FBSkYsTUFKRixDQURGLEVBWUU7QUFBUSxTQUFHLEVBQUMsVUFBWjtBQUF1QixlQUFTLEVBQUM7QUFBakMsTUFaRixDQURGLENBREY7QUFrQkQ7O0FBL0MrQjs7QUFrRGxDLGdEQUFRLENBQUN2QixNQUFULENBQWdCLDJEQUFDLEdBQUQsT0FBaEIsRUFBeUIrRSxRQUFRLENBQUNDLGNBQVQsQ0FBd0IsS0FBeEIsQ0FBekIsRSIsImZpbGUiOiJleHBvc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9qcy9tYWluLmpzXCIpO1xuIiwiaW1wb3J0IG1lbW9pemUgZnJvbSAnQGVtb3Rpb24vbWVtb2l6ZSc7XG5cbnZhciByZWFjdFByb3BzUmVnZXggPSAvXigoY2hpbGRyZW58ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUx8a2V5fHJlZnxhdXRvRm9jdXN8ZGVmYXVsdFZhbHVlfGRlZmF1bHRDaGVja2VkfGlubmVySFRNTHxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmd8dmFsdWVMaW5rfGFjY2VwdHxhY2NlcHRDaGFyc2V0fGFjY2Vzc0tleXxhY3Rpb258YWxsb3d8YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFsbGVuZ2V8Y2hhclNldHxjaGVja2VkfGNpdGV8Y2xhc3NJRHxjbGFzc05hbWV8Y29sc3xjb2xTcGFufGNvbnRlbnR8Y29udGVudEVkaXRhYmxlfGNvbnRleHRNZW51fGNvbnRyb2xzfGNvbnRyb2xzTGlzdHxjb29yZHN8Y3Jvc3NPcmlnaW58ZGF0YXxkYXRlVGltZXxkZWZhdWx0fGRlZmVyfGRpcnxkaXNhYmxlZHxkb3dubG9hZHxkcmFnZ2FibGV8ZW5jVHlwZXxmb3JtfGZvcm1BY3Rpb258Zm9ybUVuY1R5cGV8Zm9ybU1ldGhvZHxmb3JtTm9WYWxpZGF0ZXxmb3JtVGFyZ2V0fGZyYW1lQm9yZGVyfGhlYWRlcnN8aGVpZ2h0fGhpZGRlbnxoaWdofGhyZWZ8aHJlZkxhbmd8aHRtbEZvcnxodHRwRXF1aXZ8aWR8aW5wdXRNb2RlfGludGVncml0eXxpc3xrZXlQYXJhbXN8a2V5VHlwZXxraW5kfGxhYmVsfGxhbmd8bGlzdHxsb29wfGxvd3xtYXJnaW5IZWlnaHR8bWFyZ2luV2lkdGh8bWF4fG1heExlbmd0aHxtZWRpYXxtZWRpYUdyb3VwfG1ldGhvZHxtaW58bWluTGVuZ3RofG11bHRpcGxlfG11dGVkfG5hbWV8bm9uY2V8bm9WYWxpZGF0ZXxvcGVufG9wdGltdW18cGF0dGVybnxwbGFjZWhvbGRlcnxwbGF5c0lubGluZXxwb3N0ZXJ8cHJlbG9hZHxwcm9maWxlfHJhZGlvR3JvdXB8cmVhZE9ubHl8cmVmZXJyZXJQb2xpY3l8cmVsfHJlcXVpcmVkfHJldmVyc2VkfHJvbGV8cm93c3xyb3dTcGFufHNhbmRib3h8c2NvcGV8c2NvcGVkfHNjcm9sbGluZ3xzZWFtbGVzc3xzZWxlY3RlZHxzaGFwZXxzaXplfHNpemVzfHNsb3R8c3BhbnxzcGVsbENoZWNrfHNyY3xzcmNEb2N8c3JjTGFuZ3xzcmNTZXR8c3RhcnR8c3RlcHxzdHlsZXxzdW1tYXJ5fHRhYkluZGV4fHRhcmdldHx0aXRsZXx0eXBlfHVzZU1hcHx2YWx1ZXx3aWR0aHx3bW9kZXx3cmFwfGFib3V0fGRhdGF0eXBlfGlubGlzdHxwcmVmaXh8cHJvcGVydHl8cmVzb3VyY2V8dHlwZW9mfHZvY2FifGF1dG9DYXBpdGFsaXplfGF1dG9Db3JyZWN0fGF1dG9TYXZlfGNvbG9yfGl0ZW1Qcm9wfGl0ZW1TY29wZXxpdGVtVHlwZXxpdGVtSUR8aXRlbVJlZnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3MpfChvbltBLVpdLiopfCgoZGF0YXxhcmlhfHgpLS4qKSkkL2k7XG52YXIgaW5kZXggPSBtZW1vaXplKHJlYWN0UHJvcHNSZWdleC50ZXN0LmJpbmQocmVhY3RQcm9wc1JlZ2V4KSk7XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIiwiZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoY2FjaGVbYXJnXSA9PT0gdW5kZWZpbmVkKSBjYWNoZVthcmddID0gZm4oYXJnKTtcbiAgICByZXR1cm4gY2FjaGVbYXJnXTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9pemUuZXNtLmpzLm1hcFxuIiwidmFyIERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIID0gMS41MjU7XG52YXIgcmV2ZXJzZWQgPSBmdW5jdGlvbiAoZWFzaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiAxIC0gZWFzaW5nKDEgLSBwKTtcbiAgICB9O1xufTtcbnZhciBtaXJyb3JlZCA9IGZ1bmN0aW9uIChlYXNpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAgPD0gMC41ID8gZWFzaW5nKDIgKiBwKSAvIDIgOiAoMiAtIGVhc2luZygyICogKDEgLSBwKSkpIC8gMjtcbiAgICB9O1xufTtcbnZhciBjcmVhdGVSZXZlcnNlZEVhc2luZyA9IHJldmVyc2VkO1xudmFyIGNyZWF0ZU1pcnJvcmVkRWFzaW5nID0gbWlycm9yZWQ7XG52YXIgY3JlYXRlRXhwb0luID0gZnVuY3Rpb24gKHBvd2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhwLCBwb3dlcik7XG4gICAgfTtcbn07XG52YXIgY3JlYXRlQmFja0luID0gZnVuY3Rpb24gKHBvd2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwICogcCAqICgocG93ZXIgKyAxKSAqIHAgLSBwb3dlcik7XG4gICAgfTtcbn07XG52YXIgY3JlYXRlQW50aWNpcGF0ZUVhc2luZyA9IGZ1bmN0aW9uIChwb3dlcikge1xuICAgIHZhciBiYWNrRWFzaW5nID0gY3JlYXRlQmFja0luKHBvd2VyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIChwICo9IDIpIDwgMSA/IDAuNSAqIGJhY2tFYXNpbmcocCkgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcbiAgICB9O1xufTtcbnZhciBsaW5lYXIgPSBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwO1xufTtcbnZhciBlYXNlSW4gPSAvKiNfX1BVUkVfXyovY3JlYXRlRXhwb0luKDIpO1xudmFyIGVhc2VPdXQgPSAvKiNfX1BVUkVfXyovcmV2ZXJzZWQoZWFzZUluKTtcbnZhciBlYXNlSW5PdXQgPSAvKiNfX1BVUkVfXyovbWlycm9yZWQoZWFzZUluKTtcbnZhciBjaXJjSW4gPSBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5zaW4oTWF0aC5hY29zKHApKTtcbn07XG52YXIgY2lyY091dCA9IC8qI19fUFVSRV9fKi9yZXZlcnNlZChjaXJjSW4pO1xudmFyIGNpcmNJbk91dCA9IC8qI19fUFVSRV9fKi9taXJyb3JlZChjaXJjT3V0KTtcbnZhciBiYWNrSW4gPSAvKiNfX1BVUkVfXyovY3JlYXRlQmFja0luKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbnZhciBiYWNrT3V0ID0gLyojX19QVVJFX18qL3JldmVyc2VkKGJhY2tJbik7XG52YXIgYmFja0luT3V0ID0gLyojX19QVVJFX18qL21pcnJvcmVkKGJhY2tJbik7XG52YXIgYW50aWNpcGF0ZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVBbnRpY2lwYXRlRWFzaW5nKERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIKTtcbnZhciBORVdUT05fSVRFUkFUSU9OUyA9IDg7XG52YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xudmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbnZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xudmFyIEtfU1BMSU5FX1RBQkxFX1NJWkUgPSAxMTtcbnZhciBLX1NBTVBMRV9TVEVQX1NJWkUgPSAxLjAgLyAoS19TUExJTkVfVEFCTEVfU0laRSAtIDEuMCk7XG52YXIgRkxPQVRfMzJfU1VQUE9SVEVEID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgYSA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgICByZXR1cm4gMS4wIC0gMy4wICogYTIgKyAzLjAgKiBhMTtcbn07XG52YXIgYiA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgICByZXR1cm4gMy4wICogYTIgLSA2LjAgKiBhMTtcbn07XG52YXIgYyA9IGZ1bmN0aW9uIChhMSkge1xuICAgIHJldHVybiAzLjAgKiBhMTtcbn07XG52YXIgZ2V0U2xvcGUgPSBmdW5jdGlvbiAodCwgYTEsIGEyKSB7XG4gICAgcmV0dXJuIDMuMCAqIGEoYTEsIGEyKSAqIHQgKiB0ICsgMi4wICogYihhMSwgYTIpICogdCArIGMoYTEpO1xufTtcbnZhciBjYWxjQmV6aWVyID0gZnVuY3Rpb24gKHQsIGExLCBhMikge1xuICAgIHJldHVybiAoKGEoYTEsIGEyKSAqIHQgKyBiKGExLCBhMikpICogdCArIGMoYTEpKSAqIHQ7XG59O1xuZnVuY3Rpb24gY3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IEZMT0FUXzMyX1NVUFBPUlRFRCA/IG5ldyBGbG9hdDMyQXJyYXkoS19TUExJTkVfVEFCTEVfU0laRSkgOiBuZXcgQXJyYXkoS19TUExJTkVfVEFCTEVfU0laRSk7XG4gICAgdmFyIGJpbmFyeVN1YmRpdmlkZSA9IGZ1bmN0aW9uIChhWCwgYUEsIGFCKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRYO1xuICAgICAgICB2YXIgY3VycmVudFQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUO1xuICAgIH07XG4gICAgdmFyIG5ld3RvblJhcGhzb25JdGVyYXRlID0gZnVuY3Rpb24gKGFYLCBhR3Vlc3NUKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50WDtcbiAgICAgICAgZm9yICg7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgICAgICAgICBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgfTtcbiAgICB2YXIgY2FsY1NhbXBsZVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBLX1NQTElORV9UQUJMRV9TSVpFOyArK2kpIHtcbiAgICAgICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIEtfU0FNUExFX1NURVBfU0laRSwgbVgxLCBtWDIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZ2V0VEZvclggPSBmdW5jdGlvbiAoYVgpIHtcbiAgICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBLX1NQTElORV9UQUJMRV9TSVpFIC0gMTtcbiAgICAgICAgdmFyIGRpc3QgPSAwLjA7XG4gICAgICAgIHZhciBndWVzc0ZvclQgPSAwLjA7XG4gICAgICAgIHZhciBpbml0aWFsU2xvcGUgPSAwLjA7XG4gICAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IEtfU0FNUExFX1NURVBfU0laRTtcbiAgICAgICAgfVxuICAgICAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgICAgIGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgICAgICBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIEtfU0FNUExFX1NURVBfU0laRTtcbiAgICAgICAgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuICAgICAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIEtfU0FNUExFX1NURVBfU0laRSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNhbGNTYW1wbGVWYWx1ZXMoKTtcbiAgICB2YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiAoYVgpIHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlO1xuICAgICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gYVg7XG4gICAgICAgIH0gZWxzZSBpZiAoYVggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChhWCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxjQmV6aWVyKGdldFRGb3JYKGFYKSwgbVkxLCBtWTIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiByZXNvbHZlcjtcbn1cblxuZXhwb3J0IHsgcmV2ZXJzZWQsIG1pcnJvcmVkLCBjcmVhdGVSZXZlcnNlZEVhc2luZywgY3JlYXRlTWlycm9yZWRFYXNpbmcsIGNyZWF0ZUV4cG9JbiwgY3JlYXRlQmFja0luLCBjcmVhdGVBbnRpY2lwYXRlRWFzaW5nLCBsaW5lYXIsIGVhc2VJbiwgZWFzZU91dCwgZWFzZUluT3V0LCBjaXJjSW4sIGNpcmNPdXQsIGNpcmNJbk91dCwgYmFja0luLCBiYWNrT3V0LCBiYWNrSW5PdXQsIGFudGljaXBhdGUsIGN1YmljQmV6aWVyIH07XG4iLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyogZXNsaW50LWRpc2FibGUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50ICovXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgd2FybmluZyBmcm9tIFwid2FybmluZ1wiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IGludmFyaWFudCBmcm9tIFwiaW52YXJpYW50XCI7XG5pbXBvcnQgY3JlYXRlQ29udGV4dCBmcm9tIFwiY3JlYXRlLXJlYWN0LWNvbnRleHRcIjtcbmltcG9ydCB7IHBvbHlmaWxsIH0gZnJvbSBcInJlYWN0LWxpZmVjeWNsZXMtY29tcGF0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgc3RhcnRzV2l0aCwgcGljaywgcmVzb2x2ZSwgbWF0Y2gsIGluc2VydFBhcmFtcywgdmFsaWRhdGVSZWRpcmVjdCB9IGZyb20gXCIuL2xpYi91dGlsc1wiO1xuaW1wb3J0IHsgZ2xvYmFsSGlzdG9yeSwgbmF2aWdhdGUsIGNyZWF0ZUhpc3RvcnksIGNyZWF0ZU1lbW9yeVNvdXJjZSB9IGZyb20gXCIuL2xpYi9oaXN0b3J5XCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSZWFjdCBwb2x5ZmlsbFxudmFyIHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlcyA9IFJlYWN0RE9NLnVuc3RhYmxlX2RlZmVycmVkVXBkYXRlcztcblxuaWYgKHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gIHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlcyA9IGZ1bmN0aW9uIHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHJldHVybiBmbigpO1xuICB9O1xufVxuXG52YXIgY3JlYXRlTmFtZWRDb250ZXh0ID0gZnVuY3Rpb24gY3JlYXRlTmFtZWRDb250ZXh0KG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgQ3R4ID0gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpO1xuICBDdHguQ29uc3VtZXIuZGlzcGxheU5hbWUgPSBuYW1lICsgXCIuQ29uc3VtZXJcIjtcbiAgQ3R4LlByb3ZpZGVyLmRpc3BsYXlOYW1lID0gbmFtZSArIFwiLlByb3ZpZGVyXCI7XG4gIHJldHVybiBDdHg7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTG9jYXRpb24gQ29udGV4dC9Qcm92aWRlclxudmFyIExvY2F0aW9uQ29udGV4dCA9IGNyZWF0ZU5hbWVkQ29udGV4dChcIkxvY2F0aW9uXCIpO1xuXG4vLyBzZXRzIHVwIGEgbGlzdGVuZXIgaWYgdGhlcmUgaXNuJ3Qgb25lIGFscmVhZHkgc28gYXBwcyBkb24ndCBuZWVkIHRvIGJlXG4vLyB3cmFwcGVkIGluIHNvbWUgdG9wIGxldmVsIHByb3ZpZGVyXG52YXIgTG9jYXRpb24gPSBmdW5jdGlvbiBMb2NhdGlvbihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIExvY2F0aW9uQ29udGV4dC5Db25zdW1lcixcbiAgICBudWxsLFxuICAgIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY29udGV4dCA/IGNoaWxkcmVuKGNvbnRleHQpIDogUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgTG9jYXRpb25Qcm92aWRlcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfVxuICApO1xufTtcblxudmFyIExvY2F0aW9uUHJvdmlkZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTG9jYXRpb25Qcm92aWRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTG9jYXRpb25Qcm92aWRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvY2F0aW9uUHJvdmlkZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgY29udGV4dDogX3RoaXMuZ2V0Q29udGV4dCgpLFxuICAgICAgcmVmczogeyB1bmxpc3RlbjogbnVsbCB9XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBMb2NhdGlvblByb3ZpZGVyLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICB2YXIgX3Byb3BzJGhpc3RvcnkgPSB0aGlzLnByb3BzLmhpc3RvcnksXG4gICAgICAgIG5hdmlnYXRlID0gX3Byb3BzJGhpc3RvcnkubmF2aWdhdGUsXG4gICAgICAgIGxvY2F0aW9uID0gX3Byb3BzJGhpc3RvcnkubG9jYXRpb247XG5cbiAgICByZXR1cm4geyBuYXZpZ2F0ZTogbmF2aWdhdGUsIGxvY2F0aW9uOiBsb2NhdGlvbiB9O1xuICB9O1xuXG4gIExvY2F0aW9uUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICBpZiAoaXNSZWRpcmVjdChlcnJvcikpIHtcbiAgICAgIHZhciBfbmF2aWdhdGUgPSB0aGlzLnByb3BzLmhpc3RvcnkubmF2aWdhdGU7XG5cbiAgICAgIF9uYXZpZ2F0ZShlcnJvci51cmksIHsgcmVwbGFjZTogdHJ1ZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIExvY2F0aW9uUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIGlmIChwcmV2U3RhdGUuY29udGV4dC5sb2NhdGlvbiAhPT0gdGhpcy5zdGF0ZS5jb250ZXh0LmxvY2F0aW9uKSB7XG4gICAgICB0aGlzLnByb3BzLmhpc3RvcnkuX29uVHJhbnNpdGlvbkNvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIExvY2F0aW9uUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgcmVmcyA9IHRoaXMuc3RhdGUucmVmcyxcbiAgICAgICAgaGlzdG9yeSA9IHRoaXMucHJvcHMuaGlzdG9yeTtcblxuICAgIHJlZnMudW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAoKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIV90aGlzMi51bm1vdW50ZWQpIHtcbiAgICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGNvbnRleHQ6IF90aGlzMi5nZXRDb250ZXh0KCkgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBMb2NhdGlvblByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciByZWZzID0gdGhpcy5zdGF0ZS5yZWZzO1xuXG4gICAgdGhpcy51bm1vdW50ZWQgPSB0cnVlO1xuICAgIHJlZnMudW5saXN0ZW4oKTtcbiAgfTtcblxuICBMb2NhdGlvblByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLnN0YXRlLmNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLFxuICAgICAgeyB2YWx1ZTogY29udGV4dCB9LFxuICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihjb250ZXh0KSA6IGNoaWxkcmVuIHx8IG51bGxcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBMb2NhdGlvblByb3ZpZGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbkxvY2F0aW9uUHJvdmlkZXIuZGVmYXVsdFByb3BzID0ge1xuICBoaXN0b3J5OiBnbG9iYWxIaXN0b3J5XG59O1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gTG9jYXRpb25Qcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufSA6IHZvaWQgMDtcbnZhciBTZXJ2ZXJMb2NhdGlvbiA9IGZ1bmN0aW9uIFNlcnZlckxvY2F0aW9uKF9yZWYyKSB7XG4gIHZhciB1cmwgPSBfcmVmMi51cmwsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbG9jYXRpb246IHsgcGF0aG5hbWU6IHVybCB9LFxuICAgICAgICBuYXZpZ2F0ZTogZnVuY3Rpb24gbmF2aWdhdGUoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbid0IGNhbGwgbmF2aWdhdGUgb24gdGhlIHNlcnZlci5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICk7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gU2V0cyBiYXNldXJpIGFuZCBiYXNlcGF0aCBmb3IgbmVzdGVkIHJvdXRlcnMgYW5kIGxpbmtzXG52YXIgQmFzZUNvbnRleHQgPSBjcmVhdGVOYW1lZENvbnRleHQoXCJCYXNlXCIsIHsgYmFzZXVyaTogXCIvXCIsIGJhc2VwYXRoOiBcIi9cIiB9KTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRoZSBtYWluIGV2ZW50LCB3ZWxjb21lIHRvIHRoZSBzaG93IGV2ZXJ5Ym9keS5cbnZhciBSb3V0ZXIgPSBmdW5jdGlvbiBSb3V0ZXIocHJvcHMpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgQmFzZUNvbnRleHQuQ29uc3VtZXIsXG4gICAgbnVsbCxcbiAgICBmdW5jdGlvbiAoYmFzZUNvbnRleHQpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBMb2NhdGlvbixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZnVuY3Rpb24gKGxvY2F0aW9uQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlckltcGwsIF9leHRlbmRzKHt9LCBiYXNlQ29udGV4dCwgbG9jYXRpb25Db250ZXh0LCBwcm9wcykpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgKTtcbn07XG5cbnZhciBSb3V0ZXJJbXBsID0gZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSb3V0ZXJJbXBsLCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGVySW1wbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGVySW1wbCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JFB1cmVDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBSb3V0ZXJJbXBsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGxvY2F0aW9uID0gX3Byb3BzLmxvY2F0aW9uLFxuICAgICAgICBfbmF2aWdhdGUyID0gX3Byb3BzLm5hdmlnYXRlLFxuICAgICAgICBiYXNlcGF0aCA9IF9wcm9wcy5iYXNlcGF0aCxcbiAgICAgICAgcHJpbWFyeSA9IF9wcm9wcy5wcmltYXJ5LFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgYmFzZXVyaSA9IF9wcm9wcy5iYXNldXJpLFxuICAgICAgICBfcHJvcHMkY29tcG9uZW50ID0gX3Byb3BzLmNvbXBvbmVudCxcbiAgICAgICAgY29tcG9uZW50ID0gX3Byb3BzJGNvbXBvbmVudCA9PT0gdW5kZWZpbmVkID8gXCJkaXZcIiA6IF9wcm9wcyRjb21wb25lbnQsXG4gICAgICAgIGRvbVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgW1wibG9jYXRpb25cIiwgXCJuYXZpZ2F0ZVwiLCBcImJhc2VwYXRoXCIsIFwicHJpbWFyeVwiLCBcImNoaWxkcmVuXCIsIFwiYmFzZXVyaVwiLCBcImNvbXBvbmVudFwiXSk7XG5cbiAgICB2YXIgcm91dGVzID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjcmVhdGVSb3V0ZShiYXNlcGF0aCkpO1xuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuXG5cbiAgICB2YXIgbWF0Y2ggPSBwaWNrKHJvdXRlcywgcGF0aG5hbWUpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgcGFyYW1zID0gbWF0Y2gucGFyYW1zLFxuICAgICAgICAgIHVyaSA9IG1hdGNoLnVyaSxcbiAgICAgICAgICByb3V0ZSA9IG1hdGNoLnJvdXRlLFxuICAgICAgICAgIGVsZW1lbnQgPSBtYXRjaC5yb3V0ZS52YWx1ZTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSAvKiBmcm9tIHRoZSBlbmQgZm9yIGNoaWxkIHJvdXRlcyByZWxhdGl2ZSBwYXRoc1xuXG4gICAgICBiYXNlcGF0aCA9IHJvdXRlLmRlZmF1bHQgPyBiYXNlcGF0aCA6IHJvdXRlLnBhdGgucmVwbGFjZSgvXFwqJC8sIFwiXCIpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgcGFyYW1zLCB7XG4gICAgICAgIHVyaTogdXJpLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIG5hdmlnYXRlOiBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgb3B0aW9ucykge1xuICAgICAgICAgIHJldHVybiBfbmF2aWdhdGUyKHJlc29sdmUodG8sIHVyaSksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNsb25lID0gUmVhY3QuY2xvbmVFbGVtZW50KGVsZW1lbnQsIHByb3BzLCBlbGVtZW50LnByb3BzLmNoaWxkcmVuID8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUm91dGVyLFxuICAgICAgICB7IHByaW1hcnk6IHByaW1hcnkgfSxcbiAgICAgICAgZWxlbWVudC5wcm9wcy5jaGlsZHJlblxuICAgICAgKSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgIC8vIHVzaW5nICdkaXYnIGZvciA8IDE2LjMgc3VwcG9ydFxuICAgICAgdmFyIEZvY3VzV3JhcHBlciA9IHByaW1hcnkgPyBGb2N1c0hhbmRsZXIgOiBjb21wb25lbnQ7XG4gICAgICAvLyBkb24ndCBwYXNzIGFueSBwcm9wcyB0byAnZGl2J1xuICAgICAgdmFyIHdyYXBwZXJQcm9wcyA9IHByaW1hcnkgPyBfZXh0ZW5kcyh7IHVyaTogdXJpLCBsb2NhdGlvbjogbG9jYXRpb24sIGNvbXBvbmVudDogY29tcG9uZW50IH0sIGRvbVByb3BzKSA6IGRvbVByb3BzO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgQmFzZUNvbnRleHQuUHJvdmlkZXIsXG4gICAgICAgIHsgdmFsdWU6IHsgYmFzZXVyaTogdXJpLCBiYXNlcGF0aDogYmFzZXBhdGggfSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIEZvY3VzV3JhcHBlcixcbiAgICAgICAgICB3cmFwcGVyUHJvcHMsXG4gICAgICAgICAgY2xvbmVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm90IHN1cmUgaWYgd2Ugd2FudCB0aGlzLCB3b3VsZCByZXF1aXJlIGluZGV4IHJvdXRlcyBhdCBldmVyeSBsZXZlbFxuICAgICAgLy8gd2FybmluZyhcbiAgICAgIC8vICAgZmFsc2UsXG4gICAgICAvLyAgIGA8Um91dGVyIGJhc2VwYXRoPVwiJHtiYXNlcGF0aH1cIj5cXG5cXG5Ob3RoaW5nIG1hdGNoZWQ6XFxuXFx0JHtcbiAgICAgIC8vICAgICBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgLy8gICB9XFxuXFxuUGF0aHMgY2hlY2tlZDogXFxuXFx0JHtyb3V0ZXNcbiAgICAgIC8vICAgICAubWFwKHJvdXRlID0+IHJvdXRlLnBhdGgpXG4gICAgICAvLyAgICAgLmpvaW4oXG4gICAgICAvLyAgICAgICBcIlxcblxcdFwiXG4gICAgICAvLyAgICAgKX1cXG5cXG5UbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgYWRkIGEgZGVmYXVsdCBOb3RGb3VuZCBjb21wb25lbnQgYXMgY2hpbGQgb2YgUm91dGVyOlxuICAgICAgLy8gICBcXG5cXHRsZXQgTm90Rm91bmQgPSAoKSA9PiA8ZGl2Pk5vdCBGb3VuZCE8L2Rpdj5cbiAgICAgIC8vICAgXFxuXFx0PFJvdXRlcj5cXG5cXHQgIDxOb3RGb3VuZCBkZWZhdWx0Lz5cXG5cXHQgIHsvKiAuLi4gKi99XFxuXFx0PC9Sb3V0ZXI+YFxuICAgICAgLy8gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUm91dGVySW1wbDtcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cblJvdXRlckltcGwuZGVmYXVsdFByb3BzID0ge1xuICBwcmltYXJ5OiB0cnVlXG59O1xuXG5cbnZhciBGb2N1c0NvbnRleHQgPSBjcmVhdGVOYW1lZENvbnRleHQoXCJGb2N1c1wiKTtcblxudmFyIEZvY3VzSGFuZGxlciA9IGZ1bmN0aW9uIEZvY3VzSGFuZGxlcihfcmVmMykge1xuICB2YXIgdXJpID0gX3JlZjMudXJpLFxuICAgICAgbG9jYXRpb24gPSBfcmVmMy5sb2NhdGlvbixcbiAgICAgIGNvbXBvbmVudCA9IF9yZWYzLmNvbXBvbmVudCxcbiAgICAgIGRvbVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYzLCBbXCJ1cmlcIiwgXCJsb2NhdGlvblwiLCBcImNvbXBvbmVudFwiXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgRm9jdXNDb250ZXh0LkNvbnN1bWVyLFxuICAgIG51bGwsXG4gICAgZnVuY3Rpb24gKHJlcXVlc3RGb2N1cykge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNIYW5kbGVySW1wbCwgX2V4dGVuZHMoe30sIGRvbVByb3BzLCB7XG4gICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICByZXF1ZXN0Rm9jdXM6IHJlcXVlc3RGb2N1cyxcbiAgICAgICAgdXJpOiB1cmksXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgfSkpO1xuICAgIH1cbiAgKTtcbn07XG5cbi8vIGRvbid0IGZvY3VzIG9uIGluaXRpYWwgcmVuZGVyXG52YXIgaW5pdGlhbFJlbmRlciA9IHRydWU7XG52YXIgZm9jdXNIYW5kbGVyQ291bnQgPSAwO1xuXG52YXIgRm9jdXNIYW5kbGVySW1wbCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50Mikge1xuICBfaW5oZXJpdHMoRm9jdXNIYW5kbGVySW1wbCwgX1JlYWN0JENvbXBvbmVudDIpO1xuXG4gIGZ1bmN0aW9uIEZvY3VzSGFuZGxlckltcGwoKSB7XG4gICAgdmFyIF90ZW1wMiwgX3RoaXM0LCBfcmV0MjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb2N1c0hhbmRsZXJJbXBsKTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQyID0gKF90ZW1wMiA9IChfdGhpczQgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50Mi5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzNCksIF90aGlzNC5zdGF0ZSA9IHt9LCBfdGhpczQucmVxdWVzdEZvY3VzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICghX3RoaXM0LnN0YXRlLnNob3VsZEZvY3VzKSB7XG4gICAgICAgIG5vZGUuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9LCBfdGVtcDIpLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpczQsIF9yZXQyKTtcbiAgfVxuXG4gIEZvY3VzSGFuZGxlckltcGwuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgdmFyIGluaXRpYWwgPSBwcmV2U3RhdGUudXJpID09IG51bGw7XG4gICAgaWYgKGluaXRpYWwpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHNob3VsZEZvY3VzOiB0cnVlXG4gICAgICB9LCBuZXh0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbXlVUklDaGFuZ2VkID0gbmV4dFByb3BzLnVyaSAhPT0gcHJldlN0YXRlLnVyaTtcbiAgICAgIHZhciBuYXZpZ2F0ZWRVcFRvTWUgPSBwcmV2U3RhdGUubG9jYXRpb24ucGF0aG5hbWUgIT09IG5leHRQcm9wcy5sb2NhdGlvbi5wYXRobmFtZSAmJiBuZXh0UHJvcHMubG9jYXRpb24ucGF0aG5hbWUgPT09IG5leHRQcm9wcy51cmk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBzaG91bGRGb2N1czogbXlVUklDaGFuZ2VkIHx8IG5hdmlnYXRlZFVwVG9NZVxuICAgICAgfSwgbmV4dFByb3BzKTtcbiAgICB9XG4gIH07XG5cbiAgRm9jdXNIYW5kbGVySW1wbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBmb2N1c0hhbmRsZXJDb3VudCsrO1xuICAgIHRoaXMuZm9jdXMoKTtcbiAgfTtcblxuICBGb2N1c0hhbmRsZXJJbXBsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGZvY3VzSGFuZGxlckNvdW50LS07XG4gICAgaWYgKGZvY3VzSGFuZGxlckNvdW50ID09PSAwKSB7XG4gICAgICBpbml0aWFsUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgRm9jdXNIYW5kbGVySW1wbC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgaWYgKHByZXZQcm9wcy5sb2NhdGlvbiAhPT0gdGhpcy5wcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnN0YXRlLnNob3VsZEZvY3VzKSB7XG4gICAgICB0aGlzLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIEZvY3VzSGFuZGxlckltcGwucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICAgICAgLy8gZ2V0dGluZyBjYW5ub3QgcmVhZCBwcm9wZXJ0eSBmb2N1cyBvZiBudWxsIGluIHRoZSB0ZXN0c1xuICAgICAgLy8gYW5kIHRoYXQgYml0IG9mIGdsb2JhbCBgaW5pdGlhbFJlbmRlcmAgc3RhdGUgY2F1c2VzIHByb2JsZW1zXG4gICAgICAvLyBzaG91bGQgcHJvYmFibHkgZmlndXJlIGl0IG91dCFcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdEZvY3VzID0gdGhpcy5wcm9wcy5yZXF1ZXN0Rm9jdXM7XG5cblxuICAgIGlmIChyZXF1ZXN0Rm9jdXMpIHtcbiAgICAgIHJlcXVlc3RGb2N1cyh0aGlzLm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5pdGlhbFJlbmRlcikge1xuICAgICAgICBpbml0aWFsUmVuZGVyID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5vZGUuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRm9jdXNIYW5kbGVySW1wbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIHN0eWxlID0gX3Byb3BzMi5zdHlsZSxcbiAgICAgICAgcmVxdWVzdEZvY3VzID0gX3Byb3BzMi5yZXF1ZXN0Rm9jdXMsXG4gICAgICAgIF9wcm9wczIkcm9sZSA9IF9wcm9wczIucm9sZSxcbiAgICAgICAgcm9sZSA9IF9wcm9wczIkcm9sZSA9PT0gdW5kZWZpbmVkID8gXCJncm91cFwiIDogX3Byb3BzMiRyb2xlLFxuICAgICAgICBfcHJvcHMyJGNvbXBvbmVudCA9IF9wcm9wczIuY29tcG9uZW50LFxuICAgICAgICBDb21wID0gX3Byb3BzMiRjb21wb25lbnQgPT09IHVuZGVmaW5lZCA/IFwiZGl2XCIgOiBfcHJvcHMyJGNvbXBvbmVudCxcbiAgICAgICAgdXJpID0gX3Byb3BzMi51cmksXG4gICAgICAgIGxvY2F0aW9uID0gX3Byb3BzMi5sb2NhdGlvbixcbiAgICAgICAgZG9tUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzMiwgW1wiY2hpbGRyZW5cIiwgXCJzdHlsZVwiLCBcInJlcXVlc3RGb2N1c1wiLCBcInJvbGVcIiwgXCJjb21wb25lbnRcIiwgXCJ1cmlcIiwgXCJsb2NhdGlvblwiXSk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIENvbXAsXG4gICAgICBfZXh0ZW5kcyh7XG4gICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7IG91dGxpbmU6IFwibm9uZVwiIH0sIHN0eWxlKSxcbiAgICAgICAgdGFiSW5kZXg6IFwiLTFcIixcbiAgICAgICAgcm9sZTogcm9sZSxcbiAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobikge1xuICAgICAgICAgIHJldHVybiBfdGhpczUubm9kZSA9IG47XG4gICAgICAgIH1cbiAgICAgIH0sIGRvbVByb3BzKSxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEZvY3VzQ29udGV4dC5Qcm92aWRlcixcbiAgICAgICAgeyB2YWx1ZTogdGhpcy5yZXF1ZXN0Rm9jdXMgfSxcbiAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIEZvY3VzSGFuZGxlckltcGw7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbnBvbHlmaWxsKEZvY3VzSGFuZGxlckltcGwpO1xuXG52YXIgayA9IGZ1bmN0aW9uIGsoKSB7fTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbnZhciBmb3J3YXJkUmVmID0gUmVhY3QuZm9yd2FyZFJlZjtcblxuaWYgKHR5cGVvZiBmb3J3YXJkUmVmID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIGZvcndhcmRSZWYgPSBmdW5jdGlvbiBmb3J3YXJkUmVmKEMpIHtcbiAgICByZXR1cm4gQztcbiAgfTtcbn1cblxudmFyIExpbmsgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmNCwgcmVmKSB7XG4gIHZhciBpbm5lclJlZiA9IF9yZWY0LmlubmVyUmVmLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjQsIFtcImlubmVyUmVmXCJdKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBCYXNlQ29udGV4dC5Db25zdW1lcixcbiAgICBudWxsLFxuICAgIGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgdmFyIGJhc2VwYXRoID0gX3JlZjUuYmFzZXBhdGgsXG4gICAgICAgICAgYmFzZXVyaSA9IF9yZWY1LmJhc2V1cmk7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgTG9jYXRpb24sXG4gICAgICAgIG51bGwsXG4gICAgICAgIGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgICAgIHZhciBsb2NhdGlvbiA9IF9yZWY2LmxvY2F0aW9uLFxuICAgICAgICAgICAgICBuYXZpZ2F0ZSA9IF9yZWY2Lm5hdmlnYXRlO1xuXG4gICAgICAgICAgdmFyIHRvID0gcHJvcHMudG8sXG4gICAgICAgICAgICAgIHN0YXRlID0gcHJvcHMuc3RhdGUsXG4gICAgICAgICAgICAgIHJlcGxhY2UgPSBwcm9wcy5yZXBsYWNlLFxuICAgICAgICAgICAgICBfcHJvcHMkZ2V0UHJvcHMgPSBwcm9wcy5nZXRQcm9wcyxcbiAgICAgICAgICAgICAgZ2V0UHJvcHMgPSBfcHJvcHMkZ2V0UHJvcHMgPT09IHVuZGVmaW5lZCA/IGsgOiBfcHJvcHMkZ2V0UHJvcHMsXG4gICAgICAgICAgICAgIGFuY2hvclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbXCJ0b1wiLCBcInN0YXRlXCIsIFwicmVwbGFjZVwiLCBcImdldFByb3BzXCJdKTtcblxuICAgICAgICAgIHZhciBocmVmID0gcmVzb2x2ZSh0bywgYmFzZXVyaSk7XG4gICAgICAgICAgdmFyIGlzQ3VycmVudCA9IGxvY2F0aW9uLnBhdGhuYW1lID09PSBocmVmO1xuICAgICAgICAgIHZhciBpc1BhcnRpYWxseUN1cnJlbnQgPSBzdGFydHNXaXRoKGxvY2F0aW9uLnBhdGhuYW1lLCBocmVmKTtcblxuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICByZWY6IHJlZiB8fCBpbm5lclJlZixcbiAgICAgICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGlzQ3VycmVudCA/IFwicGFnZVwiIDogdW5kZWZpbmVkXG4gICAgICAgICAgfSwgYW5jaG9yUHJvcHMsIGdldFByb3BzKHsgaXNDdXJyZW50OiBpc0N1cnJlbnQsIGlzUGFydGlhbGx5Q3VycmVudDogaXNQYXJ0aWFsbHlDdXJyZW50LCBocmVmOiBocmVmLCBsb2NhdGlvbjogbG9jYXRpb24gfSksIHtcbiAgICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGlmIChhbmNob3JQcm9wcy5vbkNsaWNrKSBhbmNob3JQcm9wcy5vbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgaWYgKHNob3VsZE5hdmlnYXRlKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGUoaHJlZiwgeyBzdGF0ZTogc3RhdGUsIHJlcGxhY2U6IHJlcGxhY2UgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICApO1xufSk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBSZWRpcmVjdFJlcXVlc3QodXJpKSB7XG4gIHRoaXMudXJpID0gdXJpO1xufVxuXG52YXIgaXNSZWRpcmVjdCA9IGZ1bmN0aW9uIGlzUmVkaXJlY3Qobykge1xuICByZXR1cm4gbyBpbnN0YW5jZW9mIFJlZGlyZWN0UmVxdWVzdDtcbn07XG5cbnZhciByZWRpcmVjdFRvID0gZnVuY3Rpb24gcmVkaXJlY3RUbyh0bykge1xuICB0aHJvdyBuZXcgUmVkaXJlY3RSZXF1ZXN0KHRvKTtcbn07XG5cbnZhciBSZWRpcmVjdEltcGwgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudDMpIHtcbiAgX2luaGVyaXRzKFJlZGlyZWN0SW1wbCwgX1JlYWN0JENvbXBvbmVudDMpO1xuXG4gIGZ1bmN0aW9uIFJlZGlyZWN0SW1wbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVkaXJlY3RJbXBsKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50My5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8vIFN1cHBvcnQgUmVhY3QgPCAxNiB3aXRoIHRoaXMgaG9va1xuICBSZWRpcmVjdEltcGwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICBuYXZpZ2F0ZSA9IF9wcm9wczMubmF2aWdhdGUsXG4gICAgICAgIHRvID0gX3Byb3BzMy50byxcbiAgICAgICAgZnJvbSA9IF9wcm9wczMuZnJvbSxcbiAgICAgICAgX3Byb3BzMyRyZXBsYWNlID0gX3Byb3BzMy5yZXBsYWNlLFxuICAgICAgICByZXBsYWNlID0gX3Byb3BzMyRyZXBsYWNlID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3Byb3BzMyRyZXBsYWNlLFxuICAgICAgICBzdGF0ZSA9IF9wcm9wczMuc3RhdGUsXG4gICAgICAgIG5vVGhyb3cgPSBfcHJvcHMzLm5vVGhyb3csXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczMsIFtcIm5hdmlnYXRlXCIsIFwidG9cIiwgXCJmcm9tXCIsIFwicmVwbGFjZVwiLCBcInN0YXRlXCIsIFwibm9UaHJvd1wiXSk7XG5cbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5hdmlnYXRlKGluc2VydFBhcmFtcyh0bywgcHJvcHMpLCB7IHJlcGxhY2U6IHJlcGxhY2UsIHN0YXRlOiBzdGF0ZSB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBSZWRpcmVjdEltcGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzNCA9IHRoaXMucHJvcHMsXG4gICAgICAgIG5hdmlnYXRlID0gX3Byb3BzNC5uYXZpZ2F0ZSxcbiAgICAgICAgdG8gPSBfcHJvcHM0LnRvLFxuICAgICAgICBmcm9tID0gX3Byb3BzNC5mcm9tLFxuICAgICAgICByZXBsYWNlID0gX3Byb3BzNC5yZXBsYWNlLFxuICAgICAgICBzdGF0ZSA9IF9wcm9wczQuc3RhdGUsXG4gICAgICAgIG5vVGhyb3cgPSBfcHJvcHM0Lm5vVGhyb3csXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczQsIFtcIm5hdmlnYXRlXCIsIFwidG9cIiwgXCJmcm9tXCIsIFwicmVwbGFjZVwiLCBcInN0YXRlXCIsIFwibm9UaHJvd1wiXSk7XG5cbiAgICBpZiAoIW5vVGhyb3cpIHJlZGlyZWN0VG8oaW5zZXJ0UGFyYW1zKHRvLCBwcm9wcykpO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSZWRpcmVjdEltcGw7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbnZhciBSZWRpcmVjdCA9IGZ1bmN0aW9uIFJlZGlyZWN0KHByb3BzKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIExvY2F0aW9uLFxuICAgIG51bGwsXG4gICAgZnVuY3Rpb24gKGxvY2F0aW9uQ29udGV4dCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RJbXBsLCBfZXh0ZW5kcyh7fSwgbG9jYXRpb25Db250ZXh0LCBwcm9wcykpO1xuICAgIH1cbiAgKTtcbn07XG5cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlZGlyZWN0LnByb3BUeXBlcyA9IHtcbiAgZnJvbTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG86IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZFxufSA6IHZvaWQgMDtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbnZhciBNYXRjaCA9IGZ1bmN0aW9uIE1hdGNoKF9yZWY3KSB7XG4gIHZhciBwYXRoID0gX3JlZjcucGF0aCxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjcuY2hpbGRyZW47XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEJhc2VDb250ZXh0LkNvbnN1bWVyLFxuICAgIG51bGwsXG4gICAgZnVuY3Rpb24gKF9yZWY4KSB7XG4gICAgICB2YXIgYmFzZXVyaSA9IF9yZWY4LmJhc2V1cmk7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgTG9jYXRpb24sXG4gICAgICAgIG51bGwsXG4gICAgICAgIGZ1bmN0aW9uIChfcmVmOSkge1xuICAgICAgICAgIHZhciBuYXZpZ2F0ZSA9IF9yZWY5Lm5hdmlnYXRlLFxuICAgICAgICAgICAgICBsb2NhdGlvbiA9IF9yZWY5LmxvY2F0aW9uO1xuXG4gICAgICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IHJlc29sdmUocGF0aCwgYmFzZXVyaSk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGNoKHJlc29sdmVkUGF0aCwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbih7XG4gICAgICAgICAgICBuYXZpZ2F0ZTogbmF2aWdhdGUsXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgICBtYXRjaDogcmVzdWx0ID8gX2V4dGVuZHMoe30sIHJlc3VsdC5wYXJhbXMsIHtcbiAgICAgICAgICAgICAgdXJpOiByZXN1bHQudXJpLFxuICAgICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgICB9KSA6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICk7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSnVua1xudmFyIHN0cmlwU2xhc2hlcyA9IGZ1bmN0aW9uIHN0cmlwU2xhc2hlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXlxcLyt8XFwvKyQpL2csIFwiXCIpO1xufTtcblxudmFyIGNyZWF0ZVJvdXRlID0gZnVuY3Rpb24gY3JlYXRlUm91dGUoYmFzZXBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgIShlbGVtZW50LnByb3BzLnBhdGggfHwgZWxlbWVudC5wcm9wcy5kZWZhdWx0IHx8IGVsZW1lbnQudHlwZSA9PT0gUmVkaXJlY3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIjxSb3V0ZXI+OiBDaGlsZHJlbiBvZiA8Um91dGVyPiBtdXN0IGhhdmUgYSBgcGF0aGAgb3IgYGRlZmF1bHRgIHByb3AsIG9yIGJlIGEgYDxSZWRpcmVjdD5gLiBOb25lIGZvdW5kIG9uIGVsZW1lbnQgdHlwZSBgXCIgKyBlbGVtZW50LnR5cGUgKyBcImBcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgISEoZWxlbWVudC50eXBlID09PSBSZWRpcmVjdCAmJiAoIWVsZW1lbnQucHJvcHMuZnJvbSB8fCAhZWxlbWVudC5wcm9wcy50bykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIjxSZWRpcmVjdCBmcm9tPVxcXCJcIiArIGVsZW1lbnQucHJvcHMuZnJvbSArIFwiIHRvPVxcXCJcIiArIGVsZW1lbnQucHJvcHMudG8gKyBcIlxcXCIvPiByZXF1aXJlcyBib3RoIFxcXCJmcm9tXFxcIiBhbmQgXFxcInRvXFxcIiBwcm9wcyB3aGVuIGluc2lkZSBhIDxSb3V0ZXI+LlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAhIShlbGVtZW50LnR5cGUgPT09IFJlZGlyZWN0ICYmICF2YWxpZGF0ZVJlZGlyZWN0KGVsZW1lbnQucHJvcHMuZnJvbSwgZWxlbWVudC5wcm9wcy50bykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIjxSZWRpcmVjdCBmcm9tPVxcXCJcIiArIGVsZW1lbnQucHJvcHMuZnJvbSArIFwiIHRvPVxcXCJcIiArIGVsZW1lbnQucHJvcHMudG8gKyBcIlxcXCIvPiBoYXMgbWlzbWF0Y2hlZCBkeW5hbWljIHNlZ21lbnRzLCBlbnN1cmUgYm90aCBwYXRocyBoYXZlIHRoZSBleGFjdCBzYW1lIGR5bmFtaWMgc2VnbWVudHMuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmIChlbGVtZW50LnByb3BzLmRlZmF1bHQpIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiBlbGVtZW50LCBkZWZhdWx0OiB0cnVlIH07XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRQYXRoID0gZWxlbWVudC50eXBlID09PSBSZWRpcmVjdCA/IGVsZW1lbnQucHJvcHMuZnJvbSA6IGVsZW1lbnQucHJvcHMucGF0aDtcblxuICAgIHZhciBwYXRoID0gZWxlbWVudFBhdGggPT09IFwiL1wiID8gYmFzZXBhdGggOiBzdHJpcFNsYXNoZXMoYmFzZXBhdGgpICsgXCIvXCIgKyBzdHJpcFNsYXNoZXMoZWxlbWVudFBhdGgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBlbGVtZW50LFxuICAgICAgZGVmYXVsdDogZWxlbWVudC5wcm9wcy5kZWZhdWx0LFxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA/IHN0cmlwU2xhc2hlcyhwYXRoKSArIFwiLypcIiA6IHBhdGhcbiAgICB9O1xuICB9O1xufTtcblxudmFyIHNob3VsZE5hdmlnYXRlID0gZnVuY3Rpb24gc2hvdWxkTmF2aWdhdGUoZXZlbnQpIHtcbiAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgeyBMaW5rLCBMb2NhdGlvbiwgTG9jYXRpb25Qcm92aWRlciwgTWF0Y2gsIFJlZGlyZWN0LCBSb3V0ZXIsIFNlcnZlckxvY2F0aW9uLCBjcmVhdGVIaXN0b3J5LCBjcmVhdGVNZW1vcnlTb3VyY2UsIGlzUmVkaXJlY3QsIG5hdmlnYXRlLCByZWRpcmVjdFRvIH07IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNyZWF0ZUhpc3Rvcnkoc291cmNlKSAtIHdyYXBzIGEgaGlzdG9yeSBzb3VyY2VcbnZhciBnZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uKHNvdXJjZSkge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHNvdXJjZS5sb2NhdGlvbiwge1xuICAgIHN0YXRlOiBzb3VyY2UuaGlzdG9yeS5zdGF0ZSxcbiAgICBrZXk6IHNvdXJjZS5oaXN0b3J5LnN0YXRlICYmIHNvdXJjZS5oaXN0b3J5LnN0YXRlLmtleSB8fCBcImluaXRpYWxcIlxuICB9KTtcbn07XG5cbnZhciBjcmVhdGVIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGlzdG9yeShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihzb3VyY2UpO1xuICB2YXIgdHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICB2YXIgcmVzb2x2ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbigpIHt9O1xuXG4gIHJldHVybiB7XG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBnZXQgdHJhbnNpdGlvbmluZygpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uaW5nO1xuICAgIH0sXG5cbiAgICBfb25UcmFuc2l0aW9uQ29tcGxldGU6IGZ1bmN0aW9uIF9vblRyYW5zaXRpb25Db21wbGV0ZSgpIHtcbiAgICAgIHRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHJlc29sdmVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICB2YXIgcG9wc3RhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uIHBvcHN0YXRlTGlzdGVuZXIoKSB7XG4gICAgICAgIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oc291cmNlKTtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgcG9wc3RhdGVMaXN0ZW5lcik7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgcG9wc3RhdGVMaXN0ZW5lcik7XG4gICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgcmV0dXJuIGZuICE9PSBsaXN0ZW5lcjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uIG5hdmlnYXRlKHRvKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgICAgIF9yZWYkcmVwbGFjZSA9IF9yZWYucmVwbGFjZSxcbiAgICAgICAgICByZXBsYWNlID0gX3JlZiRyZXBsYWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkcmVwbGFjZTtcblxuICAgICAgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIHsga2V5OiBEYXRlLm5vdygpICsgXCJcIiB9KTtcbiAgICAgIC8vIHRyeS4uLmNhdGNoIGlPUyBTYWZhcmkgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uaW5nIHx8IHJlcGxhY2UpIHtcbiAgICAgICAgICBzb3VyY2UuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIG51bGwsIHRvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb3VyY2UuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIG51bGwsIHRvKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzb3VyY2UubG9jYXRpb25bcmVwbGFjZSA/IFwicmVwbGFjZVwiIDogXCJhc3NpZ25cIl0odG8pO1xuICAgICAgfVxuXG4gICAgICBsb2NhdGlvbiA9IGdldExvY2F0aW9uKHNvdXJjZSk7XG4gICAgICB0cmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zaXRpb24gPSByZXM7XG4gICAgICB9KTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb247XG4gICAgfVxuICB9O1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFN0b3JlcyBoaXN0b3J5IGVudHJpZXMgaW4gbWVtb3J5IGZvciB0ZXN0aW5nIG9yIG90aGVyIHBsYXRmb3JtcyBsaWtlIE5hdGl2ZVxudmFyIGNyZWF0ZU1lbW9yeVNvdXJjZSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVNvdXJjZSgpIHtcbiAgdmFyIGluaXRpYWxQYXRobmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCIvXCI7XG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHN0YWNrID0gW3sgcGF0aG5hbWU6IGluaXRpYWxQYXRobmFtZSwgc2VhcmNoOiBcIlwiIH1dO1xuICB2YXIgc3RhdGVzID0gW107XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gc3RhY2tbaW5kZXhdO1xuICAgIH0sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmbikge30sXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBmbikge30sXG5cbiAgICBoaXN0b3J5OiB7XG4gICAgICBnZXQgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgfSxcbiAgICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfSxcbiAgICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlc1tpbmRleF07XG4gICAgICB9LFxuICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIF8sIHVyaSkge1xuICAgICAgICB2YXIgX3VyaSRzcGxpdCA9IHVyaS5zcGxpdChcIj9cIiksXG4gICAgICAgICAgICBwYXRobmFtZSA9IF91cmkkc3BsaXRbMF0sXG4gICAgICAgICAgICBfdXJpJHNwbGl0JCA9IF91cmkkc3BsaXRbMV0sXG4gICAgICAgICAgICBzZWFyY2ggPSBfdXJpJHNwbGl0JCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IF91cmkkc3BsaXQkO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHN0YWNrLnB1c2goeyBwYXRobmFtZTogcGF0aG5hbWUsIHNlYXJjaDogc2VhcmNoIH0pO1xuICAgICAgICBzdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIF8sIHVyaSkge1xuICAgICAgICB2YXIgX3VyaSRzcGxpdDIgPSB1cmkuc3BsaXQoXCI/XCIpLFxuICAgICAgICAgICAgcGF0aG5hbWUgPSBfdXJpJHNwbGl0MlswXSxcbiAgICAgICAgICAgIF91cmkkc3BsaXQyJCA9IF91cmkkc3BsaXQyWzFdLFxuICAgICAgICAgICAgc2VhcmNoID0gX3VyaSRzcGxpdDIkID09PSB1bmRlZmluZWQgPyBcIlwiIDogX3VyaSRzcGxpdDIkO1xuXG4gICAgICAgIHN0YWNrW2luZGV4XSA9IHsgcGF0aG5hbWU6IHBhdGhuYW1lLCBzZWFyY2g6IHNlYXJjaCB9O1xuICAgICAgICBzdGF0ZXNbaW5kZXhdID0gc3RhdGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGdsb2JhbCBoaXN0b3J5IC0gdXNlcyB3aW5kb3cuaGlzdG9yeSBhcyB0aGUgc291cmNlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGFcbi8vIG1lbW9yeSBoaXN0b3J5XG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xudmFyIGdldFNvdXJjZSA9IGZ1bmN0aW9uIGdldFNvdXJjZSgpIHtcbiAgcmV0dXJuIGNhblVzZURPTSA/IHdpbmRvdyA6IGNyZWF0ZU1lbW9yeVNvdXJjZSgpO1xufTtcblxudmFyIGdsb2JhbEhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KGdldFNvdXJjZSgpKTtcbnZhciBuYXZpZ2F0ZSA9IGdsb2JhbEhpc3RvcnkubmF2aWdhdGU7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCB7IGdsb2JhbEhpc3RvcnksIG5hdmlnYXRlLCBjcmVhdGVIaXN0b3J5LCBjcmVhdGVNZW1vcnlTb3VyY2UgfTsiLCJpbXBvcnQgaW52YXJpYW50IGZyb20gXCJpbnZhcmlhbnRcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHN0YXJ0c1dpdGgoc3RyaW5nLCBzZWFyY2gpIC0gQ2hlY2sgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHNlYXJjaGBcbnZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHNlYXJjaCkge1xuICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHBpY2socm91dGVzLCB1cmkpXG4vL1xuLy8gUmFua3MgYW5kIHBpY2tzIHRoZSBiZXN0IHJvdXRlIHRvIG1hdGNoLiBFYWNoIHNlZ21lbnQgZ2V0cyB0aGUgaGlnaGVzdFxuLy8gYW1vdW50IG9mIHBvaW50cywgdGhlbiB0aGUgdHlwZSBvZiBzZWdtZW50IGdldHMgYW4gYWRkaXRpb25hbCBhbW91bnQgb2Zcbi8vIHBvaW50cyB3aGVyZVxuLy9cbi8vICAgICBzdGF0aWMgPiBkeW5hbWljID4gc3BsYXQgPiByb290XG4vL1xuLy8gVGhpcyB3YXkgd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0aGUgb3JkZXIgb2Ygb3VyIHJvdXRlcywgbGV0IHRoZVxuLy8gY29tcHV0ZXJzIGRvIGl0LlxuLy9cbi8vIEEgcm91dGUgbG9va3MgbGlrZSB0aGlzXG4vL1xuLy8gICAgIHsgcGF0aCwgZGVmYXVsdCwgdmFsdWUgfVxuLy9cbi8vIEFuZCBhIHJldHVybmVkIG1hdGNoIGxvb2tzIGxpa2U6XG4vL1xuLy8gICAgIHsgcm91dGUsIHBhcmFtcywgdXJpIH1cbi8vXG4vLyBJIGtub3csIEkgc2hvdWxkIHVzZSBUeXBlU2NyaXB0IG5vdCBjb21tZW50cyBmb3IgdGhlc2UgdHlwZXMuXG52YXIgcGljayA9IGZ1bmN0aW9uIHBpY2socm91dGVzLCB1cmkpIHtcbiAgdmFyIG1hdGNoID0gdm9pZCAwO1xuICB2YXIgZGVmYXVsdF8gPSB2b2lkIDA7XG5cbiAgdmFyIF91cmkkc3BsaXQgPSB1cmkuc3BsaXQoXCI/XCIpLFxuICAgICAgdXJpUGF0aG5hbWUgPSBfdXJpJHNwbGl0WzBdO1xuXG4gIHZhciB1cmlTZWdtZW50cyA9IHNlZ21lbnRpemUodXJpUGF0aG5hbWUpO1xuICB2YXIgaXNSb290VXJpID0gdXJpU2VnbWVudHNbMF0gPT09IFwiXCI7XG4gIHZhciByYW5rZWQgPSByYW5rUm91dGVzKHJvdXRlcyk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSByYW5rZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIG1pc3NlZCA9IGZhbHNlO1xuICAgIHZhciByb3V0ZSA9IHJhbmtlZFtpXS5yb3V0ZTtcblxuICAgIGlmIChyb3V0ZS5kZWZhdWx0KSB7XG4gICAgICBkZWZhdWx0XyA9IHtcbiAgICAgICAgcm91dGU6IHJvdXRlLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICB1cmk6IHVyaVxuICAgICAgfTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciByb3V0ZVNlZ21lbnRzID0gc2VnbWVudGl6ZShyb3V0ZS5wYXRoKTtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHVyaVNlZ21lbnRzLmxlbmd0aCwgcm91dGVTZWdtZW50cy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgIHZhciByb3V0ZVNlZ21lbnQgPSByb3V0ZVNlZ21lbnRzW2luZGV4XTtcbiAgICAgIHZhciB1cmlTZWdtZW50ID0gdXJpU2VnbWVudHNbaW5kZXhdO1xuXG4gICAgICB2YXIgX2lzU3BsYXQgPSByb3V0ZVNlZ21lbnQgPT09IFwiKlwiO1xuICAgICAgaWYgKF9pc1NwbGF0KSB7XG4gICAgICAgIC8vIEhpdCBhIHNwbGF0LCBqdXN0IGdyYWIgdGhlIHJlc3QsIGFuZCByZXR1cm4gYSBtYXRjaFxuICAgICAgICAvLyB1cmk6ICAgL2ZpbGVzL2RvY3VtZW50cy93b3JrXG4gICAgICAgIC8vIHJvdXRlOiAvZmlsZXMvKlxuICAgICAgICBwYXJhbXNbXCIqXCJdID0gdXJpU2VnbWVudHMuc2xpY2UoaW5kZXgpLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIvXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHVyaVNlZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBVUkkgaXMgc2hvcnRlciB0aGFuIHRoZSByb3V0ZSwgbm8gbWF0Y2hcbiAgICAgICAgLy8gdXJpOiAgIC91c2Vyc1xuICAgICAgICAvLyByb3V0ZTogL3VzZXJzLzp1c2VySWRcbiAgICAgICAgbWlzc2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBkeW5hbWljTWF0Y2ggPSBwYXJhbVJlLmV4ZWMocm91dGVTZWdtZW50KTtcblxuICAgICAgaWYgKGR5bmFtaWNNYXRjaCAmJiAhaXNSb290VXJpKSB7XG4gICAgICAgIHZhciBtYXRjaElzTm90UmVzZXJ2ZWQgPSByZXNlcnZlZE5hbWVzLmluZGV4T2YoZHluYW1pY01hdGNoWzFdKSA9PT0gLTE7XG4gICAgICAgICFtYXRjaElzTm90UmVzZXJ2ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiPFJvdXRlcj4gZHluYW1pYyBzZWdtZW50IFxcXCJcIiArIGR5bmFtaWNNYXRjaFsxXSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIG5hbWUuIFBsZWFzZSB1c2UgYSBkaWZmZXJlbnQgbmFtZSBpbiBwYXRoIFxcXCJcIiArIHJvdXRlLnBhdGggKyBcIlxcXCIuXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgICAgdmFyIHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHVyaVNlZ21lbnQpO1xuICAgICAgICBwYXJhbXNbZHluYW1pY01hdGNoWzFdXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChyb3V0ZVNlZ21lbnQgIT09IHVyaVNlZ21lbnQpIHtcbiAgICAgICAgLy8gQ3VycmVudCBzZWdtZW50cyBkb24ndCBtYXRjaCwgbm90IGR5bmFtaWMsIG5vdCBzcGxhdCwgc28gbm8gbWF0Y2hcbiAgICAgICAgLy8gdXJpOiAgIC91c2Vycy8xMjMvc2V0dGluZ3NcbiAgICAgICAgLy8gcm91dGU6IC91c2Vycy86aWQvcHJvZmlsZVxuICAgICAgICBtaXNzZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW1pc3NlZCkge1xuICAgICAgbWF0Y2ggPSB7XG4gICAgICAgIHJvdXRlOiByb3V0ZSxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIHVyaTogXCIvXCIgKyB1cmlTZWdtZW50cy5zbGljZSgwLCBpbmRleCkuam9pbihcIi9cIilcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2ggfHwgZGVmYXVsdF8gfHwgbnVsbDtcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYXRjaChwYXRoLCB1cmkpIC0gTWF0Y2hlcyBqdXN0IG9uZSBwYXRoIHRvIGEgdXJpLCBhbHNvIGxvbFxudmFyIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gocGF0aCwgdXJpKSB7XG4gIHJldHVybiBwaWNrKFt7IHBhdGg6IHBhdGggfV0sIHVyaSk7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gcmVzb2x2ZSh0bywgYmFzZXBhdGgpXG4vL1xuLy8gUmVzb2x2ZXMgVVJJcyBhcyB0aG91Z2ggZXZlcnkgcGF0aCBpcyBhIGRpcmVjdG9yeSwgbm8gZmlsZXMuICBSZWxhdGl2ZSBVUklzXG4vLyBpbiB0aGUgYnJvd3NlciBjYW4gZmVlbCBhd2t3YXJkIGJlY2F1c2Ugbm90IG9ubHkgY2FuIHlvdSBiZSBcImluIGEgZGlyZWN0b3J5XCJcbi8vIHlvdSBjYW4gYmUgXCJhdCBhIGZpbGVcIiwgdG9vLiBGb3IgZXhhbXBsZVxuLy9cbi8vICAgICBicm93c2VyU3BlY1Jlc29sdmUoJ2ZvbycsICcvYmFyLycpID0+IC9iYXIvZm9vXG4vLyAgICAgYnJvd3NlclNwZWNSZXNvbHZlKCdmb28nLCAnL2JhcicpID0+IC9mb29cbi8vXG4vLyBCdXQgb24gdGhlIGNvbW1hbmQgbGluZSBvZiBhIGZpbGUgc3lzdGVtLCBpdCdzIG5vdCBhcyBjb21wbGljYXRlZCwgeW91IGNhbid0XG4vLyBgY2RgIGZyb20gYSBmaWxlLCBvbmx5IGRpcmVjdG9yaWVzLiAgVGhpcyB3YXksIGxpbmtzIGhhdmUgdG8ga25vdyBsZXNzIGFib3V0XG4vLyB0aGVpciBjdXJyZW50IHBhdGguIFRvIGdvIGRlZXBlciB5b3UgY2FuIGRvIHRoaXM6XG4vL1xuLy8gICAgIDxMaW5rIHRvPVwiZGVlcGVyXCIvPlxuLy8gICAgIC8vIGluc3RlYWQgb2Zcbi8vICAgICA8TGluayB0bz1geyR7cHJvcHMudXJpfS9kZWVwZXJ9YC8+XG4vL1xuLy8gSnVzdCBsaWtlIGBjZGAsIGlmIHlvdSB3YW50IHRvIGdvIGRlZXBlciBmcm9tIHRoZSBjb21tYW5kIGxpbmUsIHlvdSBkbyB0aGlzOlxuLy9cbi8vICAgICBjZCBkZWVwZXJcbi8vICAgICAjIG5vdFxuLy8gICAgIGNkICQocHdkKS9kZWVwZXJcbi8vXG4vLyBCeSB0cmVhdGluZyBldmVyeSBwYXRoIGFzIGEgZGlyZWN0b3J5LCBsaW5raW5nIHRvIHJlbGF0aXZlIHBhdGhzIHNob3VsZFxuLy8gcmVxdWlyZSBsZXNzIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIChmaW5nZXJzIGNyb3NzZWQpIGJlIG1vcmUgaW50dWl0aXZlLlxudmFyIHJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHRvLCBiYXNlKSB7XG4gIC8vIC9mb28vYmFyLCAvYmF6L3F1eCA9PiAvZm9vL2JhclxuICBpZiAoc3RhcnRzV2l0aCh0bywgXCIvXCIpKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG5cbiAgdmFyIF90byRzcGxpdCA9IHRvLnNwbGl0KFwiP1wiKSxcbiAgICAgIHRvUGF0aG5hbWUgPSBfdG8kc3BsaXRbMF0sXG4gICAgICB0b1F1ZXJ5ID0gX3RvJHNwbGl0WzFdO1xuXG4gIHZhciBfYmFzZSRzcGxpdCA9IGJhc2Uuc3BsaXQoXCI/XCIpLFxuICAgICAgYmFzZVBhdGhuYW1lID0gX2Jhc2Ukc3BsaXRbMF07XG5cbiAgdmFyIHRvU2VnbWVudHMgPSBzZWdtZW50aXplKHRvUGF0aG5hbWUpO1xuICB2YXIgYmFzZVNlZ21lbnRzID0gc2VnbWVudGl6ZShiYXNlUGF0aG5hbWUpO1xuXG4gIC8vID9hPWIsIC91c2Vycz9iPWMgPT4gL3VzZXJzP2E9YlxuICBpZiAodG9TZWdtZW50c1swXSA9PT0gXCJcIikge1xuICAgIHJldHVybiBhZGRRdWVyeShiYXNlUGF0aG5hbWUsIHRvUXVlcnkpO1xuICB9XG5cbiAgLy8gcHJvZmlsZSwgL3VzZXJzLzc4OSA9PiAvdXNlcnMvNzg5L3Byb2ZpbGVcbiAgaWYgKCFzdGFydHNXaXRoKHRvU2VnbWVudHNbMF0sIFwiLlwiKSkge1xuICAgIHZhciBwYXRobmFtZSA9IGJhc2VTZWdtZW50cy5jb25jYXQodG9TZWdtZW50cykuam9pbihcIi9cIik7XG4gICAgcmV0dXJuIGFkZFF1ZXJ5KChiYXNlUGF0aG5hbWUgPT09IFwiL1wiID8gXCJcIiA6IFwiL1wiKSArIHBhdGhuYW1lLCB0b1F1ZXJ5KTtcbiAgfVxuXG4gIC8vIC4vICAgICAgICAgL3VzZXJzLzEyMyAgPT4gIC91c2Vycy8xMjNcbiAgLy8gLi4vICAgICAgICAvdXNlcnMvMTIzICA9PiAgL3VzZXJzXG4gIC8vIC4uLy4uICAgICAgL3VzZXJzLzEyMyAgPT4gIC9cbiAgLy8gLi4vLi4vb25lICAvYS9iL2MvZCAgICA9PiAgL2EvYi9vbmVcbiAgLy8gLi4vLi9vbmUgICAvYS9iL2MvZCAgICA9PiAgL2EvYi9jL29uZVxuICB2YXIgYWxsU2VnbWVudHMgPSBiYXNlU2VnbWVudHMuY29uY2F0KHRvU2VnbWVudHMpO1xuICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbGxTZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IGFsbFNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHNlZ21lbnRzLnBvcCgpO2Vsc2UgaWYgKHNlZ21lbnQgIT09IFwiLlwiKSBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGFkZFF1ZXJ5KFwiL1wiICsgc2VnbWVudHMuam9pbihcIi9cIiksIHRvUXVlcnkpO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGluc2VydFBhcmFtcyhwYXRoLCBwYXJhbXMpXG52YXIgaW5zZXJ0UGFyYW1zID0gZnVuY3Rpb24gaW5zZXJ0UGFyYW1zKHBhdGgsIHBhcmFtcykge1xuICB2YXIgc2VnbWVudHMgPSBzZWdtZW50aXplKHBhdGgpO1xuICByZXR1cm4gXCIvXCIgKyBzZWdtZW50cy5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICB2YXIgbWF0Y2ggPSBwYXJhbVJlLmV4ZWMoc2VnbWVudCk7XG4gICAgcmV0dXJuIG1hdGNoID8gcGFyYW1zW21hdGNoWzFdXSA6IHNlZ21lbnQ7XG4gIH0pLmpvaW4oXCIvXCIpO1xufTtcblxudmFyIHZhbGlkYXRlUmVkaXJlY3QgPSBmdW5jdGlvbiB2YWxpZGF0ZVJlZGlyZWN0KGZyb20sIHRvKSB7XG4gIHZhciBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoc2VnbWVudCkge1xuICAgIHJldHVybiBpc0R5bmFtaWMoc2VnbWVudCk7XG4gIH07XG4gIHZhciBmcm9tU3RyaW5nID0gc2VnbWVudGl6ZShmcm9tKS5maWx0ZXIoZmlsdGVyKS5zb3J0KCkuam9pbihcIi9cIik7XG4gIHZhciB0b1N0cmluZyA9IHNlZ21lbnRpemUodG8pLmZpbHRlcihmaWx0ZXIpLnNvcnQoKS5qb2luKFwiL1wiKTtcbiAgcmV0dXJuIGZyb21TdHJpbmcgPT09IHRvU3RyaW5nO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEp1bmtcbnZhciBwYXJhbVJlID0gL146KC4rKS87XG5cbnZhciBTRUdNRU5UX1BPSU5UUyA9IDQ7XG52YXIgU1RBVElDX1BPSU5UUyA9IDM7XG52YXIgRFlOQU1JQ19QT0lOVFMgPSAyO1xudmFyIFNQTEFUX1BFTkFMVFkgPSAxO1xudmFyIFJPT1RfUE9JTlRTID0gMTtcblxudmFyIGlzUm9vdFNlZ21lbnQgPSBmdW5jdGlvbiBpc1Jvb3RTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnQgPT09IFwiXCI7XG59O1xudmFyIGlzRHluYW1pYyA9IGZ1bmN0aW9uIGlzRHluYW1pYyhzZWdtZW50KSB7XG4gIHJldHVybiBwYXJhbVJlLnRlc3Qoc2VnbWVudCk7XG59O1xudmFyIGlzU3BsYXQgPSBmdW5jdGlvbiBpc1NwbGF0KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnQgPT09IFwiKlwiO1xufTtcblxudmFyIHJhbmtSb3V0ZSA9IGZ1bmN0aW9uIHJhbmtSb3V0ZShyb3V0ZSwgaW5kZXgpIHtcbiAgdmFyIHNjb3JlID0gcm91dGUuZGVmYXVsdCA/IDAgOiBzZWdtZW50aXplKHJvdXRlLnBhdGgpLnJlZHVjZShmdW5jdGlvbiAoc2NvcmUsIHNlZ21lbnQpIHtcbiAgICBzY29yZSArPSBTRUdNRU5UX1BPSU5UUztcbiAgICBpZiAoaXNSb290U2VnbWVudChzZWdtZW50KSkgc2NvcmUgKz0gUk9PVF9QT0lOVFM7ZWxzZSBpZiAoaXNEeW5hbWljKHNlZ21lbnQpKSBzY29yZSArPSBEWU5BTUlDX1BPSU5UUztlbHNlIGlmIChpc1NwbGF0KHNlZ21lbnQpKSBzY29yZSAtPSBTRUdNRU5UX1BPSU5UUyArIFNQTEFUX1BFTkFMVFk7ZWxzZSBzY29yZSArPSBTVEFUSUNfUE9JTlRTO1xuICAgIHJldHVybiBzY29yZTtcbiAgfSwgMCk7XG4gIHJldHVybiB7IHJvdXRlOiByb3V0ZSwgc2NvcmU6IHNjb3JlLCBpbmRleDogaW5kZXggfTtcbn07XG5cbnZhciByYW5rUm91dGVzID0gZnVuY3Rpb24gcmFua1JvdXRlcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAocmFua1JvdXRlKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEuc2NvcmUgPCBiLnNjb3JlID8gMSA6IGEuc2NvcmUgPiBiLnNjb3JlID8gLTEgOiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfSk7XG59O1xuXG52YXIgc2VnbWVudGl6ZSA9IGZ1bmN0aW9uIHNlZ21lbnRpemUodXJpKSB7XG4gIHJldHVybiB1cmlcbiAgLy8gc3RyaXAgc3RhcnRpbmcvZW5kaW5nIHNsYXNoZXNcbiAgLnJlcGxhY2UoLyheXFwvK3xcXC8rJCkvZywgXCJcIikuc3BsaXQoXCIvXCIpO1xufTtcblxudmFyIGFkZFF1ZXJ5ID0gZnVuY3Rpb24gYWRkUXVlcnkocGF0aG5hbWUsIHF1ZXJ5KSB7XG4gIHJldHVybiBwYXRobmFtZSArIChxdWVyeSA/IFwiP1wiICsgcXVlcnkgOiBcIlwiKTtcbn07XG5cbnZhciByZXNlcnZlZE5hbWVzID0gW1widXJpXCIsIFwicGF0aFwiXTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCB7IHN0YXJ0c1dpdGgsIHBpY2ssIG1hdGNoLCByZXNvbHZlLCBpbnNlcnRQYXJhbXMsIHZhbGlkYXRlUmVkaXJlY3QgfTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfZ3VkID0gcmVxdWlyZSgnZ3VkJyk7XG5cbnZhciBfZ3VkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2d1ZCk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgPSAxMDczNzQxODIzO1xuXG4vLyBJbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbC5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuZnVuY3Rpb24gb2JqZWN0SXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW1pdHRlcih2YWx1ZSkge1xuICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBvbjogZnVuY3Rpb24gb24oaGFuZGxlcikge1xuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBoICE9PSBoYW5kbGVyO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlLCBjaGFuZ2VkQml0cykge1xuICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIodmFsdWUsIGNoYW5nZWRCaXRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0Q29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIHZhciBfUHJvdmlkZXIkY2hpbGRDb250ZXgsIF9Db25zdW1lciRjb250ZXh0VHlwZTtcblxuICB2YXIgY29udGV4dFByb3AgPSAnX19jcmVhdGUtcmVhY3QtY29udGV4dC0nICsgKDAsIF9ndWQyLmRlZmF1bHQpKCkgKyAnX18nO1xuXG4gIHZhciBQcm92aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKCkge1xuICAgICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb3ZpZGVyKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwuYXBwbHkoX0NvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmVtaXR0ZXIgPSBjcmVhdGVFdmVudEVtaXR0ZXIoX3RoaXMucHJvcHMudmFsdWUpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG5cbiAgICBQcm92aWRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbY29udGV4dFByb3BdID0gdGhpcy5lbWl0dGVyLCBfcmVmO1xuICAgIH07XG5cbiAgICBQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gbmV4dFByb3BzLnZhbHVlKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IG5leHRQcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIGNoYW5nZWRCaXRzID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgY2hhbmdlZEJpdHMgPSAwOyAvLyBObyBjaGFuZ2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2VkQml0cyA9IHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGN1bGF0ZUNoYW5nZWRCaXRzKG9sZFZhbHVlLCBuZXdWYWx1ZSkgOiBNQVhfU0lHTkVEXzMxX0JJVF9JTlQ7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoKGNoYW5nZWRCaXRzICYgTUFYX1NJR05FRF8zMV9CSVRfSU5UKSA9PT0gY2hhbmdlZEJpdHMsICdjYWxjdWxhdGVDaGFuZ2VkQml0czogRXhwZWN0ZWQgdGhlIHJldHVybiB2YWx1ZSB0byBiZSBhICcgKyAnMzEtYml0IGludGVnZXIuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2hhbmdlZEJpdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWRCaXRzIHw9IDA7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZEJpdHMgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5zZXQobmV4dFByb3BzLnZhbHVlLCBjaGFuZ2VkQml0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb3ZpZGVyO1xuICB9KF9yZWFjdC5Db21wb25lbnQpO1xuXG4gIFByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0gKF9Qcm92aWRlciRjaGlsZENvbnRleCA9IHt9LCBfUHJvdmlkZXIkY2hpbGRDb250ZXhbY29udGV4dFByb3BdID0gX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZCwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4KTtcblxuICB2YXIgQ29uc3VtZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudDIpIHtcbiAgICBfaW5oZXJpdHMoQ29uc3VtZXIsIF9Db21wb25lbnQyKTtcblxuICAgIGZ1bmN0aW9uIENvbnN1bWVyKCkge1xuICAgICAgdmFyIF90ZW1wMiwgX3RoaXMyLCBfcmV0MjtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnN1bWVyKTtcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JldDIgPSAoX3RlbXAyID0gKF90aGlzMiA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQyLmNhbGwuYXBwbHkoX0NvbXBvbmVudDIsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMyKSwgX3RoaXMyLnN0YXRlID0ge1xuICAgICAgICB2YWx1ZTogX3RoaXMyLmdldFZhbHVlKClcbiAgICAgIH0sIF90aGlzMi5vblVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgY2hhbmdlZEJpdHMpIHtcbiAgICAgICAgdmFyIG9ic2VydmVkQml0cyA9IF90aGlzMi5vYnNlcnZlZEJpdHMgfCAwO1xuICAgICAgICBpZiAoKG9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7IHZhbHVlOiBfdGhpczIuZ2V0VmFsdWUoKSB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgX3RlbXAyKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMyLCBfcmV0Mik7XG4gICAgfVxuXG4gICAgQ29uc3VtZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIG9ic2VydmVkQml0cyA9IG5leHRQcm9wcy5vYnNlcnZlZEJpdHM7XG5cbiAgICAgIHRoaXMub2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzID09PSB1bmRlZmluZWQgfHwgb2JzZXJ2ZWRCaXRzID09PSBudWxsID8gTUFYX1NJR05FRF8zMV9CSVRfSU5UIC8vIFN1YnNjcmliZSB0byBhbGwgY2hhbmdlcyBieSBkZWZhdWx0XG4gICAgICA6IG9ic2VydmVkQml0cztcbiAgICB9O1xuXG4gICAgQ29uc3VtZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLm9uKHRoaXMub25VcGRhdGUpO1xuICAgICAgfVxuICAgICAgdmFyIG9ic2VydmVkQml0cyA9IHRoaXMucHJvcHMub2JzZXJ2ZWRCaXRzO1xuXG4gICAgICB0aGlzLm9ic2VydmVkQml0cyA9IG9ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkIHx8IG9ic2VydmVkQml0cyA9PT0gbnVsbCA/IE1BWF9TSUdORURfMzFfQklUX0lOVCAvLyBTdWJzY3JpYmUgdG8gYWxsIGNoYW5nZXMgYnkgZGVmYXVsdFxuICAgICAgOiBvYnNlcnZlZEJpdHM7XG4gICAgfTtcblxuICAgIENvbnN1bWVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5vZmYodGhpcy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbnN1bWVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0uZ2V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb25zdW1lci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIG9ubHlDaGlsZCh0aGlzLnByb3BzLmNoaWxkcmVuKSh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbnN1bWVyO1xuICB9KF9yZWFjdC5Db21wb25lbnQpO1xuXG4gIENvbnN1bWVyLmNvbnRleHRUeXBlcyA9IChfQ29uc3VtZXIkY29udGV4dFR5cGUgPSB7fSwgX0NvbnN1bWVyJGNvbnRleHRUeXBlW2NvbnRleHRQcm9wXSA9IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LCBfQ29uc3VtZXIkY29udGV4dFR5cGUpO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBQcm92aWRlcjogUHJvdmlkZXIsXG4gICAgQ29uc3VtZXI6IENvbnN1bWVyXG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVJlYWN0Q29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgX2ltcGxlbWVudGF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ltcGxlbWVudGF0aW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNvbnRleHQgfHwgX2ltcGxlbWVudGF0aW9uMi5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiEgbm9ybWFsaXplLmNzcyB2Ny4wLjAgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovXFxuXFxuLyogRG9jdW1lbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluXFxuICogICAgSUUgb24gV2luZG93cyBQaG9uZSBhbmQgaW4gaU9TLlxcbiAqL1xcblxcbmh0bWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuMTU7IC8qIDEgKi9cXG4gICAgICAtbXMtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXFxufVxcblxcbi8qIFNlY3Rpb25zXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMgKG9waW5pb25hdGVkKS5cXG4gKi9cXG5cXG5ib2R5IHtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgOS0uXFxuICovXFxuXFxuYXJ0aWNsZSxcXG5hc2lkZSxcXG5mb290ZXIsXFxuaGVhZGVyLFxcbm5hdixcXG5zZWN0aW9uIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBmb250IHNpemUgYW5kIG1hcmdpbiBvbiBgaDFgIGVsZW1lbnRzIHdpdGhpbiBgc2VjdGlvbmAgYW5kXFxuICogYGFydGljbGVgIGNvbnRleHRzIGluIENocm9tZSwgRmlyZWZveCwgYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5oMSB7XFxuICBmb250LXNpemU6IDJlbTtcXG4gIG1hcmdpbjogLjY3ZW0gMDtcXG59XFxuXFxuLyogR3JvdXBpbmcgY29udGVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgOS0uXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUuXFxuICovXFxuXFxuZmlnY2FwdGlvbixcXG5maWd1cmUsXFxubWFpbiB7XFxuICAvKiAxICovXFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IG1hcmdpbiBpbiBJRSA4LlxcbiAqL1xcblxcbmZpZ3VyZSB7XFxuICBtYXJnaW46IDFlbSA0MHB4O1xcbn1cXG5cXG4vKipcXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgYm94IHNpemluZyBpbiBGaXJlZm94LlxcbiAqIDIuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UgYW5kIElFLlxcbiAqL1xcblxcbmhyIHtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94OyAvKiAxICovXFxuICBoZWlnaHQ6IDA7IC8qIDEgKi9cXG4gIG92ZXJmbG93OiB2aXNpYmxlOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIGFuZCBzY2FsaW5nIG9mIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuICogMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnByZSB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXFxufVxcblxcbi8qIFRleHQtbGV2ZWwgc2VtYW50aWNzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiAxLiBSZW1vdmUgdGhlIGdyYXkgYmFja2dyb3VuZCBvbiBhY3RpdmUgbGlua3MgaW4gSUUgMTAuXFxuICogMi4gUmVtb3ZlIGdhcHMgaW4gbGlua3MgdW5kZXJsaW5lIGluIGlPUyA4KyBhbmQgU2FmYXJpIDgrLlxcbiAqL1xcblxcbmEge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDEgKi9cXG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXA6IG9iamVjdHM7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogMS4gUmVtb3ZlIHRoZSBib3R0b20gYm9yZGVyIGluIENocm9tZSA1Ny0gYW5kIEZpcmVmb3ggMzktLlxcbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBJRSwgT3BlcmEsIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYWJiclt0aXRsZV0ge1xcbiAgYm9yZGVyLWJvdHRvbTogbm9uZTsgLyogMSAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7IC8qIDIgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBQcmV2ZW50IHRoZSBkdXBsaWNhdGUgYXBwbGljYXRpb24gb2YgYGJvbGRlcmAgYnkgdGhlIG5leHQgcnVsZSBpbiBTYWZhcmkgNi5cXG4gKi9cXG5cXG5iLFxcbnN0cm9uZyB7XFxuICBmb250LXdlaWdodDogaW5oZXJpdDtcXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGZvbnQgd2VpZ2h0IGluIENocm9tZSwgRWRnZSwgYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5iLFxcbnN0cm9uZyB7XFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBhbmQgc2NhbGluZyBvZiBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5cXG5jb2RlLFxcbmtiZCxcXG5zYW1wIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxZW07IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGZvbnQgc3R5bGUgaW4gQW5kcm9pZCA0LjMtLlxcbiAqL1xcblxcbmRmbiB7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBiYWNrZ3JvdW5kIGFuZCBjb2xvciBpbiBJRSA5LS5cXG4gKi9cXG5cXG5tYXJrIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZjA7XFxuICBjb2xvcjogIzAwMDtcXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuc21hbGwge1xcbiAgZm9udC1zaXplOiA4MCU7XFxufVxcblxcbi8qKlxcbiAqIFByZXZlbnQgYHN1YmAgYW5kIGBzdXBgIGVsZW1lbnRzIGZyb20gYWZmZWN0aW5nIHRoZSBsaW5lIGhlaWdodCBpblxcbiAqIGFsbCBicm93c2Vycy5cXG4gKi9cXG5cXG5zdWIsXFxuc3VwIHtcXG4gIGZvbnQtc2l6ZTogNzUlO1xcbiAgbGluZS1oZWlnaHQ6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcblxcbnN1YiB7XFxuICBib3R0b206IC0wLjI1ZW07XFxufVxcblxcbnN1cCB7XFxuICB0b3A6IC0wLjVlbTtcXG59XFxuXFxuLyogRW1iZWRkZWQgY29udGVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgOS0uXFxuICovXFxuXFxuYXVkaW8sXFxudmlkZW8ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBpT1MgNC03LlxcbiAqL1xcblxcbmF1ZGlvOm5vdChbY29udHJvbHNdKSB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgaGVpZ2h0OiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGJvcmRlciBvbiBpbWFnZXMgaW5zaWRlIGxpbmtzIGluIElFIDEwLS5cXG4gKi9cXG5cXG5pbWcge1xcbiAgYm9yZGVyLXN0eWxlOiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiBIaWRlIHRoZSBvdmVyZmxvdyBpbiBJRS5cXG4gKi9cXG5cXG5zdmc6bm90KDpyb290KSB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4vKiBGb3Jtc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogMS4gQ2hhbmdlIHRoZSBmb250IHN0eWxlcyBpbiBhbGwgYnJvd3NlcnMgKG9waW5pb25hdGVkKS5cXG4gKiAyLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIFNob3cgdGhlIG92ZXJmbG93IGluIElFLlxcbiAqIDEuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UuXFxuICovXFxuXFxuYnV0dG9uLFxcbmlucHV0IHtcXG4gIC8qIDEgKi9cXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UsIEZpcmVmb3gsIGFuZCBJRS5cXG4gKiAxLiBSZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEZpcmVmb3guXFxuICovXFxuXFxuYnV0dG9uLFxcbnNlbGVjdCB7XFxuICAvKiAxICovXFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogMS4gUHJldmVudCBhIFdlYktpdCBidWcgd2hlcmUgKDIpIGRlc3Ryb3lzIG5hdGl2ZSBgYXVkaW9gIGFuZCBgdmlkZW9gXFxuICogICAgY29udHJvbHMgaW4gQW5kcm9pZCA0LlxcbiAqIDIuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYnV0dG9uLFxcbmh0bWwgW3R5cGU9XFxcImJ1dHRvblxcXCJdLFxcbi8qIDEgKi9cXG5bdHlwZT1cXFwicmVzZXRcXFwiXSxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBib3JkZXIgYW5kIHBhZGRpbmcgaW4gRmlyZWZveC5cXG4gKi9cXG5cXG5idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZXN0b3JlIHRoZSBmb2N1cyBzdHlsZXMgdW5zZXQgYnkgdGhlIHByZXZpb3VzIHJ1bGUuXFxuICovXFxuXFxuYnV0dG9uOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwicmVzZXRcXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl06LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogMXB4IGRvdHRlZCBCdXR0b25UZXh0O1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBwYWRkaW5nIGluIEZpcmVmb3guXFxuICovXFxuXFxuZmllbGRzZXQge1xcbiAgcGFkZGluZzogLjM1ZW0gLjc1ZW0gLjYyNWVtO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxcbiAqIDIuIENvcnJlY3QgdGhlIGNvbG9yIGluaGVyaXRhbmNlIGZyb20gYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBJRS5cXG4gKiAzLiBSZW1vdmUgdGhlIHBhZGRpbmcgc28gZGV2ZWxvcGVycyBhcmUgbm90IGNhdWdodCBvdXQgd2hlbiB0aGV5IHplcm8gb3V0XFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxubGVnZW5kIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBkaXNwbGF5OiB0YWJsZTsgLyogMSAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsOyAvKiAxICovXFxufVxcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDktLlxcbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXFxuICovXFxuXFxucHJvZ3Jlc3Mge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyAvKiAxICovXFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRS5cXG4gKi9cXG5cXG50ZXh0YXJlYSB7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gSUUgMTAtLlxcbiAqIDIuIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBJRSAxMC0uXFxuICovXFxuXFxuW3R5cGU9XFxcImNoZWNrYm94XFxcIl0sXFxuW3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgcGFkZGluZzogMDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBDaHJvbWUuXFxuICovXFxuXFxuW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcblt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiAqIDIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcbiAqL1xcblxcblt0eXBlPVxcXCJzZWFyY2hcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGFuZCBjYW5jZWwgYnV0dG9ucyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4gKi9cXG5cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKiAyLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuICovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKiBJbnRlcmFjdGl2ZVxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLypcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSA5LS5cXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBFZGdlLCBJRSwgYW5kIEZpcmVmb3guXFxuICovXFxuXFxuZGV0YWlscyxcXG4vKiAxICovXFxubWVudSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLypcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcblxcbi8qIFNjcmlwdGluZ1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgOS0uXFxuICovXFxuXFxuY2FudmFzIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUuXFxuICovXFxuXFxudGVtcGxhdGUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLyogSGlkZGVuXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSAxMC0uXFxuICovXFxuXFxuW2hpZGRlbl0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogTWFudWFsbHkgZm9ya2VkIGZyb20gU1VJVCBDU1MgQmFzZTogaHR0cHM6Ly9naXRodWIuY29tL3N1aXRjc3MvYmFzZVxcbiAqIEEgdGhpbiBsYXllciBvbiB0b3Agb2Ygbm9ybWFsaXplLmNzcyB0aGF0IHByb3ZpZGVzIGEgc3RhcnRpbmcgcG9pbnQgbW9yZVxcbiAqIHN1aXRhYmxlIGZvciB3ZWIgYXBwbGljYXRpb25zLlxcbiAqL1xcblxcbi8qKlxcbiAqIDEuIFByZXZlbnQgcGFkZGluZyBhbmQgYm9yZGVyIGZyb20gYWZmZWN0aW5nIGVsZW1lbnQgd2lkdGhcXG4gKiBodHRwczovL2dvby5nbC9wWXRiSzdcXG4gKiAyLiBDaGFuZ2UgdGhlIGRlZmF1bHQgZm9udCBmYW1pbHkgaW4gYWxsIGJyb3dzZXJzIChvcGluaW9uYXRlZClcXG4gKi9cXG5cXG5odG1sIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmOyAvKiAyICovXFxufVxcblxcbiosXFxuKjo6YmVmb3JlLFxcbio6OmFmdGVyIHtcXG4gIGJveC1zaXppbmc6IGluaGVyaXQ7XFxufVxcblxcbi8qKlxcbiAqIFJlbW92ZXMgdGhlIGRlZmF1bHQgc3BhY2luZyBhbmQgYm9yZGVyIGZvciBhcHByb3ByaWF0ZSBlbGVtZW50cy5cXG4gKi9cXG5cXG5ibG9ja3F1b3RlLFxcbmRsLFxcbmRkLFxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2LFxcbmZpZ3VyZSxcXG5wLFxcbnByZSB7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbmJ1dHRvbiB7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbi8qKlxcbiAqIFdvcmsgYXJvdW5kIGEgRmlyZWZveC9JRSBidWcgd2hlcmUgdGhlIHRyYW5zcGFyZW50IGBidXR0b25gIGJhY2tncm91bmRcXG4gKiByZXN1bHRzIGluIGEgbG9zcyBvZiB0aGUgZGVmYXVsdCBgYnV0dG9uYCBmb2N1cyBzdHlsZXMuXFxuICovXFxuXFxuYnV0dG9uOmZvY3VzIHtcXG4gIG91dGxpbmU6IDFweCBkb3R0ZWQ7XFxuICBvdXRsaW5lOiA1cHggYXV0byAtd2Via2l0LWZvY3VzLXJpbmctY29sb3I7XFxufVxcblxcbmZpZWxkc2V0IHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbm9sLFxcbnVsIHtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuLyoqXFxuICogVGFpbHdpbmQgY3VzdG9tIHJlc2V0IHN0eWxlc1xcbiAqL1xcblxcbi8qKlxcbiAqIEFsbG93IGFkZGluZyBhIGJvcmRlciB0byBhbiBlbGVtZW50IGJ5IGp1c3QgYWRkaW5nIGEgYm9yZGVyLXdpZHRoLlxcbiAqXFxuICogQnkgZGVmYXVsdCwgdGhlIHdheSB0aGUgYnJvd3NlciBzcGVjaWZpZXMgdGhhdCBhbiBlbGVtZW50IHNob3VsZCBoYXZlIG5vXFxuICogYm9yZGVyIGlzIGJ5IHNldHRpbmcgaXQncyBib3JkZXItc3R5bGUgdG8gYG5vbmVgIGluIHRoZSB1c2VyLWFnZW50XFxuICogc3R5bGVzaGVldC5cXG4gKlxcbiAqIEluIG9yZGVyIHRvIGVhc2lseSBhZGQgYm9yZGVycyB0byBlbGVtZW50cyBieSBqdXN0IHNldHRpbmcgdGhlIGBib3JkZXItd2lkdGhgXFxuICogcHJvcGVydHksIHdlIGNoYW5nZSB0aGUgZGVmYXVsdCBib3JkZXItc3R5bGUgZm9yIGFsbCBlbGVtZW50cyB0byBgc29saWRgLCBhbmRcXG4gKiB1c2UgYm9yZGVyLXdpZHRoIHRvIGhpZGUgdGhlbSBpbnN0ZWFkLiBUaGlzIHdheSBvdXIgYGJvcmRlcmAgdXRpbGl0aWVzIG9ubHlcXG4gKiBuZWVkIHRvIHNldCB0aGUgYGJvcmRlci13aWR0aGAgcHJvcGVydHkgaW5zdGVhZCBvZiB0aGUgZW50aXJlIGBib3JkZXJgXFxuICogc2hvcnRoYW5kLCBtYWtpbmcgb3VyIGJvcmRlciB1dGlsaXRpZXMgbXVjaCBtb3JlIHN0cmFpZ2h0Zm9yd2FyZCB0byBjb21wb3NlLlxcbiAqXFxuICogaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kY3NzL3RhaWx3aW5kY3NzL3B1bGwvMTE2XFxuICovXFxuXFxuKixcXG4qOjpiZWZvcmUsXFxuKjo6YWZ0ZXIge1xcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gIGJvcmRlci1jb2xvcjogI2U3ZTdlYztcXG59XFxuXFxuLyoqXFxuICogVW5kbyB0aGUgYGJvcmRlci1zdHlsZTogbm9uZWAgcmVzZXQgdGhhdCBOb3JtYWxpemUgYXBwbGllcyB0byBpbWFnZXMgc28gdGhhdFxcbiAqIG91ciBgYm9yZGVyLXt3aWR0aH1gIHV0aWxpdGllcyBoYXZlIHRoZSBleHBlY3RlZCBlZmZlY3QuXFxuICpcXG4gKiBUaGUgTm9ybWFsaXplIHJlc2V0IGlzIHVubmVjZXNzYXJ5IGZvciB1cyBzaW5jZSB3ZSBkZWZhdWx0IHRoZSBib3JkZXItd2lkdGhcXG4gKiB0byAwIG9uIGFsbCBlbGVtZW50cy5cXG4gKlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGNzcy90YWlsd2luZGNzcy9pc3N1ZXMvMzYyXFxuICovXFxuXFxuaW1nIHtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxufVxcblxcbi8qKlxcbiAqIFRlbXBvcmFyeSByZXNldCBmb3IgYSBjaGFuZ2UgaW50cm9kdWNlZCBpbiBDaHJvbWUgNjIgYnV0IG5vdyByZXZlcnRlZC5cXG4gKlxcbiAqIFdlIGNhbiByZW1vdmUgdGhpcyB3aGVuIHRoZSByZXZlcnNpb24gaXMgaW4gYSBub3JtYWwgQ2hyb21lIHJlbGVhc2UuXFxuICovXFxuXFxuYnV0dG9uLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXSxcXG5bdHlwZT1cXFwicmVzZXRcXFwiXSxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl0ge1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG59XFxuXFxudGV4dGFyZWEge1xcbiAgcmVzaXplOiB2ZXJ0aWNhbDtcXG59XFxuXFxuaW1nIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG59XFxuXFxuaW5wdXQ6OnBsYWNlaG9sZGVyLFxcbnRleHRhcmVhOjpwbGFjZWhvbGRlciB7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIG9wYWNpdHk6IC41O1xcbn1cXG5cXG5idXR0b24sXFxuW3JvbGU9YnV0dG9uXSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbnRhYmxlIHtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcblxcbi8qXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ0thcmxhJztcXG4gIHNyYzogdXJsKCcuL2ZvbnRzL2thcmxhLXJlZ3VsYXIud29mZjInKSBmb3JtYXQoJ3dvZmYyJyksXFxuICAgIHVybCgnLi9mb250cy9rYXJsYS1yZWd1bGFyLndvZmYnKSBmb3JtYXQoJ3dvZmYnKTtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxufVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6ICdLYXJsYSc7XFxuICBzcmM6IHVybCgnLi9mb250cy9rYXJsYS1yZWd1bGFyLWl0YWxpYy53b2ZmMicpIGZvcm1hdCgnd29mZjInKSxcXG4gICAgdXJsKCcuL2ZvbnRzL2thcmxhLXJlZ3VsYXItaXRhbGljLndvZmYnKSBmb3JtYXQoJ3dvZmYnKTtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6ICdLYXJsYSc7XFxuICBzcmM6IHVybCgnLi9mb250cy9rYXJsYS1ib2xkLndvZmYyJykgZm9ybWF0KCd3b2ZmMicpLFxcbiAgICB1cmwoJy4vZm9udHMva2FybGEtYm9sZC53b2ZmJykgZm9ybWF0KCd3b2ZmJyk7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG59XFxuXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ0thcmxhJztcXG4gIHNyYzogdXJsKCcuL2ZvbnRzL2thcmxhLWJvbGQtaXRhbGljLndvZmYyJykgZm9ybWF0KCd3b2ZmMicpLFxcbiAgICB1cmwoJy4vZm9udHMva2FybGEtYm9sZC1pdGFsaWMud29mZicpIGZvcm1hdCgnd29mZicpO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcbiovXFxuXFxuaHRtbCB7XFxuICBmb250LXNpemU6IDYyLjUlO1xcbn1cXG5cXG5ib2R5IHtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsICdPcGVuIFNhbnMnLCAnSGVsdmV0aWNhIE5ldWUnLCBzYW5zLXNlcmlmO1xcbiAgZm9udC1zaXplOiAxLjZyZW07XFxuICBjb2xvcjogIzQ1M2Y1NjtcXG59XFxuXFxuLm91dGxpbmUtMCB7XFxuICBvdXRsaW5lOiAwO1xcbn1cXG5cXG4uZm9jdXNcXFxcOm91dGxpbmUtMDpmb2N1cyB7XFxuICBvdXRsaW5lOiAwO1xcbn1cXG5cXG4uc3Itb25seSxcXG4uc3Itb25seS1mb2N1c2FibGU6bm90KDpmb2N1cyk6bm90KDphY3RpdmUpIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiAxcHg7XFxuICBoZWlnaHQ6IDFweDtcXG4gIG1hcmdpbjogLTFweDtcXG4gIGJvcmRlcjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgY2xpcC1wYXRoOiBpbnNldCgxMDAlKTtcXG4gIGNsaXA6IHJlY3QoMCAwIDAgMCk7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG46Zm9jdXMgKyAuY2hlY2tib3gge1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG59XFxuXFxuOmNoZWNrZWQgKyAuY2hlY2tib3gge1xcbiAgYmFja2dyb3VuZDogIzgzNjBkNiB1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyBmaWxsPSclMjNmZmYnIHZpZXdCb3g9JzAgMCAyNCAyNCclM0UlM0NwYXRoIGQ9J005IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXonLyUzRSUzQy9zdmclM0VcXFwiKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtc2l6ZTogMTZweCAxNnB4O1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxudGFibGUgdGJvZHkgdGQ6Zmlyc3QtY2hpbGQ6Zm9jdXMtd2l0aGluIH4gdGQsXFxudGFibGUgdGJvZHkgdHI6aG92ZXIgdGQ6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgYmFja2dyb3VuZDogI2NjYzJlOTtcXG4gIGNvbG9yOiAjNGMyOWIwO1xcbn1cXG5cXG4uYWN0aW9uczo6YmVmb3JlLFxcbi5hY3Rpb25zOjphZnRlciB7XFxuICBjb250ZW50OiAnJztcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICBtYXJnaW4tdG9wOiAtNnB4O1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbn1cXG5cXG4uYWN0aW9uczo6YmVmb3JlIHtcXG4gIHJpZ2h0OiAxMDAlO1xcbiAgYm9yZGVyLXdpZHRoOiA2cHggNnB4IDZweCAwO1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCAjNDUzZjU2IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4uYWN0aW9uczo6YWZ0ZXIge1xcbiAgbGVmdDogMTAwJTtcXG4gIGJvcmRlci13aWR0aDogNnB4IDAgNnB4IDZweDtcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzQ1M2Y1NjtcXG59XFxuXFxuLnRvb2xiYXIgPiBidXR0b246bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgd2lkdGg6IDMzcHg7XFxuICBib3JkZXItbGVmdDogMXB4IHNvbGlkICM0NTNmNTY7XFxufVxcblxcbi50b29sYmFyID4gYnV0dG9uOm5vdCg6Zmlyc3QtY2hpbGQpOjpiZWZvcmUge1xcbiAgY29udGVudDogJyc7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IC0xcHg7XFxuICB0b3A6IDUwJTtcXG4gIGhlaWdodDogMjBweDtcXG4gIG1hcmdpbi10b3A6IC0xMHB4O1xcbiAgd2lkdGg6IDFweDtcXG4gIGJhY2tncm91bmQ6ICM4NzgwOWI7XFxufVxcblxcbi50b29sYmFyLS1hYm92ZTo6YWZ0ZXIsXFxuLnRvb2xiYXItLWJlbG93OjpiZWZvcmUge1xcbiAgY29udGVudDogJyc7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDUwJTtcXG4gIG1hcmdpbi1sZWZ0OiAtNnB4O1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbn1cXG5cXG4udG9vbGJhci0tYWJvdmU6OmFmdGVyIHtcXG4gIHRvcDogMTAwJTtcXG4gIGJvcmRlci13aWR0aDogNnB4IDZweCAwO1xcbiAgYm9yZGVyLWNvbG9yOiAjNDUzZjU2IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4udG9vbGJhci0tYmVsb3c6OmJlZm9yZSB7XFxuICBib3R0b206IDEwMCU7XFxuICBib3JkZXItd2lkdGg6IDAgNnB4IDZweDtcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzQ1M2Y1NjtcXG59XFxuXFxuLmxvZ28tY29udGFpbmVyIHtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChoc2woMjQwLCAyMCUsIDk2JSkgMCUsIGhzbGEoMjQwLCAyMCUsIDk2JSwgLjczOCkgMTklLCBoc2xhKDI0MCwgMjAlLCA5NiUsIC41NDEpIDM0JSwgaHNsYSgyNDAsIDIwJSwgOTYlLCAuMzgyKSA0NyUsIGhzbGEoMjQwLCAyMCUsIDk2JSwgLjI3OCkgNTYuNSUsIGhzbGEoMjQwLCAyMCUsIDk2JSwgLjE5NCkgNjUlLCBoc2xhKDI0MCwgMjAlLCA5NiUsIC4xMjYpIDczJSwgaHNsYSgyNDAsIDIwJSwgOTYlLCAuMDc1KSA4MC4yJSwgaHNsYSgyNDAsIDIwJSwgOTYlLCAuMDQyKSA4Ni4xJSwgaHNsYSgyNDAsIDIwJSwgOTYlLCAuMDIxKSA5MSUsIGhzbGEoMjQwLCAyMCUsIDk2JSwgLjAwOCkgOTUuMiUsIGhzbGEoMjQwLCAyMCUsIDk2JSwgLjAwMikgOTguMiUsIGhzbGEoMjQwLCAyMCUsIDk2JSwgMCkgMTAwJSk7XFxufVxcblxcbi5sb2dvLWNvbnRhaW5lcjo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBwb2ludGVyLWV2ZW50czogYXV0bztcXG4gIGJvdHRvbTogMTAwJTtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQ6ICNmM2YzZjc7XFxuICBoZWlnaHQ6IDEwMHB4O1xcbn1cXG5cXG4uYnV0dG9uLWdyb3VwIHtcXG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgZGlzcGxheTogaW5saW5lLWdyaWQ7XFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxZnI7XFxufVxcblxcbjpjaGVja2VkICsgLmNoZWNrZWRcXFxcOmJnLXB1cnBsZS1kYXJrLTEwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbn1cXG5cXG4uYnRuLWdyb3VwIGJ1dHRvbjpmaXJzdC1jaGlsZCB7XFxuICBtYXJnaW4tbGVmdDogMDtcXG59XFxuXFxuLmJ0bi1ncm91cCBidXR0b246Zmlyc3QtY2hpbGQ6OmJlZm9yZSB7XFxuICBjb250ZW50OiBub25lO1xcbn1cXG5cXG4uYnRuLWdyb3VwIGJ1dHRvbjo6YmVmb3JlLFxcbi5idG4tZ3JvdXAgYnV0dG9uOjphZnRlciB7XFxuICBjb250ZW50OiAnJztcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG5cXG4uYnRuLWdyb3VwIGJ1dHRvbjo6YmVmb3JlIHtcXG4gIHRvcDogNXB4O1xcbiAgYm90dG9tOiA1cHg7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDFweDtcXG4gIGJhY2tncm91bmQ6ICMyMTJhMzg7XFxuICBvcGFjaXR5OiAuMjtcXG59XFxuXFxuLmJ0bi1ncm91cCBidXR0b246OmFmdGVyIHtcXG4gIHRvcDogMnB4O1xcbiAgcmlnaHQ6IDJweDtcXG4gIGJvdHRvbTogMnB4O1xcbiAgbGVmdDogM3B4O1xcbiAgYmFja2dyb3VuZDogIzgzNjBkNjtcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG59XFxuXFxuLmxpc3QtcmVzZXQge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbi5hcHBlYXJhbmNlLW5vbmUge1xcbiAgYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLmJnLWZpeGVkIHtcXG4gIGJhY2tncm91bmQtYXR0YWNobWVudDogZml4ZWQ7XFxufVxcblxcbi5iZy1sb2NhbCB7XFxuICBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6IGxvY2FsO1xcbn1cXG5cXG4uYmctc2Nyb2xsIHtcXG4gIGJhY2tncm91bmQtYXR0YWNobWVudDogc2Nyb2xsO1xcbn1cXG5cXG4uYmctaW5oZXJpdCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4uYmctdHJhbnNwYXJlbnQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcblxcbi5iZy1ibGFjayB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjgyODI4O1xcbn1cXG5cXG4uYmctd2hpdGUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG59XFxuXFxuLmJnLWdyZXktbGlnaHRlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmM2Y3O1xcbn1cXG5cXG4uYmctZ3JleS1saWdodCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTdlN2VjO1xcbn1cXG5cXG4uYmctZ3JleSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzJjMmM2O1xcbn1cXG5cXG4uYmctcHVycGxlLWxpZ2h0ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NjYzJlOTtcXG59XFxuXFxuLmJnLXB1cnBsZS1saWdodCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjODc4MDliO1xcbn1cXG5cXG4uYmctcHVycGxlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM4MzYwZDY7XFxufVxcblxcbi5iZy1wdXJwbGUtYnJpZ2h0IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM0YzI5YjA7XFxufVxcblxcbi5iZy1wdXJwbGUtZGFyayB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDUzZjU2O1xcbn1cXG5cXG4uYmctcHVycGxlLWRhcmstMTAge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxufVxcblxcbi5iZy1wdXJwbGUtZGFya2VyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyYTI1Mzg7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctaW5oZXJpdDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLXRyYW5zcGFyZW50OmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLWJsYWNrOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyODI4Mjg7XFxufVxcblxcbi5ob3ZlclxcXFw6Ymctd2hpdGU6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0ZXI6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YzZjNmNztcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0OmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlN2U3ZWM7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctZ3JleTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzJjMmM2O1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodGVyOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjY2MyZTk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0OmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM4NzgwOWI7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctcHVycGxlOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM4MzYwZDY7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctcHVycGxlLWJyaWdodDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNGMyOWIwO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM0NTNmNTY7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctcHVycGxlLWRhcmstMTA6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctcHVycGxlLWRhcmtlcjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMmEyNTM4O1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLWluaGVyaXQ6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy10cmFuc3BhcmVudDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1ibGFjazpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjgyODI4O1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXdoaXRlOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxufVxcblxcbi5mb2N1c1xcXFw6YmctZ3JleS1saWdodGVyOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxufVxcblxcbi5mb2N1c1xcXFw6YmctZ3JleS1saWdodDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTdlN2VjO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLWdyZXk6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2MyYzJjNjtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1wdXJwbGUtbGlnaHRlcjpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS1saWdodDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjODc4MDliO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZTpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjODM2MGQ2O1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS1icmlnaHQ6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFyazpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDUzZjU2O1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrLTEwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrZXI6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG59XFxuXFxuLmJnLWJvdHRvbSB7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b207XFxufVxcblxcbi5iZy1jZW50ZXIge1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcbn1cXG5cXG4uYmctbGVmdCB7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBsZWZ0O1xcbn1cXG5cXG4uYmctbGVmdC1ib3R0b20ge1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogbGVmdCBib3R0b207XFxufVxcblxcbi5iZy1sZWZ0LXRvcCB7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBsZWZ0IHRvcDtcXG59XFxuXFxuLmJnLXJpZ2h0IHtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0O1xcbn1cXG5cXG4uYmctcmlnaHQtYm90dG9tIHtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0IGJvdHRvbTtcXG59XFxuXFxuLmJnLXJpZ2h0LXRvcCB7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiByaWdodCB0b3A7XFxufVxcblxcbi5iZy10b3Age1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogdG9wO1xcbn1cXG5cXG4uYmctcmVwZWF0IHtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQ7XFxufVxcblxcbi5iZy1uby1yZXBlYXQge1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuXFxuLmJnLXJlcGVhdC14IHtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcXG59XFxuXFxuLmJnLXJlcGVhdC15IHtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteTtcXG59XFxuXFxuLmJnLWF1dG8ge1xcbiAgYmFja2dyb3VuZC1zaXplOiBhdXRvO1xcbn1cXG5cXG4uYmctY292ZXIge1xcbiAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG59XFxuXFxuLmJnLWNvbnRhaW4ge1xcbiAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbn1cXG5cXG4uYm9yZGVyLWNvbGxhcHNlIHtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcblxcbi5ib3JkZXItc2VwYXJhdGUge1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBzZXBhcmF0ZTtcXG59XFxuXFxuLmJvcmRlci1pbmhlcml0IHtcXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcXG59XFxuXFxuLmJvcmRlci10cmFuc3BhcmVudCB7XFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4uYm9yZGVyLWJsYWNrIHtcXG4gIGJvcmRlci1jb2xvcjogIzI4MjgyODtcXG59XFxuXFxuLmJvcmRlci13aGl0ZSB7XFxuICBib3JkZXItY29sb3I6ICNmZmY7XFxufVxcblxcbi5ib3JkZXItZ3JleS1saWdodGVyIHtcXG4gIGJvcmRlci1jb2xvcjogI2YzZjNmNztcXG59XFxuXFxuLmJvcmRlci1ncmV5LWxpZ2h0IHtcXG4gIGJvcmRlci1jb2xvcjogI2U3ZTdlYztcXG59XFxuXFxuLmJvcmRlci1ncmV5IHtcXG4gIGJvcmRlci1jb2xvcjogI2MyYzJjNjtcXG59XFxuXFxuLmJvcmRlci1wdXJwbGUtbGlnaHRlciB7XFxuICBib3JkZXItY29sb3I6ICNjY2MyZTk7XFxufVxcblxcbi5ib3JkZXItcHVycGxlLWxpZ2h0IHtcXG4gIGJvcmRlci1jb2xvcjogIzg3ODA5YjtcXG59XFxuXFxuLmJvcmRlci1wdXJwbGUge1xcbiAgYm9yZGVyLWNvbG9yOiAjODM2MGQ2O1xcbn1cXG5cXG4uYm9yZGVyLXB1cnBsZS1icmlnaHQge1xcbiAgYm9yZGVyLWNvbG9yOiAjNGMyOWIwO1xcbn1cXG5cXG4uYm9yZGVyLXB1cnBsZS1kYXJrIHtcXG4gIGJvcmRlci1jb2xvcjogIzQ1M2Y1NjtcXG59XFxuXFxuLmJvcmRlci1wdXJwbGUtZGFyay0xMCB7XFxuICBib3JkZXItY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbn1cXG5cXG4uYm9yZGVyLXB1cnBsZS1kYXJrZXIge1xcbiAgYm9yZGVyLWNvbG9yOiAjMmEyNTM4O1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJvcmRlci1pbmhlcml0OmhvdmVyIHtcXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcXG59XFxuXFxuLmhvdmVyXFxcXDpib3JkZXItdHJhbnNwYXJlbnQ6aG92ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuLmhvdmVyXFxcXDpib3JkZXItYmxhY2s6aG92ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiAjMjgyODI4O1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJvcmRlci13aGl0ZTpob3ZlciB7XFxuICBib3JkZXItY29sb3I6ICNmZmY7XFxufVxcblxcbi5ob3ZlclxcXFw6Ym9yZGVyLWdyZXktbGlnaHRlcjpob3ZlciB7XFxuICBib3JkZXItY29sb3I6ICNmM2YzZjc7XFxufVxcblxcbi5ob3ZlclxcXFw6Ym9yZGVyLWdyZXktbGlnaHQ6aG92ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiAjZTdlN2VjO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJvcmRlci1ncmV5OmhvdmVyIHtcXG4gIGJvcmRlci1jb2xvcjogI2MyYzJjNjtcXG59XFxuXFxuLmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWxpZ2h0ZXI6aG92ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiAjY2NjMmU5O1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHQ6aG92ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiAjODc4MDliO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJvcmRlci1wdXJwbGU6aG92ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiAjODM2MGQ2O1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtYnJpZ2h0OmhvdmVyIHtcXG4gIGJvcmRlci1jb2xvcjogIzRjMjliMDtcXG59XFxuXFxuLmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWRhcms6aG92ZXIge1xcbiAgYm9yZGVyLWNvbG9yOiAjNDUzZjU2O1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICBib3JkZXItY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtZGFya2VyOmhvdmVyIHtcXG4gIGJvcmRlci1jb2xvcjogIzJhMjUzODtcXG59XFxuXFxuLnJvdW5kZWQtbm9uZSB7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbn1cXG5cXG4ucm91bmRlZC1zbSB7XFxuICBib3JkZXItcmFkaXVzOiAycHg7XFxufVxcblxcbi5yb3VuZGVkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG59XFxuXFxuLnJvdW5kZWQtZnVsbCB7XFxuICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XFxufVxcblxcbi5yb3VuZGVkLXQtbm9uZSB7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxufVxcblxcbi5yb3VuZGVkLXItbm9uZSB7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbn1cXG5cXG4ucm91bmRlZC1iLW5vbmUge1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbn1cXG5cXG4ucm91bmRlZC1sLW5vbmUge1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxufVxcblxcbi5yb3VuZGVkLXQtc20ge1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDJweDtcXG59XFxuXFxuLnJvdW5kZWQtci1zbSB7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXG59XFxuXFxuLnJvdW5kZWQtYi1zbSB7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMnB4O1xcbn1cXG5cXG4ucm91bmRlZC1sLXNtIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXG59XFxuXFxuLnJvdW5kZWQtdCB7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA0cHg7XFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcbn1cXG5cXG4ucm91bmRlZC1yIHtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcbn1cXG5cXG4ucm91bmRlZC1iIHtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxufVxcblxcbi5yb3VuZGVkLWwge1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNHB4O1xcbn1cXG5cXG4ucm91bmRlZC10LWZ1bGwge1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDk5OTlweDtcXG59XFxuXFxuLnJvdW5kZWQtci1mdWxsIHtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogOTk5OXB4O1xcbn1cXG5cXG4ucm91bmRlZC1iLWZ1bGwge1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDk5OTlweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDk5OTlweDtcXG59XFxuXFxuLnJvdW5kZWQtbC1mdWxsIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDk5OTlweDtcXG59XFxuXFxuLnJvdW5kZWQtdGwtbm9uZSB7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbn1cXG5cXG4ucm91bmRlZC10ci1ub25lIHtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwO1xcbn1cXG5cXG4ucm91bmRlZC1ici1ub25lIHtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbn1cXG5cXG4ucm91bmRlZC1ibC1ub25lIHtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxufVxcblxcbi5yb3VuZGVkLXRsLXNtIHtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXG59XFxuXFxuLnJvdW5kZWQtdHItc20ge1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDJweDtcXG59XFxuXFxuLnJvdW5kZWQtYnItc20ge1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXG59XFxuXFxuLnJvdW5kZWQtYmwtc20ge1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMnB4O1xcbn1cXG5cXG4ucm91bmRlZC10bCB7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA0cHg7XFxufVxcblxcbi5yb3VuZGVkLXRyIHtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxufVxcblxcbi5yb3VuZGVkLWJyIHtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxufVxcblxcbi5yb3VuZGVkLWJsIHtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXG59XFxuXFxuLnJvdW5kZWQtdGwtZnVsbCB7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA5OTk5cHg7XFxufVxcblxcbi5yb3VuZGVkLXRyLWZ1bGwge1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDk5OTlweDtcXG59XFxuXFxuLnJvdW5kZWQtYnItZnVsbCB7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogOTk5OXB4O1xcbn1cXG5cXG4ucm91bmRlZC1ibC1mdWxsIHtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDk5OTlweDtcXG59XFxuXFxuLmJvcmRlci1zb2xpZCB7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbn1cXG5cXG4uYm9yZGVyLWRhc2hlZCB7XFxuICBib3JkZXItc3R5bGU6IGRhc2hlZDtcXG59XFxuXFxuLmJvcmRlci1kb3R0ZWQge1xcbiAgYm9yZGVyLXN0eWxlOiBkb3R0ZWQ7XFxufVxcblxcbi5ib3JkZXItbm9uZSB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxufVxcblxcbi5ib3JkZXItMCB7XFxuICBib3JkZXItd2lkdGg6IDA7XFxufVxcblxcbi5ib3JkZXItMiB7XFxuICBib3JkZXItd2lkdGg6IDJweDtcXG59XFxuXFxuLmJvcmRlci00IHtcXG4gIGJvcmRlci13aWR0aDogNHB4O1xcbn1cXG5cXG4uYm9yZGVyLTgge1xcbiAgYm9yZGVyLXdpZHRoOiA4cHg7XFxufVxcblxcbi5ib3JkZXIge1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxufVxcblxcbi5ib3JkZXItdC0wIHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDA7XFxufVxcblxcbi5ib3JkZXItci0wIHtcXG4gIGJvcmRlci1yaWdodC13aWR0aDogMDtcXG59XFxuXFxuLmJvcmRlci1iLTAge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG59XFxuXFxuLmJvcmRlci1sLTAge1xcbiAgYm9yZGVyLWxlZnQtd2lkdGg6IDA7XFxufVxcblxcbi5ib3JkZXItdC0yIHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDJweDtcXG59XFxuXFxuLmJvcmRlci1yLTIge1xcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAycHg7XFxufVxcblxcbi5ib3JkZXItYi0yIHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDJweDtcXG59XFxuXFxuLmJvcmRlci1sLTIge1xcbiAgYm9yZGVyLWxlZnQtd2lkdGg6IDJweDtcXG59XFxuXFxuLmJvcmRlci10LTQge1xcbiAgYm9yZGVyLXRvcC13aWR0aDogNHB4O1xcbn1cXG5cXG4uYm9yZGVyLXItNCB7XFxuICBib3JkZXItcmlnaHQtd2lkdGg6IDRweDtcXG59XFxuXFxuLmJvcmRlci1iLTQge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogNHB4O1xcbn1cXG5cXG4uYm9yZGVyLWwtNCB7XFxuICBib3JkZXItbGVmdC13aWR0aDogNHB4O1xcbn1cXG5cXG4uYm9yZGVyLXQtOCB7XFxuICBib3JkZXItdG9wLXdpZHRoOiA4cHg7XFxufVxcblxcbi5ib3JkZXItci04IHtcXG4gIGJvcmRlci1yaWdodC13aWR0aDogOHB4O1xcbn1cXG5cXG4uYm9yZGVyLWItOCB7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiA4cHg7XFxufVxcblxcbi5ib3JkZXItbC04IHtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiA4cHg7XFxufVxcblxcbi5ib3JkZXItdCB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAxcHg7XFxufVxcblxcbi5ib3JkZXItciB7XFxuICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDtcXG59XFxuXFxuLmJvcmRlci1iIHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXG59XFxuXFxuLmJvcmRlci1sIHtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7XFxufVxcblxcbi5jdXJzb3ItYXV0byB7XFxuICBjdXJzb3I6IGF1dG87XFxufVxcblxcbi5jdXJzb3ItZGVmYXVsdCB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbi5jdXJzb3ItcG9pbnRlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5jdXJzb3Itd2FpdCB7XFxuICBjdXJzb3I6IHdhaXQ7XFxufVxcblxcbi5jdXJzb3ItbW92ZSB7XFxuICBjdXJzb3I6IG1vdmU7XFxufVxcblxcbi5jdXJzb3Itbm90LWFsbG93ZWQge1xcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG59XFxuXFxuLmJsb2NrIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4uaW5saW5lLWJsb2NrIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuXFxuLmlubGluZSB7XFxuICBkaXNwbGF5OiBpbmxpbmU7XFxufVxcblxcbi50YWJsZSB7XFxuICBkaXNwbGF5OiB0YWJsZTtcXG59XFxuXFxuLnRhYmxlLXJvdyB7XFxuICBkaXNwbGF5OiB0YWJsZS1yb3c7XFxufVxcblxcbi50YWJsZS1jZWxsIHtcXG4gIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxufVxcblxcbi5oaWRkZW4ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLmZsZXgge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLmlubGluZS1mbGV4IHtcXG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbn1cXG5cXG4uZmxleC1yb3cge1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG59XFxuXFxuLmZsZXgtcm93LXJldmVyc2Uge1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xcbn1cXG5cXG4uZmxleC1jb2wge1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLmZsZXgtY29sLXJldmVyc2Uge1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xcbn1cXG5cXG4uZmxleC13cmFwIHtcXG4gIGZsZXgtd3JhcDogd3JhcDtcXG59XFxuXFxuLmZsZXgtd3JhcC1yZXZlcnNlIHtcXG4gIGZsZXgtd3JhcDogd3JhcC1yZXZlcnNlO1xcbn1cXG5cXG4uZmxleC1uby13cmFwIHtcXG4gIGZsZXgtd3JhcDogbm93cmFwO1xcbn1cXG5cXG4uaXRlbXMtc3RhcnQge1xcbiAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxufVxcblxcbi5pdGVtcy1lbmQge1xcbiAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbn1cXG5cXG4uaXRlbXMtY2VudGVyIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5pdGVtcy1iYXNlbGluZSB7XFxuICBhbGlnbi1pdGVtczogYmFzZWxpbmU7XFxufVxcblxcbi5pdGVtcy1zdHJldGNoIHtcXG4gIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcbn1cXG5cXG4uc2VsZi1hdXRvIHtcXG4gIGFsaWduLXNlbGY6IGF1dG87XFxufVxcblxcbi5zZWxmLXN0YXJ0IHtcXG4gIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XFxufVxcblxcbi5zZWxmLWVuZCB7XFxuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcXG59XFxuXFxuLnNlbGYtY2VudGVyIHtcXG4gIGFsaWduLXNlbGY6IGNlbnRlcjtcXG59XFxuXFxuLnNlbGYtc3RyZXRjaCB7XFxuICBhbGlnbi1zZWxmOiBzdHJldGNoO1xcbn1cXG5cXG4uanVzdGlmeS1zdGFydCB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxufVxcblxcbi5qdXN0aWZ5LWVuZCB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbn1cXG5cXG4uanVzdGlmeS1jZW50ZXIge1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5qdXN0aWZ5LWJldHdlZW4ge1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbn1cXG5cXG4uanVzdGlmeS1hcm91bmQge1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxufVxcblxcbi5jb250ZW50LWNlbnRlciB7XFxuICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5jb250ZW50LXN0YXJ0IHtcXG4gIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxufVxcblxcbi5jb250ZW50LWVuZCB7XFxuICBhbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcXG59XFxuXFxuLmNvbnRlbnQtYmV0d2VlbiB7XFxuICBhbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbn1cXG5cXG4uY29udGVudC1hcm91bmQge1xcbiAgYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kO1xcbn1cXG5cXG4uZmxleC0xIHtcXG4gIGZsZXg6IDE7XFxufVxcblxcbi5mbGV4LWF1dG8ge1xcbiAgZmxleDogYXV0bztcXG59XFxuXFxuLmZsZXgtaW5pdGlhbCB7XFxuICBmbGV4OiBpbml0aWFsO1xcbn1cXG5cXG4uZmxleC1ub25lIHtcXG4gIGZsZXg6IG5vbmU7XFxufVxcblxcbi5mbGV4LWdyb3cge1xcbiAgZmxleC1ncm93OiAxO1xcbn1cXG5cXG4uZmxleC1zaHJpbmsge1xcbiAgZmxleC1zaHJpbms6IDE7XFxufVxcblxcbi5mbGV4LW5vLWdyb3cge1xcbiAgZmxleC1ncm93OiAwO1xcbn1cXG5cXG4uZmxleC1uby1zaHJpbmsge1xcbiAgZmxleC1zaHJpbms6IDA7XFxufVxcblxcbi5mbG9hdC1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcblxcbi5mbG9hdC1sZWZ0IHtcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG5cXG4uZmxvYXQtbm9uZSB7XFxuICBmbG9hdDogbm9uZTtcXG59XFxuXFxuLmNsZWFyZml4OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgZGlzcGxheTogdGFibGU7XFxuICBjbGVhcjogYm90aDtcXG59XFxuXFxuLmZvbnQtc2FucyB7XFxuICBmb250LWZhbWlseTogc3lzdGVtLXVpLCBCbGlua01hY1N5c3RlbUZvbnQsIC1hcHBsZS1zeXN0ZW0sIFNlZ29lIFVJLCBSb2JvdG8sIE94eWdlbiwgVWJ1bnR1LCBDYW50YXJlbGwsIEZpcmEgU2FucywgRHJvaWQgU2FucywgSGVsdmV0aWNhIE5ldWUsIHNhbnMtc2VyaWY7XFxufVxcblxcbi5mb250LXNlcmlmIHtcXG4gIGZvbnQtZmFtaWx5OiBDb25zdGFudGlhLCBMdWNpZGEgQnJpZ2h0LCBMdWNpZGFicmlnaHQsIEx1Y2lkYSBTZXJpZiwgTHVjaWRhLCBEZWphVnUgU2VyaWYsIEJpdHN0cmVhbSBWZXJhIFNlcmlmLCBMaWJlcmF0aW9uIFNlcmlmLCBHZW9yZ2lhLCBzZXJpZjtcXG59XFxuXFxuLmZvbnQtbW9ubyB7XFxuICBmb250LWZhbWlseTogTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIExpYmVyYXRpb24gTW9ubywgQ291cmllciBOZXcsIG1vbm9zcGFjZTtcXG59XFxuXFxuLmZvbnQtaGFpcmxpbmUge1xcbiAgZm9udC13ZWlnaHQ6IDEwMDtcXG59XFxuXFxuLmZvbnQtdGhpbiB7XFxuICBmb250LXdlaWdodDogMjAwO1xcbn1cXG5cXG4uZm9udC1saWdodCB7XFxuICBmb250LXdlaWdodDogMzAwO1xcbn1cXG5cXG4uZm9udC1ub3JtYWwge1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG59XFxuXFxuLmZvbnQtbWVkaXVtIHtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxufVxcblxcbi5mb250LXNlbWlib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxufVxcblxcbi5mb250LWJvbGQge1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuXFxuLmZvbnQtZXh0cmFib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxufVxcblxcbi5mb250LWJsYWNrIHtcXG4gIGZvbnQtd2VpZ2h0OiA5MDA7XFxufVxcblxcbi5ob3ZlclxcXFw6Zm9udC1oYWlybGluZTpob3ZlciB7XFxuICBmb250LXdlaWdodDogMTAwO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmZvbnQtdGhpbjpob3ZlciB7XFxuICBmb250LXdlaWdodDogMjAwO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmZvbnQtbGlnaHQ6aG92ZXIge1xcbiAgZm9udC13ZWlnaHQ6IDMwMDtcXG59XFxuXFxuLmhvdmVyXFxcXDpmb250LW5vcm1hbDpob3ZlciB7XFxuICBmb250LXdlaWdodDogNDAwO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmZvbnQtbWVkaXVtOmhvdmVyIHtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxufVxcblxcbi5ob3ZlclxcXFw6Zm9udC1zZW1pYm9sZDpob3ZlciB7XFxuICBmb250LXdlaWdodDogNjAwO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmZvbnQtYm9sZDpob3ZlciB7XFxuICBmb250LXdlaWdodDogNzAwO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmZvbnQtZXh0cmFib2xkOmhvdmVyIHtcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxufVxcblxcbi5ob3ZlclxcXFw6Zm9udC1ibGFjazpob3ZlciB7XFxuICBmb250LXdlaWdodDogOTAwO1xcbn1cXG5cXG4uaC0wIHtcXG4gIGhlaWdodDogMDtcXG59XFxuXFxuLmgtMSB7XFxuICBoZWlnaHQ6IDJweDtcXG59XFxuXFxuLmgtMiB7XFxuICBoZWlnaHQ6IDRweDtcXG59XFxuXFxuLmgtMyB7XFxuICBoZWlnaHQ6IDhweDtcXG59XFxuXFxuLmgtNCB7XFxuICBoZWlnaHQ6IDE2cHg7XFxufVxcblxcbi5oLTUge1xcbiAgaGVpZ2h0OiAyNHB4O1xcbn1cXG5cXG4uaC02IHtcXG4gIGhlaWdodDogMzJweDtcXG59XFxuXFxuLmgtNyB7XFxuICBoZWlnaHQ6IDM2cHg7XFxufVxcblxcbi5oLTgge1xcbiAgaGVpZ2h0OiA0OHB4O1xcbn1cXG5cXG4uaC05IHtcXG4gIGhlaWdodDogNjRweDtcXG59XFxuXFxuLmgtMTAge1xcbiAgaGVpZ2h0OiA5NnB4O1xcbn1cXG5cXG4uaC1zY3JlZW4ge1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG59XFxuXFxuLmgtYXV0byB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi5oLWZ1bGwge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG4uaC1weCB7XFxuICBoZWlnaHQ6IDFweDtcXG59XFxuXFxuLmgtMVxcXFwvNiB7XFxuICBoZWlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxufVxcblxcbi5sZWFkaW5nLW5vbmUge1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxufVxcblxcbi5sZWFkaW5nLXRpZ2h0IHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjI1O1xcbn1cXG5cXG4ubGVhZGluZy1ub3JtYWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG59XFxuXFxuLmxlYWRpbmctbG9vc2Uge1xcbiAgbGluZS1oZWlnaHQ6IDI7XFxufVxcblxcbi5tLTAge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4ubS0xIHtcXG4gIG1hcmdpbjogMnB4O1xcbn1cXG5cXG4ubS0yIHtcXG4gIG1hcmdpbjogNHB4O1xcbn1cXG5cXG4ubS0zIHtcXG4gIG1hcmdpbjogOHB4O1xcbn1cXG5cXG4ubS00IHtcXG4gIG1hcmdpbjogMTZweDtcXG59XFxuXFxuLm0tNSB7XFxuICBtYXJnaW46IDI0cHg7XFxufVxcblxcbi5tLTYge1xcbiAgbWFyZ2luOiAzMnB4O1xcbn1cXG5cXG4ubS03IHtcXG4gIG1hcmdpbjogMzZweDtcXG59XFxuXFxuLm0tOCB7XFxuICBtYXJnaW46IDQ4cHg7XFxufVxcblxcbi5tLTkge1xcbiAgbWFyZ2luOiA2NHB4O1xcbn1cXG5cXG4ubS0xMCB7XFxuICBtYXJnaW46IDk2cHg7XFxufVxcblxcbi5tLWF1dG8ge1xcbiAgbWFyZ2luOiBhdXRvO1xcbn1cXG5cXG4ubS1mdWxsIHtcXG4gIG1hcmdpbjogMTAwJTtcXG59XFxuXFxuLm0tcHgge1xcbiAgbWFyZ2luOiAxcHg7XFxufVxcblxcbi5tLTFcXFxcLzYge1xcbiAgbWFyZ2luOiAxNi42NjY2NjY2NjclO1xcbn1cXG5cXG4ubXktMCB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbiAgbWFyZ2luLWJvdHRvbTogMDtcXG59XFxuXFxuLm14LTAge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxufVxcblxcbi5teS0xIHtcXG4gIG1hcmdpbi10b3A6IDJweDtcXG4gIG1hcmdpbi1ib3R0b206IDJweDtcXG59XFxuXFxuLm14LTEge1xcbiAgbWFyZ2luLWxlZnQ6IDJweDtcXG4gIG1hcmdpbi1yaWdodDogMnB4O1xcbn1cXG5cXG4ubXktMiB7XFxuICBtYXJnaW4tdG9wOiA0cHg7XFxuICBtYXJnaW4tYm90dG9tOiA0cHg7XFxufVxcblxcbi5teC0yIHtcXG4gIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICBtYXJnaW4tcmlnaHQ6IDRweDtcXG59XFxuXFxuLm15LTMge1xcbiAgbWFyZ2luLXRvcDogOHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbn1cXG5cXG4ubXgtMyB7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiA4cHg7XFxufVxcblxcbi5teS00IHtcXG4gIG1hcmdpbi10b3A6IDE2cHg7XFxuICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbn1cXG5cXG4ubXgtNCB7XFxuICBtYXJnaW4tbGVmdDogMTZweDtcXG4gIG1hcmdpbi1yaWdodDogMTZweDtcXG59XFxuXFxuLm15LTUge1xcbiAgbWFyZ2luLXRvcDogMjRweDtcXG4gIG1hcmdpbi1ib3R0b206IDI0cHg7XFxufVxcblxcbi5teC01IHtcXG4gIG1hcmdpbi1sZWZ0OiAyNHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAyNHB4O1xcbn1cXG5cXG4ubXktNiB7XFxuICBtYXJnaW4tdG9wOiAzMnB4O1xcbiAgbWFyZ2luLWJvdHRvbTogMzJweDtcXG59XFxuXFxuLm14LTYge1xcbiAgbWFyZ2luLWxlZnQ6IDMycHg7XFxuICBtYXJnaW4tcmlnaHQ6IDMycHg7XFxufVxcblxcbi5teS03IHtcXG4gIG1hcmdpbi10b3A6IDM2cHg7XFxuICBtYXJnaW4tYm90dG9tOiAzNnB4O1xcbn1cXG5cXG4ubXgtNyB7XFxuICBtYXJnaW4tbGVmdDogMzZweDtcXG4gIG1hcmdpbi1yaWdodDogMzZweDtcXG59XFxuXFxuLm15LTgge1xcbiAgbWFyZ2luLXRvcDogNDhweDtcXG4gIG1hcmdpbi1ib3R0b206IDQ4cHg7XFxufVxcblxcbi5teC04IHtcXG4gIG1hcmdpbi1sZWZ0OiA0OHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiA0OHB4O1xcbn1cXG5cXG4ubXktOSB7XFxuICBtYXJnaW4tdG9wOiA2NHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogNjRweDtcXG59XFxuXFxuLm14LTkge1xcbiAgbWFyZ2luLWxlZnQ6IDY0cHg7XFxuICBtYXJnaW4tcmlnaHQ6IDY0cHg7XFxufVxcblxcbi5teS0xMCB7XFxuICBtYXJnaW4tdG9wOiA5NnB4O1xcbiAgbWFyZ2luLWJvdHRvbTogOTZweDtcXG59XFxuXFxuLm14LTEwIHtcXG4gIG1hcmdpbi1sZWZ0OiA5NnB4O1xcbiAgbWFyZ2luLXJpZ2h0OiA5NnB4O1xcbn1cXG5cXG4ubXktYXV0byB7XFxuICBtYXJnaW4tdG9wOiBhdXRvO1xcbiAgbWFyZ2luLWJvdHRvbTogYXV0bztcXG59XFxuXFxuLm14LWF1dG8ge1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxufVxcblxcbi5teS1mdWxsIHtcXG4gIG1hcmdpbi10b3A6IDEwMCU7XFxuICBtYXJnaW4tYm90dG9tOiAxMDAlO1xcbn1cXG5cXG4ubXgtZnVsbCB7XFxuICBtYXJnaW4tbGVmdDogMTAwJTtcXG4gIG1hcmdpbi1yaWdodDogMTAwJTtcXG59XFxuXFxuLm15LXB4IHtcXG4gIG1hcmdpbi10b3A6IDFweDtcXG4gIG1hcmdpbi1ib3R0b206IDFweDtcXG59XFxuXFxuLm14LXB4IHtcXG4gIG1hcmdpbi1sZWZ0OiAxcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDFweDtcXG59XFxuXFxuLm15LTFcXFxcLzYge1xcbiAgbWFyZ2luLXRvcDogMTYuNjY2NjY2NjY3JTtcXG4gIG1hcmdpbi1ib3R0b206IDE2LjY2NjY2NjY2NyU7XFxufVxcblxcbi5teC0xXFxcXC82IHtcXG4gIG1hcmdpbi1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgbWFyZ2luLXJpZ2h0OiAxNi42NjY2NjY2NjclO1xcbn1cXG5cXG4ubXQtMCB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbn1cXG5cXG4ubXItMCB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxufVxcblxcbi5tYi0wIHtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxufVxcblxcbi5tbC0wIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbn1cXG5cXG4ubXQtMSB7XFxuICBtYXJnaW4tdG9wOiAycHg7XFxufVxcblxcbi5tci0xIHtcXG4gIG1hcmdpbi1yaWdodDogMnB4O1xcbn1cXG5cXG4ubWItMSB7XFxuICBtYXJnaW4tYm90dG9tOiAycHg7XFxufVxcblxcbi5tbC0xIHtcXG4gIG1hcmdpbi1sZWZ0OiAycHg7XFxufVxcblxcbi5tdC0yIHtcXG4gIG1hcmdpbi10b3A6IDRweDtcXG59XFxuXFxuLm1yLTIge1xcbiAgbWFyZ2luLXJpZ2h0OiA0cHg7XFxufVxcblxcbi5tYi0yIHtcXG4gIG1hcmdpbi1ib3R0b206IDRweDtcXG59XFxuXFxuLm1sLTIge1xcbiAgbWFyZ2luLWxlZnQ6IDRweDtcXG59XFxuXFxuLm10LTMge1xcbiAgbWFyZ2luLXRvcDogOHB4O1xcbn1cXG5cXG4ubXItMyB7XFxuICBtYXJnaW4tcmlnaHQ6IDhweDtcXG59XFxuXFxuLm1iLTMge1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbn1cXG5cXG4ubWwtMyB7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbn1cXG5cXG4ubXQtNCB7XFxuICBtYXJnaW4tdG9wOiAxNnB4O1xcbn1cXG5cXG4ubXItNCB7XFxuICBtYXJnaW4tcmlnaHQ6IDE2cHg7XFxufVxcblxcbi5tYi00IHtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHg7XFxufVxcblxcbi5tbC00IHtcXG4gIG1hcmdpbi1sZWZ0OiAxNnB4O1xcbn1cXG5cXG4ubXQtNSB7XFxuICBtYXJnaW4tdG9wOiAyNHB4O1xcbn1cXG5cXG4ubXItNSB7XFxuICBtYXJnaW4tcmlnaHQ6IDI0cHg7XFxufVxcblxcbi5tYi01IHtcXG4gIG1hcmdpbi1ib3R0b206IDI0cHg7XFxufVxcblxcbi5tbC01IHtcXG4gIG1hcmdpbi1sZWZ0OiAyNHB4O1xcbn1cXG5cXG4ubXQtNiB7XFxuICBtYXJnaW4tdG9wOiAzMnB4O1xcbn1cXG5cXG4ubXItNiB7XFxuICBtYXJnaW4tcmlnaHQ6IDMycHg7XFxufVxcblxcbi5tYi02IHtcXG4gIG1hcmdpbi1ib3R0b206IDMycHg7XFxufVxcblxcbi5tbC02IHtcXG4gIG1hcmdpbi1sZWZ0OiAzMnB4O1xcbn1cXG5cXG4ubXQtNyB7XFxuICBtYXJnaW4tdG9wOiAzNnB4O1xcbn1cXG5cXG4ubXItNyB7XFxuICBtYXJnaW4tcmlnaHQ6IDM2cHg7XFxufVxcblxcbi5tYi03IHtcXG4gIG1hcmdpbi1ib3R0b206IDM2cHg7XFxufVxcblxcbi5tbC03IHtcXG4gIG1hcmdpbi1sZWZ0OiAzNnB4O1xcbn1cXG5cXG4ubXQtOCB7XFxuICBtYXJnaW4tdG9wOiA0OHB4O1xcbn1cXG5cXG4ubXItOCB7XFxuICBtYXJnaW4tcmlnaHQ6IDQ4cHg7XFxufVxcblxcbi5tYi04IHtcXG4gIG1hcmdpbi1ib3R0b206IDQ4cHg7XFxufVxcblxcbi5tbC04IHtcXG4gIG1hcmdpbi1sZWZ0OiA0OHB4O1xcbn1cXG5cXG4ubXQtOSB7XFxuICBtYXJnaW4tdG9wOiA2NHB4O1xcbn1cXG5cXG4ubXItOSB7XFxuICBtYXJnaW4tcmlnaHQ6IDY0cHg7XFxufVxcblxcbi5tYi05IHtcXG4gIG1hcmdpbi1ib3R0b206IDY0cHg7XFxufVxcblxcbi5tbC05IHtcXG4gIG1hcmdpbi1sZWZ0OiA2NHB4O1xcbn1cXG5cXG4ubXQtMTAge1xcbiAgbWFyZ2luLXRvcDogOTZweDtcXG59XFxuXFxuLm1yLTEwIHtcXG4gIG1hcmdpbi1yaWdodDogOTZweDtcXG59XFxuXFxuLm1iLTEwIHtcXG4gIG1hcmdpbi1ib3R0b206IDk2cHg7XFxufVxcblxcbi5tbC0xMCB7XFxuICBtYXJnaW4tbGVmdDogOTZweDtcXG59XFxuXFxuLm10LWF1dG8ge1xcbiAgbWFyZ2luLXRvcDogYXV0bztcXG59XFxuXFxuLm1yLWF1dG8ge1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbn1cXG5cXG4ubWItYXV0byB7XFxuICBtYXJnaW4tYm90dG9tOiBhdXRvO1xcbn1cXG5cXG4ubWwtYXV0byB7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG59XFxuXFxuLm10LWZ1bGwge1xcbiAgbWFyZ2luLXRvcDogMTAwJTtcXG59XFxuXFxuLm1yLWZ1bGwge1xcbiAgbWFyZ2luLXJpZ2h0OiAxMDAlO1xcbn1cXG5cXG4ubWItZnVsbCB7XFxuICBtYXJnaW4tYm90dG9tOiAxMDAlO1xcbn1cXG5cXG4ubWwtZnVsbCB7XFxuICBtYXJnaW4tbGVmdDogMTAwJTtcXG59XFxuXFxuLm10LXB4IHtcXG4gIG1hcmdpbi10b3A6IDFweDtcXG59XFxuXFxuLm1yLXB4IHtcXG4gIG1hcmdpbi1yaWdodDogMXB4O1xcbn1cXG5cXG4ubWItcHgge1xcbiAgbWFyZ2luLWJvdHRvbTogMXB4O1xcbn1cXG5cXG4ubWwtcHgge1xcbiAgbWFyZ2luLWxlZnQ6IDFweDtcXG59XFxuXFxuLm10LTFcXFxcLzYge1xcbiAgbWFyZ2luLXRvcDogMTYuNjY2NjY2NjY3JTtcXG59XFxuXFxuLm1yLTFcXFxcLzYge1xcbiAgbWFyZ2luLXJpZ2h0OiAxNi42NjY2NjY2NjclO1xcbn1cXG5cXG4ubWItMVxcXFwvNiB7XFxuICBtYXJnaW4tYm90dG9tOiAxNi42NjY2NjY2NjclO1xcbn1cXG5cXG4ubWwtMVxcXFwvNiB7XFxuICBtYXJnaW4tbGVmdDogMTYuNjY2NjY2NjY3JTtcXG59XFxuXFxuLm1heC1oLTAge1xcbiAgbWF4LWhlaWdodDogMDtcXG59XFxuXFxuLm1heC1oLTEge1xcbiAgbWF4LWhlaWdodDogMnB4O1xcbn1cXG5cXG4ubWF4LWgtMiB7XFxuICBtYXgtaGVpZ2h0OiA0cHg7XFxufVxcblxcbi5tYXgtaC0zIHtcXG4gIG1heC1oZWlnaHQ6IDhweDtcXG59XFxuXFxuLm1heC1oLTQge1xcbiAgbWF4LWhlaWdodDogMTZweDtcXG59XFxuXFxuLm1heC1oLTUge1xcbiAgbWF4LWhlaWdodDogMjRweDtcXG59XFxuXFxuLm1heC1oLTYge1xcbiAgbWF4LWhlaWdodDogMzJweDtcXG59XFxuXFxuLm1heC1oLTcge1xcbiAgbWF4LWhlaWdodDogMzZweDtcXG59XFxuXFxuLm1heC1oLTgge1xcbiAgbWF4LWhlaWdodDogNDhweDtcXG59XFxuXFxuLm1heC1oLTkge1xcbiAgbWF4LWhlaWdodDogNjRweDtcXG59XFxuXFxuLm1heC1oLTEwIHtcXG4gIG1heC1oZWlnaHQ6IDk2cHg7XFxufVxcblxcbi5tYXgtaC1zY3JlZW4ge1xcbiAgbWF4LWhlaWdodDogMTAwdmg7XFxufVxcblxcbi5tYXgtaC1hdXRvIHtcXG4gIG1heC1oZWlnaHQ6IGF1dG87XFxufVxcblxcbi5tYXgtaC1mdWxsIHtcXG4gIG1heC1oZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5tYXgtaC1weCB7XFxuICBtYXgtaGVpZ2h0OiAxcHg7XFxufVxcblxcbi5tYXgtaC0xXFxcXC82IHtcXG4gIG1heC1oZWlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxufVxcblxcbi5tYXgtdy0wIHtcXG4gIG1heC13aWR0aDogMDtcXG59XFxuXFxuLm1heC13LTEge1xcbiAgbWF4LXdpZHRoOiAycHg7XFxufVxcblxcbi5tYXgtdy0yIHtcXG4gIG1heC13aWR0aDogNHB4O1xcbn1cXG5cXG4ubWF4LXctMyB7XFxuICBtYXgtd2lkdGg6IDhweDtcXG59XFxuXFxuLm1heC13LTQge1xcbiAgbWF4LXdpZHRoOiAxNnB4O1xcbn1cXG5cXG4ubWF4LXctNSB7XFxuICBtYXgtd2lkdGg6IDI0cHg7XFxufVxcblxcbi5tYXgtdy02IHtcXG4gIG1heC13aWR0aDogMzJweDtcXG59XFxuXFxuLm1heC13LTcge1xcbiAgbWF4LXdpZHRoOiAzNnB4O1xcbn1cXG5cXG4ubWF4LXctOCB7XFxuICBtYXgtd2lkdGg6IDQ4cHg7XFxufVxcblxcbi5tYXgtdy05IHtcXG4gIG1heC13aWR0aDogNjRweDtcXG59XFxuXFxuLm1heC13LTEwIHtcXG4gIG1heC13aWR0aDogOTZweDtcXG59XFxuXFxuLm1heC13LWF1dG8ge1xcbiAgbWF4LXdpZHRoOiBhdXRvO1xcbn1cXG5cXG4ubWF4LXctZnVsbCB7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxufVxcblxcbi5tYXgtdy1weCB7XFxuICBtYXgtd2lkdGg6IDFweDtcXG59XFxuXFxuLm1heC13LTFcXFxcLzYge1xcbiAgbWF4LXdpZHRoOiAxNi42NjY2NjY2NjclO1xcbn1cXG5cXG4ubWluLWgtMCB7XFxuICBtaW4taGVpZ2h0OiAwO1xcbn1cXG5cXG4ubWluLWgtMSB7XFxuICBtaW4taGVpZ2h0OiAycHg7XFxufVxcblxcbi5taW4taC0yIHtcXG4gIG1pbi1oZWlnaHQ6IDRweDtcXG59XFxuXFxuLm1pbi1oLTMge1xcbiAgbWluLWhlaWdodDogOHB4O1xcbn1cXG5cXG4ubWluLWgtNCB7XFxuICBtaW4taGVpZ2h0OiAxNnB4O1xcbn1cXG5cXG4ubWluLWgtNSB7XFxuICBtaW4taGVpZ2h0OiAyNHB4O1xcbn1cXG5cXG4ubWluLWgtNiB7XFxuICBtaW4taGVpZ2h0OiAzMnB4O1xcbn1cXG5cXG4ubWluLWgtNyB7XFxuICBtaW4taGVpZ2h0OiAzNnB4O1xcbn1cXG5cXG4ubWluLWgtOCB7XFxuICBtaW4taGVpZ2h0OiA0OHB4O1xcbn1cXG5cXG4ubWluLWgtOSB7XFxuICBtaW4taGVpZ2h0OiA2NHB4O1xcbn1cXG5cXG4ubWluLWgtMTAge1xcbiAgbWluLWhlaWdodDogOTZweDtcXG59XFxuXFxuLm1pbi1oLXNjcmVlbiB7XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG59XFxuXFxuLm1pbi1oLWF1dG8ge1xcbiAgbWluLWhlaWdodDogYXV0bztcXG59XFxuXFxuLm1pbi1oLWZ1bGwge1xcbiAgbWluLWhlaWdodDogMTAwJTtcXG59XFxuXFxuLm1pbi1oLXB4IHtcXG4gIG1pbi1oZWlnaHQ6IDFweDtcXG59XFxuXFxuLm1pbi1oLTFcXFxcLzYge1xcbiAgbWluLWhlaWdodDogMTYuNjY2NjY2NjY3JTtcXG59XFxuXFxuLm1pbi13LTAge1xcbiAgbWluLXdpZHRoOiAwO1xcbn1cXG5cXG4ubWluLXctMSB7XFxuICBtaW4td2lkdGg6IDJweDtcXG59XFxuXFxuLm1pbi13LTIge1xcbiAgbWluLXdpZHRoOiA0cHg7XFxufVxcblxcbi5taW4tdy0zIHtcXG4gIG1pbi13aWR0aDogOHB4O1xcbn1cXG5cXG4ubWluLXctNCB7XFxuICBtaW4td2lkdGg6IDE2cHg7XFxufVxcblxcbi5taW4tdy01IHtcXG4gIG1pbi13aWR0aDogMjRweDtcXG59XFxuXFxuLm1pbi13LTYge1xcbiAgbWluLXdpZHRoOiAzMnB4O1xcbn1cXG5cXG4ubWluLXctNyB7XFxuICBtaW4td2lkdGg6IDM2cHg7XFxufVxcblxcbi5taW4tdy04IHtcXG4gIG1pbi13aWR0aDogNDhweDtcXG59XFxuXFxuLm1pbi13LTkge1xcbiAgbWluLXdpZHRoOiA2NHB4O1xcbn1cXG5cXG4ubWluLXctMTAge1xcbiAgbWluLXdpZHRoOiA5NnB4O1xcbn1cXG5cXG4ubWluLXctYXV0byB7XFxuICBtaW4td2lkdGg6IGF1dG87XFxufVxcblxcbi5taW4tdy1mdWxsIHtcXG4gIG1pbi13aWR0aDogMTAwJTtcXG59XFxuXFxuLm1pbi13LXB4IHtcXG4gIG1pbi13aWR0aDogMXB4O1xcbn1cXG5cXG4ubWluLXctMVxcXFwvNiB7XFxuICBtaW4td2lkdGg6IDE2LjY2NjY2NjY2NyU7XFxufVxcblxcbi4tbS0wIHtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuLi1tLTEge1xcbiAgbWFyZ2luOiAtMnB4O1xcbn1cXG5cXG4uLW0tMiB7XFxuICBtYXJnaW46IC00cHg7XFxufVxcblxcbi4tbS0zIHtcXG4gIG1hcmdpbjogLThweDtcXG59XFxuXFxuLi1tLTQge1xcbiAgbWFyZ2luOiAtMTZweDtcXG59XFxuXFxuLi1tLTUge1xcbiAgbWFyZ2luOiAtMjRweDtcXG59XFxuXFxuLi1tLTYge1xcbiAgbWFyZ2luOiAtMzJweDtcXG59XFxuXFxuLi1tLTcge1xcbiAgbWFyZ2luOiAtMzZweDtcXG59XFxuXFxuLi1tLTgge1xcbiAgbWFyZ2luOiAtNDhweDtcXG59XFxuXFxuLi1tLTkge1xcbiAgbWFyZ2luOiAtNjRweDtcXG59XFxuXFxuLi1tLTEwIHtcXG4gIG1hcmdpbjogLTk2cHg7XFxufVxcblxcbi4tbS1hdXRvIHtcXG4gIG1hcmdpbjogLWF1dG87XFxufVxcblxcbi4tbS1mdWxsIHtcXG4gIG1hcmdpbjogLTEwMCU7XFxufVxcblxcbi4tbS1weCB7XFxuICBtYXJnaW46IC0xcHg7XFxufVxcblxcbi4tbS0xXFxcXC82IHtcXG4gIG1hcmdpbjogLTE2LjY2NjY2NjY2NyU7XFxufVxcblxcbi4tbXktMCB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbiAgbWFyZ2luLWJvdHRvbTogMDtcXG59XFxuXFxuLi1teC0wIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbn1cXG5cXG4uLW15LTEge1xcbiAgbWFyZ2luLXRvcDogLTJweDtcXG4gIG1hcmdpbi1ib3R0b206IC0ycHg7XFxufVxcblxcbi4tbXgtMSB7XFxuICBtYXJnaW4tbGVmdDogLTJweDtcXG4gIG1hcmdpbi1yaWdodDogLTJweDtcXG59XFxuXFxuLi1teS0yIHtcXG4gIG1hcmdpbi10b3A6IC00cHg7XFxuICBtYXJnaW4tYm90dG9tOiAtNHB4O1xcbn1cXG5cXG4uLW14LTIge1xcbiAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICBtYXJnaW4tcmlnaHQ6IC00cHg7XFxufVxcblxcbi4tbXktMyB7XFxuICBtYXJnaW4tdG9wOiAtOHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogLThweDtcXG59XFxuXFxuLi1teC0zIHtcXG4gIG1hcmdpbi1sZWZ0OiAtOHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAtOHB4O1xcbn1cXG5cXG4uLW15LTQge1xcbiAgbWFyZ2luLXRvcDogLTE2cHg7XFxuICBtYXJnaW4tYm90dG9tOiAtMTZweDtcXG59XFxuXFxuLi1teC00IHtcXG4gIG1hcmdpbi1sZWZ0OiAtMTZweDtcXG4gIG1hcmdpbi1yaWdodDogLTE2cHg7XFxufVxcblxcbi4tbXktNSB7XFxuICBtYXJnaW4tdG9wOiAtMjRweDtcXG4gIG1hcmdpbi1ib3R0b206IC0yNHB4O1xcbn1cXG5cXG4uLW14LTUge1xcbiAgbWFyZ2luLWxlZnQ6IC0yNHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAtMjRweDtcXG59XFxuXFxuLi1teS02IHtcXG4gIG1hcmdpbi10b3A6IC0zMnB4O1xcbiAgbWFyZ2luLWJvdHRvbTogLTMycHg7XFxufVxcblxcbi4tbXgtNiB7XFxuICBtYXJnaW4tbGVmdDogLTMycHg7XFxuICBtYXJnaW4tcmlnaHQ6IC0zMnB4O1xcbn1cXG5cXG4uLW15LTcge1xcbiAgbWFyZ2luLXRvcDogLTM2cHg7XFxuICBtYXJnaW4tYm90dG9tOiAtMzZweDtcXG59XFxuXFxuLi1teC03IHtcXG4gIG1hcmdpbi1sZWZ0OiAtMzZweDtcXG4gIG1hcmdpbi1yaWdodDogLTM2cHg7XFxufVxcblxcbi4tbXktOCB7XFxuICBtYXJnaW4tdG9wOiAtNDhweDtcXG4gIG1hcmdpbi1ib3R0b206IC00OHB4O1xcbn1cXG5cXG4uLW14LTgge1xcbiAgbWFyZ2luLWxlZnQ6IC00OHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAtNDhweDtcXG59XFxuXFxuLi1teS05IHtcXG4gIG1hcmdpbi10b3A6IC02NHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogLTY0cHg7XFxufVxcblxcbi4tbXgtOSB7XFxuICBtYXJnaW4tbGVmdDogLTY0cHg7XFxuICBtYXJnaW4tcmlnaHQ6IC02NHB4O1xcbn1cXG5cXG4uLW15LTEwIHtcXG4gIG1hcmdpbi10b3A6IC05NnB4O1xcbiAgbWFyZ2luLWJvdHRvbTogLTk2cHg7XFxufVxcblxcbi4tbXgtMTAge1xcbiAgbWFyZ2luLWxlZnQ6IC05NnB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAtOTZweDtcXG59XFxuXFxuLi1teS1hdXRvIHtcXG4gIG1hcmdpbi10b3A6IC1hdXRvO1xcbiAgbWFyZ2luLWJvdHRvbTogLWF1dG87XFxufVxcblxcbi4tbXgtYXV0byB7XFxuICBtYXJnaW4tbGVmdDogLWF1dG87XFxuICBtYXJnaW4tcmlnaHQ6IC1hdXRvO1xcbn1cXG5cXG4uLW15LWZ1bGwge1xcbiAgbWFyZ2luLXRvcDogLTEwMCU7XFxuICBtYXJnaW4tYm90dG9tOiAtMTAwJTtcXG59XFxuXFxuLi1teC1mdWxsIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMTAwJTtcXG4gIG1hcmdpbi1yaWdodDogLTEwMCU7XFxufVxcblxcbi4tbXktcHgge1xcbiAgbWFyZ2luLXRvcDogLTFweDtcXG4gIG1hcmdpbi1ib3R0b206IC0xcHg7XFxufVxcblxcbi4tbXgtcHgge1xcbiAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxuICBtYXJnaW4tcmlnaHQ6IC0xcHg7XFxufVxcblxcbi4tbXktMVxcXFwvNiB7XFxuICBtYXJnaW4tdG9wOiAtMTYuNjY2NjY2NjY3JTtcXG4gIG1hcmdpbi1ib3R0b206IC0xNi42NjY2NjY2NjclO1xcbn1cXG5cXG4uLW14LTFcXFxcLzYge1xcbiAgbWFyZ2luLWxlZnQ6IC0xNi42NjY2NjY2NjclO1xcbiAgbWFyZ2luLXJpZ2h0OiAtMTYuNjY2NjY2NjY3JTtcXG59XFxuXFxuLi1tdC0wIHtcXG4gIG1hcmdpbi10b3A6IDA7XFxufVxcblxcbi4tbXItMCB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxufVxcblxcbi4tbWItMCB7XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbn1cXG5cXG4uLW1sLTAge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxufVxcblxcbi4tbXQtMSB7XFxuICBtYXJnaW4tdG9wOiAtMnB4O1xcbn1cXG5cXG4uLW1yLTEge1xcbiAgbWFyZ2luLXJpZ2h0OiAtMnB4O1xcbn1cXG5cXG4uLW1iLTEge1xcbiAgbWFyZ2luLWJvdHRvbTogLTJweDtcXG59XFxuXFxuLi1tbC0xIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMnB4O1xcbn1cXG5cXG4uLW10LTIge1xcbiAgbWFyZ2luLXRvcDogLTRweDtcXG59XFxuXFxuLi1tci0yIHtcXG4gIG1hcmdpbi1yaWdodDogLTRweDtcXG59XFxuXFxuLi1tYi0yIHtcXG4gIG1hcmdpbi1ib3R0b206IC00cHg7XFxufVxcblxcbi4tbWwtMiB7XFxuICBtYXJnaW4tbGVmdDogLTRweDtcXG59XFxuXFxuLi1tdC0zIHtcXG4gIG1hcmdpbi10b3A6IC04cHg7XFxufVxcblxcbi4tbXItMyB7XFxuICBtYXJnaW4tcmlnaHQ6IC04cHg7XFxufVxcblxcbi4tbWItMyB7XFxuICBtYXJnaW4tYm90dG9tOiAtOHB4O1xcbn1cXG5cXG4uLW1sLTMge1xcbiAgbWFyZ2luLWxlZnQ6IC04cHg7XFxufVxcblxcbi4tbXQtNCB7XFxuICBtYXJnaW4tdG9wOiAtMTZweDtcXG59XFxuXFxuLi1tci00IHtcXG4gIG1hcmdpbi1yaWdodDogLTE2cHg7XFxufVxcblxcbi4tbWItNCB7XFxuICBtYXJnaW4tYm90dG9tOiAtMTZweDtcXG59XFxuXFxuLi1tbC00IHtcXG4gIG1hcmdpbi1sZWZ0OiAtMTZweDtcXG59XFxuXFxuLi1tdC01IHtcXG4gIG1hcmdpbi10b3A6IC0yNHB4O1xcbn1cXG5cXG4uLW1yLTUge1xcbiAgbWFyZ2luLXJpZ2h0OiAtMjRweDtcXG59XFxuXFxuLi1tYi01IHtcXG4gIG1hcmdpbi1ib3R0b206IC0yNHB4O1xcbn1cXG5cXG4uLW1sLTUge1xcbiAgbWFyZ2luLWxlZnQ6IC0yNHB4O1xcbn1cXG5cXG4uLW10LTYge1xcbiAgbWFyZ2luLXRvcDogLTMycHg7XFxufVxcblxcbi4tbXItNiB7XFxuICBtYXJnaW4tcmlnaHQ6IC0zMnB4O1xcbn1cXG5cXG4uLW1iLTYge1xcbiAgbWFyZ2luLWJvdHRvbTogLTMycHg7XFxufVxcblxcbi4tbWwtNiB7XFxuICBtYXJnaW4tbGVmdDogLTMycHg7XFxufVxcblxcbi4tbXQtNyB7XFxuICBtYXJnaW4tdG9wOiAtMzZweDtcXG59XFxuXFxuLi1tci03IHtcXG4gIG1hcmdpbi1yaWdodDogLTM2cHg7XFxufVxcblxcbi4tbWItNyB7XFxuICBtYXJnaW4tYm90dG9tOiAtMzZweDtcXG59XFxuXFxuLi1tbC03IHtcXG4gIG1hcmdpbi1sZWZ0OiAtMzZweDtcXG59XFxuXFxuLi1tdC04IHtcXG4gIG1hcmdpbi10b3A6IC00OHB4O1xcbn1cXG5cXG4uLW1yLTgge1xcbiAgbWFyZ2luLXJpZ2h0OiAtNDhweDtcXG59XFxuXFxuLi1tYi04IHtcXG4gIG1hcmdpbi1ib3R0b206IC00OHB4O1xcbn1cXG5cXG4uLW1sLTgge1xcbiAgbWFyZ2luLWxlZnQ6IC00OHB4O1xcbn1cXG5cXG4uLW10LTkge1xcbiAgbWFyZ2luLXRvcDogLTY0cHg7XFxufVxcblxcbi4tbXItOSB7XFxuICBtYXJnaW4tcmlnaHQ6IC02NHB4O1xcbn1cXG5cXG4uLW1iLTkge1xcbiAgbWFyZ2luLWJvdHRvbTogLTY0cHg7XFxufVxcblxcbi4tbWwtOSB7XFxuICBtYXJnaW4tbGVmdDogLTY0cHg7XFxufVxcblxcbi4tbXQtMTAge1xcbiAgbWFyZ2luLXRvcDogLTk2cHg7XFxufVxcblxcbi4tbXItMTAge1xcbiAgbWFyZ2luLXJpZ2h0OiAtOTZweDtcXG59XFxuXFxuLi1tYi0xMCB7XFxuICBtYXJnaW4tYm90dG9tOiAtOTZweDtcXG59XFxuXFxuLi1tbC0xMCB7XFxuICBtYXJnaW4tbGVmdDogLTk2cHg7XFxufVxcblxcbi4tbXQtYXV0byB7XFxuICBtYXJnaW4tdG9wOiAtYXV0bztcXG59XFxuXFxuLi1tci1hdXRvIHtcXG4gIG1hcmdpbi1yaWdodDogLWF1dG87XFxufVxcblxcbi4tbWItYXV0byB7XFxuICBtYXJnaW4tYm90dG9tOiAtYXV0bztcXG59XFxuXFxuLi1tbC1hdXRvIHtcXG4gIG1hcmdpbi1sZWZ0OiAtYXV0bztcXG59XFxuXFxuLi1tdC1mdWxsIHtcXG4gIG1hcmdpbi10b3A6IC0xMDAlO1xcbn1cXG5cXG4uLW1yLWZ1bGwge1xcbiAgbWFyZ2luLXJpZ2h0OiAtMTAwJTtcXG59XFxuXFxuLi1tYi1mdWxsIHtcXG4gIG1hcmdpbi1ib3R0b206IC0xMDAlO1xcbn1cXG5cXG4uLW1sLWZ1bGwge1xcbiAgbWFyZ2luLWxlZnQ6IC0xMDAlO1xcbn1cXG5cXG4uLW10LXB4IHtcXG4gIG1hcmdpbi10b3A6IC0xcHg7XFxufVxcblxcbi4tbXItcHgge1xcbiAgbWFyZ2luLXJpZ2h0OiAtMXB4O1xcbn1cXG5cXG4uLW1iLXB4IHtcXG4gIG1hcmdpbi1ib3R0b206IC0xcHg7XFxufVxcblxcbi4tbWwtcHgge1xcbiAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxufVxcblxcbi4tbXQtMVxcXFwvNiB7XFxuICBtYXJnaW4tdG9wOiAtMTYuNjY2NjY2NjY3JTtcXG59XFxuXFxuLi1tci0xXFxcXC82IHtcXG4gIG1hcmdpbi1yaWdodDogLTE2LjY2NjY2NjY2NyU7XFxufVxcblxcbi4tbWItMVxcXFwvNiB7XFxuICBtYXJnaW4tYm90dG9tOiAtMTYuNjY2NjY2NjY3JTtcXG59XFxuXFxuLi1tbC0xXFxcXC82IHtcXG4gIG1hcmdpbi1sZWZ0OiAtMTYuNjY2NjY2NjY3JTtcXG59XFxuXFxuLm9wYWNpdHktMCB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cXG4ub3BhY2l0eS0yNSB7XFxuICBvcGFjaXR5OiAuMjU7XFxufVxcblxcbi5vcGFjaXR5LTUwIHtcXG4gIG9wYWNpdHk6IC41O1xcbn1cXG5cXG4ub3BhY2l0eS03NSB7XFxuICBvcGFjaXR5OiAuNzU7XFxufVxcblxcbi5vcGFjaXR5LTEwMCB7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4ub3V0bGluZS1ub25lIHtcXG4gIG91dGxpbmU6IDA7XFxufVxcblxcbi5mb2N1c1xcXFw6b3V0bGluZS1ub25lOmZvY3VzIHtcXG4gIG91dGxpbmU6IDA7XFxufVxcblxcbi5vdmVyZmxvdy1hdXRvIHtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbn1cXG5cXG4ub3ZlcmZsb3ctaGlkZGVuIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5vdmVyZmxvdy12aXNpYmxlIHtcXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbn1cXG5cXG4ub3ZlcmZsb3ctc2Nyb2xsIHtcXG4gIG92ZXJmbG93OiBzY3JvbGw7XFxufVxcblxcbi5vdmVyZmxvdy14LWF1dG8ge1xcbiAgb3ZlcmZsb3cteDogYXV0bztcXG59XFxuXFxuLm92ZXJmbG93LXktYXV0byB7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbn1cXG5cXG4ub3ZlcmZsb3cteC1oaWRkZW4ge1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbn1cXG5cXG4ub3ZlcmZsb3cteS1oaWRkZW4ge1xcbiAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbn1cXG5cXG4ub3ZlcmZsb3cteC12aXNpYmxlIHtcXG4gIG92ZXJmbG93LXg6IHZpc2libGU7XFxufVxcblxcbi5vdmVyZmxvdy15LXZpc2libGUge1xcbiAgb3ZlcmZsb3cteTogdmlzaWJsZTtcXG59XFxuXFxuLm92ZXJmbG93LXgtc2Nyb2xsIHtcXG4gIG92ZXJmbG93LXg6IHNjcm9sbDtcXG59XFxuXFxuLm92ZXJmbG93LXktc2Nyb2xsIHtcXG4gIG92ZXJmbG93LXk6IHNjcm9sbDtcXG59XFxuXFxuLnNjcm9sbGluZy10b3VjaCB7XFxuICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XFxufVxcblxcbi5zY3JvbGxpbmctYXV0byB7XFxuICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogYXV0bztcXG59XFxuXFxuLnAtMCB7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4ucC0xIHtcXG4gIHBhZGRpbmc6IDJweDtcXG59XFxuXFxuLnAtMiB7XFxuICBwYWRkaW5nOiA0cHg7XFxufVxcblxcbi5wLTMge1xcbiAgcGFkZGluZzogOHB4O1xcbn1cXG5cXG4ucC00IHtcXG4gIHBhZGRpbmc6IDE2cHg7XFxufVxcblxcbi5wLTUge1xcbiAgcGFkZGluZzogMjRweDtcXG59XFxuXFxuLnAtNiB7XFxuICBwYWRkaW5nOiAzMnB4O1xcbn1cXG5cXG4ucC03IHtcXG4gIHBhZGRpbmc6IDM2cHg7XFxufVxcblxcbi5wLTgge1xcbiAgcGFkZGluZzogNDhweDtcXG59XFxuXFxuLnAtOSB7XFxuICBwYWRkaW5nOiA2NHB4O1xcbn1cXG5cXG4ucC0xMCB7XFxuICBwYWRkaW5nOiA5NnB4O1xcbn1cXG5cXG4ucC1hdXRvIHtcXG4gIHBhZGRpbmc6IGF1dG87XFxufVxcblxcbi5wLWZ1bGwge1xcbiAgcGFkZGluZzogMTAwJTtcXG59XFxuXFxuLnAtcHgge1xcbiAgcGFkZGluZzogMXB4O1xcbn1cXG5cXG4ucC0xXFxcXC82IHtcXG4gIHBhZGRpbmc6IDE2LjY2NjY2NjY2NyU7XFxufVxcblxcbi5weS0wIHtcXG4gIHBhZGRpbmctdG9wOiAwO1xcbiAgcGFkZGluZy1ib3R0b206IDA7XFxufVxcblxcbi5weC0wIHtcXG4gIHBhZGRpbmctbGVmdDogMDtcXG4gIHBhZGRpbmctcmlnaHQ6IDA7XFxufVxcblxcbi5weS0xIHtcXG4gIHBhZGRpbmctdG9wOiAycHg7XFxuICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbn1cXG5cXG4ucHgtMSB7XFxuICBwYWRkaW5nLWxlZnQ6IDJweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDJweDtcXG59XFxuXFxuLnB5LTIge1xcbiAgcGFkZGluZy10b3A6IDRweDtcXG4gIHBhZGRpbmctYm90dG9tOiA0cHg7XFxufVxcblxcbi5weC0yIHtcXG4gIHBhZGRpbmctbGVmdDogNHB4O1xcbiAgcGFkZGluZy1yaWdodDogNHB4O1xcbn1cXG5cXG4ucHktMyB7XFxuICBwYWRkaW5nLXRvcDogOHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDhweDtcXG59XFxuXFxuLnB4LTMge1xcbiAgcGFkZGluZy1sZWZ0OiA4cHg7XFxuICBwYWRkaW5nLXJpZ2h0OiA4cHg7XFxufVxcblxcbi5weS00IHtcXG4gIHBhZGRpbmctdG9wOiAxNnB4O1xcbiAgcGFkZGluZy1ib3R0b206IDE2cHg7XFxufVxcblxcbi5weC00IHtcXG4gIHBhZGRpbmctbGVmdDogMTZweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDE2cHg7XFxufVxcblxcbi5weS01IHtcXG4gIHBhZGRpbmctdG9wOiAyNHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDI0cHg7XFxufVxcblxcbi5weC01IHtcXG4gIHBhZGRpbmctbGVmdDogMjRweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDI0cHg7XFxufVxcblxcbi5weS02IHtcXG4gIHBhZGRpbmctdG9wOiAzMnB4O1xcbiAgcGFkZGluZy1ib3R0b206IDMycHg7XFxufVxcblxcbi5weC02IHtcXG4gIHBhZGRpbmctbGVmdDogMzJweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDMycHg7XFxufVxcblxcbi5weS03IHtcXG4gIHBhZGRpbmctdG9wOiAzNnB4O1xcbiAgcGFkZGluZy1ib3R0b206IDM2cHg7XFxufVxcblxcbi5weC03IHtcXG4gIHBhZGRpbmctbGVmdDogMzZweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDM2cHg7XFxufVxcblxcbi5weS04IHtcXG4gIHBhZGRpbmctdG9wOiA0OHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDQ4cHg7XFxufVxcblxcbi5weC04IHtcXG4gIHBhZGRpbmctbGVmdDogNDhweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDQ4cHg7XFxufVxcblxcbi5weS05IHtcXG4gIHBhZGRpbmctdG9wOiA2NHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDY0cHg7XFxufVxcblxcbi5weC05IHtcXG4gIHBhZGRpbmctbGVmdDogNjRweDtcXG4gIHBhZGRpbmctcmlnaHQ6IDY0cHg7XFxufVxcblxcbi5weS0xMCB7XFxuICBwYWRkaW5nLXRvcDogOTZweDtcXG4gIHBhZGRpbmctYm90dG9tOiA5NnB4O1xcbn1cXG5cXG4ucHgtMTAge1xcbiAgcGFkZGluZy1sZWZ0OiA5NnB4O1xcbiAgcGFkZGluZy1yaWdodDogOTZweDtcXG59XFxuXFxuLnB5LWF1dG8ge1xcbiAgcGFkZGluZy10b3A6IGF1dG87XFxuICBwYWRkaW5nLWJvdHRvbTogYXV0bztcXG59XFxuXFxuLnB4LWF1dG8ge1xcbiAgcGFkZGluZy1sZWZ0OiBhdXRvO1xcbiAgcGFkZGluZy1yaWdodDogYXV0bztcXG59XFxuXFxuLnB5LWZ1bGwge1xcbiAgcGFkZGluZy10b3A6IDEwMCU7XFxuICBwYWRkaW5nLWJvdHRvbTogMTAwJTtcXG59XFxuXFxuLnB4LWZ1bGwge1xcbiAgcGFkZGluZy1sZWZ0OiAxMDAlO1xcbiAgcGFkZGluZy1yaWdodDogMTAwJTtcXG59XFxuXFxuLnB5LXB4IHtcXG4gIHBhZGRpbmctdG9wOiAxcHg7XFxuICBwYWRkaW5nLWJvdHRvbTogMXB4O1xcbn1cXG5cXG4ucHgtcHgge1xcbiAgcGFkZGluZy1sZWZ0OiAxcHg7XFxuICBwYWRkaW5nLXJpZ2h0OiAxcHg7XFxufVxcblxcbi5weS0xXFxcXC82IHtcXG4gIHBhZGRpbmctdG9wOiAxNi42NjY2NjY2NjclO1xcbiAgcGFkZGluZy1ib3R0b206IDE2LjY2NjY2NjY2NyU7XFxufVxcblxcbi5weC0xXFxcXC82IHtcXG4gIHBhZGRpbmctbGVmdDogMTYuNjY2NjY2NjY3JTtcXG4gIHBhZGRpbmctcmlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxufVxcblxcbi5wdC0wIHtcXG4gIHBhZGRpbmctdG9wOiAwO1xcbn1cXG5cXG4ucHItMCB7XFxuICBwYWRkaW5nLXJpZ2h0OiAwO1xcbn1cXG5cXG4ucGItMCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMDtcXG59XFxuXFxuLnBsLTAge1xcbiAgcGFkZGluZy1sZWZ0OiAwO1xcbn1cXG5cXG4ucHQtMSB7XFxuICBwYWRkaW5nLXRvcDogMnB4O1xcbn1cXG5cXG4ucHItMSB7XFxuICBwYWRkaW5nLXJpZ2h0OiAycHg7XFxufVxcblxcbi5wYi0xIHtcXG4gIHBhZGRpbmctYm90dG9tOiAycHg7XFxufVxcblxcbi5wbC0xIHtcXG4gIHBhZGRpbmctbGVmdDogMnB4O1xcbn1cXG5cXG4ucHQtMiB7XFxuICBwYWRkaW5nLXRvcDogNHB4O1xcbn1cXG5cXG4ucHItMiB7XFxuICBwYWRkaW5nLXJpZ2h0OiA0cHg7XFxufVxcblxcbi5wYi0yIHtcXG4gIHBhZGRpbmctYm90dG9tOiA0cHg7XFxufVxcblxcbi5wbC0yIHtcXG4gIHBhZGRpbmctbGVmdDogNHB4O1xcbn1cXG5cXG4ucHQtMyB7XFxuICBwYWRkaW5nLXRvcDogOHB4O1xcbn1cXG5cXG4ucHItMyB7XFxuICBwYWRkaW5nLXJpZ2h0OiA4cHg7XFxufVxcblxcbi5wYi0zIHtcXG4gIHBhZGRpbmctYm90dG9tOiA4cHg7XFxufVxcblxcbi5wbC0zIHtcXG4gIHBhZGRpbmctbGVmdDogOHB4O1xcbn1cXG5cXG4ucHQtNCB7XFxuICBwYWRkaW5nLXRvcDogMTZweDtcXG59XFxuXFxuLnByLTQge1xcbiAgcGFkZGluZy1yaWdodDogMTZweDtcXG59XFxuXFxuLnBiLTQge1xcbiAgcGFkZGluZy1ib3R0b206IDE2cHg7XFxufVxcblxcbi5wbC00IHtcXG4gIHBhZGRpbmctbGVmdDogMTZweDtcXG59XFxuXFxuLnB0LTUge1xcbiAgcGFkZGluZy10b3A6IDI0cHg7XFxufVxcblxcbi5wci01IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDI0cHg7XFxufVxcblxcbi5wYi01IHtcXG4gIHBhZGRpbmctYm90dG9tOiAyNHB4O1xcbn1cXG5cXG4ucGwtNSB7XFxuICBwYWRkaW5nLWxlZnQ6IDI0cHg7XFxufVxcblxcbi5wdC02IHtcXG4gIHBhZGRpbmctdG9wOiAzMnB4O1xcbn1cXG5cXG4ucHItNiB7XFxuICBwYWRkaW5nLXJpZ2h0OiAzMnB4O1xcbn1cXG5cXG4ucGItNiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMzJweDtcXG59XFxuXFxuLnBsLTYge1xcbiAgcGFkZGluZy1sZWZ0OiAzMnB4O1xcbn1cXG5cXG4ucHQtNyB7XFxuICBwYWRkaW5nLXRvcDogMzZweDtcXG59XFxuXFxuLnByLTcge1xcbiAgcGFkZGluZy1yaWdodDogMzZweDtcXG59XFxuXFxuLnBiLTcge1xcbiAgcGFkZGluZy1ib3R0b206IDM2cHg7XFxufVxcblxcbi5wbC03IHtcXG4gIHBhZGRpbmctbGVmdDogMzZweDtcXG59XFxuXFxuLnB0LTgge1xcbiAgcGFkZGluZy10b3A6IDQ4cHg7XFxufVxcblxcbi5wci04IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDQ4cHg7XFxufVxcblxcbi5wYi04IHtcXG4gIHBhZGRpbmctYm90dG9tOiA0OHB4O1xcbn1cXG5cXG4ucGwtOCB7XFxuICBwYWRkaW5nLWxlZnQ6IDQ4cHg7XFxufVxcblxcbi5wdC05IHtcXG4gIHBhZGRpbmctdG9wOiA2NHB4O1xcbn1cXG5cXG4ucHItOSB7XFxuICBwYWRkaW5nLXJpZ2h0OiA2NHB4O1xcbn1cXG5cXG4ucGItOSB7XFxuICBwYWRkaW5nLWJvdHRvbTogNjRweDtcXG59XFxuXFxuLnBsLTkge1xcbiAgcGFkZGluZy1sZWZ0OiA2NHB4O1xcbn1cXG5cXG4ucHQtMTAge1xcbiAgcGFkZGluZy10b3A6IDk2cHg7XFxufVxcblxcbi5wci0xMCB7XFxuICBwYWRkaW5nLXJpZ2h0OiA5NnB4O1xcbn1cXG5cXG4ucGItMTAge1xcbiAgcGFkZGluZy1ib3R0b206IDk2cHg7XFxufVxcblxcbi5wbC0xMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDk2cHg7XFxufVxcblxcbi5wdC1hdXRvIHtcXG4gIHBhZGRpbmctdG9wOiBhdXRvO1xcbn1cXG5cXG4ucHItYXV0byB7XFxuICBwYWRkaW5nLXJpZ2h0OiBhdXRvO1xcbn1cXG5cXG4ucGItYXV0byB7XFxuICBwYWRkaW5nLWJvdHRvbTogYXV0bztcXG59XFxuXFxuLnBsLWF1dG8ge1xcbiAgcGFkZGluZy1sZWZ0OiBhdXRvO1xcbn1cXG5cXG4ucHQtZnVsbCB7XFxuICBwYWRkaW5nLXRvcDogMTAwJTtcXG59XFxuXFxuLnByLWZ1bGwge1xcbiAgcGFkZGluZy1yaWdodDogMTAwJTtcXG59XFxuXFxuLnBiLWZ1bGwge1xcbiAgcGFkZGluZy1ib3R0b206IDEwMCU7XFxufVxcblxcbi5wbC1mdWxsIHtcXG4gIHBhZGRpbmctbGVmdDogMTAwJTtcXG59XFxuXFxuLnB0LXB4IHtcXG4gIHBhZGRpbmctdG9wOiAxcHg7XFxufVxcblxcbi5wci1weCB7XFxuICBwYWRkaW5nLXJpZ2h0OiAxcHg7XFxufVxcblxcbi5wYi1weCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMXB4O1xcbn1cXG5cXG4ucGwtcHgge1xcbiAgcGFkZGluZy1sZWZ0OiAxcHg7XFxufVxcblxcbi5wdC0xXFxcXC82IHtcXG4gIHBhZGRpbmctdG9wOiAxNi42NjY2NjY2NjclO1xcbn1cXG5cXG4ucHItMVxcXFwvNiB7XFxuICBwYWRkaW5nLXJpZ2h0OiAxNi42NjY2NjY2NjclO1xcbn1cXG5cXG4ucGItMVxcXFwvNiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMTYuNjY2NjY2NjY3JTtcXG59XFxuXFxuLnBsLTFcXFxcLzYge1xcbiAgcGFkZGluZy1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbn1cXG5cXG4ucG9pbnRlci1ldmVudHMtbm9uZSB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLnBvaW50ZXItZXZlbnRzLWF1dG8ge1xcbiAgcG9pbnRlci1ldmVudHM6IGF1dG87XFxufVxcblxcbi5zdGF0aWMge1xcbiAgcG9zaXRpb246IHN0YXRpYztcXG59XFxuXFxuLmZpeGVkIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG59XFxuXFxuLmFic29sdXRlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLnJlbGF0aXZlIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLnN0aWNreSB7XFxuICBwb3NpdGlvbjogc3RpY2t5O1xcbn1cXG5cXG4ucGluLW5vbmUge1xcbiAgdG9wOiBhdXRvO1xcbiAgcmlnaHQ6IGF1dG87XFxuICBib3R0b206IGF1dG87XFxuICBsZWZ0OiBhdXRvO1xcbn1cXG5cXG4ucGluIHtcXG4gIHRvcDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG59XFxuXFxuLnBpbi15IHtcXG4gIHRvcDogMDtcXG4gIGJvdHRvbTogMDtcXG59XFxuXFxuLnBpbi14IHtcXG4gIHJpZ2h0OiAwO1xcbiAgbGVmdDogMDtcXG59XFxuXFxuLnBpbi10IHtcXG4gIHRvcDogMDtcXG59XFxuXFxuLnBpbi1yIHtcXG4gIHJpZ2h0OiAwO1xcbn1cXG5cXG4ucGluLWIge1xcbiAgYm90dG9tOiAwO1xcbn1cXG5cXG4ucGluLWwge1xcbiAgbGVmdDogMDtcXG59XFxuXFxuLnJlc2l6ZS1ub25lIHtcXG4gIHJlc2l6ZTogbm9uZTtcXG59XFxuXFxuLnJlc2l6ZS15IHtcXG4gIHJlc2l6ZTogdmVydGljYWw7XFxufVxcblxcbi5yZXNpemUteCB7XFxuICByZXNpemU6IGhvcml6b250YWw7XFxufVxcblxcbi5yZXNpemUge1xcbiAgcmVzaXplOiBib3RoO1xcbn1cXG5cXG4uc2hhZG93IHtcXG4gIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwIHJnYmEoMCwgMCwgMCwgLjEpO1xcbn1cXG5cXG4uc2hhZG93LW1kIHtcXG4gIGJveC1zaGFkb3c6ICAwIDhweCAyMHB4IDAgcmdiYSgwLCAwLCAwLCAuNDIpO1xcbn1cXG5cXG4uc2hhZG93LW5vbmUge1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG59XFxuXFxuLmZpbGwtY3VycmVudCB7XFxuICBmaWxsOiBjdXJyZW50Q29sb3I7XFxufVxcblxcbi5zdHJva2UtY3VycmVudCB7XFxuICBzdHJva2U6IGN1cnJlbnRDb2xvcjtcXG59XFxuXFxuLnRhYmxlLWF1dG8ge1xcbiAgdGFibGUtbGF5b3V0OiBhdXRvO1xcbn1cXG5cXG4udGFibGUtZml4ZWQge1xcbiAgdGFibGUtbGF5b3V0OiBmaXhlZDtcXG59XFxuXFxuLnRleHQtbGVmdCB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbn1cXG5cXG4udGV4dC1jZW50ZXIge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4udGV4dC1yaWdodCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuXFxuLnRleHQtanVzdGlmeSB7XFxuICB0ZXh0LWFsaWduOiBqdXN0aWZ5O1xcbn1cXG5cXG4udGV4dC1pbmhlcml0IHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4udGV4dC10cmFuc3BhcmVudCB7XFxuICBjb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcblxcbi50ZXh0LWJsYWNrIHtcXG4gIGNvbG9yOiAjMjgyODI4O1xcbn1cXG5cXG4udGV4dC13aGl0ZSB7XFxuICBjb2xvcjogI2ZmZjtcXG59XFxuXFxuLnRleHQtZ3JleS1saWdodGVyIHtcXG4gIGNvbG9yOiAjZjNmM2Y3O1xcbn1cXG5cXG4udGV4dC1ncmV5LWxpZ2h0IHtcXG4gIGNvbG9yOiAjZTdlN2VjO1xcbn1cXG5cXG4udGV4dC1ncmV5IHtcXG4gIGNvbG9yOiAjYzJjMmM2O1xcbn1cXG5cXG4udGV4dC1wdXJwbGUtbGlnaHRlciB7XFxuICBjb2xvcjogI2NjYzJlOTtcXG59XFxuXFxuLnRleHQtcHVycGxlLWxpZ2h0IHtcXG4gIGNvbG9yOiAjODc4MDliO1xcbn1cXG5cXG4udGV4dC1wdXJwbGUge1xcbiAgY29sb3I6ICM4MzYwZDY7XFxufVxcblxcbi50ZXh0LXB1cnBsZS1icmlnaHQge1xcbiAgY29sb3I6ICM0YzI5YjA7XFxufVxcblxcbi50ZXh0LXB1cnBsZS1kYXJrIHtcXG4gIGNvbG9yOiAjNDUzZjU2O1xcbn1cXG5cXG4udGV4dC1wdXJwbGUtZGFyay0xMCB7XFxuICBjb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxufVxcblxcbi50ZXh0LXB1cnBsZS1kYXJrZXIge1xcbiAgY29sb3I6ICMyYTI1Mzg7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC1pbmhlcml0OmhvdmVyIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4uaG92ZXJcXFxcOnRleHQtdHJhbnNwYXJlbnQ6aG92ZXIge1xcbiAgY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4uaG92ZXJcXFxcOnRleHQtYmxhY2s6aG92ZXIge1xcbiAgY29sb3I6ICMyODI4Mjg7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC13aGl0ZTpob3ZlciB7XFxuICBjb2xvcjogI2ZmZjtcXG59XFxuXFxuLmhvdmVyXFxcXDp0ZXh0LWdyZXktbGlnaHRlcjpob3ZlciB7XFxuICBjb2xvcjogI2YzZjNmNztcXG59XFxuXFxuLmhvdmVyXFxcXDp0ZXh0LWdyZXktbGlnaHQ6aG92ZXIge1xcbiAgY29sb3I6ICNlN2U3ZWM7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC1ncmV5OmhvdmVyIHtcXG4gIGNvbG9yOiAjYzJjMmM2O1xcbn1cXG5cXG4uaG92ZXJcXFxcOnRleHQtcHVycGxlLWxpZ2h0ZXI6aG92ZXIge1xcbiAgY29sb3I6ICNjY2MyZTk7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC1wdXJwbGUtbGlnaHQ6aG92ZXIge1xcbiAgY29sb3I6ICM4NzgwOWI7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC1wdXJwbGU6aG92ZXIge1xcbiAgY29sb3I6ICM4MzYwZDY7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC1wdXJwbGUtYnJpZ2h0OmhvdmVyIHtcXG4gIGNvbG9yOiAjNGMyOWIwO1xcbn1cXG5cXG4uaG92ZXJcXFxcOnRleHQtcHVycGxlLWRhcms6aG92ZXIge1xcbiAgY29sb3I6ICM0NTNmNTY7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICBjb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC1wdXJwbGUtZGFya2VyOmhvdmVyIHtcXG4gIGNvbG9yOiAjMmEyNTM4O1xcbn1cXG5cXG4udGV4dC1zbSB7XFxuICBmb250LXNpemU6IDEuNHJlbTtcXG59XFxuXFxuLnRleHQtYmFzZSB7XFxuICBmb250LXNpemU6IDEuNnJlbTtcXG59XFxuXFxuLml0YWxpYyB7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcbi5yb21hbiB7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxufVxcblxcbi51cHBlcmNhc2Uge1xcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG59XFxuXFxuLmxvd2VyY2FzZSB7XFxuICB0ZXh0LXRyYW5zZm9ybTogbG93ZXJjYXNlO1xcbn1cXG5cXG4uY2FwaXRhbGl6ZSB7XFxuICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTtcXG59XFxuXFxuLm5vcm1hbC1jYXNlIHtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbn1cXG5cXG4udW5kZXJsaW5lIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4ubGluZS10aHJvdWdoIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xcbn1cXG5cXG4ubm8tdW5kZXJsaW5lIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuXFxuLmFudGlhbGlhc2VkIHtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG59XFxuXFxuLnN1YnBpeGVsLWFudGlhbGlhc2VkIHtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGF1dG87XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogYXV0bztcXG59XFxuXFxuLmhvdmVyXFxcXDppdGFsaWM6aG92ZXIge1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbn1cXG5cXG4uaG92ZXJcXFxcOnJvbWFuOmhvdmVyIHtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG59XFxuXFxuLmhvdmVyXFxcXDp1cHBlcmNhc2U6aG92ZXIge1xcbiAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG59XFxuXFxuLmhvdmVyXFxcXDpsb3dlcmNhc2U6aG92ZXIge1xcbiAgdGV4dC10cmFuc2Zvcm06IGxvd2VyY2FzZTtcXG59XFxuXFxuLmhvdmVyXFxcXDpjYXBpdGFsaXplOmhvdmVyIHtcXG4gIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xcbn1cXG5cXG4uaG92ZXJcXFxcOm5vcm1hbC1jYXNlOmhvdmVyIHtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbn1cXG5cXG4uaG92ZXJcXFxcOnVuZGVybGluZTpob3ZlciB7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuXFxuLmhvdmVyXFxcXDpsaW5lLXRocm91Z2g6aG92ZXIge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XFxufVxcblxcbi5ob3ZlclxcXFw6bm8tdW5kZXJsaW5lOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuXFxuLmhvdmVyXFxcXDphbnRpYWxpYXNlZDpob3ZlciB7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxufVxcblxcbi5ob3ZlclxcXFw6c3VicGl4ZWwtYW50aWFsaWFzZWQ6aG92ZXIge1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYXV0bztcXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBhdXRvO1xcbn1cXG5cXG4udHJhY2tpbmctdGlnaHQge1xcbiAgbGV0dGVyLXNwYWNpbmc6IC0wLjA1ZW07XFxufVxcblxcbi50cmFja2luZy1ub3JtYWwge1xcbiAgbGV0dGVyLXNwYWNpbmc6IDA7XFxufVxcblxcbi50cmFja2luZy13aWRlIHtcXG4gIGxldHRlci1zcGFjaW5nOiAuMDVlbTtcXG59XFxuXFxuLnNlbGVjdC1ub25lIHtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbn1cXG5cXG4uc2VsZWN0LXRleHQge1xcbiAgdXNlci1zZWxlY3Q6IHRleHQ7XFxufVxcblxcbi5hbGlnbi1iYXNlbGluZSB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcblxcbi5hbGlnbi10b3Age1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcXG59XFxuXFxuLmFsaWduLW1pZGRsZSB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG5cXG4uYWxpZ24tYm90dG9tIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBib3R0b207XFxufVxcblxcbi5hbGlnbi10ZXh0LXRvcCB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdGV4dC10b3A7XFxufVxcblxcbi5hbGlnbi10ZXh0LWJvdHRvbSB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdGV4dC1ib3R0b207XFxufVxcblxcbi52aXNpYmxlIHtcXG4gIHZpc2liaWxpdHk6IHZpc2libGU7XFxufVxcblxcbi5pbnZpc2libGUge1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbn1cXG5cXG4ud2hpdGVzcGFjZS1ub3JtYWwge1xcbiAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG59XFxuXFxuLndoaXRlc3BhY2Utbm8td3JhcCB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG4ud2hpdGVzcGFjZS1wcmUge1xcbiAgd2hpdGUtc3BhY2U6IHByZTtcXG59XFxuXFxuLndoaXRlc3BhY2UtcHJlLWxpbmUge1xcbiAgd2hpdGUtc3BhY2U6IHByZS1saW5lO1xcbn1cXG5cXG4ud2hpdGVzcGFjZS1wcmUtd3JhcCB7XFxuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxufVxcblxcbi5icmVhay13b3JkcyB7XFxuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxufVxcblxcbi5icmVhay1ub3JtYWwge1xcbiAgd29yZC13cmFwOiBub3JtYWw7XFxufVxcblxcbi50cnVuY2F0ZSB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG5cXG4udy0wIHtcXG4gIHdpZHRoOiAwO1xcbn1cXG5cXG4udy0xIHtcXG4gIHdpZHRoOiAycHg7XFxufVxcblxcbi53LTIge1xcbiAgd2lkdGg6IDRweDtcXG59XFxuXFxuLnctMyB7XFxuICB3aWR0aDogOHB4O1xcbn1cXG5cXG4udy00IHtcXG4gIHdpZHRoOiAxNnB4O1xcbn1cXG5cXG4udy01IHtcXG4gIHdpZHRoOiAyNHB4O1xcbn1cXG5cXG4udy02IHtcXG4gIHdpZHRoOiAzMnB4O1xcbn1cXG5cXG4udy03IHtcXG4gIHdpZHRoOiAzNnB4O1xcbn1cXG5cXG4udy04IHtcXG4gIHdpZHRoOiA0OHB4O1xcbn1cXG5cXG4udy05IHtcXG4gIHdpZHRoOiA2NHB4O1xcbn1cXG5cXG4udy0xMCB7XFxuICB3aWR0aDogOTZweDtcXG59XFxuXFxuLnctc2NyZWVuIHtcXG4gIHdpZHRoOiAxMDB2dztcXG59XFxuXFxuLnctYXV0byB7XFxuICB3aWR0aDogYXV0bztcXG59XFxuXFxuLnctZnVsbCB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLnctcHgge1xcbiAgd2lkdGg6IDFweDtcXG59XFxuXFxuLnctMVxcXFwvNiB7XFxuICB3aWR0aDogMTYuNjY2NjY2NjY3JTtcXG59XFxuXFxuLnotMCB7XFxuICB6LWluZGV4OiAwO1xcbn1cXG5cXG4uei0xMCB7XFxuICB6LWluZGV4OiAxMDtcXG59XFxuXFxuLnotMjAge1xcbiAgei1pbmRleDogMjA7XFxufVxcblxcbi56LTMwIHtcXG4gIHotaW5kZXg6IDMwO1xcbn1cXG5cXG4uei00MCB7XFxuICB6LWluZGV4OiA0MDtcXG59XFxuXFxuLnotNTAge1xcbiAgei1pbmRleDogNTA7XFxufVxcblxcbi56LWF1dG8ge1xcbiAgei1pbmRleDogYXV0bztcXG59XFxuXFxuLmJnLWJsYWNrLTEwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDAsIDQwLCA0MCwgLjEpO1xcbn1cXG5cXG4uYmctd2hpdGUtMTAge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMSk7XFxufVxcblxcbi5iZy1ncmV5LWxpZ2h0ZXItMTAge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMSk7XFxufVxcblxcbi5iZy1ncmV5LWxpZ2h0LTEwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjMxLCAyMzEsIDIzNiwgLjEpO1xcbn1cXG5cXG4uYmctZ3JleS0xMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4xKTtcXG59XFxuXFxuLmJnLXB1cnBsZS1saWdodGVyLTEwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjEpO1xcbn1cXG5cXG4uYmctcHVycGxlLWxpZ2h0LTEwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTM1LCAxMjgsIDE1NSwgLjEpO1xcbn1cXG5cXG4uYmctcHVycGxlLTEwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMSk7XFxufVxcblxcbi5iZy1wdXJwbGUtYnJpZ2h0LTEwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4xKTtcXG59XFxuXFxuLmJnLXB1cnBsZS1kYXJrLTEwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbn1cXG5cXG4uYmctcHVycGxlLWRhcmtlci0xMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4xKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1ibGFjay0xMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4xKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy13aGl0ZS0xMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4xKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMTA6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctZ3JleS1saWdodC0xMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4xKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1ncmV5LTEwOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjEpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodGVyLTEwOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjEpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodC0xMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4xKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1wdXJwbGUtMTA6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4xKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTEwOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4xKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFya2VyLTEwOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjEpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLWJsYWNrLTEwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDAsIDQwLCA0MCwgLjEpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXdoaXRlLTEwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjEpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLWdyZXktbGlnaHRlci0xMDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4xKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0LTEwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjMxLCAyMzEsIDIzNiwgLjEpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLWdyZXktMTA6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMSk7XFxufVxcblxcbi5mb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0ZXItMTA6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMSk7XFxufVxcblxcbi5mb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0LTEwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTM1LCAxMjgsIDE1NSwgLjEpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS0xMDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjEpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS1icmlnaHQtMTA6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjEpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrLTEwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrZXItMTA6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMSk7XFxufVxcblxcbi5iZy1ibGFjay0zMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4zKTtcXG59XFxuXFxuLmJnLXdoaXRlLTMwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjMpO1xcbn1cXG5cXG4uYmctZ3JleS1saWdodGVyLTMwIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQzLCAyNDMsIDI0NywgLjMpO1xcbn1cXG5cXG4uYmctZ3JleS1saWdodC0zMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4zKTtcXG59XFxuXFxuLmJnLWdyZXktMzAge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMyk7XFxufVxcblxcbi5iZy1wdXJwbGUtbGlnaHRlci0zMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwNCwgMTk0LCAyMzMsIC4zKTtcXG59XFxuXFxuLmJnLXB1cnBsZS1saWdodC0zMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4zKTtcXG59XFxuXFxuLmJnLXB1cnBsZS0zMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjMpO1xcbn1cXG5cXG4uYmctcHVycGxlLWJyaWdodC0zMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDc2LCA0MSwgMTc2LCAuMyk7XFxufVxcblxcbi5iZy1wdXJwbGUtZGFyay0zMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4zKTtcXG59XFxuXFxuLmJnLXB1cnBsZS1kYXJrZXItMzAge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMyk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctYmxhY2stMzA6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MCwgNDAsIDQwLCAuMyk7XFxufVxcblxcbi5ob3ZlclxcXFw6Ymctd2hpdGUtMzA6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMyk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctZ3JleS1saWdodGVyLTMwOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQzLCAyNDMsIDI0NywgLjMpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLWdyZXktbGlnaHQtMzA6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzEsIDIzMSwgMjM2LCAuMyk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctZ3JleS0zMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4zKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0zMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwNCwgMTk0LCAyMzMsIC4zKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1wdXJwbGUtbGlnaHQtMzA6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzUsIDEyOCwgMTU1LCAuMyk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctcHVycGxlLTMwOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMyk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctcHVycGxlLWJyaWdodC0zMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDc2LCA0MSwgMTc2LCAuMyk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctcHVycGxlLWRhcmstMzA6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMyk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctcHVycGxlLWRhcmtlci0zMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4zKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1ibGFjay0zMDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4zKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy13aGl0ZS0zMDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMzA6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMyk7XFxufVxcblxcbi5mb2N1c1xcXFw6YmctZ3JleS1saWdodC0zMDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4zKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1ncmV5LTMwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjMpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS1saWdodGVyLTMwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjMpO1xcbn1cXG5cXG4uZm9jdXNcXFxcOmJnLXB1cnBsZS1saWdodC0zMDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4zKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1wdXJwbGUtMzA6Zm9jdXMge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4zKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTMwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4zKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFyay0zMDpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4zKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFya2VyLTMwOmZvY3VzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjMpO1xcbn1cXG5cXG4uYXNwZWN0LXJhdGlvLXNxdWFyZSB7XFxuICBwYWRkaW5nLXRvcDogMTAwJTtcXG59XFxuXFxuLmFzcGVjdC1yYXRpby1sb2dvIHtcXG4gIHBhZGRpbmctdG9wOiAyNC4xMSU7XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA1NzZweCkge1xcbiAgLnNtXFxcXDpsaXN0LXJlc2V0IHtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YXBwZWFyYW5jZS1ub25lIHtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctZml4ZWQge1xcbiAgICBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6IGZpeGVkO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1sb2NhbCB7XFxuICAgIGJhY2tncm91bmQtYXR0YWNobWVudDogbG9jYWw7XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLXNjcm9sbCB7XFxuICAgIGJhY2tncm91bmQtYXR0YWNobWVudDogc2Nyb2xsO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1pbmhlcml0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctdHJhbnNwYXJlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctYmxhY2sge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjgyODI4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy13aGl0ZSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLWdyZXktbGlnaHRlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLWdyZXktbGlnaHQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTdlN2VjO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1ncmV5IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2MyYzJjNjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctcHVycGxlLWxpZ2h0ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtbGlnaHQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjODc4MDliO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjODM2MGQ2O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtYnJpZ2h0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctcHVycGxlLWRhcmsge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDUzZjU2O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtZGFyay0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtZGFya2VyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLWluaGVyaXQ6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctdHJhbnNwYXJlbnQ6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLWJsYWNrOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXdoaXRlOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHRlcjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLWdyZXk6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0ZXI6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtYnJpZ2h0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrLTEwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFya2VyOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLWluaGVyaXQ6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb2N1c1xcXFw6YmctdHJhbnNwYXJlbnQ6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLWJsYWNrOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLXdoaXRlOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLWdyZXktbGlnaHRlcjpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLWdyZXk6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0ZXI6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZTpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtYnJpZ2h0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFya2VyOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctYm90dG9tIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1jZW50ZXIge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLWxlZnQge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBsZWZ0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1sZWZ0LWJvdHRvbSB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgYm90dG9tO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1sZWZ0LXRvcCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgdG9wO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1yaWdodCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1yaWdodC1ib3R0b20ge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiByaWdodCBib3R0b207XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLXJpZ2h0LXRvcCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0IHRvcDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctdG9wIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogdG9wO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1yZXBlYXQge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1uby1yZXBlYXQge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1yZXBlYXQteCB7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctcmVwZWF0LXkge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXk7XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLWF1dG8ge1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLWNvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctY29udGFpbiB7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLWluaGVyaXQge1xcbiAgICBib3JkZXItY29sb3I6IGluaGVyaXQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci10cmFuc3BhcmVudCB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1ibGFjayB7XFxuICAgIGJvcmRlci1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLXdoaXRlIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItZ3JleS1saWdodGVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZjNmM2Y3O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItZ3JleS1saWdodCB7XFxuICAgIGJvcmRlci1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLWdyZXkge1xcbiAgICBib3JkZXItY29sb3I6ICNjMmMyYzY7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1wdXJwbGUtbGlnaHRlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2NjYzJlOTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLXB1cnBsZS1saWdodCB7XFxuICAgIGJvcmRlci1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLXB1cnBsZSB7XFxuICAgIGJvcmRlci1jb2xvcjogIzgzNjBkNjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLXB1cnBsZS1icmlnaHQge1xcbiAgICBib3JkZXItY29sb3I6ICM0YzI5YjA7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1wdXJwbGUtZGFyayB7XFxuICAgIGJvcmRlci1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrLTEwIHtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrZXIge1xcbiAgICBib3JkZXItY29sb3I6ICMyYTI1Mzg7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpib3JkZXItaW5oZXJpdDpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJvcmRlci10cmFuc3BhcmVudDpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpib3JkZXItYmxhY2s6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICMyODI4Mjg7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpib3JkZXItd2hpdGU6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpib3JkZXItZ3JleS1saWdodGVyOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZjNmM2Y3O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6Ym9yZGVyLWdyZXktbGlnaHQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNlN2U3ZWM7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpib3JkZXItZ3JleTpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2MyYzJjNjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHRlcjpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2NjYzJlOTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM4NzgwOWI7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjODM2MGQ2O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXB1cnBsZS1icmlnaHQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM0YzI5YjA7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWRhcms6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM0NTNmNTY7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWRhcmstMTA6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrZXI6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICMyYTI1Mzg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtbm9uZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtc20ge1xcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQge1xcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtZnVsbCB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cm91bmRlZC10LW5vbmUge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cm91bmRlZC1yLW5vbmUge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtYi1ub25lIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtbC1ub25lIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cm91bmRlZC10LXNtIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLXItc20ge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLWItc20ge1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtbC1zbSB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLXQge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA0cHg7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtciB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtYiB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cm91bmRlZC1sIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtdC1mdWxsIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLXItZnVsbCB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtYi1mdWxsIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDk5OTlweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLWwtZnVsbCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLXRsLW5vbmUge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLXRyLW5vbmUge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cm91bmRlZC1ici1ub25lIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtYmwtbm9uZSB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtdGwtc20ge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtdHItc20ge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLWJyLXNtIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cm91bmRlZC1ibC1zbSB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cm91bmRlZC10bCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cm91bmRlZC10ciB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtYnIge1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLWJsIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyb3VuZGVkLXRsLWZ1bGwge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtdHItZnVsbCB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtYnItZnVsbCB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvdW5kZWQtYmwtZnVsbCB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLXNvbGlkIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLWRhc2hlZCB7XFxuICAgIGJvcmRlci1zdHlsZTogZGFzaGVkO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItZG90dGVkIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBkb3R0ZWQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1ub25lIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItMCB7XFxuICAgIGJvcmRlci13aWR0aDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLTIge1xcbiAgICBib3JkZXItd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLTQge1xcbiAgICBib3JkZXItd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLTgge1xcbiAgICBib3JkZXItd2lkdGg6IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyIHtcXG4gICAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci10LTAge1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItci0wIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItYi0wIHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLWwtMCB7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItdC0yIHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItci0yIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1iLTIge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1sLTIge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItdC00IHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItci00IHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1iLTQge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1sLTQge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItdC04IHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItci04IHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1iLTgge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1sLTgge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpib3JkZXItdCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLXIge1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ym9yZGVyLWIge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmJvcmRlci1sIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Y3Vyc29yLWF1dG8ge1xcbiAgICBjdXJzb3I6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOmN1cnNvci1kZWZhdWx0IHtcXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpjdXJzb3ItcG9pbnRlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Y3Vyc29yLXdhaXQge1xcbiAgICBjdXJzb3I6IHdhaXQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmN1cnNvci1tb3ZlIHtcXG4gICAgY3Vyc29yOiBtb3ZlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpjdXJzb3Itbm90LWFsbG93ZWQge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpibG9jayB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgfVxcblxcbiAgLnNtXFxcXDppbmxpbmUtYmxvY2sge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB9XFxuXFxuICAuc21cXFxcOmlubGluZSB7XFxuICAgIGRpc3BsYXk6IGlubGluZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dGFibGUge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dGFibGUtcm93IHtcXG4gICAgZGlzcGxheTogdGFibGUtcm93O1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0YWJsZS1jZWxsIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aGlkZGVuIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6ZmxleCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuXFxuICAuc21cXFxcOmlubGluZS1mbGV4IHtcXG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICB9XFxuXFxuICAuc21cXFxcOmZsZXgtcm93IHtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6ZmxleC1yb3ctcmV2ZXJzZSB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6ZmxleC1jb2wge1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmbGV4LWNvbC1yZXZlcnNlIHtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmbGV4LXdyYXAge1xcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICB9XFxuXFxuICAuc21cXFxcOmZsZXgtd3JhcC1yZXZlcnNlIHtcXG4gICAgZmxleC13cmFwOiB3cmFwLXJldmVyc2U7XFxuICB9XFxuXFxuICAuc21cXFxcOmZsZXgtbm8td3JhcCB7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDppdGVtcy1zdGFydCB7XFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDppdGVtcy1lbmQge1xcbiAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxuICB9XFxuXFxuICAuc21cXFxcOml0ZW1zLWNlbnRlciB7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB9XFxuXFxuICAuc21cXFxcOml0ZW1zLWJhc2VsaW5lIHtcXG4gICAgYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xcbiAgfVxcblxcbiAgLnNtXFxcXDppdGVtcy1zdHJldGNoIHtcXG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICB9XFxuXFxuICAuc21cXFxcOnNlbGYtYXV0byB7XFxuICAgIGFsaWduLXNlbGY6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOnNlbGYtc3RhcnQge1xcbiAgICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpzZWxmLWVuZCB7XFxuICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpzZWxmLWNlbnRlciB7XFxuICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6c2VsZi1zdHJldGNoIHtcXG4gICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6anVzdGlmeS1zdGFydCB7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6anVzdGlmeS1lbmQge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpqdXN0aWZ5LWNlbnRlciB7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpqdXN0aWZ5LWJldHdlZW4ge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB9XFxuXFxuICAuc21cXFxcOmp1c3RpZnktYXJvdW5kIHtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmNvbnRlbnQtY2VudGVyIHtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpjb250ZW50LXN0YXJ0IHtcXG4gICAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Y29udGVudC1lbmQge1xcbiAgICBhbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Y29udGVudC1iZXR3ZWVuIHtcXG4gICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Y29udGVudC1hcm91bmQge1xcbiAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmZsZXgtMSB7XFxuICAgIGZsZXg6IDE7XFxuICB9XFxuXFxuICAuc21cXFxcOmZsZXgtYXV0byB7XFxuICAgIGZsZXg6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOmZsZXgtaW5pdGlhbCB7XFxuICAgIGZsZXg6IGluaXRpYWw7XFxuICB9XFxuXFxuICAuc21cXFxcOmZsZXgtbm9uZSB7XFxuICAgIGZsZXg6IG5vbmU7XFxuICB9XFxuXFxuICAuc21cXFxcOmZsZXgtZ3JvdyB7XFxuICAgIGZsZXgtZ3JvdzogMTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6ZmxleC1zaHJpbmsge1xcbiAgICBmbGV4LXNocmluazogMTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6ZmxleC1uby1ncm93IHtcXG4gICAgZmxleC1ncm93OiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmbGV4LW5vLXNocmluayB7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmbG9hdC1yaWdodCB7XFxuICAgIGZsb2F0OiByaWdodDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6ZmxvYXQtbGVmdCB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmbG9hdC1ub25lIHtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICB9XFxuXFxuICAuc21cXFxcOmNsZWFyZml4OmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbiAgICBjbGVhcjogYm90aDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9udC1zYW5zIHtcXG4gICAgZm9udC1mYW1pbHk6IHN5c3RlbS11aSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAtYXBwbGUtc3lzdGVtLCBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCBGaXJhIFNhbnMsIERyb2lkIFNhbnMsIEhlbHZldGljYSBOZXVlLCBzYW5zLXNlcmlmO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb250LXNlcmlmIHtcXG4gICAgZm9udC1mYW1pbHk6IENvbnN0YW50aWEsIEx1Y2lkYSBCcmlnaHQsIEx1Y2lkYWJyaWdodCwgTHVjaWRhIFNlcmlmLCBMdWNpZGEsIERlamFWdSBTZXJpZiwgQml0c3RyZWFtIFZlcmEgU2VyaWYsIExpYmVyYXRpb24gU2VyaWYsIEdlb3JnaWEsIHNlcmlmO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb250LW1vbm8ge1xcbiAgICBmb250LWZhbWlseTogTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIExpYmVyYXRpb24gTW9ubywgQ291cmllciBOZXcsIG1vbm9zcGFjZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9udC1oYWlybGluZSB7XFxuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvbnQtdGhpbiB7XFxuICAgIGZvbnQtd2VpZ2h0OiAyMDA7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvbnQtbGlnaHQge1xcbiAgICBmb250LXdlaWdodDogMzAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb250LW5vcm1hbCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvbnQtbWVkaXVtIHtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9udC1zZW1pYm9sZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvbnQtYm9sZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvbnQtZXh0cmFib2xkIHtcXG4gICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9udC1ibGFjayB7XFxuICAgIGZvbnQtd2VpZ2h0OiA5MDA7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpmb250LWhhaXJsaW5lOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmZvbnQtdGhpbjpob3ZlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiAyMDA7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpmb250LWxpZ2h0OmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmZvbnQtbm9ybWFsOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmZvbnQtbWVkaXVtOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmZvbnQtc2VtaWJvbGQ6aG92ZXIge1xcbiAgICBmb250LXdlaWdodDogNjAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6Zm9udC1ib2xkOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmZvbnQtZXh0cmFib2xkOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmZvbnQtYmxhY2s6aG92ZXIge1xcbiAgICBmb250LXdlaWdodDogOTAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpoLTAge1xcbiAgICBoZWlnaHQ6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOmgtMSB7XFxuICAgIGhlaWdodDogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpoLTIge1xcbiAgICBoZWlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aC0zIHtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmgtNCB7XFxuICAgIGhlaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aC01IHtcXG4gICAgaGVpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpoLTYge1xcbiAgICBoZWlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmgtNyB7XFxuICAgIGhlaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aC04IHtcXG4gICAgaGVpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpoLTkge1xcbiAgICBoZWlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmgtMTAge1xcbiAgICBoZWlnaHQ6IDk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOmgtc2NyZWVuIHtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aC1hdXRvIHtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpoLWZ1bGwge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOmgtcHgge1xcbiAgICBoZWlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aC0xXFxcXC82IHtcXG4gICAgaGVpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpsZWFkaW5nLW5vbmUge1xcbiAgICBsaW5lLWhlaWdodDogMTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bGVhZGluZy10aWdodCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjI1O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpsZWFkaW5nLW5vcm1hbCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICB9XFxuXFxuICAuc21cXFxcOmxlYWRpbmctbG9vc2Uge1xcbiAgICBsaW5lLWhlaWdodDogMjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bS0wIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptLTEge1xcbiAgICBtYXJnaW46IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bS0yIHtcXG4gICAgbWFyZ2luOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm0tMyB7XFxuICAgIG1hcmdpbjogOHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptLTQge1xcbiAgICBtYXJnaW46IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm0tNSB7XFxuICAgIG1hcmdpbjogMjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bS02IHtcXG4gICAgbWFyZ2luOiAzMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptLTcge1xcbiAgICBtYXJnaW46IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm0tOCB7XFxuICAgIG1hcmdpbjogNDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bS05IHtcXG4gICAgbWFyZ2luOiA2NHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptLTEwIHtcXG4gICAgbWFyZ2luOiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptLWF1dG8ge1xcbiAgICBtYXJnaW46IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOm0tZnVsbCB7XFxuICAgIG1hcmdpbjogMTAwJTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bS1weCB7XFxuICAgIG1hcmdpbjogMXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptLTFcXFxcLzYge1xcbiAgICBtYXJnaW46IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOm15LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteC0wIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXktMSB7XFxuICAgIG1hcmdpbi10b3A6IDJweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteC0xIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDJweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm15LTIge1xcbiAgICBtYXJnaW4tdG9wOiA0cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXgtMiB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteS0zIHtcXG4gICAgbWFyZ2luLXRvcDogOHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm14LTMge1xcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXktNCB7XFxuICAgIG1hcmdpbi10b3A6IDE2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm14LTQge1xcbiAgICBtYXJnaW4tbGVmdDogMTZweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteS01IHtcXG4gICAgbWFyZ2luLXRvcDogMjRweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXgtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAyNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm15LTYge1xcbiAgICBtYXJnaW4tdG9wOiAzMnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAzMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteC02IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDMycHg7XFxuICAgIG1hcmdpbi1yaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXktNyB7XFxuICAgIG1hcmdpbi10b3A6IDM2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm14LTcge1xcbiAgICBtYXJnaW4tbGVmdDogMzZweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAzNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteS04IHtcXG4gICAgbWFyZ2luLXRvcDogNDhweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogNDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXgtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0OHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm15LTkge1xcbiAgICBtYXJnaW4tdG9wOiA2NHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA2NHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteC05IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDY0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXktMTAge1xcbiAgICBtYXJnaW4tdG9wOiA5NnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteC0xMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA5NnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm15LWF1dG8ge1xcbiAgICBtYXJnaW4tdG9wOiBhdXRvO1xcbiAgICBtYXJnaW4tYm90dG9tOiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteC1hdXRvIHtcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXktZnVsbCB7XFxuICAgIG1hcmdpbi10b3A6IDEwMCU7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOm14LWZ1bGwge1xcbiAgICBtYXJnaW4tbGVmdDogMTAwJTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteS1weCB7XFxuICAgIG1hcmdpbi10b3A6IDFweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteC1weCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxcHg7XFxuICAgIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpteS0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXRvcDogMTYuNjY2NjY2NjY3JTtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXgtMVxcXFwvNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOm10LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptci0wIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYi0wIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWwtMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptdC0xIHtcXG4gICAgbWFyZ2luLXRvcDogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptci0xIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1iLTEge1xcbiAgICBtYXJnaW4tYm90dG9tOiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1sLTEge1xcbiAgICBtYXJnaW4tbGVmdDogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptdC0yIHtcXG4gICAgbWFyZ2luLXRvcDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptci0yIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1iLTIge1xcbiAgICBtYXJnaW4tYm90dG9tOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1sLTIge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptdC0zIHtcXG4gICAgbWFyZ2luLXRvcDogOHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptci0zIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1iLTMge1xcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1sLTMge1xcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptdC00IHtcXG4gICAgbWFyZ2luLXRvcDogMTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXItNCB7XFxuICAgIG1hcmdpbi1yaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWItNCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1sLTQge1xcbiAgICBtYXJnaW4tbGVmdDogMTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXQtNSB7XFxuICAgIG1hcmdpbi10b3A6IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1yLTUge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1iLTUge1xcbiAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptbC01IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm10LTYge1xcbiAgICBtYXJnaW4tdG9wOiAzMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptci02IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAzMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYi02IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWwtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAzMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptdC03IHtcXG4gICAgbWFyZ2luLXRvcDogMzZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXItNyB7XFxuICAgIG1hcmdpbi1yaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWItNyB7XFxuICAgIG1hcmdpbi1ib3R0b206IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1sLTcge1xcbiAgICBtYXJnaW4tbGVmdDogMzZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXQtOCB7XFxuICAgIG1hcmdpbi10b3A6IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1yLTgge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1iLTgge1xcbiAgICBtYXJnaW4tYm90dG9tOiA0OHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptbC04IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm10LTkge1xcbiAgICBtYXJnaW4tdG9wOiA2NHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptci05IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA2NHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYi05IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWwtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA2NHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptdC0xMCB7XFxuICAgIG1hcmdpbi10b3A6IDk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1yLTEwIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYi0xMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1sLTEwIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm10LWF1dG8ge1xcbiAgICBtYXJnaW4tdG9wOiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptci1hdXRvIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYi1hdXRvIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWwtYXV0byB7XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptdC1mdWxsIHtcXG4gICAgbWFyZ2luLXRvcDogMTAwJTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXItZnVsbCB7XFxuICAgIG1hcmdpbi1yaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWItZnVsbCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOm1sLWZ1bGwge1xcbiAgICBtYXJnaW4tbGVmdDogMTAwJTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bXQtcHgge1xcbiAgICBtYXJnaW4tdG9wOiAxcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1yLXB4IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1iLXB4IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptbC1weCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm10LTFcXFxcLzYge1xcbiAgICBtYXJnaW4tdG9wOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptci0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYi0xXFxcXC82IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWwtMVxcXFwvNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtaC0wIHtcXG4gICAgbWF4LWhlaWdodDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LWgtMSB7XFxuICAgIG1heC1oZWlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LWgtMiB7XFxuICAgIG1heC1oZWlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LWgtMyB7XFxuICAgIG1heC1oZWlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LWgtNCB7XFxuICAgIG1heC1oZWlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC1oLTUge1xcbiAgICBtYXgtaGVpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtaC02IHtcXG4gICAgbWF4LWhlaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LWgtNyB7XFxuICAgIG1heC1oZWlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC1oLTgge1xcbiAgICBtYXgtaGVpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtaC05IHtcXG4gICAgbWF4LWhlaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LWgtMTAge1xcbiAgICBtYXgtaGVpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtaC1zY3JlZW4ge1xcbiAgICBtYXgtaGVpZ2h0OiAxMDB2aDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LWgtYXV0byB7XFxuICAgIG1heC1oZWlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC1oLWZ1bGwge1xcbiAgICBtYXgtaGVpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtaC1weCB7XFxuICAgIG1heC1oZWlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LWgtMVxcXFwvNiB7XFxuICAgIG1heC1oZWlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC13LTAge1xcbiAgICBtYXgtd2lkdGg6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC13LTEge1xcbiAgICBtYXgtd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWF4LXctMiB7XFxuICAgIG1heC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtdy0zIHtcXG4gICAgbWF4LXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC13LTQge1xcbiAgICBtYXgtd2lkdGg6IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC13LTUge1xcbiAgICBtYXgtd2lkdGg6IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC13LTYge1xcbiAgICBtYXgtd2lkdGg6IDMycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC13LTcge1xcbiAgICBtYXgtd2lkdGg6IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC13LTgge1xcbiAgICBtYXgtd2lkdGg6IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC13LTkge1xcbiAgICBtYXgtd2lkdGg6IDY0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1heC13LTEwIHtcXG4gICAgbWF4LXdpZHRoOiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtdy1hdXRvIHtcXG4gICAgbWF4LXdpZHRoOiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtdy1mdWxsIHtcXG4gICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtdy1weCB7XFxuICAgIG1heC13aWR0aDogMXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYXgtdy0xXFxcXC82IHtcXG4gICAgbWF4LXdpZHRoOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4taC0wIHtcXG4gICAgbWluLWhlaWdodDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWluLWgtMSB7XFxuICAgIG1pbi1oZWlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWluLWgtMiB7XFxuICAgIG1pbi1oZWlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWluLWgtMyB7XFxuICAgIG1pbi1oZWlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWluLWgtNCB7XFxuICAgIG1pbi1oZWlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi1oLTUge1xcbiAgICBtaW4taGVpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4taC02IHtcXG4gICAgbWluLWhlaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWluLWgtNyB7XFxuICAgIG1pbi1oZWlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi1oLTgge1xcbiAgICBtaW4taGVpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4taC05IHtcXG4gICAgbWluLWhlaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWluLWgtMTAge1xcbiAgICBtaW4taGVpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4taC1zY3JlZW4ge1xcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWluLWgtYXV0byB7XFxuICAgIG1pbi1oZWlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi1oLWZ1bGwge1xcbiAgICBtaW4taGVpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4taC1weCB7XFxuICAgIG1pbi1oZWlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWluLWgtMVxcXFwvNiB7XFxuICAgIG1pbi1oZWlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi13LTAge1xcbiAgICBtaW4td2lkdGg6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi13LTEge1xcbiAgICBtaW4td2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bWluLXctMiB7XFxuICAgIG1pbi13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4tdy0zIHtcXG4gICAgbWluLXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi13LTQge1xcbiAgICBtaW4td2lkdGg6IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi13LTUge1xcbiAgICBtaW4td2lkdGg6IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi13LTYge1xcbiAgICBtaW4td2lkdGg6IDMycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi13LTcge1xcbiAgICBtaW4td2lkdGg6IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi13LTgge1xcbiAgICBtaW4td2lkdGg6IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi13LTkge1xcbiAgICBtaW4td2lkdGg6IDY0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOm1pbi13LTEwIHtcXG4gICAgbWluLXdpZHRoOiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4tdy1hdXRvIHtcXG4gICAgbWluLXdpZHRoOiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4tdy1mdWxsIHtcXG4gICAgbWluLXdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4tdy1weCB7XFxuICAgIG1pbi13aWR0aDogMXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDptaW4tdy0xXFxcXC82IHtcXG4gICAgbWluLXdpZHRoOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbS0wIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbS0xIHtcXG4gICAgbWFyZ2luOiAtMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbS0yIHtcXG4gICAgbWFyZ2luOiAtNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbS0zIHtcXG4gICAgbWFyZ2luOiAtOHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbS00IHtcXG4gICAgbWFyZ2luOiAtMTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW0tNSB7XFxuICAgIG1hcmdpbjogLTI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tLTYge1xcbiAgICBtYXJnaW46IC0zMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbS03IHtcXG4gICAgbWFyZ2luOiAtMzZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW0tOCB7XFxuICAgIG1hcmdpbjogLTQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tLTkge1xcbiAgICBtYXJnaW46IC02NHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbS0xMCB7XFxuICAgIG1hcmdpbjogLTk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tLWF1dG8ge1xcbiAgICBtYXJnaW46IC1hdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbS1mdWxsIHtcXG4gICAgbWFyZ2luOiAtMTAwJTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW0tcHgge1xcbiAgICBtYXJnaW46IC0xcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tLTFcXFxcLzYge1xcbiAgICBtYXJnaW46IC0xNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXktMCB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOi1teC0wIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW15LTEge1xcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXgtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0ycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1teS0yIHtcXG4gICAgbWFyZ2luLXRvcDogLTRweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW14LTIge1xcbiAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXktMyB7XFxuICAgIG1hcmdpbi10b3A6IC04cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC04cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1teC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC04cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLThweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW15LTQge1xcbiAgICBtYXJnaW4tdG9wOiAtMTZweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1teC00IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xNnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXktNSB7XFxuICAgIG1hcmdpbi10b3A6IC0yNHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW14LTUge1xcbiAgICBtYXJnaW4tbGVmdDogLTI0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1teS02IHtcXG4gICAgbWFyZ2luLXRvcDogLTMycHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXgtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzJweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW15LTcge1xcbiAgICBtYXJnaW4tdG9wOiAtMzZweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1teC03IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0zNnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0zNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXktOCB7XFxuICAgIG1hcmdpbi10b3A6IC00OHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtNDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW14LTgge1xcbiAgICBtYXJnaW4tbGVmdDogLTQ4cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1teS05IHtcXG4gICAgbWFyZ2luLXRvcDogLTY0cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC02NHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXgtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNjRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW15LTEwIHtcXG4gICAgbWFyZ2luLXRvcDogLTk2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC05NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXgtMTAge1xcbiAgICBtYXJnaW4tbGVmdDogLTk2cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1teS1hdXRvIHtcXG4gICAgbWFyZ2luLXRvcDogLWF1dG87XFxuICAgIG1hcmdpbi1ib3R0b206IC1hdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXgtYXV0byB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtYXV0bztcXG4gICAgbWFyZ2luLXJpZ2h0OiAtYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW15LWZ1bGwge1xcbiAgICBtYXJnaW4tdG9wOiAtMTAwJTtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOi1teC1mdWxsIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xMDAlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xMDAlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXktcHgge1xcbiAgICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXgtcHgge1xcbiAgICBtYXJnaW4tbGVmdDogLTFweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXktMVxcXFwvNiB7XFxuICAgIG1hcmdpbi10b3A6IC0xNi42NjY2NjY2NjclO1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW14LTFcXFxcLzYge1xcbiAgICBtYXJnaW4tbGVmdDogLTE2LjY2NjY2NjY2NyU7XFxuICAgIG1hcmdpbi1yaWdodDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tdC0wIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1yLTAge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tYi0wIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1sLTAge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW10LTEge1xcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXItMSB7XFxuICAgIG1hcmdpbi1yaWdodDogLTJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1iLTEge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWwtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbXQtMiB7XFxuICAgIG1hcmdpbi10b3A6IC00cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tci0yIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWItMiB7XFxuICAgIG1hcmdpbi1ib3R0b206IC00cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tbC0yIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tdC0zIHtcXG4gICAgbWFyZ2luLXRvcDogLThweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1yLTMge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC04cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tYi0zIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLThweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1sLTMge1xcbiAgICBtYXJnaW4tbGVmdDogLThweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW10LTQge1xcbiAgICBtYXJnaW4tdG9wOiAtMTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1yLTQge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWItNCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0xNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWwtNCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW10LTUge1xcbiAgICBtYXJnaW4tdG9wOiAtMjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1yLTUge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0yNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWItNSB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0yNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWwtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW10LTYge1xcbiAgICBtYXJnaW4tdG9wOiAtMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1yLTYge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0zMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWItNiB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWwtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW10LTcge1xcbiAgICBtYXJnaW4tdG9wOiAtMzZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1yLTcge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0zNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWItNyB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWwtNyB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW10LTgge1xcbiAgICBtYXJnaW4tdG9wOiAtNDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1yLTgge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC00OHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWItOCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC00OHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWwtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW10LTkge1xcbiAgICBtYXJnaW4tdG9wOiAtNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1yLTkge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC02NHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWItOSB7XFxuICAgIG1hcmdpbi1ib3R0b206IC02NHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWwtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW10LTEwIHtcXG4gICAgbWFyZ2luLXRvcDogLTk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tci0xMCB7XFxuICAgIG1hcmdpbi1yaWdodDogLTk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tYi0xMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC05NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDotbWwtMTAge1xcbiAgICBtYXJnaW4tbGVmdDogLTk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tdC1hdXRvIHtcXG4gICAgbWFyZ2luLXRvcDogLWF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOi1tci1hdXRvIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1iLWF1dG8ge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1sLWF1dG8ge1xcbiAgICBtYXJnaW4tbGVmdDogLWF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOi1tdC1mdWxsIHtcXG4gICAgbWFyZ2luLXRvcDogLTEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tci1mdWxsIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMTAwJTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1iLWZ1bGwge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTAwJTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1sLWZ1bGwge1xcbiAgICBtYXJnaW4tbGVmdDogLTEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tdC1weCB7XFxuICAgIG1hcmdpbi10b3A6IC0xcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tci1weCB7XFxuICAgIG1hcmdpbi1yaWdodDogLTFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1iLXB4IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1sLXB4IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tdC0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXRvcDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOi1tci0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1iLTFcXFxcLzYge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6LW1sLTFcXFxcLzYge1xcbiAgICBtYXJnaW4tbGVmdDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOm9wYWNpdHktMCB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOm9wYWNpdHktMjUge1xcbiAgICBvcGFjaXR5OiAuMjU7XFxuICB9XFxuXFxuICAuc21cXFxcOm9wYWNpdHktNTAge1xcbiAgICBvcGFjaXR5OiAuNTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6b3BhY2l0eS03NSB7XFxuICAgIG9wYWNpdHk6IC43NTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6b3BhY2l0eS0xMDAge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpvdmVyZmxvdy1hdXRvIHtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOm92ZXJmbG93LWhpZGRlbiB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICB9XFxuXFxuICAuc21cXFxcOm92ZXJmbG93LXZpc2libGUge1xcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6b3ZlcmZsb3ctc2Nyb2xsIHtcXG4gICAgb3ZlcmZsb3c6IHNjcm9sbDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6b3ZlcmZsb3cteC1hdXRvIHtcXG4gICAgb3ZlcmZsb3cteDogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6b3ZlcmZsb3cteS1hdXRvIHtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6b3ZlcmZsb3cteC1oaWRkZW4ge1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICB9XFxuXFxuICAuc21cXFxcOm92ZXJmbG93LXktaGlkZGVuIHtcXG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpvdmVyZmxvdy14LXZpc2libGUge1xcbiAgICBvdmVyZmxvdy14OiB2aXNpYmxlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpvdmVyZmxvdy15LXZpc2libGUge1xcbiAgICBvdmVyZmxvdy15OiB2aXNpYmxlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpvdmVyZmxvdy14LXNjcm9sbCB7XFxuICAgIG92ZXJmbG93LXg6IHNjcm9sbDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6b3ZlcmZsb3cteS1zY3JvbGwge1xcbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XFxuICB9XFxuXFxuICAuc21cXFxcOnNjcm9sbGluZy10b3VjaCB7XFxuICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6c2Nyb2xsaW5nLWF1dG8ge1xcbiAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cC0wIHtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cC0xIHtcXG4gICAgcGFkZGluZzogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwLTIge1xcbiAgICBwYWRkaW5nOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnAtMyB7XFxuICAgIHBhZGRpbmc6IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cC00IHtcXG4gICAgcGFkZGluZzogMTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cC01IHtcXG4gICAgcGFkZGluZzogMjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cC02IHtcXG4gICAgcGFkZGluZzogMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cC03IHtcXG4gICAgcGFkZGluZzogMzZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cC04IHtcXG4gICAgcGFkZGluZzogNDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cC05IHtcXG4gICAgcGFkZGluZzogNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cC0xMCB7XFxuICAgIHBhZGRpbmc6IDk2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnAtYXV0byB7XFxuICAgIHBhZGRpbmc6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOnAtZnVsbCB7XFxuICAgIHBhZGRpbmc6IDEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOnAtcHgge1xcbiAgICBwYWRkaW5nOiAxcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnAtMVxcXFwvNiB7XFxuICAgIHBhZGRpbmc6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTAge1xcbiAgICBwYWRkaW5nLXRvcDogMDtcXG4gICAgcGFkZGluZy1ib3R0b206IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnB4LTAge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTEge1xcbiAgICBwYWRkaW5nLXRvcDogMnB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpweC0xIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAycHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHktMiB7XFxuICAgIHBhZGRpbmctdG9wOiA0cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB4LTIge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDRweDtcXG4gICAgcGFkZGluZy1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpweS0zIHtcXG4gICAgcGFkZGluZy10b3A6IDhweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHgtMyB7XFxuICAgIHBhZGRpbmctbGVmdDogOHB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTQge1xcbiAgICBwYWRkaW5nLXRvcDogMTZweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB4LTQge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDE2cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTUge1xcbiAgICBwYWRkaW5nLXRvcDogMjRweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB4LTUge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDI0cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTYge1xcbiAgICBwYWRkaW5nLXRvcDogMzJweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDMycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB4LTYge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDMycHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTcge1xcbiAgICBwYWRkaW5nLXRvcDogMzZweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB4LTcge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDM2cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTgge1xcbiAgICBwYWRkaW5nLXRvcDogNDhweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB4LTgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDQ4cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTkge1xcbiAgICBwYWRkaW5nLXRvcDogNjRweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDY0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB4LTkge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDY0cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTEwIHtcXG4gICAgcGFkZGluZy10b3A6IDk2cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpweC0xMCB7XFxuICAgIHBhZGRpbmctbGVmdDogOTZweDtcXG4gICAgcGFkZGluZy1yaWdodDogOTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHktYXV0byB7XFxuICAgIHBhZGRpbmctdG9wOiBhdXRvO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHgtYXV0byB7XFxuICAgIHBhZGRpbmctbGVmdDogYXV0bztcXG4gICAgcGFkZGluZy1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHktZnVsbCB7XFxuICAgIHBhZGRpbmctdG9wOiAxMDAlO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMTAwJTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHgtZnVsbCB7XFxuICAgIHBhZGRpbmctbGVmdDogMTAwJTtcXG4gICAgcGFkZGluZy1yaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHktcHgge1xcbiAgICBwYWRkaW5nLXRvcDogMXB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMXB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpweC1weCB7XFxuICAgIHBhZGRpbmctbGVmdDogMXB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB5LTFcXFxcLzYge1xcbiAgICBwYWRkaW5nLXRvcDogMTYuNjY2NjY2NjY3JTtcXG4gICAgcGFkZGluZy1ib3R0b206IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOnB4LTFcXFxcLzYge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDE2LjY2NjY2NjY2NyU7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOnB0LTAge1xcbiAgICBwYWRkaW5nLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHItMCB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnBiLTAge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGwtMCB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHQtMSB7XFxuICAgIHBhZGRpbmctdG9wOiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnByLTEge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnBiLTEge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwbC0xIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB0LTIge1xcbiAgICBwYWRkaW5nLXRvcDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwci0yIHtcXG4gICAgcGFkZGluZy1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwYi0yIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGwtMiB7XFxuICAgIHBhZGRpbmctbGVmdDogNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwdC0zIHtcXG4gICAgcGFkZGluZy10b3A6IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHItMyB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGItMyB7XFxuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnBsLTMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHQtNCB7XFxuICAgIHBhZGRpbmctdG9wOiAxNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwci00IHtcXG4gICAgcGFkZGluZy1yaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGItNCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwbC00IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwdC01IHtcXG4gICAgcGFkZGluZy10b3A6IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnByLTUge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwYi01IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnBsLTUge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDI0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB0LTYge1xcbiAgICBwYWRkaW5nLXRvcDogMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHItNiB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnBiLTYge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGwtNiB7XFxuICAgIHBhZGRpbmctbGVmdDogMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHQtNyB7XFxuICAgIHBhZGRpbmctdG9wOiAzNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwci03IHtcXG4gICAgcGFkZGluZy1yaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGItNyB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAzNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwbC03IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAzNnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwdC04IHtcXG4gICAgcGFkZGluZy10b3A6IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnByLTgge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwYi04IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnBsLTgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDQ4cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnB0LTkge1xcbiAgICBwYWRkaW5nLXRvcDogNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHItOSB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnBiLTkge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGwtOSB7XFxuICAgIHBhZGRpbmctbGVmdDogNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHQtMTAge1xcbiAgICBwYWRkaW5nLXRvcDogOTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHItMTAge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwYi0xMCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwbC0xMCB7XFxuICAgIHBhZGRpbmctbGVmdDogOTZweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHQtYXV0byB7XFxuICAgIHBhZGRpbmctdG9wOiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwci1hdXRvIHtcXG4gICAgcGFkZGluZy1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGItYXV0byB7XFxuICAgIHBhZGRpbmctYm90dG9tOiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwbC1hdXRvIHtcXG4gICAgcGFkZGluZy1sZWZ0OiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwdC1mdWxsIHtcXG4gICAgcGFkZGluZy10b3A6IDEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOnByLWZ1bGwge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwYi1mdWxsIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOnBsLWZ1bGwge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEwMCU7XFxuICB9XFxuXFxuICAuc21cXFxcOnB0LXB4IHtcXG4gICAgcGFkZGluZy10b3A6IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHItcHgge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnBiLXB4IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGwtcHgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cHQtMVxcXFwvNiB7XFxuICAgIHBhZGRpbmctdG9wOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwci0xXFxcXC82IHtcXG4gICAgcGFkZGluZy1yaWdodDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGItMVxcXFwvNiB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwbC0xXFxcXC82IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwb2ludGVyLWV2ZW50cy1ub25lIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB9XFxuXFxuICAuc21cXFxcOnBvaW50ZXItZXZlbnRzLWF1dG8ge1xcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6c3RhdGljIHtcXG4gICAgcG9zaXRpb246IHN0YXRpYztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zml4ZWQge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmFic29sdXRlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyZWxhdGl2ZSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6c3RpY2t5IHtcXG4gICAgcG9zaXRpb246IHN0aWNreTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGluLW5vbmUge1xcbiAgICB0b3A6IGF1dG87XFxuICAgIHJpZ2h0OiBhdXRvO1xcbiAgICBib3R0b206IGF1dG87XFxuICAgIGxlZnQ6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOnBpbiB7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGluLXkge1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGluLXgge1xcbiAgICByaWdodDogMDtcXG4gICAgbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6cGluLXQge1xcbiAgICB0b3A6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnBpbi1yIHtcXG4gICAgcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnBpbi1iIHtcXG4gICAgYm90dG9tOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpwaW4tbCB7XFxuICAgIGxlZnQ6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnJlc2l6ZS1ub25lIHtcXG4gICAgcmVzaXplOiBub25lO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyZXNpemUteSB7XFxuICAgIHJlc2l6ZTogdmVydGljYWw7XFxuICB9XFxuXFxuICAuc21cXFxcOnJlc2l6ZS14IHtcXG4gICAgcmVzaXplOiBob3Jpem9udGFsO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpyZXNpemUge1xcbiAgICByZXNpemU6IGJvdGg7XFxuICB9XFxuXFxuICAuc21cXFxcOnNoYWRvdyB7XFxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwIHJnYmEoMCwgMCwgMCwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpzaGFkb3ctbWQge1xcbiAgICBib3gtc2hhZG93OiAgMCA4cHggMjBweCAwIHJnYmEoMCwgMCwgMCwgLjQyKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6c2hhZG93LW5vbmUge1xcbiAgICBib3gtc2hhZG93OiBub25lO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0YWJsZS1hdXRvIHtcXG4gICAgdGFibGUtbGF5b3V0OiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0YWJsZS1maXhlZCB7XFxuICAgIHRhYmxlLWxheW91dDogZml4ZWQ7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtbGVmdCB7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtY2VudGVyIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0ZXh0LXJpZ2h0IHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtanVzdGlmeSB7XFxuICAgIHRleHQtYWxpZ246IGp1c3RpZnk7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtaW5oZXJpdCB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0ZXh0LXRyYW5zcGFyZW50IHtcXG4gICAgY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0ZXh0LWJsYWNrIHtcXG4gICAgY29sb3I6ICMyODI4Mjg7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtd2hpdGUge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dGV4dC1ncmV5LWxpZ2h0ZXIge1xcbiAgICBjb2xvcjogI2YzZjNmNztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dGV4dC1ncmV5LWxpZ2h0IHtcXG4gICAgY29sb3I6ICNlN2U3ZWM7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtZ3JleSB7XFxuICAgIGNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0ZXh0LXB1cnBsZS1saWdodGVyIHtcXG4gICAgY29sb3I6ICNjY2MyZTk7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtcHVycGxlLWxpZ2h0IHtcXG4gICAgY29sb3I6ICM4NzgwOWI7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtcHVycGxlIHtcXG4gICAgY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtcHVycGxlLWJyaWdodCB7XFxuICAgIGNvbG9yOiAjNGMyOWIwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0ZXh0LXB1cnBsZS1kYXJrIHtcXG4gICAgY29sb3I6ICM0NTNmNTY7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtcHVycGxlLWRhcmstMTAge1xcbiAgICBjb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtcHVycGxlLWRhcmtlciB7XFxuICAgIGNvbG9yOiAjMmEyNTM4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6dGV4dC1pbmhlcml0OmhvdmVyIHtcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDp0ZXh0LXRyYW5zcGFyZW50OmhvdmVyIHtcXG4gICAgY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6dGV4dC1ibGFjazpob3ZlciB7XFxuICAgIGNvbG9yOiAjMjgyODI4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6dGV4dC13aGl0ZTpob3ZlciB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6dGV4dC1ncmV5LWxpZ2h0ZXI6aG92ZXIge1xcbiAgICBjb2xvcjogI2YzZjNmNztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOnRleHQtZ3JleS1saWdodDpob3ZlciB7XFxuICAgIGNvbG9yOiAjZTdlN2VjO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6dGV4dC1ncmV5OmhvdmVyIHtcXG4gICAgY29sb3I6ICNjMmMyYzY7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDp0ZXh0LXB1cnBsZS1saWdodGVyOmhvdmVyIHtcXG4gICAgY29sb3I6ICNjY2MyZTk7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDp0ZXh0LXB1cnBsZS1saWdodDpob3ZlciB7XFxuICAgIGNvbG9yOiAjODc4MDliO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGU6aG92ZXIge1xcbiAgICBjb2xvcjogIzgzNjBkNjtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOnRleHQtcHVycGxlLWJyaWdodDpob3ZlciB7XFxuICAgIGNvbG9yOiAjNGMyOWIwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGUtZGFyazpob3ZlciB7XFxuICAgIGNvbG9yOiAjNDUzZjU2O1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICAgIGNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOnRleHQtcHVycGxlLWRhcmtlcjpob3ZlciB7XFxuICAgIGNvbG9yOiAjMmEyNTM4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0ZXh0LXNtIHtcXG4gICAgZm9udC1zaXplOiAxLjRyZW07XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtYmFzZSB7XFxuICAgIGZvbnQtc2l6ZTogMS42cmVtO1xcbiAgfVxcblxcbiAgLnNtXFxcXDppdGFsaWMge1xcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICB9XFxuXFxuICAuc21cXFxcOnJvbWFuIHtcXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp1cHBlcmNhc2Uge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpsb3dlcmNhc2Uge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogbG93ZXJjYXNlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpjYXBpdGFsaXplIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IGNhcGl0YWxpemU7XFxuICB9XFxuXFxuICAuc21cXFxcOm5vcm1hbC1jYXNlIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxuXFxuICAuc21cXFxcOnVuZGVybGluZSB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpsaW5lLXRocm91Z2gge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6bm8tdW5kZXJsaW5lIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgfVxcblxcbiAgLnNtXFxcXDphbnRpYWxpYXNlZCB7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpzdWJwaXhlbC1hbnRpYWxpYXNlZCB7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGF1dG87XFxuICAgIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6aXRhbGljOmhvdmVyIHtcXG4gICAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6cm9tYW46aG92ZXIge1xcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDp1cHBlcmNhc2U6aG92ZXIge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6bG93ZXJjYXNlOmhvdmVyIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IGxvd2VyY2FzZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmNhcGl0YWxpemU6aG92ZXIge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOm5vcm1hbC1jYXNlOmhvdmVyIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDp1bmRlcmxpbmU6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmxpbmUtdGhyb3VnaDpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6bm8tdW5kZXJsaW5lOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YW50aWFsaWFzZWQ6aG92ZXIge1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOnN1YnBpeGVsLWFudGlhbGlhc2VkOmhvdmVyIHtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYXV0bztcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOnRyYWNraW5nLXRpZ2h0IHtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IC0wLjA1ZW07XFxuICB9XFxuXFxuICAuc21cXFxcOnRyYWNraW5nLW5vcm1hbCB7XFxuICAgIGxldHRlci1zcGFjaW5nOiAwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0cmFja2luZy13aWRlIHtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IC4wNWVtO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpzZWxlY3Qtbm9uZSB7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpzZWxlY3QtdGV4dCB7XFxuICAgIHVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgfVxcblxcbiAgLnNtXFxcXDphbGlnbi1iYXNlbGluZSB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YWxpZ24tdG9wIHtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YWxpZ24tbWlkZGxlIHtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YWxpZ24tYm90dG9tIHtcXG4gICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YWxpZ24tdGV4dC10b3Age1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdGV4dC10b3A7XFxuICB9XFxuXFxuICAuc21cXFxcOmFsaWduLXRleHQtYm90dG9tIHtcXG4gICAgdmVydGljYWwtYWxpZ246IHRleHQtYm90dG9tO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp2aXNpYmxlIHtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aW52aXNpYmxlIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp3aGl0ZXNwYWNlLW5vcm1hbCB7XFxuICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICB9XFxuXFxuICAuc21cXFxcOndoaXRlc3BhY2Utbm8td3JhcCB7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICB9XFxuXFxuICAuc21cXFxcOndoaXRlc3BhY2UtcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6d2hpdGVzcGFjZS1wcmUtbGluZSB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtbGluZTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6d2hpdGVzcGFjZS1wcmUtd3JhcCB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YnJlYWstd29yZHMge1xcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICB9XFxuXFxuICAuc21cXFxcOmJyZWFrLW5vcm1hbCB7XFxuICAgIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp0cnVuY2F0ZSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp3LTAge1xcbiAgICB3aWR0aDogMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dy0xIHtcXG4gICAgd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dy0yIHtcXG4gICAgd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dy0zIHtcXG4gICAgd2lkdGg6IDhweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dy00IHtcXG4gICAgd2lkdGg6IDE2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnctNSB7XFxuICAgIHdpZHRoOiAyNHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDp3LTYge1xcbiAgICB3aWR0aDogMzJweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dy03IHtcXG4gICAgd2lkdGg6IDM2cHg7XFxuICB9XFxuXFxuICAuc21cXFxcOnctOCB7XFxuICAgIHdpZHRoOiA0OHB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDp3LTkge1xcbiAgICB3aWR0aDogNjRweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dy0xMCB7XFxuICAgIHdpZHRoOiA5NnB4O1xcbiAgfVxcblxcbiAgLnNtXFxcXDp3LXNjcmVlbiB7XFxuICAgIHdpZHRoOiAxMDB2dztcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dy1hdXRvIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICB9XFxuXFxuICAuc21cXFxcOnctZnVsbCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp3LXB4IHtcXG4gICAgd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dy0xXFxcXC82IHtcXG4gICAgd2lkdGg6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAuc21cXFxcOnotMCB7XFxuICAgIHotaW5kZXg6IDA7XFxuICB9XFxuXFxuICAuc21cXFxcOnotMTAge1xcbiAgICB6LWluZGV4OiAxMDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6ei0yMCB7XFxuICAgIHotaW5kZXg6IDIwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp6LTMwIHtcXG4gICAgei1pbmRleDogMzA7XFxuICB9XFxuXFxuICAuc21cXFxcOnotNDAge1xcbiAgICB6LWluZGV4OiA0MDtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6ei01MCB7XFxuICAgIHotaW5kZXg6IDUwO1xcbiAgfVxcblxcbiAgLnNtXFxcXDp6LWF1dG8ge1xcbiAgICB6LWluZGV4OiBhdXRvO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1ibGFjay0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDAsIDQwLCA0MCwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy13aGl0ZS0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctZ3JleS1saWdodC0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjMxLCAyMzEsIDIzNiwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1ncmV5LTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLXB1cnBsZS1saWdodGVyLTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLXB1cnBsZS1saWdodC0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTM1LCAxMjgsIDE1NSwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtZGFyay0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtZGFya2VyLTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpiZy1ibGFjay0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDAsIDQwLCA0MCwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6Ymctd2hpdGUtMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHRlci0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQzLCAyNDMsIDI0NywgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctZ3JleS1saWdodC0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjMxLCAyMzEsIDIzNiwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctZ3JleS0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0ZXItMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwNCwgMTk0LCAyMzMsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodC0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTM1LCAxMjgsIDE1NSwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLTEwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1icmlnaHQtMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDc2LCA0MSwgMTc2LCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWRhcmtlci0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb2N1c1xcXFw6YmctYmxhY2stMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLXdoaXRlLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLWdyZXktbGlnaHQtMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLWdyZXktMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1saWdodGVyLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtbGlnaHQtMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS0xMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMSk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjEpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWRhcmstMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrZXItMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4xKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctYmxhY2stMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Ymctd2hpdGUtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctZ3JleS1saWdodGVyLTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmJnLWdyZXktbGlnaHQtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctZ3JleS0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjMpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjMpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpiZy1wdXJwbGUtbGlnaHQtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctcHVycGxlLTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctcHVycGxlLWJyaWdodC0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctcHVycGxlLWRhcmstMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6YmctcHVycGxlLWRhcmtlci0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjMpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctYmxhY2stMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXdoaXRlLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHQtMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLWdyZXktMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodGVyLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtbGlnaHQtMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS0zMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjMpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWRhcmstMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrZXItMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLWJsYWNrLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MCwgNDAsIDQwLCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy13aGl0ZS0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjMpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb2N1c1xcXFw6YmctZ3JleS1saWdodGVyLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0LTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzEsIDIzMSwgMjM2LCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1ncmV5LTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjMpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0LTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzUsIDEyOCwgMTU1LCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtMzA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjMpO1xcbiAgfVxcblxcbiAgLnNtXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWJyaWdodC0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMyk7XFxuICB9XFxuXFxuICAuc21cXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFya2VyLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMyk7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcbiAgLm1kXFxcXDpsaXN0LXJlc2V0IHtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YXBwZWFyYW5jZS1ub25lIHtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctZml4ZWQge1xcbiAgICBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6IGZpeGVkO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1sb2NhbCB7XFxuICAgIGJhY2tncm91bmQtYXR0YWNobWVudDogbG9jYWw7XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLXNjcm9sbCB7XFxuICAgIGJhY2tncm91bmQtYXR0YWNobWVudDogc2Nyb2xsO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1pbmhlcml0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctdHJhbnNwYXJlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctYmxhY2sge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjgyODI4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy13aGl0ZSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLWdyZXktbGlnaHRlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLWdyZXktbGlnaHQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTdlN2VjO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1ncmV5IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2MyYzJjNjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctcHVycGxlLWxpZ2h0ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtbGlnaHQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjODc4MDliO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjODM2MGQ2O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtYnJpZ2h0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctcHVycGxlLWRhcmsge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDUzZjU2O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtZGFyay0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtZGFya2VyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLWluaGVyaXQ6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctdHJhbnNwYXJlbnQ6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLWJsYWNrOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXdoaXRlOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHRlcjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLWdyZXk6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0ZXI6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtYnJpZ2h0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrLTEwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFya2VyOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLWluaGVyaXQ6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb2N1c1xcXFw6YmctdHJhbnNwYXJlbnQ6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLWJsYWNrOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLXdoaXRlOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLWdyZXktbGlnaHRlcjpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLWdyZXk6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0ZXI6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZTpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtYnJpZ2h0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFya2VyOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctYm90dG9tIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1jZW50ZXIge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLWxlZnQge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBsZWZ0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1sZWZ0LWJvdHRvbSB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgYm90dG9tO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1sZWZ0LXRvcCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgdG9wO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1yaWdodCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1yaWdodC1ib3R0b20ge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiByaWdodCBib3R0b207XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLXJpZ2h0LXRvcCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0IHRvcDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctdG9wIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogdG9wO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1yZXBlYXQge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1uby1yZXBlYXQge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1yZXBlYXQteCB7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctcmVwZWF0LXkge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXk7XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLWF1dG8ge1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLWNvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctY29udGFpbiB7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLWluaGVyaXQge1xcbiAgICBib3JkZXItY29sb3I6IGluaGVyaXQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci10cmFuc3BhcmVudCB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1ibGFjayB7XFxuICAgIGJvcmRlci1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLXdoaXRlIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItZ3JleS1saWdodGVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZjNmM2Y3O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItZ3JleS1saWdodCB7XFxuICAgIGJvcmRlci1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLWdyZXkge1xcbiAgICBib3JkZXItY29sb3I6ICNjMmMyYzY7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHRlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2NjYzJlOTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLXB1cnBsZS1saWdodCB7XFxuICAgIGJvcmRlci1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLXB1cnBsZSB7XFxuICAgIGJvcmRlci1jb2xvcjogIzgzNjBkNjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLXB1cnBsZS1icmlnaHQge1xcbiAgICBib3JkZXItY29sb3I6ICM0YzI5YjA7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1wdXJwbGUtZGFyayB7XFxuICAgIGJvcmRlci1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrLTEwIHtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrZXIge1xcbiAgICBib3JkZXItY29sb3I6ICMyYTI1Mzg7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpib3JkZXItaW5oZXJpdDpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJvcmRlci10cmFuc3BhcmVudDpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpib3JkZXItYmxhY2s6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICMyODI4Mjg7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpib3JkZXItd2hpdGU6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpib3JkZXItZ3JleS1saWdodGVyOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZjNmM2Y3O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6Ym9yZGVyLWdyZXktbGlnaHQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNlN2U3ZWM7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpib3JkZXItZ3JleTpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2MyYzJjNjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHRlcjpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2NjYzJlOTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM4NzgwOWI7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjODM2MGQ2O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXB1cnBsZS1icmlnaHQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM0YzI5YjA7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWRhcms6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM0NTNmNTY7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWRhcmstMTA6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrZXI6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICMyYTI1Mzg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtbm9uZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtc20ge1xcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQge1xcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtZnVsbCB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cm91bmRlZC10LW5vbmUge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cm91bmRlZC1yLW5vbmUge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtYi1ub25lIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtbC1ub25lIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cm91bmRlZC10LXNtIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLXItc20ge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLWItc20ge1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtbC1zbSB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLXQge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA0cHg7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtciB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtYiB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cm91bmRlZC1sIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtdC1mdWxsIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLXItZnVsbCB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtYi1mdWxsIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDk5OTlweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLWwtZnVsbCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLXRsLW5vbmUge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLXRyLW5vbmUge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cm91bmRlZC1ici1ub25lIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtYmwtbm9uZSB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtdGwtc20ge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtdHItc20ge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLWJyLXNtIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cm91bmRlZC1ibC1zbSB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cm91bmRlZC10bCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cm91bmRlZC10ciB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtYnIge1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLWJsIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyb3VuZGVkLXRsLWZ1bGwge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtdHItZnVsbCB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtYnItZnVsbCB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvdW5kZWQtYmwtZnVsbCB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLXNvbGlkIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLWRhc2hlZCB7XFxuICAgIGJvcmRlci1zdHlsZTogZGFzaGVkO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItZG90dGVkIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBkb3R0ZWQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1ub25lIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItMCB7XFxuICAgIGJvcmRlci13aWR0aDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLTIge1xcbiAgICBib3JkZXItd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLTQge1xcbiAgICBib3JkZXItd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLTgge1xcbiAgICBib3JkZXItd2lkdGg6IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyIHtcXG4gICAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci10LTAge1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItci0wIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItYi0wIHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLWwtMCB7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItdC0yIHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItci0yIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1iLTIge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1sLTIge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItdC00IHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItci00IHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1iLTQge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1sLTQge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItdC04IHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItci04IHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1iLTgge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1sLTgge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpib3JkZXItdCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLXIge1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ym9yZGVyLWIge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmJvcmRlci1sIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Y3Vyc29yLWF1dG8ge1xcbiAgICBjdXJzb3I6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOmN1cnNvci1kZWZhdWx0IHtcXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpjdXJzb3ItcG9pbnRlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Y3Vyc29yLXdhaXQge1xcbiAgICBjdXJzb3I6IHdhaXQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmN1cnNvci1tb3ZlIHtcXG4gICAgY3Vyc29yOiBtb3ZlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpjdXJzb3Itbm90LWFsbG93ZWQge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpibG9jayB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgfVxcblxcbiAgLm1kXFxcXDppbmxpbmUtYmxvY2sge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB9XFxuXFxuICAubWRcXFxcOmlubGluZSB7XFxuICAgIGRpc3BsYXk6IGlubGluZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dGFibGUge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dGFibGUtcm93IHtcXG4gICAgZGlzcGxheTogdGFibGUtcm93O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0YWJsZS1jZWxsIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aGlkZGVuIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6ZmxleCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuXFxuICAubWRcXFxcOmlubGluZS1mbGV4IHtcXG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICB9XFxuXFxuICAubWRcXFxcOmZsZXgtcm93IHtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6ZmxleC1yb3ctcmV2ZXJzZSB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6ZmxleC1jb2wge1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmbGV4LWNvbC1yZXZlcnNlIHtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmbGV4LXdyYXAge1xcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICB9XFxuXFxuICAubWRcXFxcOmZsZXgtd3JhcC1yZXZlcnNlIHtcXG4gICAgZmxleC13cmFwOiB3cmFwLXJldmVyc2U7XFxuICB9XFxuXFxuICAubWRcXFxcOmZsZXgtbm8td3JhcCB7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDppdGVtcy1zdGFydCB7XFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDppdGVtcy1lbmQge1xcbiAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxuICB9XFxuXFxuICAubWRcXFxcOml0ZW1zLWNlbnRlciB7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB9XFxuXFxuICAubWRcXFxcOml0ZW1zLWJhc2VsaW5lIHtcXG4gICAgYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xcbiAgfVxcblxcbiAgLm1kXFxcXDppdGVtcy1zdHJldGNoIHtcXG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICB9XFxuXFxuICAubWRcXFxcOnNlbGYtYXV0byB7XFxuICAgIGFsaWduLXNlbGY6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOnNlbGYtc3RhcnQge1xcbiAgICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpzZWxmLWVuZCB7XFxuICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpzZWxmLWNlbnRlciB7XFxuICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6c2VsZi1zdHJldGNoIHtcXG4gICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6anVzdGlmeS1zdGFydCB7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6anVzdGlmeS1lbmQge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpqdXN0aWZ5LWNlbnRlciB7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpqdXN0aWZ5LWJldHdlZW4ge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB9XFxuXFxuICAubWRcXFxcOmp1c3RpZnktYXJvdW5kIHtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmNvbnRlbnQtY2VudGVyIHtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpjb250ZW50LXN0YXJ0IHtcXG4gICAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Y29udGVudC1lbmQge1xcbiAgICBhbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Y29udGVudC1iZXR3ZWVuIHtcXG4gICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Y29udGVudC1hcm91bmQge1xcbiAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmZsZXgtMSB7XFxuICAgIGZsZXg6IDE7XFxuICB9XFxuXFxuICAubWRcXFxcOmZsZXgtYXV0byB7XFxuICAgIGZsZXg6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOmZsZXgtaW5pdGlhbCB7XFxuICAgIGZsZXg6IGluaXRpYWw7XFxuICB9XFxuXFxuICAubWRcXFxcOmZsZXgtbm9uZSB7XFxuICAgIGZsZXg6IG5vbmU7XFxuICB9XFxuXFxuICAubWRcXFxcOmZsZXgtZ3JvdyB7XFxuICAgIGZsZXgtZ3JvdzogMTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6ZmxleC1zaHJpbmsge1xcbiAgICBmbGV4LXNocmluazogMTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6ZmxleC1uby1ncm93IHtcXG4gICAgZmxleC1ncm93OiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmbGV4LW5vLXNocmluayB7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmbG9hdC1yaWdodCB7XFxuICAgIGZsb2F0OiByaWdodDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6ZmxvYXQtbGVmdCB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmbG9hdC1ub25lIHtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICB9XFxuXFxuICAubWRcXFxcOmNsZWFyZml4OmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbiAgICBjbGVhcjogYm90aDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9udC1zYW5zIHtcXG4gICAgZm9udC1mYW1pbHk6IHN5c3RlbS11aSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAtYXBwbGUtc3lzdGVtLCBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCBGaXJhIFNhbnMsIERyb2lkIFNhbnMsIEhlbHZldGljYSBOZXVlLCBzYW5zLXNlcmlmO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb250LXNlcmlmIHtcXG4gICAgZm9udC1mYW1pbHk6IENvbnN0YW50aWEsIEx1Y2lkYSBCcmlnaHQsIEx1Y2lkYWJyaWdodCwgTHVjaWRhIFNlcmlmLCBMdWNpZGEsIERlamFWdSBTZXJpZiwgQml0c3RyZWFtIFZlcmEgU2VyaWYsIExpYmVyYXRpb24gU2VyaWYsIEdlb3JnaWEsIHNlcmlmO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb250LW1vbm8ge1xcbiAgICBmb250LWZhbWlseTogTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIExpYmVyYXRpb24gTW9ubywgQ291cmllciBOZXcsIG1vbm9zcGFjZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9udC1oYWlybGluZSB7XFxuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvbnQtdGhpbiB7XFxuICAgIGZvbnQtd2VpZ2h0OiAyMDA7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvbnQtbGlnaHQge1xcbiAgICBmb250LXdlaWdodDogMzAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb250LW5vcm1hbCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvbnQtbWVkaXVtIHtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9udC1zZW1pYm9sZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvbnQtYm9sZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvbnQtZXh0cmFib2xkIHtcXG4gICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9udC1ibGFjayB7XFxuICAgIGZvbnQtd2VpZ2h0OiA5MDA7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpmb250LWhhaXJsaW5lOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmZvbnQtdGhpbjpob3ZlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiAyMDA7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpmb250LWxpZ2h0OmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmZvbnQtbm9ybWFsOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmZvbnQtbWVkaXVtOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmZvbnQtc2VtaWJvbGQ6aG92ZXIge1xcbiAgICBmb250LXdlaWdodDogNjAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6Zm9udC1ib2xkOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmZvbnQtZXh0cmFib2xkOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmZvbnQtYmxhY2s6aG92ZXIge1xcbiAgICBmb250LXdlaWdodDogOTAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpoLTAge1xcbiAgICBoZWlnaHQ6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOmgtMSB7XFxuICAgIGhlaWdodDogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpoLTIge1xcbiAgICBoZWlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aC0zIHtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmgtNCB7XFxuICAgIGhlaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aC01IHtcXG4gICAgaGVpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpoLTYge1xcbiAgICBoZWlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmgtNyB7XFxuICAgIGhlaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aC04IHtcXG4gICAgaGVpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpoLTkge1xcbiAgICBoZWlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmgtMTAge1xcbiAgICBoZWlnaHQ6IDk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOmgtc2NyZWVuIHtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aC1hdXRvIHtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpoLWZ1bGwge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOmgtcHgge1xcbiAgICBoZWlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aC0xXFxcXC82IHtcXG4gICAgaGVpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpsZWFkaW5nLW5vbmUge1xcbiAgICBsaW5lLWhlaWdodDogMTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bGVhZGluZy10aWdodCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjI1O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpsZWFkaW5nLW5vcm1hbCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICB9XFxuXFxuICAubWRcXFxcOmxlYWRpbmctbG9vc2Uge1xcbiAgICBsaW5lLWhlaWdodDogMjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bS0wIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptLTEge1xcbiAgICBtYXJnaW46IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bS0yIHtcXG4gICAgbWFyZ2luOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm0tMyB7XFxuICAgIG1hcmdpbjogOHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptLTQge1xcbiAgICBtYXJnaW46IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm0tNSB7XFxuICAgIG1hcmdpbjogMjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bS02IHtcXG4gICAgbWFyZ2luOiAzMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptLTcge1xcbiAgICBtYXJnaW46IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm0tOCB7XFxuICAgIG1hcmdpbjogNDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bS05IHtcXG4gICAgbWFyZ2luOiA2NHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptLTEwIHtcXG4gICAgbWFyZ2luOiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptLWF1dG8ge1xcbiAgICBtYXJnaW46IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOm0tZnVsbCB7XFxuICAgIG1hcmdpbjogMTAwJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bS1weCB7XFxuICAgIG1hcmdpbjogMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptLTFcXFxcLzYge1xcbiAgICBtYXJnaW46IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOm15LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteC0wIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXktMSB7XFxuICAgIG1hcmdpbi10b3A6IDJweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteC0xIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDJweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm15LTIge1xcbiAgICBtYXJnaW4tdG9wOiA0cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXgtMiB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteS0zIHtcXG4gICAgbWFyZ2luLXRvcDogOHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm14LTMge1xcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXktNCB7XFxuICAgIG1hcmdpbi10b3A6IDE2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm14LTQge1xcbiAgICBtYXJnaW4tbGVmdDogMTZweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteS01IHtcXG4gICAgbWFyZ2luLXRvcDogMjRweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXgtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAyNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm15LTYge1xcbiAgICBtYXJnaW4tdG9wOiAzMnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAzMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteC02IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDMycHg7XFxuICAgIG1hcmdpbi1yaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXktNyB7XFxuICAgIG1hcmdpbi10b3A6IDM2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm14LTcge1xcbiAgICBtYXJnaW4tbGVmdDogMzZweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAzNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteS04IHtcXG4gICAgbWFyZ2luLXRvcDogNDhweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogNDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXgtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0OHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm15LTkge1xcbiAgICBtYXJnaW4tdG9wOiA2NHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA2NHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteC05IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDY0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXktMTAge1xcbiAgICBtYXJnaW4tdG9wOiA5NnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteC0xMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA5NnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm15LWF1dG8ge1xcbiAgICBtYXJnaW4tdG9wOiBhdXRvO1xcbiAgICBtYXJnaW4tYm90dG9tOiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteC1hdXRvIHtcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXktZnVsbCB7XFxuICAgIG1hcmdpbi10b3A6IDEwMCU7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOm14LWZ1bGwge1xcbiAgICBtYXJnaW4tbGVmdDogMTAwJTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteS1weCB7XFxuICAgIG1hcmdpbi10b3A6IDFweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteC1weCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxcHg7XFxuICAgIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpteS0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXRvcDogMTYuNjY2NjY2NjY3JTtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXgtMVxcXFwvNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOm10LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptci0wIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYi0wIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWwtMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptdC0xIHtcXG4gICAgbWFyZ2luLXRvcDogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptci0xIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1iLTEge1xcbiAgICBtYXJnaW4tYm90dG9tOiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1sLTEge1xcbiAgICBtYXJnaW4tbGVmdDogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptdC0yIHtcXG4gICAgbWFyZ2luLXRvcDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptci0yIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1iLTIge1xcbiAgICBtYXJnaW4tYm90dG9tOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1sLTIge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptdC0zIHtcXG4gICAgbWFyZ2luLXRvcDogOHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptci0zIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1iLTMge1xcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1sLTMge1xcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptdC00IHtcXG4gICAgbWFyZ2luLXRvcDogMTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXItNCB7XFxuICAgIG1hcmdpbi1yaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWItNCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1sLTQge1xcbiAgICBtYXJnaW4tbGVmdDogMTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXQtNSB7XFxuICAgIG1hcmdpbi10b3A6IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1yLTUge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1iLTUge1xcbiAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptbC01IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm10LTYge1xcbiAgICBtYXJnaW4tdG9wOiAzMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptci02IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAzMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYi02IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWwtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAzMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptdC03IHtcXG4gICAgbWFyZ2luLXRvcDogMzZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXItNyB7XFxuICAgIG1hcmdpbi1yaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWItNyB7XFxuICAgIG1hcmdpbi1ib3R0b206IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1sLTcge1xcbiAgICBtYXJnaW4tbGVmdDogMzZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXQtOCB7XFxuICAgIG1hcmdpbi10b3A6IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1yLTgge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1iLTgge1xcbiAgICBtYXJnaW4tYm90dG9tOiA0OHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptbC04IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm10LTkge1xcbiAgICBtYXJnaW4tdG9wOiA2NHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptci05IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA2NHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYi05IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWwtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA2NHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptdC0xMCB7XFxuICAgIG1hcmdpbi10b3A6IDk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1yLTEwIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYi0xMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1sLTEwIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm10LWF1dG8ge1xcbiAgICBtYXJnaW4tdG9wOiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptci1hdXRvIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYi1hdXRvIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWwtYXV0byB7XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptdC1mdWxsIHtcXG4gICAgbWFyZ2luLXRvcDogMTAwJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXItZnVsbCB7XFxuICAgIG1hcmdpbi1yaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWItZnVsbCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOm1sLWZ1bGwge1xcbiAgICBtYXJnaW4tbGVmdDogMTAwJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bXQtcHgge1xcbiAgICBtYXJnaW4tdG9wOiAxcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1yLXB4IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1iLXB4IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptbC1weCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm10LTFcXFxcLzYge1xcbiAgICBtYXJnaW4tdG9wOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptci0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYi0xXFxcXC82IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWwtMVxcXFwvNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtaC0wIHtcXG4gICAgbWF4LWhlaWdodDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LWgtMSB7XFxuICAgIG1heC1oZWlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LWgtMiB7XFxuICAgIG1heC1oZWlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LWgtMyB7XFxuICAgIG1heC1oZWlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LWgtNCB7XFxuICAgIG1heC1oZWlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC1oLTUge1xcbiAgICBtYXgtaGVpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtaC02IHtcXG4gICAgbWF4LWhlaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LWgtNyB7XFxuICAgIG1heC1oZWlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC1oLTgge1xcbiAgICBtYXgtaGVpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtaC05IHtcXG4gICAgbWF4LWhlaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LWgtMTAge1xcbiAgICBtYXgtaGVpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtaC1zY3JlZW4ge1xcbiAgICBtYXgtaGVpZ2h0OiAxMDB2aDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LWgtYXV0byB7XFxuICAgIG1heC1oZWlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC1oLWZ1bGwge1xcbiAgICBtYXgtaGVpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtaC1weCB7XFxuICAgIG1heC1oZWlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LWgtMVxcXFwvNiB7XFxuICAgIG1heC1oZWlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LTAge1xcbiAgICBtYXgtd2lkdGg6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LTEge1xcbiAgICBtYXgtd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWF4LXctMiB7XFxuICAgIG1heC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtdy0zIHtcXG4gICAgbWF4LXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LTQge1xcbiAgICBtYXgtd2lkdGg6IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LTUge1xcbiAgICBtYXgtd2lkdGg6IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LTYge1xcbiAgICBtYXgtd2lkdGg6IDMycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LTcge1xcbiAgICBtYXgtd2lkdGg6IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LTgge1xcbiAgICBtYXgtd2lkdGg6IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LTkge1xcbiAgICBtYXgtd2lkdGg6IDY0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1heC13LTEwIHtcXG4gICAgbWF4LXdpZHRoOiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtdy1hdXRvIHtcXG4gICAgbWF4LXdpZHRoOiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtdy1mdWxsIHtcXG4gICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtdy1weCB7XFxuICAgIG1heC13aWR0aDogMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptYXgtdy0xXFxcXC82IHtcXG4gICAgbWF4LXdpZHRoOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4taC0wIHtcXG4gICAgbWluLWhlaWdodDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWluLWgtMSB7XFxuICAgIG1pbi1oZWlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWluLWgtMiB7XFxuICAgIG1pbi1oZWlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWluLWgtMyB7XFxuICAgIG1pbi1oZWlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWluLWgtNCB7XFxuICAgIG1pbi1oZWlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi1oLTUge1xcbiAgICBtaW4taGVpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4taC02IHtcXG4gICAgbWluLWhlaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWluLWgtNyB7XFxuICAgIG1pbi1oZWlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi1oLTgge1xcbiAgICBtaW4taGVpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4taC05IHtcXG4gICAgbWluLWhlaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWluLWgtMTAge1xcbiAgICBtaW4taGVpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4taC1zY3JlZW4ge1xcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWluLWgtYXV0byB7XFxuICAgIG1pbi1oZWlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi1oLWZ1bGwge1xcbiAgICBtaW4taGVpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4taC1weCB7XFxuICAgIG1pbi1oZWlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWluLWgtMVxcXFwvNiB7XFxuICAgIG1pbi1oZWlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi13LTAge1xcbiAgICBtaW4td2lkdGg6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi13LTEge1xcbiAgICBtaW4td2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bWluLXctMiB7XFxuICAgIG1pbi13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4tdy0zIHtcXG4gICAgbWluLXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi13LTQge1xcbiAgICBtaW4td2lkdGg6IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi13LTUge1xcbiAgICBtaW4td2lkdGg6IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi13LTYge1xcbiAgICBtaW4td2lkdGg6IDMycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi13LTcge1xcbiAgICBtaW4td2lkdGg6IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi13LTgge1xcbiAgICBtaW4td2lkdGg6IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi13LTkge1xcbiAgICBtaW4td2lkdGg6IDY0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOm1pbi13LTEwIHtcXG4gICAgbWluLXdpZHRoOiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4tdy1hdXRvIHtcXG4gICAgbWluLXdpZHRoOiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4tdy1mdWxsIHtcXG4gICAgbWluLXdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4tdy1weCB7XFxuICAgIG1pbi13aWR0aDogMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDptaW4tdy0xXFxcXC82IHtcXG4gICAgbWluLXdpZHRoOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbS0wIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbS0xIHtcXG4gICAgbWFyZ2luOiAtMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbS0yIHtcXG4gICAgbWFyZ2luOiAtNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbS0zIHtcXG4gICAgbWFyZ2luOiAtOHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbS00IHtcXG4gICAgbWFyZ2luOiAtMTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW0tNSB7XFxuICAgIG1hcmdpbjogLTI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tLTYge1xcbiAgICBtYXJnaW46IC0zMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbS03IHtcXG4gICAgbWFyZ2luOiAtMzZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW0tOCB7XFxuICAgIG1hcmdpbjogLTQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tLTkge1xcbiAgICBtYXJnaW46IC02NHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbS0xMCB7XFxuICAgIG1hcmdpbjogLTk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tLWF1dG8ge1xcbiAgICBtYXJnaW46IC1hdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbS1mdWxsIHtcXG4gICAgbWFyZ2luOiAtMTAwJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW0tcHgge1xcbiAgICBtYXJnaW46IC0xcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tLTFcXFxcLzYge1xcbiAgICBtYXJnaW46IC0xNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXktMCB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOi1teC0wIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW15LTEge1xcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXgtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0ycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1teS0yIHtcXG4gICAgbWFyZ2luLXRvcDogLTRweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW14LTIge1xcbiAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXktMyB7XFxuICAgIG1hcmdpbi10b3A6IC04cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC04cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1teC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC04cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLThweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW15LTQge1xcbiAgICBtYXJnaW4tdG9wOiAtMTZweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1teC00IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xNnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXktNSB7XFxuICAgIG1hcmdpbi10b3A6IC0yNHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW14LTUge1xcbiAgICBtYXJnaW4tbGVmdDogLTI0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1teS02IHtcXG4gICAgbWFyZ2luLXRvcDogLTMycHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXgtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzJweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW15LTcge1xcbiAgICBtYXJnaW4tdG9wOiAtMzZweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1teC03IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0zNnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0zNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXktOCB7XFxuICAgIG1hcmdpbi10b3A6IC00OHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtNDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW14LTgge1xcbiAgICBtYXJnaW4tbGVmdDogLTQ4cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1teS05IHtcXG4gICAgbWFyZ2luLXRvcDogLTY0cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC02NHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXgtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNjRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW15LTEwIHtcXG4gICAgbWFyZ2luLXRvcDogLTk2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC05NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXgtMTAge1xcbiAgICBtYXJnaW4tbGVmdDogLTk2cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1teS1hdXRvIHtcXG4gICAgbWFyZ2luLXRvcDogLWF1dG87XFxuICAgIG1hcmdpbi1ib3R0b206IC1hdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXgtYXV0byB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtYXV0bztcXG4gICAgbWFyZ2luLXJpZ2h0OiAtYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW15LWZ1bGwge1xcbiAgICBtYXJnaW4tdG9wOiAtMTAwJTtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOi1teC1mdWxsIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xMDAlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xMDAlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXktcHgge1xcbiAgICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXgtcHgge1xcbiAgICBtYXJnaW4tbGVmdDogLTFweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXktMVxcXFwvNiB7XFxuICAgIG1hcmdpbi10b3A6IC0xNi42NjY2NjY2NjclO1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW14LTFcXFxcLzYge1xcbiAgICBtYXJnaW4tbGVmdDogLTE2LjY2NjY2NjY2NyU7XFxuICAgIG1hcmdpbi1yaWdodDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tdC0wIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1yLTAge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tYi0wIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1sLTAge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW10LTEge1xcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXItMSB7XFxuICAgIG1hcmdpbi1yaWdodDogLTJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1iLTEge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWwtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbXQtMiB7XFxuICAgIG1hcmdpbi10b3A6IC00cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tci0yIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWItMiB7XFxuICAgIG1hcmdpbi1ib3R0b206IC00cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tbC0yIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tdC0zIHtcXG4gICAgbWFyZ2luLXRvcDogLThweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1yLTMge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC04cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tYi0zIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLThweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1sLTMge1xcbiAgICBtYXJnaW4tbGVmdDogLThweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW10LTQge1xcbiAgICBtYXJnaW4tdG9wOiAtMTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1yLTQge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWItNCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0xNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWwtNCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW10LTUge1xcbiAgICBtYXJnaW4tdG9wOiAtMjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1yLTUge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0yNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWItNSB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0yNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWwtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW10LTYge1xcbiAgICBtYXJnaW4tdG9wOiAtMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1yLTYge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0zMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWItNiB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWwtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW10LTcge1xcbiAgICBtYXJnaW4tdG9wOiAtMzZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1yLTcge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0zNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWItNyB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWwtNyB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW10LTgge1xcbiAgICBtYXJnaW4tdG9wOiAtNDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1yLTgge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC00OHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWItOCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC00OHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWwtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW10LTkge1xcbiAgICBtYXJnaW4tdG9wOiAtNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1yLTkge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC02NHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWItOSB7XFxuICAgIG1hcmdpbi1ib3R0b206IC02NHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWwtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW10LTEwIHtcXG4gICAgbWFyZ2luLXRvcDogLTk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tci0xMCB7XFxuICAgIG1hcmdpbi1yaWdodDogLTk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tYi0xMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC05NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDotbWwtMTAge1xcbiAgICBtYXJnaW4tbGVmdDogLTk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tdC1hdXRvIHtcXG4gICAgbWFyZ2luLXRvcDogLWF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOi1tci1hdXRvIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1iLWF1dG8ge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1sLWF1dG8ge1xcbiAgICBtYXJnaW4tbGVmdDogLWF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOi1tdC1mdWxsIHtcXG4gICAgbWFyZ2luLXRvcDogLTEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tci1mdWxsIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMTAwJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1iLWZ1bGwge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTAwJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1sLWZ1bGwge1xcbiAgICBtYXJnaW4tbGVmdDogLTEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tdC1weCB7XFxuICAgIG1hcmdpbi10b3A6IC0xcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tci1weCB7XFxuICAgIG1hcmdpbi1yaWdodDogLTFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1iLXB4IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1sLXB4IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tdC0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXRvcDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOi1tci0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1iLTFcXFxcLzYge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6LW1sLTFcXFxcLzYge1xcbiAgICBtYXJnaW4tbGVmdDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOm9wYWNpdHktMCB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOm9wYWNpdHktMjUge1xcbiAgICBvcGFjaXR5OiAuMjU7XFxuICB9XFxuXFxuICAubWRcXFxcOm9wYWNpdHktNTAge1xcbiAgICBvcGFjaXR5OiAuNTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6b3BhY2l0eS03NSB7XFxuICAgIG9wYWNpdHk6IC43NTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6b3BhY2l0eS0xMDAge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpvdmVyZmxvdy1hdXRvIHtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOm92ZXJmbG93LWhpZGRlbiB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICB9XFxuXFxuICAubWRcXFxcOm92ZXJmbG93LXZpc2libGUge1xcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6b3ZlcmZsb3ctc2Nyb2xsIHtcXG4gICAgb3ZlcmZsb3c6IHNjcm9sbDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6b3ZlcmZsb3cteC1hdXRvIHtcXG4gICAgb3ZlcmZsb3cteDogYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6b3ZlcmZsb3cteS1hdXRvIHtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6b3ZlcmZsb3cteC1oaWRkZW4ge1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICB9XFxuXFxuICAubWRcXFxcOm92ZXJmbG93LXktaGlkZGVuIHtcXG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpvdmVyZmxvdy14LXZpc2libGUge1xcbiAgICBvdmVyZmxvdy14OiB2aXNpYmxlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpvdmVyZmxvdy15LXZpc2libGUge1xcbiAgICBvdmVyZmxvdy15OiB2aXNpYmxlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpvdmVyZmxvdy14LXNjcm9sbCB7XFxuICAgIG92ZXJmbG93LXg6IHNjcm9sbDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6b3ZlcmZsb3cteS1zY3JvbGwge1xcbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XFxuICB9XFxuXFxuICAubWRcXFxcOnNjcm9sbGluZy10b3VjaCB7XFxuICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6c2Nyb2xsaW5nLWF1dG8ge1xcbiAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cC0wIHtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cC0xIHtcXG4gICAgcGFkZGluZzogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwLTIge1xcbiAgICBwYWRkaW5nOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnAtMyB7XFxuICAgIHBhZGRpbmc6IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cC00IHtcXG4gICAgcGFkZGluZzogMTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cC01IHtcXG4gICAgcGFkZGluZzogMjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cC02IHtcXG4gICAgcGFkZGluZzogMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cC03IHtcXG4gICAgcGFkZGluZzogMzZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cC04IHtcXG4gICAgcGFkZGluZzogNDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cC05IHtcXG4gICAgcGFkZGluZzogNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cC0xMCB7XFxuICAgIHBhZGRpbmc6IDk2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnAtYXV0byB7XFxuICAgIHBhZGRpbmc6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOnAtZnVsbCB7XFxuICAgIHBhZGRpbmc6IDEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOnAtcHgge1xcbiAgICBwYWRkaW5nOiAxcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnAtMVxcXFwvNiB7XFxuICAgIHBhZGRpbmc6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTAge1xcbiAgICBwYWRkaW5nLXRvcDogMDtcXG4gICAgcGFkZGluZy1ib3R0b206IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTAge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTEge1xcbiAgICBwYWRkaW5nLXRvcDogMnB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpweC0xIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAycHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHktMiB7XFxuICAgIHBhZGRpbmctdG9wOiA0cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTIge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDRweDtcXG4gICAgcGFkZGluZy1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpweS0zIHtcXG4gICAgcGFkZGluZy10b3A6IDhweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHgtMyB7XFxuICAgIHBhZGRpbmctbGVmdDogOHB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTQge1xcbiAgICBwYWRkaW5nLXRvcDogMTZweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTQge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDE2cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTUge1xcbiAgICBwYWRkaW5nLXRvcDogMjRweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTUge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDI0cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTYge1xcbiAgICBwYWRkaW5nLXRvcDogMzJweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDMycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTYge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDMycHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTcge1xcbiAgICBwYWRkaW5nLXRvcDogMzZweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTcge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDM2cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTgge1xcbiAgICBwYWRkaW5nLXRvcDogNDhweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDQ4cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTkge1xcbiAgICBwYWRkaW5nLXRvcDogNjRweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDY0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTkge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDY0cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTEwIHtcXG4gICAgcGFkZGluZy10b3A6IDk2cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpweC0xMCB7XFxuICAgIHBhZGRpbmctbGVmdDogOTZweDtcXG4gICAgcGFkZGluZy1yaWdodDogOTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHktYXV0byB7XFxuICAgIHBhZGRpbmctdG9wOiBhdXRvO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHgtYXV0byB7XFxuICAgIHBhZGRpbmctbGVmdDogYXV0bztcXG4gICAgcGFkZGluZy1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHktZnVsbCB7XFxuICAgIHBhZGRpbmctdG9wOiAxMDAlO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMTAwJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHgtZnVsbCB7XFxuICAgIHBhZGRpbmctbGVmdDogMTAwJTtcXG4gICAgcGFkZGluZy1yaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHktcHgge1xcbiAgICBwYWRkaW5nLXRvcDogMXB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMXB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpweC1weCB7XFxuICAgIHBhZGRpbmctbGVmdDogMXB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB5LTFcXFxcLzYge1xcbiAgICBwYWRkaW5nLXRvcDogMTYuNjY2NjY2NjY3JTtcXG4gICAgcGFkZGluZy1ib3R0b206IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOnB4LTFcXFxcLzYge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDE2LjY2NjY2NjY2NyU7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOnB0LTAge1xcbiAgICBwYWRkaW5nLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHItMCB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnBiLTAge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGwtMCB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHQtMSB7XFxuICAgIHBhZGRpbmctdG9wOiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnByLTEge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnBiLTEge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwbC0xIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB0LTIge1xcbiAgICBwYWRkaW5nLXRvcDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwci0yIHtcXG4gICAgcGFkZGluZy1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwYi0yIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGwtMiB7XFxuICAgIHBhZGRpbmctbGVmdDogNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwdC0zIHtcXG4gICAgcGFkZGluZy10b3A6IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHItMyB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGItMyB7XFxuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnBsLTMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHQtNCB7XFxuICAgIHBhZGRpbmctdG9wOiAxNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwci00IHtcXG4gICAgcGFkZGluZy1yaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGItNCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwbC00IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwdC01IHtcXG4gICAgcGFkZGluZy10b3A6IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnByLTUge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwYi01IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnBsLTUge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDI0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB0LTYge1xcbiAgICBwYWRkaW5nLXRvcDogMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHItNiB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnBiLTYge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGwtNiB7XFxuICAgIHBhZGRpbmctbGVmdDogMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHQtNyB7XFxuICAgIHBhZGRpbmctdG9wOiAzNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwci03IHtcXG4gICAgcGFkZGluZy1yaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGItNyB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAzNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwbC03IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAzNnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwdC04IHtcXG4gICAgcGFkZGluZy10b3A6IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnByLTgge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwYi04IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnBsLTgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnB0LTkge1xcbiAgICBwYWRkaW5nLXRvcDogNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHItOSB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnBiLTkge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGwtOSB7XFxuICAgIHBhZGRpbmctbGVmdDogNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHQtMTAge1xcbiAgICBwYWRkaW5nLXRvcDogOTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHItMTAge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwYi0xMCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwbC0xMCB7XFxuICAgIHBhZGRpbmctbGVmdDogOTZweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHQtYXV0byB7XFxuICAgIHBhZGRpbmctdG9wOiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwci1hdXRvIHtcXG4gICAgcGFkZGluZy1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGItYXV0byB7XFxuICAgIHBhZGRpbmctYm90dG9tOiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwbC1hdXRvIHtcXG4gICAgcGFkZGluZy1sZWZ0OiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwdC1mdWxsIHtcXG4gICAgcGFkZGluZy10b3A6IDEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOnByLWZ1bGwge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwYi1mdWxsIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOnBsLWZ1bGwge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEwMCU7XFxuICB9XFxuXFxuICAubWRcXFxcOnB0LXB4IHtcXG4gICAgcGFkZGluZy10b3A6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHItcHgge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnBiLXB4IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGwtcHgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cHQtMVxcXFwvNiB7XFxuICAgIHBhZGRpbmctdG9wOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwci0xXFxcXC82IHtcXG4gICAgcGFkZGluZy1yaWdodDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGItMVxcXFwvNiB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwbC0xXFxcXC82IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwb2ludGVyLWV2ZW50cy1ub25lIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB9XFxuXFxuICAubWRcXFxcOnBvaW50ZXItZXZlbnRzLWF1dG8ge1xcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6c3RhdGljIHtcXG4gICAgcG9zaXRpb246IHN0YXRpYztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zml4ZWQge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmFic29sdXRlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyZWxhdGl2ZSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6c3RpY2t5IHtcXG4gICAgcG9zaXRpb246IHN0aWNreTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGluLW5vbmUge1xcbiAgICB0b3A6IGF1dG87XFxuICAgIHJpZ2h0OiBhdXRvO1xcbiAgICBib3R0b206IGF1dG87XFxuICAgIGxlZnQ6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOnBpbiB7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGluLXkge1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGluLXgge1xcbiAgICByaWdodDogMDtcXG4gICAgbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6cGluLXQge1xcbiAgICB0b3A6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnBpbi1yIHtcXG4gICAgcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnBpbi1iIHtcXG4gICAgYm90dG9tOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpwaW4tbCB7XFxuICAgIGxlZnQ6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnJlc2l6ZS1ub25lIHtcXG4gICAgcmVzaXplOiBub25lO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyZXNpemUteSB7XFxuICAgIHJlc2l6ZTogdmVydGljYWw7XFxuICB9XFxuXFxuICAubWRcXFxcOnJlc2l6ZS14IHtcXG4gICAgcmVzaXplOiBob3Jpem9udGFsO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpyZXNpemUge1xcbiAgICByZXNpemU6IGJvdGg7XFxuICB9XFxuXFxuICAubWRcXFxcOnNoYWRvdyB7XFxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwIHJnYmEoMCwgMCwgMCwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpzaGFkb3ctbWQge1xcbiAgICBib3gtc2hhZG93OiAgMCA4cHggMjBweCAwIHJnYmEoMCwgMCwgMCwgLjQyKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6c2hhZG93LW5vbmUge1xcbiAgICBib3gtc2hhZG93OiBub25lO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0YWJsZS1hdXRvIHtcXG4gICAgdGFibGUtbGF5b3V0OiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0YWJsZS1maXhlZCB7XFxuICAgIHRhYmxlLWxheW91dDogZml4ZWQ7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtbGVmdCB7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtY2VudGVyIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0ZXh0LXJpZ2h0IHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtanVzdGlmeSB7XFxuICAgIHRleHQtYWxpZ246IGp1c3RpZnk7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtaW5oZXJpdCB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0ZXh0LXRyYW5zcGFyZW50IHtcXG4gICAgY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0ZXh0LWJsYWNrIHtcXG4gICAgY29sb3I6ICMyODI4Mjg7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtd2hpdGUge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dGV4dC1ncmV5LWxpZ2h0ZXIge1xcbiAgICBjb2xvcjogI2YzZjNmNztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dGV4dC1ncmV5LWxpZ2h0IHtcXG4gICAgY29sb3I6ICNlN2U3ZWM7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtZ3JleSB7XFxuICAgIGNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0ZXh0LXB1cnBsZS1saWdodGVyIHtcXG4gICAgY29sb3I6ICNjY2MyZTk7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtcHVycGxlLWxpZ2h0IHtcXG4gICAgY29sb3I6ICM4NzgwOWI7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtcHVycGxlIHtcXG4gICAgY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtcHVycGxlLWJyaWdodCB7XFxuICAgIGNvbG9yOiAjNGMyOWIwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0ZXh0LXB1cnBsZS1kYXJrIHtcXG4gICAgY29sb3I6ICM0NTNmNTY7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtcHVycGxlLWRhcmstMTAge1xcbiAgICBjb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtcHVycGxlLWRhcmtlciB7XFxuICAgIGNvbG9yOiAjMmEyNTM4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6dGV4dC1pbmhlcml0OmhvdmVyIHtcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDp0ZXh0LXRyYW5zcGFyZW50OmhvdmVyIHtcXG4gICAgY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6dGV4dC1ibGFjazpob3ZlciB7XFxuICAgIGNvbG9yOiAjMjgyODI4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6dGV4dC13aGl0ZTpob3ZlciB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6dGV4dC1ncmV5LWxpZ2h0ZXI6aG92ZXIge1xcbiAgICBjb2xvcjogI2YzZjNmNztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOnRleHQtZ3JleS1saWdodDpob3ZlciB7XFxuICAgIGNvbG9yOiAjZTdlN2VjO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6dGV4dC1ncmV5OmhvdmVyIHtcXG4gICAgY29sb3I6ICNjMmMyYzY7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDp0ZXh0LXB1cnBsZS1saWdodGVyOmhvdmVyIHtcXG4gICAgY29sb3I6ICNjY2MyZTk7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDp0ZXh0LXB1cnBsZS1saWdodDpob3ZlciB7XFxuICAgIGNvbG9yOiAjODc4MDliO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGU6aG92ZXIge1xcbiAgICBjb2xvcjogIzgzNjBkNjtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOnRleHQtcHVycGxlLWJyaWdodDpob3ZlciB7XFxuICAgIGNvbG9yOiAjNGMyOWIwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGUtZGFyazpob3ZlciB7XFxuICAgIGNvbG9yOiAjNDUzZjU2O1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICAgIGNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOnRleHQtcHVycGxlLWRhcmtlcjpob3ZlciB7XFxuICAgIGNvbG9yOiAjMmEyNTM4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0ZXh0LXNtIHtcXG4gICAgZm9udC1zaXplOiAxLjRyZW07XFxuICB9XFxuXFxuICAubWRcXFxcOnRleHQtYmFzZSB7XFxuICAgIGZvbnQtc2l6ZTogMS42cmVtO1xcbiAgfVxcblxcbiAgLm1kXFxcXDppdGFsaWMge1xcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICB9XFxuXFxuICAubWRcXFxcOnJvbWFuIHtcXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp1cHBlcmNhc2Uge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpsb3dlcmNhc2Uge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogbG93ZXJjYXNlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpjYXBpdGFsaXplIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IGNhcGl0YWxpemU7XFxuICB9XFxuXFxuICAubWRcXFxcOm5vcm1hbC1jYXNlIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxuXFxuICAubWRcXFxcOnVuZGVybGluZSB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpsaW5lLXRocm91Z2gge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6bm8tdW5kZXJsaW5lIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgfVxcblxcbiAgLm1kXFxcXDphbnRpYWxpYXNlZCB7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpzdWJwaXhlbC1hbnRpYWxpYXNlZCB7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGF1dG87XFxuICAgIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6aXRhbGljOmhvdmVyIHtcXG4gICAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6cm9tYW46aG92ZXIge1xcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDp1cHBlcmNhc2U6aG92ZXIge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6bG93ZXJjYXNlOmhvdmVyIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IGxvd2VyY2FzZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmNhcGl0YWxpemU6aG92ZXIge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOm5vcm1hbC1jYXNlOmhvdmVyIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDp1bmRlcmxpbmU6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmxpbmUtdGhyb3VnaDpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6bm8tdW5kZXJsaW5lOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YW50aWFsaWFzZWQ6aG92ZXIge1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOnN1YnBpeGVsLWFudGlhbGlhc2VkOmhvdmVyIHtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYXV0bztcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOnRyYWNraW5nLXRpZ2h0IHtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IC0wLjA1ZW07XFxuICB9XFxuXFxuICAubWRcXFxcOnRyYWNraW5nLW5vcm1hbCB7XFxuICAgIGxldHRlci1zcGFjaW5nOiAwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0cmFja2luZy13aWRlIHtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IC4wNWVtO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpzZWxlY3Qtbm9uZSB7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpzZWxlY3QtdGV4dCB7XFxuICAgIHVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgfVxcblxcbiAgLm1kXFxcXDphbGlnbi1iYXNlbGluZSB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YWxpZ24tdG9wIHtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YWxpZ24tbWlkZGxlIHtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YWxpZ24tYm90dG9tIHtcXG4gICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YWxpZ24tdGV4dC10b3Age1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdGV4dC10b3A7XFxuICB9XFxuXFxuICAubWRcXFxcOmFsaWduLXRleHQtYm90dG9tIHtcXG4gICAgdmVydGljYWwtYWxpZ246IHRleHQtYm90dG9tO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp2aXNpYmxlIHtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aW52aXNpYmxlIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp3aGl0ZXNwYWNlLW5vcm1hbCB7XFxuICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICB9XFxuXFxuICAubWRcXFxcOndoaXRlc3BhY2Utbm8td3JhcCB7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICB9XFxuXFxuICAubWRcXFxcOndoaXRlc3BhY2UtcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6d2hpdGVzcGFjZS1wcmUtbGluZSB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtbGluZTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6d2hpdGVzcGFjZS1wcmUtd3JhcCB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YnJlYWstd29yZHMge1xcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICB9XFxuXFxuICAubWRcXFxcOmJyZWFrLW5vcm1hbCB7XFxuICAgIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp0cnVuY2F0ZSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp3LTAge1xcbiAgICB3aWR0aDogMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dy0xIHtcXG4gICAgd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dy0yIHtcXG4gICAgd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dy0zIHtcXG4gICAgd2lkdGg6IDhweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dy00IHtcXG4gICAgd2lkdGg6IDE2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnctNSB7XFxuICAgIHdpZHRoOiAyNHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp3LTYge1xcbiAgICB3aWR0aDogMzJweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dy03IHtcXG4gICAgd2lkdGg6IDM2cHg7XFxuICB9XFxuXFxuICAubWRcXFxcOnctOCB7XFxuICAgIHdpZHRoOiA0OHB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp3LTkge1xcbiAgICB3aWR0aDogNjRweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dy0xMCB7XFxuICAgIHdpZHRoOiA5NnB4O1xcbiAgfVxcblxcbiAgLm1kXFxcXDp3LXNjcmVlbiB7XFxuICAgIHdpZHRoOiAxMDB2dztcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dy1hdXRvIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICB9XFxuXFxuICAubWRcXFxcOnctZnVsbCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp3LXB4IHtcXG4gICAgd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6dy0xXFxcXC82IHtcXG4gICAgd2lkdGg6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubWRcXFxcOnotMCB7XFxuICAgIHotaW5kZXg6IDA7XFxuICB9XFxuXFxuICAubWRcXFxcOnotMTAge1xcbiAgICB6LWluZGV4OiAxMDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6ei0yMCB7XFxuICAgIHotaW5kZXg6IDIwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp6LTMwIHtcXG4gICAgei1pbmRleDogMzA7XFxuICB9XFxuXFxuICAubWRcXFxcOnotNDAge1xcbiAgICB6LWluZGV4OiA0MDtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6ei01MCB7XFxuICAgIHotaW5kZXg6IDUwO1xcbiAgfVxcblxcbiAgLm1kXFxcXDp6LWF1dG8ge1xcbiAgICB6LWluZGV4OiBhdXRvO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1ibGFjay0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDAsIDQwLCA0MCwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy13aGl0ZS0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctZ3JleS1saWdodC0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjMxLCAyMzEsIDIzNiwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1ncmV5LTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLXB1cnBsZS1saWdodGVyLTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLXB1cnBsZS1saWdodC0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTM1LCAxMjgsIDE1NSwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtZGFyay0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtZGFya2VyLTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpiZy1ibGFjay0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDAsIDQwLCA0MCwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6Ymctd2hpdGUtMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHRlci0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQzLCAyNDMsIDI0NywgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctZ3JleS1saWdodC0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjMxLCAyMzEsIDIzNiwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctZ3JleS0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0ZXItMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwNCwgMTk0LCAyMzMsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodC0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTM1LCAxMjgsIDE1NSwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLTEwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1icmlnaHQtMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDc2LCA0MSwgMTc2LCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWRhcmtlci0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb2N1c1xcXFw6YmctYmxhY2stMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLXdoaXRlLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLWdyZXktbGlnaHQtMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLWdyZXktMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1saWdodGVyLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtbGlnaHQtMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS0xMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMSk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjEpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWRhcmstMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrZXItMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4xKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctYmxhY2stMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Ymctd2hpdGUtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctZ3JleS1saWdodGVyLTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmJnLWdyZXktbGlnaHQtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctZ3JleS0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjMpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjMpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpiZy1wdXJwbGUtbGlnaHQtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctcHVycGxlLTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctcHVycGxlLWJyaWdodC0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctcHVycGxlLWRhcmstMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6YmctcHVycGxlLWRhcmtlci0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjMpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctYmxhY2stMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXdoaXRlLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHQtMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLWdyZXktMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodGVyLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtbGlnaHQtMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS0zMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjMpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWRhcmstMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrZXItMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLWJsYWNrLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MCwgNDAsIDQwLCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy13aGl0ZS0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjMpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb2N1c1xcXFw6YmctZ3JleS1saWdodGVyLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0LTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzEsIDIzMSwgMjM2LCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjMpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0LTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzUsIDEyOCwgMTU1LCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtMzA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjMpO1xcbiAgfVxcblxcbiAgLm1kXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWJyaWdodC0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5tZFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMyk7XFxuICB9XFxuXFxuICAubWRcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFya2VyLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMyk7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgLmxnXFxcXDpsaXN0LXJlc2V0IHtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YXBwZWFyYW5jZS1ub25lIHtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctZml4ZWQge1xcbiAgICBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6IGZpeGVkO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1sb2NhbCB7XFxuICAgIGJhY2tncm91bmQtYXR0YWNobWVudDogbG9jYWw7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLXNjcm9sbCB7XFxuICAgIGJhY2tncm91bmQtYXR0YWNobWVudDogc2Nyb2xsO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1pbmhlcml0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctdHJhbnNwYXJlbnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctYmxhY2sge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjgyODI4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy13aGl0ZSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLWdyZXktbGlnaHRlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLWdyZXktbGlnaHQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTdlN2VjO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1ncmV5IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2MyYzJjNjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctcHVycGxlLWxpZ2h0ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtbGlnaHQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjODc4MDliO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjODM2MGQ2O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtYnJpZ2h0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctcHVycGxlLWRhcmsge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNDUzZjU2O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtZGFyay0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtZGFya2VyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLWluaGVyaXQ6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctdHJhbnNwYXJlbnQ6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLWJsYWNrOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXdoaXRlOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHRlcjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLWdyZXk6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0ZXI6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtYnJpZ2h0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrLTEwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFya2VyOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLWluaGVyaXQ6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb2N1c1xcXFw6YmctdHJhbnNwYXJlbnQ6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLWJsYWNrOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLXdoaXRlOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLWdyZXktbGlnaHRlcjpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLWdyZXk6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0ZXI6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZTpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtYnJpZ2h0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFya2VyOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctYm90dG9tIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogYm90dG9tO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1jZW50ZXIge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLWxlZnQge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBsZWZ0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1sZWZ0LWJvdHRvbSB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgYm90dG9tO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1sZWZ0LXRvcCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGxlZnQgdG9wO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1yaWdodCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1yaWdodC1ib3R0b20ge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiByaWdodCBib3R0b207XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLXJpZ2h0LXRvcCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IHJpZ2h0IHRvcDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctdG9wIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogdG9wO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1yZXBlYXQge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1uby1yZXBlYXQge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1yZXBlYXQteCB7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctcmVwZWF0LXkge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXk7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLWF1dG8ge1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLWNvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctY29udGFpbiB7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLWluaGVyaXQge1xcbiAgICBib3JkZXItY29sb3I6IGluaGVyaXQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci10cmFuc3BhcmVudCB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1ibGFjayB7XFxuICAgIGJvcmRlci1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLXdoaXRlIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItZ3JleS1saWdodGVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZjNmM2Y3O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItZ3JleS1saWdodCB7XFxuICAgIGJvcmRlci1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLWdyZXkge1xcbiAgICBib3JkZXItY29sb3I6ICNjMmMyYzY7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHRlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2NjYzJlOTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLXB1cnBsZS1saWdodCB7XFxuICAgIGJvcmRlci1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLXB1cnBsZSB7XFxuICAgIGJvcmRlci1jb2xvcjogIzgzNjBkNjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLXB1cnBsZS1icmlnaHQge1xcbiAgICBib3JkZXItY29sb3I6ICM0YzI5YjA7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1wdXJwbGUtZGFyayB7XFxuICAgIGJvcmRlci1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrLTEwIHtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrZXIge1xcbiAgICBib3JkZXItY29sb3I6ICMyYTI1Mzg7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpib3JkZXItaW5oZXJpdDpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJvcmRlci10cmFuc3BhcmVudDpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpib3JkZXItYmxhY2s6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICMyODI4Mjg7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpib3JkZXItd2hpdGU6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpib3JkZXItZ3JleS1saWdodGVyOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZjNmM2Y3O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6Ym9yZGVyLWdyZXktbGlnaHQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNlN2U3ZWM7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpib3JkZXItZ3JleTpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2MyYzJjNjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHRlcjpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2NjYzJlOTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM4NzgwOWI7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjODM2MGQ2O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXB1cnBsZS1icmlnaHQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM0YzI5YjA7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWRhcms6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICM0NTNmNTY7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWRhcmstMTA6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrZXI6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICMyYTI1Mzg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtbm9uZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtc20ge1xcbiAgICBib3JkZXItcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQge1xcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtZnVsbCB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cm91bmRlZC10LW5vbmUge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cm91bmRlZC1yLW5vbmUge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtYi1ub25lIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtbC1ub25lIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cm91bmRlZC10LXNtIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLXItc20ge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLWItc20ge1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtbC1zbSB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLXQge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA0cHg7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtciB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtYiB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cm91bmRlZC1sIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtdC1mdWxsIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLXItZnVsbCB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtYi1mdWxsIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDk5OTlweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLWwtZnVsbCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLXRsLW5vbmUge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLXRyLW5vbmUge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cm91bmRlZC1ici1ub25lIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtYmwtbm9uZSB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtdGwtc20ge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtdHItc20ge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLWJyLXNtIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cm91bmRlZC1ibC1zbSB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cm91bmRlZC10bCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cm91bmRlZC10ciB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtYnIge1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLWJsIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyb3VuZGVkLXRsLWZ1bGwge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtdHItZnVsbCB7XFxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtYnItZnVsbCB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvdW5kZWQtYmwtZnVsbCB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLXNvbGlkIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLWRhc2hlZCB7XFxuICAgIGJvcmRlci1zdHlsZTogZGFzaGVkO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItZG90dGVkIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBkb3R0ZWQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1ub25lIHtcXG4gICAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItMCB7XFxuICAgIGJvcmRlci13aWR0aDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLTIge1xcbiAgICBib3JkZXItd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLTQge1xcbiAgICBib3JkZXItd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLTgge1xcbiAgICBib3JkZXItd2lkdGg6IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyIHtcXG4gICAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci10LTAge1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItci0wIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItYi0wIHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLWwtMCB7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItdC0yIHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItci0yIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1iLTIge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1sLTIge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItdC00IHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItci00IHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1iLTQge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1sLTQge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItdC04IHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItci04IHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1iLTgge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1sLTgge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpib3JkZXItdCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLXIge1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ym9yZGVyLWIge1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmJvcmRlci1sIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Y3Vyc29yLWF1dG8ge1xcbiAgICBjdXJzb3I6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOmN1cnNvci1kZWZhdWx0IHtcXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpjdXJzb3ItcG9pbnRlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Y3Vyc29yLXdhaXQge1xcbiAgICBjdXJzb3I6IHdhaXQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmN1cnNvci1tb3ZlIHtcXG4gICAgY3Vyc29yOiBtb3ZlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpjdXJzb3Itbm90LWFsbG93ZWQge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpibG9jayB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgfVxcblxcbiAgLmxnXFxcXDppbmxpbmUtYmxvY2sge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB9XFxuXFxuICAubGdcXFxcOmlubGluZSB7XFxuICAgIGRpc3BsYXk6IGlubGluZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dGFibGUge1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dGFibGUtcm93IHtcXG4gICAgZGlzcGxheTogdGFibGUtcm93O1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0YWJsZS1jZWxsIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aGlkZGVuIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6ZmxleCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuXFxuICAubGdcXFxcOmlubGluZS1mbGV4IHtcXG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICB9XFxuXFxuICAubGdcXFxcOmZsZXgtcm93IHtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6ZmxleC1yb3ctcmV2ZXJzZSB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6ZmxleC1jb2wge1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmbGV4LWNvbC1yZXZlcnNlIHtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmbGV4LXdyYXAge1xcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICB9XFxuXFxuICAubGdcXFxcOmZsZXgtd3JhcC1yZXZlcnNlIHtcXG4gICAgZmxleC13cmFwOiB3cmFwLXJldmVyc2U7XFxuICB9XFxuXFxuICAubGdcXFxcOmZsZXgtbm8td3JhcCB7XFxuICAgIGZsZXgtd3JhcDogbm93cmFwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDppdGVtcy1zdGFydCB7XFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDppdGVtcy1lbmQge1xcbiAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxuICB9XFxuXFxuICAubGdcXFxcOml0ZW1zLWNlbnRlciB7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB9XFxuXFxuICAubGdcXFxcOml0ZW1zLWJhc2VsaW5lIHtcXG4gICAgYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xcbiAgfVxcblxcbiAgLmxnXFxcXDppdGVtcy1zdHJldGNoIHtcXG4gICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XFxuICB9XFxuXFxuICAubGdcXFxcOnNlbGYtYXV0byB7XFxuICAgIGFsaWduLXNlbGY6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOnNlbGYtc3RhcnQge1xcbiAgICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpzZWxmLWVuZCB7XFxuICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpzZWxmLWNlbnRlciB7XFxuICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6c2VsZi1zdHJldGNoIHtcXG4gICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6anVzdGlmeS1zdGFydCB7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6anVzdGlmeS1lbmQge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpqdXN0aWZ5LWNlbnRlciB7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpqdXN0aWZ5LWJldHdlZW4ge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB9XFxuXFxuICAubGdcXFxcOmp1c3RpZnktYXJvdW5kIHtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmNvbnRlbnQtY2VudGVyIHtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpjb250ZW50LXN0YXJ0IHtcXG4gICAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Y29udGVudC1lbmQge1xcbiAgICBhbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Y29udGVudC1iZXR3ZWVuIHtcXG4gICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Y29udGVudC1hcm91bmQge1xcbiAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmZsZXgtMSB7XFxuICAgIGZsZXg6IDE7XFxuICB9XFxuXFxuICAubGdcXFxcOmZsZXgtYXV0byB7XFxuICAgIGZsZXg6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOmZsZXgtaW5pdGlhbCB7XFxuICAgIGZsZXg6IGluaXRpYWw7XFxuICB9XFxuXFxuICAubGdcXFxcOmZsZXgtbm9uZSB7XFxuICAgIGZsZXg6IG5vbmU7XFxuICB9XFxuXFxuICAubGdcXFxcOmZsZXgtZ3JvdyB7XFxuICAgIGZsZXgtZ3JvdzogMTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6ZmxleC1zaHJpbmsge1xcbiAgICBmbGV4LXNocmluazogMTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6ZmxleC1uby1ncm93IHtcXG4gICAgZmxleC1ncm93OiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmbGV4LW5vLXNocmluayB7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmbG9hdC1yaWdodCB7XFxuICAgIGZsb2F0OiByaWdodDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6ZmxvYXQtbGVmdCB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmbG9hdC1ub25lIHtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICB9XFxuXFxuICAubGdcXFxcOmNsZWFyZml4OmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbiAgICBjbGVhcjogYm90aDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9udC1zYW5zIHtcXG4gICAgZm9udC1mYW1pbHk6IHN5c3RlbS11aSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAtYXBwbGUtc3lzdGVtLCBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCBGaXJhIFNhbnMsIERyb2lkIFNhbnMsIEhlbHZldGljYSBOZXVlLCBzYW5zLXNlcmlmO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb250LXNlcmlmIHtcXG4gICAgZm9udC1mYW1pbHk6IENvbnN0YW50aWEsIEx1Y2lkYSBCcmlnaHQsIEx1Y2lkYWJyaWdodCwgTHVjaWRhIFNlcmlmLCBMdWNpZGEsIERlamFWdSBTZXJpZiwgQml0c3RyZWFtIFZlcmEgU2VyaWYsIExpYmVyYXRpb24gU2VyaWYsIEdlb3JnaWEsIHNlcmlmO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb250LW1vbm8ge1xcbiAgICBmb250LWZhbWlseTogTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIExpYmVyYXRpb24gTW9ubywgQ291cmllciBOZXcsIG1vbm9zcGFjZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9udC1oYWlybGluZSB7XFxuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvbnQtdGhpbiB7XFxuICAgIGZvbnQtd2VpZ2h0OiAyMDA7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvbnQtbGlnaHQge1xcbiAgICBmb250LXdlaWdodDogMzAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb250LW5vcm1hbCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvbnQtbWVkaXVtIHtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9udC1zZW1pYm9sZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvbnQtYm9sZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvbnQtZXh0cmFib2xkIHtcXG4gICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9udC1ibGFjayB7XFxuICAgIGZvbnQtd2VpZ2h0OiA5MDA7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpmb250LWhhaXJsaW5lOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmZvbnQtdGhpbjpob3ZlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiAyMDA7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpmb250LWxpZ2h0OmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmZvbnQtbm9ybWFsOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmZvbnQtbWVkaXVtOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmZvbnQtc2VtaWJvbGQ6aG92ZXIge1xcbiAgICBmb250LXdlaWdodDogNjAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6Zm9udC1ib2xkOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmZvbnQtZXh0cmFib2xkOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDgwMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmZvbnQtYmxhY2s6aG92ZXIge1xcbiAgICBmb250LXdlaWdodDogOTAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpoLTAge1xcbiAgICBoZWlnaHQ6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOmgtMSB7XFxuICAgIGhlaWdodDogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpoLTIge1xcbiAgICBoZWlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aC0zIHtcXG4gICAgaGVpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmgtNCB7XFxuICAgIGhlaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aC01IHtcXG4gICAgaGVpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpoLTYge1xcbiAgICBoZWlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmgtNyB7XFxuICAgIGhlaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aC04IHtcXG4gICAgaGVpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpoLTkge1xcbiAgICBoZWlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmgtMTAge1xcbiAgICBoZWlnaHQ6IDk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOmgtc2NyZWVuIHtcXG4gICAgaGVpZ2h0OiAxMDB2aDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aC1hdXRvIHtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpoLWZ1bGwge1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOmgtcHgge1xcbiAgICBoZWlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aC0xXFxcXC82IHtcXG4gICAgaGVpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpsZWFkaW5nLW5vbmUge1xcbiAgICBsaW5lLWhlaWdodDogMTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bGVhZGluZy10aWdodCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjI1O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpsZWFkaW5nLW5vcm1hbCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICB9XFxuXFxuICAubGdcXFxcOmxlYWRpbmctbG9vc2Uge1xcbiAgICBsaW5lLWhlaWdodDogMjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bS0wIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptLTEge1xcbiAgICBtYXJnaW46IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bS0yIHtcXG4gICAgbWFyZ2luOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm0tMyB7XFxuICAgIG1hcmdpbjogOHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptLTQge1xcbiAgICBtYXJnaW46IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm0tNSB7XFxuICAgIG1hcmdpbjogMjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bS02IHtcXG4gICAgbWFyZ2luOiAzMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptLTcge1xcbiAgICBtYXJnaW46IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm0tOCB7XFxuICAgIG1hcmdpbjogNDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bS05IHtcXG4gICAgbWFyZ2luOiA2NHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptLTEwIHtcXG4gICAgbWFyZ2luOiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptLWF1dG8ge1xcbiAgICBtYXJnaW46IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOm0tZnVsbCB7XFxuICAgIG1hcmdpbjogMTAwJTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bS1weCB7XFxuICAgIG1hcmdpbjogMXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptLTFcXFxcLzYge1xcbiAgICBtYXJnaW46IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOm15LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteC0wIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXktMSB7XFxuICAgIG1hcmdpbi10b3A6IDJweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteC0xIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDJweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm15LTIge1xcbiAgICBtYXJnaW4tdG9wOiA0cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXgtMiB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteS0zIHtcXG4gICAgbWFyZ2luLXRvcDogOHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm14LTMge1xcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXktNCB7XFxuICAgIG1hcmdpbi10b3A6IDE2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm14LTQge1xcbiAgICBtYXJnaW4tbGVmdDogMTZweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteS01IHtcXG4gICAgbWFyZ2luLXRvcDogMjRweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXgtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAyNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm15LTYge1xcbiAgICBtYXJnaW4tdG9wOiAzMnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAzMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteC02IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDMycHg7XFxuICAgIG1hcmdpbi1yaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXktNyB7XFxuICAgIG1hcmdpbi10b3A6IDM2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm14LTcge1xcbiAgICBtYXJnaW4tbGVmdDogMzZweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAzNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteS04IHtcXG4gICAgbWFyZ2luLXRvcDogNDhweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogNDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXgtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0OHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm15LTkge1xcbiAgICBtYXJnaW4tdG9wOiA2NHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA2NHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteC05IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDY0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXktMTAge1xcbiAgICBtYXJnaW4tdG9wOiA5NnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteC0xMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA5NnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm15LWF1dG8ge1xcbiAgICBtYXJnaW4tdG9wOiBhdXRvO1xcbiAgICBtYXJnaW4tYm90dG9tOiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteC1hdXRvIHtcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXktZnVsbCB7XFxuICAgIG1hcmdpbi10b3A6IDEwMCU7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOm14LWZ1bGwge1xcbiAgICBtYXJnaW4tbGVmdDogMTAwJTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteS1weCB7XFxuICAgIG1hcmdpbi10b3A6IDFweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteC1weCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxcHg7XFxuICAgIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpteS0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXRvcDogMTYuNjY2NjY2NjY3JTtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXgtMVxcXFwvNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOm10LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptci0wIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYi0wIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWwtMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC0xIHtcXG4gICAgbWFyZ2luLXRvcDogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptci0xIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1iLTEge1xcbiAgICBtYXJnaW4tYm90dG9tOiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1sLTEge1xcbiAgICBtYXJnaW4tbGVmdDogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC0yIHtcXG4gICAgbWFyZ2luLXRvcDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptci0yIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1iLTIge1xcbiAgICBtYXJnaW4tYm90dG9tOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1sLTIge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC0zIHtcXG4gICAgbWFyZ2luLXRvcDogOHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptci0zIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1iLTMge1xcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1sLTMge1xcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC00IHtcXG4gICAgbWFyZ2luLXRvcDogMTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXItNCB7XFxuICAgIG1hcmdpbi1yaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWItNCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1sLTQge1xcbiAgICBtYXJnaW4tbGVmdDogMTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXQtNSB7XFxuICAgIG1hcmdpbi10b3A6IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1yLTUge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1iLTUge1xcbiAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptbC01IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm10LTYge1xcbiAgICBtYXJnaW4tdG9wOiAzMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptci02IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAzMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYi02IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWwtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAzMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC03IHtcXG4gICAgbWFyZ2luLXRvcDogMzZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXItNyB7XFxuICAgIG1hcmdpbi1yaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWItNyB7XFxuICAgIG1hcmdpbi1ib3R0b206IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1sLTcge1xcbiAgICBtYXJnaW4tbGVmdDogMzZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXQtOCB7XFxuICAgIG1hcmdpbi10b3A6IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1yLTgge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1iLTgge1xcbiAgICBtYXJnaW4tYm90dG9tOiA0OHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptbC04IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm10LTkge1xcbiAgICBtYXJnaW4tdG9wOiA2NHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptci05IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA2NHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYi05IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWwtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA2NHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC0xMCB7XFxuICAgIG1hcmdpbi10b3A6IDk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1yLTEwIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYi0xMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1sLTEwIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm10LWF1dG8ge1xcbiAgICBtYXJnaW4tdG9wOiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptci1hdXRvIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYi1hdXRvIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWwtYXV0byB7XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptdC1mdWxsIHtcXG4gICAgbWFyZ2luLXRvcDogMTAwJTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXItZnVsbCB7XFxuICAgIG1hcmdpbi1yaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWItZnVsbCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOm1sLWZ1bGwge1xcbiAgICBtYXJnaW4tbGVmdDogMTAwJTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bXQtcHgge1xcbiAgICBtYXJnaW4tdG9wOiAxcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1yLXB4IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1iLXB4IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptbC1weCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm10LTFcXFxcLzYge1xcbiAgICBtYXJnaW4tdG9wOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptci0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYi0xXFxcXC82IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWwtMVxcXFwvNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtaC0wIHtcXG4gICAgbWF4LWhlaWdodDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LWgtMSB7XFxuICAgIG1heC1oZWlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LWgtMiB7XFxuICAgIG1heC1oZWlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LWgtMyB7XFxuICAgIG1heC1oZWlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LWgtNCB7XFxuICAgIG1heC1oZWlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC1oLTUge1xcbiAgICBtYXgtaGVpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtaC02IHtcXG4gICAgbWF4LWhlaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LWgtNyB7XFxuICAgIG1heC1oZWlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC1oLTgge1xcbiAgICBtYXgtaGVpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtaC05IHtcXG4gICAgbWF4LWhlaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LWgtMTAge1xcbiAgICBtYXgtaGVpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtaC1zY3JlZW4ge1xcbiAgICBtYXgtaGVpZ2h0OiAxMDB2aDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LWgtYXV0byB7XFxuICAgIG1heC1oZWlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC1oLWZ1bGwge1xcbiAgICBtYXgtaGVpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtaC1weCB7XFxuICAgIG1heC1oZWlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LWgtMVxcXFwvNiB7XFxuICAgIG1heC1oZWlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC13LTAge1xcbiAgICBtYXgtd2lkdGg6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC13LTEge1xcbiAgICBtYXgtd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWF4LXctMiB7XFxuICAgIG1heC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtdy0zIHtcXG4gICAgbWF4LXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC13LTQge1xcbiAgICBtYXgtd2lkdGg6IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC13LTUge1xcbiAgICBtYXgtd2lkdGg6IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC13LTYge1xcbiAgICBtYXgtd2lkdGg6IDMycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC13LTcge1xcbiAgICBtYXgtd2lkdGg6IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC13LTgge1xcbiAgICBtYXgtd2lkdGg6IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC13LTkge1xcbiAgICBtYXgtd2lkdGg6IDY0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1heC13LTEwIHtcXG4gICAgbWF4LXdpZHRoOiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtdy1hdXRvIHtcXG4gICAgbWF4LXdpZHRoOiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtdy1mdWxsIHtcXG4gICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtdy1weCB7XFxuICAgIG1heC13aWR0aDogMXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptYXgtdy0xXFxcXC82IHtcXG4gICAgbWF4LXdpZHRoOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4taC0wIHtcXG4gICAgbWluLWhlaWdodDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWluLWgtMSB7XFxuICAgIG1pbi1oZWlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWluLWgtMiB7XFxuICAgIG1pbi1oZWlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWluLWgtMyB7XFxuICAgIG1pbi1oZWlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWluLWgtNCB7XFxuICAgIG1pbi1oZWlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi1oLTUge1xcbiAgICBtaW4taGVpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4taC02IHtcXG4gICAgbWluLWhlaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWluLWgtNyB7XFxuICAgIG1pbi1oZWlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi1oLTgge1xcbiAgICBtaW4taGVpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4taC05IHtcXG4gICAgbWluLWhlaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWluLWgtMTAge1xcbiAgICBtaW4taGVpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4taC1zY3JlZW4ge1xcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWluLWgtYXV0byB7XFxuICAgIG1pbi1oZWlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi1oLWZ1bGwge1xcbiAgICBtaW4taGVpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4taC1weCB7XFxuICAgIG1pbi1oZWlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWluLWgtMVxcXFwvNiB7XFxuICAgIG1pbi1oZWlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi13LTAge1xcbiAgICBtaW4td2lkdGg6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi13LTEge1xcbiAgICBtaW4td2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bWluLXctMiB7XFxuICAgIG1pbi13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4tdy0zIHtcXG4gICAgbWluLXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi13LTQge1xcbiAgICBtaW4td2lkdGg6IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi13LTUge1xcbiAgICBtaW4td2lkdGg6IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi13LTYge1xcbiAgICBtaW4td2lkdGg6IDMycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi13LTcge1xcbiAgICBtaW4td2lkdGg6IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi13LTgge1xcbiAgICBtaW4td2lkdGg6IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi13LTkge1xcbiAgICBtaW4td2lkdGg6IDY0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOm1pbi13LTEwIHtcXG4gICAgbWluLXdpZHRoOiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4tdy1hdXRvIHtcXG4gICAgbWluLXdpZHRoOiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4tdy1mdWxsIHtcXG4gICAgbWluLXdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4tdy1weCB7XFxuICAgIG1pbi13aWR0aDogMXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDptaW4tdy0xXFxcXC82IHtcXG4gICAgbWluLXdpZHRoOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbS0wIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbS0xIHtcXG4gICAgbWFyZ2luOiAtMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbS0yIHtcXG4gICAgbWFyZ2luOiAtNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbS0zIHtcXG4gICAgbWFyZ2luOiAtOHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbS00IHtcXG4gICAgbWFyZ2luOiAtMTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW0tNSB7XFxuICAgIG1hcmdpbjogLTI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tLTYge1xcbiAgICBtYXJnaW46IC0zMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbS03IHtcXG4gICAgbWFyZ2luOiAtMzZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW0tOCB7XFxuICAgIG1hcmdpbjogLTQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tLTkge1xcbiAgICBtYXJnaW46IC02NHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbS0xMCB7XFxuICAgIG1hcmdpbjogLTk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tLWF1dG8ge1xcbiAgICBtYXJnaW46IC1hdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbS1mdWxsIHtcXG4gICAgbWFyZ2luOiAtMTAwJTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW0tcHgge1xcbiAgICBtYXJnaW46IC0xcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tLTFcXFxcLzYge1xcbiAgICBtYXJnaW46IC0xNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXktMCB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOi1teC0wIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW15LTEge1xcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXgtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0ycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1teS0yIHtcXG4gICAgbWFyZ2luLXRvcDogLTRweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW14LTIge1xcbiAgICBtYXJnaW4tbGVmdDogLTRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXktMyB7XFxuICAgIG1hcmdpbi10b3A6IC04cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC04cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1teC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC04cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLThweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW15LTQge1xcbiAgICBtYXJnaW4tdG9wOiAtMTZweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1teC00IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xNnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXktNSB7XFxuICAgIG1hcmdpbi10b3A6IC0yNHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW14LTUge1xcbiAgICBtYXJnaW4tbGVmdDogLTI0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1teS02IHtcXG4gICAgbWFyZ2luLXRvcDogLTMycHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXgtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzJweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW15LTcge1xcbiAgICBtYXJnaW4tdG9wOiAtMzZweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1teC03IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0zNnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0zNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXktOCB7XFxuICAgIG1hcmdpbi10b3A6IC00OHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtNDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW14LTgge1xcbiAgICBtYXJnaW4tbGVmdDogLTQ4cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1teS05IHtcXG4gICAgbWFyZ2luLXRvcDogLTY0cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC02NHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXgtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNjRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW15LTEwIHtcXG4gICAgbWFyZ2luLXRvcDogLTk2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC05NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXgtMTAge1xcbiAgICBtYXJnaW4tbGVmdDogLTk2cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1teS1hdXRvIHtcXG4gICAgbWFyZ2luLXRvcDogLWF1dG87XFxuICAgIG1hcmdpbi1ib3R0b206IC1hdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXgtYXV0byB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtYXV0bztcXG4gICAgbWFyZ2luLXJpZ2h0OiAtYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW15LWZ1bGwge1xcbiAgICBtYXJnaW4tdG9wOiAtMTAwJTtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOi1teC1mdWxsIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xMDAlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xMDAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXktcHgge1xcbiAgICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXgtcHgge1xcbiAgICBtYXJnaW4tbGVmdDogLTFweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXktMVxcXFwvNiB7XFxuICAgIG1hcmdpbi10b3A6IC0xNi42NjY2NjY2NjclO1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW14LTFcXFxcLzYge1xcbiAgICBtYXJnaW4tbGVmdDogLTE2LjY2NjY2NjY2NyU7XFxuICAgIG1hcmdpbi1yaWdodDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tdC0wIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1yLTAge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tYi0wIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1sLTAge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW10LTEge1xcbiAgICBtYXJnaW4tdG9wOiAtMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXItMSB7XFxuICAgIG1hcmdpbi1yaWdodDogLTJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1iLTEge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWwtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbXQtMiB7XFxuICAgIG1hcmdpbi10b3A6IC00cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tci0yIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWItMiB7XFxuICAgIG1hcmdpbi1ib3R0b206IC00cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tbC0yIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tdC0zIHtcXG4gICAgbWFyZ2luLXRvcDogLThweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1yLTMge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC04cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tYi0zIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLThweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1sLTMge1xcbiAgICBtYXJnaW4tbGVmdDogLThweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW10LTQge1xcbiAgICBtYXJnaW4tdG9wOiAtMTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1yLTQge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWItNCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0xNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWwtNCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW10LTUge1xcbiAgICBtYXJnaW4tdG9wOiAtMjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1yLTUge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0yNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWItNSB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0yNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWwtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW10LTYge1xcbiAgICBtYXJnaW4tdG9wOiAtMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1yLTYge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0zMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWItNiB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWwtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW10LTcge1xcbiAgICBtYXJnaW4tdG9wOiAtMzZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1yLTcge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0zNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWItNyB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWwtNyB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW10LTgge1xcbiAgICBtYXJnaW4tdG9wOiAtNDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1yLTgge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC00OHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWItOCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC00OHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWwtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW10LTkge1xcbiAgICBtYXJnaW4tdG9wOiAtNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1yLTkge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC02NHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWItOSB7XFxuICAgIG1hcmdpbi1ib3R0b206IC02NHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWwtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW10LTEwIHtcXG4gICAgbWFyZ2luLXRvcDogLTk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tci0xMCB7XFxuICAgIG1hcmdpbi1yaWdodDogLTk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tYi0xMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC05NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDotbWwtMTAge1xcbiAgICBtYXJnaW4tbGVmdDogLTk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tdC1hdXRvIHtcXG4gICAgbWFyZ2luLXRvcDogLWF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOi1tci1hdXRvIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1iLWF1dG8ge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1sLWF1dG8ge1xcbiAgICBtYXJnaW4tbGVmdDogLWF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOi1tdC1mdWxsIHtcXG4gICAgbWFyZ2luLXRvcDogLTEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tci1mdWxsIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMTAwJTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1iLWZ1bGwge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTAwJTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1sLWZ1bGwge1xcbiAgICBtYXJnaW4tbGVmdDogLTEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tdC1weCB7XFxuICAgIG1hcmdpbi10b3A6IC0xcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tci1weCB7XFxuICAgIG1hcmdpbi1yaWdodDogLTFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1iLXB4IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1sLXB4IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tdC0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXRvcDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOi1tci0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1iLTFcXFxcLzYge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6LW1sLTFcXFxcLzYge1xcbiAgICBtYXJnaW4tbGVmdDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOm9wYWNpdHktMCB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOm9wYWNpdHktMjUge1xcbiAgICBvcGFjaXR5OiAuMjU7XFxuICB9XFxuXFxuICAubGdcXFxcOm9wYWNpdHktNTAge1xcbiAgICBvcGFjaXR5OiAuNTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6b3BhY2l0eS03NSB7XFxuICAgIG9wYWNpdHk6IC43NTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6b3BhY2l0eS0xMDAge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpvdmVyZmxvdy1hdXRvIHtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOm92ZXJmbG93LWhpZGRlbiB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICB9XFxuXFxuICAubGdcXFxcOm92ZXJmbG93LXZpc2libGUge1xcbiAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6b3ZlcmZsb3ctc2Nyb2xsIHtcXG4gICAgb3ZlcmZsb3c6IHNjcm9sbDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6b3ZlcmZsb3cteC1hdXRvIHtcXG4gICAgb3ZlcmZsb3cteDogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6b3ZlcmZsb3cteS1hdXRvIHtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6b3ZlcmZsb3cteC1oaWRkZW4ge1xcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XFxuICB9XFxuXFxuICAubGdcXFxcOm92ZXJmbG93LXktaGlkZGVuIHtcXG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpvdmVyZmxvdy14LXZpc2libGUge1xcbiAgICBvdmVyZmxvdy14OiB2aXNpYmxlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpvdmVyZmxvdy15LXZpc2libGUge1xcbiAgICBvdmVyZmxvdy15OiB2aXNpYmxlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpvdmVyZmxvdy14LXNjcm9sbCB7XFxuICAgIG92ZXJmbG93LXg6IHNjcm9sbDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6b3ZlcmZsb3cteS1zY3JvbGwge1xcbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XFxuICB9XFxuXFxuICAubGdcXFxcOnNjcm9sbGluZy10b3VjaCB7XFxuICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6c2Nyb2xsaW5nLWF1dG8ge1xcbiAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cC0wIHtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cC0xIHtcXG4gICAgcGFkZGluZzogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwLTIge1xcbiAgICBwYWRkaW5nOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnAtMyB7XFxuICAgIHBhZGRpbmc6IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cC00IHtcXG4gICAgcGFkZGluZzogMTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cC01IHtcXG4gICAgcGFkZGluZzogMjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cC02IHtcXG4gICAgcGFkZGluZzogMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cC03IHtcXG4gICAgcGFkZGluZzogMzZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cC04IHtcXG4gICAgcGFkZGluZzogNDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cC05IHtcXG4gICAgcGFkZGluZzogNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cC0xMCB7XFxuICAgIHBhZGRpbmc6IDk2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnAtYXV0byB7XFxuICAgIHBhZGRpbmc6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOnAtZnVsbCB7XFxuICAgIHBhZGRpbmc6IDEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOnAtcHgge1xcbiAgICBwYWRkaW5nOiAxcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnAtMVxcXFwvNiB7XFxuICAgIHBhZGRpbmc6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTAge1xcbiAgICBwYWRkaW5nLXRvcDogMDtcXG4gICAgcGFkZGluZy1ib3R0b206IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTAge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTEge1xcbiAgICBwYWRkaW5nLXRvcDogMnB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC0xIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAycHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHktMiB7XFxuICAgIHBhZGRpbmctdG9wOiA0cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTIge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDRweDtcXG4gICAgcGFkZGluZy1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweS0zIHtcXG4gICAgcGFkZGluZy10b3A6IDhweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHgtMyB7XFxuICAgIHBhZGRpbmctbGVmdDogOHB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTQge1xcbiAgICBwYWRkaW5nLXRvcDogMTZweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTQge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDE2cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTUge1xcbiAgICBwYWRkaW5nLXRvcDogMjRweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTUge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDI0cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTYge1xcbiAgICBwYWRkaW5nLXRvcDogMzJweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDMycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTYge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDMycHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTcge1xcbiAgICBwYWRkaW5nLXRvcDogMzZweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTcge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDM2cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTgge1xcbiAgICBwYWRkaW5nLXRvcDogNDhweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDQ4cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTkge1xcbiAgICBwYWRkaW5nLXRvcDogNjRweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDY0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTkge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDY0cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTEwIHtcXG4gICAgcGFkZGluZy10b3A6IDk2cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC0xMCB7XFxuICAgIHBhZGRpbmctbGVmdDogOTZweDtcXG4gICAgcGFkZGluZy1yaWdodDogOTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHktYXV0byB7XFxuICAgIHBhZGRpbmctdG9wOiBhdXRvO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHgtYXV0byB7XFxuICAgIHBhZGRpbmctbGVmdDogYXV0bztcXG4gICAgcGFkZGluZy1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHktZnVsbCB7XFxuICAgIHBhZGRpbmctdG9wOiAxMDAlO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMTAwJTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHgtZnVsbCB7XFxuICAgIHBhZGRpbmctbGVmdDogMTAwJTtcXG4gICAgcGFkZGluZy1yaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHktcHgge1xcbiAgICBwYWRkaW5nLXRvcDogMXB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMXB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpweC1weCB7XFxuICAgIHBhZGRpbmctbGVmdDogMXB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB5LTFcXFxcLzYge1xcbiAgICBwYWRkaW5nLXRvcDogMTYuNjY2NjY2NjY3JTtcXG4gICAgcGFkZGluZy1ib3R0b206IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOnB4LTFcXFxcLzYge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDE2LjY2NjY2NjY2NyU7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOnB0LTAge1xcbiAgICBwYWRkaW5nLXRvcDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHItMCB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnBiLTAge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGwtMCB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHQtMSB7XFxuICAgIHBhZGRpbmctdG9wOiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnByLTEge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnBiLTEge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwbC0xIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB0LTIge1xcbiAgICBwYWRkaW5nLXRvcDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwci0yIHtcXG4gICAgcGFkZGluZy1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwYi0yIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGwtMiB7XFxuICAgIHBhZGRpbmctbGVmdDogNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwdC0zIHtcXG4gICAgcGFkZGluZy10b3A6IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHItMyB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGItMyB7XFxuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnBsLTMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHQtNCB7XFxuICAgIHBhZGRpbmctdG9wOiAxNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwci00IHtcXG4gICAgcGFkZGluZy1yaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGItNCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwbC00IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwdC01IHtcXG4gICAgcGFkZGluZy10b3A6IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnByLTUge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwYi01IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnBsLTUge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDI0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB0LTYge1xcbiAgICBwYWRkaW5nLXRvcDogMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHItNiB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnBiLTYge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGwtNiB7XFxuICAgIHBhZGRpbmctbGVmdDogMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHQtNyB7XFxuICAgIHBhZGRpbmctdG9wOiAzNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwci03IHtcXG4gICAgcGFkZGluZy1yaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGItNyB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAzNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwbC03IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAzNnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwdC04IHtcXG4gICAgcGFkZGluZy10b3A6IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnByLTgge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwYi04IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnBsLTgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDQ4cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnB0LTkge1xcbiAgICBwYWRkaW5nLXRvcDogNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHItOSB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnBiLTkge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGwtOSB7XFxuICAgIHBhZGRpbmctbGVmdDogNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHQtMTAge1xcbiAgICBwYWRkaW5nLXRvcDogOTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHItMTAge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwYi0xMCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwbC0xMCB7XFxuICAgIHBhZGRpbmctbGVmdDogOTZweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHQtYXV0byB7XFxuICAgIHBhZGRpbmctdG9wOiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwci1hdXRvIHtcXG4gICAgcGFkZGluZy1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGItYXV0byB7XFxuICAgIHBhZGRpbmctYm90dG9tOiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwbC1hdXRvIHtcXG4gICAgcGFkZGluZy1sZWZ0OiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwdC1mdWxsIHtcXG4gICAgcGFkZGluZy10b3A6IDEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOnByLWZ1bGwge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwYi1mdWxsIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOnBsLWZ1bGwge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEwMCU7XFxuICB9XFxuXFxuICAubGdcXFxcOnB0LXB4IHtcXG4gICAgcGFkZGluZy10b3A6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHItcHgge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnBiLXB4IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGwtcHgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cHQtMVxcXFwvNiB7XFxuICAgIHBhZGRpbmctdG9wOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwci0xXFxcXC82IHtcXG4gICAgcGFkZGluZy1yaWdodDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGItMVxcXFwvNiB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwbC0xXFxcXC82IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwb2ludGVyLWV2ZW50cy1ub25lIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICB9XFxuXFxuICAubGdcXFxcOnBvaW50ZXItZXZlbnRzLWF1dG8ge1xcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6c3RhdGljIHtcXG4gICAgcG9zaXRpb246IHN0YXRpYztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zml4ZWQge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmFic29sdXRlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyZWxhdGl2ZSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6c3RpY2t5IHtcXG4gICAgcG9zaXRpb246IHN0aWNreTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGluLW5vbmUge1xcbiAgICB0b3A6IGF1dG87XFxuICAgIHJpZ2h0OiBhdXRvO1xcbiAgICBib3R0b206IGF1dG87XFxuICAgIGxlZnQ6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOnBpbiB7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGluLXkge1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGluLXgge1xcbiAgICByaWdodDogMDtcXG4gICAgbGVmdDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6cGluLXQge1xcbiAgICB0b3A6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnBpbi1yIHtcXG4gICAgcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnBpbi1iIHtcXG4gICAgYm90dG9tOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpwaW4tbCB7XFxuICAgIGxlZnQ6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnJlc2l6ZS1ub25lIHtcXG4gICAgcmVzaXplOiBub25lO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyZXNpemUteSB7XFxuICAgIHJlc2l6ZTogdmVydGljYWw7XFxuICB9XFxuXFxuICAubGdcXFxcOnJlc2l6ZS14IHtcXG4gICAgcmVzaXplOiBob3Jpem9udGFsO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpyZXNpemUge1xcbiAgICByZXNpemU6IGJvdGg7XFxuICB9XFxuXFxuICAubGdcXFxcOnNoYWRvdyB7XFxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCAwIHJnYmEoMCwgMCwgMCwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpzaGFkb3ctbWQge1xcbiAgICBib3gtc2hhZG93OiAgMCA4cHggMjBweCAwIHJnYmEoMCwgMCwgMCwgLjQyKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6c2hhZG93LW5vbmUge1xcbiAgICBib3gtc2hhZG93OiBub25lO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0YWJsZS1hdXRvIHtcXG4gICAgdGFibGUtbGF5b3V0OiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0YWJsZS1maXhlZCB7XFxuICAgIHRhYmxlLWxheW91dDogZml4ZWQ7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtbGVmdCB7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtY2VudGVyIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0ZXh0LXJpZ2h0IHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtanVzdGlmeSB7XFxuICAgIHRleHQtYWxpZ246IGp1c3RpZnk7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtaW5oZXJpdCB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0ZXh0LXRyYW5zcGFyZW50IHtcXG4gICAgY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0ZXh0LWJsYWNrIHtcXG4gICAgY29sb3I6ICMyODI4Mjg7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtd2hpdGUge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dGV4dC1ncmV5LWxpZ2h0ZXIge1xcbiAgICBjb2xvcjogI2YzZjNmNztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dGV4dC1ncmV5LWxpZ2h0IHtcXG4gICAgY29sb3I6ICNlN2U3ZWM7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtZ3JleSB7XFxuICAgIGNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0ZXh0LXB1cnBsZS1saWdodGVyIHtcXG4gICAgY29sb3I6ICNjY2MyZTk7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtcHVycGxlLWxpZ2h0IHtcXG4gICAgY29sb3I6ICM4NzgwOWI7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtcHVycGxlIHtcXG4gICAgY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtcHVycGxlLWJyaWdodCB7XFxuICAgIGNvbG9yOiAjNGMyOWIwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0ZXh0LXB1cnBsZS1kYXJrIHtcXG4gICAgY29sb3I6ICM0NTNmNTY7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtcHVycGxlLWRhcmstMTAge1xcbiAgICBjb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtcHVycGxlLWRhcmtlciB7XFxuICAgIGNvbG9yOiAjMmEyNTM4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6dGV4dC1pbmhlcml0OmhvdmVyIHtcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDp0ZXh0LXRyYW5zcGFyZW50OmhvdmVyIHtcXG4gICAgY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6dGV4dC1ibGFjazpob3ZlciB7XFxuICAgIGNvbG9yOiAjMjgyODI4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6dGV4dC13aGl0ZTpob3ZlciB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6dGV4dC1ncmV5LWxpZ2h0ZXI6aG92ZXIge1xcbiAgICBjb2xvcjogI2YzZjNmNztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOnRleHQtZ3JleS1saWdodDpob3ZlciB7XFxuICAgIGNvbG9yOiAjZTdlN2VjO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6dGV4dC1ncmV5OmhvdmVyIHtcXG4gICAgY29sb3I6ICNjMmMyYzY7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDp0ZXh0LXB1cnBsZS1saWdodGVyOmhvdmVyIHtcXG4gICAgY29sb3I6ICNjY2MyZTk7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDp0ZXh0LXB1cnBsZS1saWdodDpob3ZlciB7XFxuICAgIGNvbG9yOiAjODc4MDliO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGU6aG92ZXIge1xcbiAgICBjb2xvcjogIzgzNjBkNjtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOnRleHQtcHVycGxlLWJyaWdodDpob3ZlciB7XFxuICAgIGNvbG9yOiAjNGMyOWIwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGUtZGFyazpob3ZlciB7XFxuICAgIGNvbG9yOiAjNDUzZjU2O1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICAgIGNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOnRleHQtcHVycGxlLWRhcmtlcjpob3ZlciB7XFxuICAgIGNvbG9yOiAjMmEyNTM4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0ZXh0LXNtIHtcXG4gICAgZm9udC1zaXplOiAxLjRyZW07XFxuICB9XFxuXFxuICAubGdcXFxcOnRleHQtYmFzZSB7XFxuICAgIGZvbnQtc2l6ZTogMS42cmVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDppdGFsaWMge1xcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICB9XFxuXFxuICAubGdcXFxcOnJvbWFuIHtcXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp1cHBlcmNhc2Uge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpsb3dlcmNhc2Uge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogbG93ZXJjYXNlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpjYXBpdGFsaXplIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IGNhcGl0YWxpemU7XFxuICB9XFxuXFxuICAubGdcXFxcOm5vcm1hbC1jYXNlIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxuXFxuICAubGdcXFxcOnVuZGVybGluZSB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpsaW5lLXRocm91Z2gge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6bm8tdW5kZXJsaW5lIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgfVxcblxcbiAgLmxnXFxcXDphbnRpYWxpYXNlZCB7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpzdWJwaXhlbC1hbnRpYWxpYXNlZCB7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGF1dG87XFxuICAgIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6aXRhbGljOmhvdmVyIHtcXG4gICAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6cm9tYW46aG92ZXIge1xcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDp1cHBlcmNhc2U6aG92ZXIge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6bG93ZXJjYXNlOmhvdmVyIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IGxvd2VyY2FzZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmNhcGl0YWxpemU6aG92ZXIge1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOm5vcm1hbC1jYXNlOmhvdmVyIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDp1bmRlcmxpbmU6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmxpbmUtdGhyb3VnaDpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6bm8tdW5kZXJsaW5lOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YW50aWFsaWFzZWQ6aG92ZXIge1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOnN1YnBpeGVsLWFudGlhbGlhc2VkOmhvdmVyIHtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYXV0bztcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOnRyYWNraW5nLXRpZ2h0IHtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IC0wLjA1ZW07XFxuICB9XFxuXFxuICAubGdcXFxcOnRyYWNraW5nLW5vcm1hbCB7XFxuICAgIGxldHRlci1zcGFjaW5nOiAwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0cmFja2luZy13aWRlIHtcXG4gICAgbGV0dGVyLXNwYWNpbmc6IC4wNWVtO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpzZWxlY3Qtbm9uZSB7XFxuICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpzZWxlY3QtdGV4dCB7XFxuICAgIHVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgfVxcblxcbiAgLmxnXFxcXDphbGlnbi1iYXNlbGluZSB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YWxpZ24tdG9wIHtcXG4gICAgdmVydGljYWwtYWxpZ246IHRvcDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YWxpZ24tbWlkZGxlIHtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YWxpZ24tYm90dG9tIHtcXG4gICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YWxpZ24tdGV4dC10b3Age1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdGV4dC10b3A7XFxuICB9XFxuXFxuICAubGdcXFxcOmFsaWduLXRleHQtYm90dG9tIHtcXG4gICAgdmVydGljYWwtYWxpZ246IHRleHQtYm90dG9tO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp2aXNpYmxlIHtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aW52aXNpYmxlIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3aGl0ZXNwYWNlLW5vcm1hbCB7XFxuICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICB9XFxuXFxuICAubGdcXFxcOndoaXRlc3BhY2Utbm8td3JhcCB7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICB9XFxuXFxuICAubGdcXFxcOndoaXRlc3BhY2UtcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6d2hpdGVzcGFjZS1wcmUtbGluZSB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtbGluZTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6d2hpdGVzcGFjZS1wcmUtd3JhcCB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YnJlYWstd29yZHMge1xcbiAgICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICB9XFxuXFxuICAubGdcXFxcOmJyZWFrLW5vcm1hbCB7XFxuICAgIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp0cnVuY2F0ZSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LTAge1xcbiAgICB3aWR0aDogMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dy0xIHtcXG4gICAgd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dy0yIHtcXG4gICAgd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dy0zIHtcXG4gICAgd2lkdGg6IDhweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dy00IHtcXG4gICAgd2lkdGg6IDE2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnctNSB7XFxuICAgIHdpZHRoOiAyNHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LTYge1xcbiAgICB3aWR0aDogMzJweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dy03IHtcXG4gICAgd2lkdGg6IDM2cHg7XFxuICB9XFxuXFxuICAubGdcXFxcOnctOCB7XFxuICAgIHdpZHRoOiA0OHB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LTkge1xcbiAgICB3aWR0aDogNjRweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dy0xMCB7XFxuICAgIHdpZHRoOiA5NnB4O1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LXNjcmVlbiB7XFxuICAgIHdpZHRoOiAxMDB2dztcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dy1hdXRvIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICB9XFxuXFxuICAubGdcXFxcOnctZnVsbCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp3LXB4IHtcXG4gICAgd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6dy0xXFxcXC82IHtcXG4gICAgd2lkdGg6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAubGdcXFxcOnotMCB7XFxuICAgIHotaW5kZXg6IDA7XFxuICB9XFxuXFxuICAubGdcXFxcOnotMTAge1xcbiAgICB6LWluZGV4OiAxMDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6ei0yMCB7XFxuICAgIHotaW5kZXg6IDIwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp6LTMwIHtcXG4gICAgei1pbmRleDogMzA7XFxuICB9XFxuXFxuICAubGdcXFxcOnotNDAge1xcbiAgICB6LWluZGV4OiA0MDtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6ei01MCB7XFxuICAgIHotaW5kZXg6IDUwO1xcbiAgfVxcblxcbiAgLmxnXFxcXDp6LWF1dG8ge1xcbiAgICB6LWluZGV4OiBhdXRvO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1ibGFjay0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDAsIDQwLCA0MCwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy13aGl0ZS0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctZ3JleS1saWdodC0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjMxLCAyMzEsIDIzNiwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1ncmV5LTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLXB1cnBsZS1saWdodGVyLTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLXB1cnBsZS1saWdodC0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTM1LCAxMjgsIDE1NSwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtZGFyay0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtZGFya2VyLTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpiZy1ibGFjay0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDAsIDQwLCA0MCwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6Ymctd2hpdGUtMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHRlci0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQzLCAyNDMsIDI0NywgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctZ3JleS1saWdodC0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjMxLCAyMzEsIDIzNiwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctZ3JleS0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0ZXItMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwNCwgMTk0LCAyMzMsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodC0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTM1LCAxMjgsIDE1NSwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLTEwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1icmlnaHQtMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDc2LCA0MSwgMTc2LCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWRhcmtlci0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb2N1c1xcXFw6YmctYmxhY2stMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLXdoaXRlLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLWdyZXktbGlnaHQtMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLWdyZXktMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1saWdodGVyLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtbGlnaHQtMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS0xMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMSk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjEpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWRhcmstMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrZXItMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4xKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctYmxhY2stMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Ymctd2hpdGUtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctZ3JleS1saWdodGVyLTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmJnLWdyZXktbGlnaHQtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctZ3JleS0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjMpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjMpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpiZy1wdXJwbGUtbGlnaHQtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctcHVycGxlLTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctcHVycGxlLWJyaWdodC0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctcHVycGxlLWRhcmstMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6YmctcHVycGxlLWRhcmtlci0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjMpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctYmxhY2stMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXdoaXRlLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHQtMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLWdyZXktMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodGVyLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtbGlnaHQtMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS0zMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjMpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWRhcmstMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrZXItMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLWJsYWNrLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MCwgNDAsIDQwLCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy13aGl0ZS0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjMpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb2N1c1xcXFw6YmctZ3JleS1saWdodGVyLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0LTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzEsIDIzMSwgMjM2LCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjMpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0LTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzUsIDEyOCwgMTU1LCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtMzA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjMpO1xcbiAgfVxcblxcbiAgLmxnXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWJyaWdodC0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4zKTtcXG4gIH1cXG5cXG4gIC5sZ1xcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMyk7XFxuICB9XFxuXFxuICAubGdcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFya2VyLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMyk7XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjAwcHgpIHtcXG4gIC54bFxcXFw6bGlzdC1yZXNldCB7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmFwcGVhcmFuY2Utbm9uZSB7XFxuICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLWZpeGVkIHtcXG4gICAgYmFja2dyb3VuZC1hdHRhY2htZW50OiBmaXhlZDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctbG9jYWwge1xcbiAgICBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6IGxvY2FsO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1zY3JvbGwge1xcbiAgICBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6IHNjcm9sbDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctaW5oZXJpdCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXRyYW5zcGFyZW50IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLWJsYWNrIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ymctd2hpdGUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1ncmV5LWxpZ2h0ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmM2Y3O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1ncmV5LWxpZ2h0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctZ3JleSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNjMmMyYzY7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXB1cnBsZS1saWdodGVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYzJlOTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLWxpZ2h0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzgzNjBkNjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLWJyaWdodCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM0YzI5YjA7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXB1cnBsZS1kYXJrIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLWRhcmstMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLWRhcmtlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyYTI1Mzg7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1pbmhlcml0OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLXRyYW5zcGFyZW50OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1ibGFjazpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyODI4Mjg7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy13aGl0ZTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0ZXI6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmM2Y3O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6YmctZ3JleS1saWdodDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlN2U3ZWM7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1ncmV5OmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2MyYzJjNjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodGVyOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYzJlOTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4NzgwOWI7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGU6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjODM2MGQ2O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWJyaWdodDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM0YzI5YjA7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFyazpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM0NTNmNTY7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFyay0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWRhcmtlcjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyYTI1Mzg7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1pbmhlcml0OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9jdXNcXFxcOmJnLXRyYW5zcGFyZW50OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1ibGFjazpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyODI4Mjg7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy13aGl0ZTpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0ZXI6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjNmM2Y3O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctZ3JleS1saWdodDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlN2U3ZWM7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1ncmV5OmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2MyYzJjNjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1saWdodGVyOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYzJlOTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1saWdodDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM4NzgwOWI7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGU6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjODM2MGQ2O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWJyaWdodDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM0YzI5YjA7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFyazpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM0NTNmNTY7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFyay0xMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWRhcmtlcjpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMyYTI1Mzg7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLWJvdHRvbSB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGJvdHRvbTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctY2VudGVyIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1sZWZ0IHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogbGVmdDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctbGVmdC1ib3R0b20ge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBsZWZ0IGJvdHRvbTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctbGVmdC10b3Age1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBsZWZ0IHRvcDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcmlnaHQge1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiByaWdodDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcmlnaHQtYm90dG9tIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogcmlnaHQgYm90dG9tO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1yaWdodC10b3Age1xcbiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiByaWdodCB0b3A7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXRvcCB7XFxuICAgIGJhY2tncm91bmQtcG9zaXRpb246IHRvcDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcmVwZWF0IHtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IHJlcGVhdDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ymctbm8tcmVwZWF0IHtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcmVwZWF0LXgge1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXg7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXJlcGVhdC15IHtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IHJlcGVhdC15O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1hdXRvIHtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1jb3ZlciB7XFxuICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLWNvbnRhaW4ge1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1pbmhlcml0IHtcXG4gICAgYm9yZGVyLWNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItdHJhbnNwYXJlbnQge1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItYmxhY2sge1xcbiAgICBib3JkZXItY29sb3I6ICMyODI4Mjg7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci13aGl0ZSB7XFxuICAgIGJvcmRlci1jb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLWdyZXktbGlnaHRlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2YzZjNmNztcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLWdyZXktbGlnaHQge1xcbiAgICBib3JkZXItY29sb3I6ICNlN2U3ZWM7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1ncmV5IHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItcHVycGxlLWxpZ2h0ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNjY2MyZTk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1wdXJwbGUtbGlnaHQge1xcbiAgICBib3JkZXItY29sb3I6ICM4NzgwOWI7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1wdXJwbGUge1xcbiAgICBib3JkZXItY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1wdXJwbGUtYnJpZ2h0IHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNGMyOWIwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItcHVycGxlLWRhcmsge1xcbiAgICBib3JkZXItY29sb3I6ICM0NTNmNTY7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1wdXJwbGUtZGFyay0xMCB7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1wdXJwbGUtZGFya2VyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMmEyNTM4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Ym9yZGVyLWluaGVyaXQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6IGluaGVyaXQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpib3JkZXItdHJhbnNwYXJlbnQ6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Ym9yZGVyLWJsYWNrOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMjgyODI4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXdoaXRlOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZmZmO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Ym9yZGVyLWdyZXktbGlnaHRlcjpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogI2YzZjNmNztcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJvcmRlci1ncmV5LWxpZ2h0OmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZTdlN2VjO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Ym9yZGVyLWdyZXk6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNjMmMyYzY7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWxpZ2h0ZXI6aG92ZXIge1xcbiAgICBib3JkZXItY29sb3I6ICNjY2MyZTk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpib3JkZXItcHVycGxlLWxpZ2h0OmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjODc4MDliO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXB1cnBsZTpob3ZlciB7XFxuICAgIGJvcmRlci1jb2xvcjogIzgzNjBkNjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtYnJpZ2h0OmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNGMyOWIwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNDUzZjU2O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Ym9yZGVyLXB1cnBsZS1kYXJrLTEwOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJvcmRlci1wdXJwbGUtZGFya2VyOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMmEyNTM4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLW5vbmUge1xcbiAgICBib3JkZXItcmFkaXVzOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLXNtIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkIHtcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWZ1bGwge1xcbiAgICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnJvdW5kZWQtdC1ub25lIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnJvdW5kZWQtci1ub25lIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWItbm9uZSB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWwtbm9uZSB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnJvdW5kZWQtdC1zbSB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDJweDtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC1yLXNtIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDJweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC1iLXNtIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDJweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWwtc20ge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAycHg7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC10IHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLXIge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWIge1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnJvdW5kZWQtbCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDRweDtcXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLXQtZnVsbCB7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDk5OTlweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC1yLWZ1bGwge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogOTk5OXB4O1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWItZnVsbCB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA5OTk5cHg7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC1sLWZ1bGwge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA5OTk5cHg7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDk5OTlweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC10bC1ub25lIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC10ci1ub25lIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnJvdW5kZWQtYnItbm9uZSB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWJsLW5vbmUge1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLXRsLXNtIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLXRyLXNtIHtcXG4gICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC1ici1zbSB7XFxuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnJvdW5kZWQtYmwtc20ge1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnJvdW5kZWQtdGwge1xcbiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnJvdW5kZWQtdHIge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWJyIHtcXG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC1ibCB7XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cm91bmRlZC10bC1mdWxsIHtcXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLXRyLWZ1bGwge1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWJyLWZ1bGwge1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogOTk5OXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb3VuZGVkLWJsLWZ1bGwge1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA5OTk5cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1zb2xpZCB7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1kYXNoZWQge1xcbiAgICBib3JkZXItc3R5bGU6IGRhc2hlZDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLWRvdHRlZCB7XFxuICAgIGJvcmRlci1zdHlsZTogZG90dGVkO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItbm9uZSB7XFxuICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLTAge1xcbiAgICBib3JkZXItd2lkdGg6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci0yIHtcXG4gICAgYm9yZGVyLXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci00IHtcXG4gICAgYm9yZGVyLXdpZHRoOiA0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci04IHtcXG4gICAgYm9yZGVyLXdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlciB7XFxuICAgIGJvcmRlci13aWR0aDogMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItdC0wIHtcXG4gICAgYm9yZGVyLXRvcC13aWR0aDogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLXItMCB7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLWItMCB7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1sLTAge1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLXQtMiB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLXItMiB7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItYi0yIHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItbC0yIHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLXQtNCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLXItNCB7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItYi00IHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItbC00IHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLXQtOCB7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLXItOCB7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItYi04IHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItbC04IHtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ym9yZGVyLXQge1xcbiAgICBib3JkZXItdG9wLXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1yIHtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmJvcmRlci1iIHtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpib3JkZXItbCB7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmN1cnNvci1hdXRvIHtcXG4gICAgY3Vyc29yOiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpjdXJzb3ItZGVmYXVsdCB7XFxuICAgIGN1cnNvcjogZGVmYXVsdDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Y3Vyc29yLXBvaW50ZXIge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuXFxuICAueGxcXFxcOmN1cnNvci13YWl0IHtcXG4gICAgY3Vyc29yOiB3YWl0O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpjdXJzb3ItbW92ZSB7XFxuICAgIGN1cnNvcjogbW92ZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Y3Vyc29yLW5vdC1hbGxvd2VkIHtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmxvY2sge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gIH1cXG5cXG4gIC54bFxcXFw6aW5saW5lLWJsb2NrIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgfVxcblxcbiAgLnhsXFxcXDppbmxpbmUge1xcbiAgICBkaXNwbGF5OiBpbmxpbmU7XFxuICB9XFxuXFxuICAueGxcXFxcOnRhYmxlIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICB9XFxuXFxuICAueGxcXFxcOnRhYmxlLXJvdyB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLXJvdztcXG4gIH1cXG5cXG4gIC54bFxcXFw6dGFibGUtY2VsbCB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICB9XFxuXFxuICAueGxcXFxcOmhpZGRlbiB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxuXFxuICAueGxcXFxcOmZsZXgge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDppbmxpbmUtZmxleCB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmbGV4LXJvdyB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICB9XFxuXFxuICAueGxcXFxcOmZsZXgtcm93LXJldmVyc2Uge1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XFxuICB9XFxuXFxuICAueGxcXFxcOmZsZXgtY29sIHtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6ZmxleC1jb2wtcmV2ZXJzZSB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6ZmxleC13cmFwIHtcXG4gICAgZmxleC13cmFwOiB3cmFwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmbGV4LXdyYXAtcmV2ZXJzZSB7XFxuICAgIGZsZXgtd3JhcDogd3JhcC1yZXZlcnNlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmbGV4LW5vLXdyYXAge1xcbiAgICBmbGV4LXdyYXA6IG5vd3JhcDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aXRlbXMtc3RhcnQge1xcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aXRlbXMtZW5kIHtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbiAgfVxcblxcbiAgLnhsXFxcXDppdGVtcy1jZW50ZXIge1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgfVxcblxcbiAgLnhsXFxcXDppdGVtcy1iYXNlbGluZSB7XFxuICAgIGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aXRlbXMtc3RyZXRjaCB7XFxuICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpzZWxmLWF1dG8ge1xcbiAgICBhbGlnbi1zZWxmOiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpzZWxmLXN0YXJ0IHtcXG4gICAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6c2VsZi1lbmQge1xcbiAgICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6c2VsZi1jZW50ZXIge1xcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxuICB9XFxuXFxuICAueGxcXFxcOnNlbGYtc3RyZXRjaCB7XFxuICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XFxuICB9XFxuXFxuICAueGxcXFxcOmp1c3RpZnktc3RhcnQge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmp1c3RpZnktZW5kIHtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6anVzdGlmeS1jZW50ZXIge1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6anVzdGlmeS1iZXR3ZWVuIHtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpqdXN0aWZ5LWFyb3VuZCB7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpjb250ZW50LWNlbnRlciB7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Y29udGVudC1zdGFydCB7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmNvbnRlbnQtZW5kIHtcXG4gICAgYWxpZ24tY29udGVudDogZmxleC1lbmQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmNvbnRlbnQtYmV0d2VlbiB7XFxuICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB9XFxuXFxuICAueGxcXFxcOmNvbnRlbnQtYXJvdW5kIHtcXG4gICAgYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmbGV4LTEge1xcbiAgICBmbGV4OiAxO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmbGV4LWF1dG8ge1xcbiAgICBmbGV4OiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmbGV4LWluaXRpYWwge1xcbiAgICBmbGV4OiBpbml0aWFsO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmbGV4LW5vbmUge1xcbiAgICBmbGV4OiBub25lO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmbGV4LWdyb3cge1xcbiAgICBmbGV4LWdyb3c6IDE7XFxuICB9XFxuXFxuICAueGxcXFxcOmZsZXgtc2hyaW5rIHtcXG4gICAgZmxleC1zaHJpbms6IDE7XFxuICB9XFxuXFxuICAueGxcXFxcOmZsZXgtbm8tZ3JvdyB7XFxuICAgIGZsZXgtZ3JvdzogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6ZmxleC1uby1zaHJpbmsge1xcbiAgICBmbGV4LXNocmluazogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6ZmxvYXQtcmlnaHQge1xcbiAgICBmbG9hdDogcmlnaHQ7XFxuICB9XFxuXFxuICAueGxcXFxcOmZsb2F0LWxlZnQge1xcbiAgICBmbG9hdDogbGVmdDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6ZmxvYXQtbm9uZSB7XFxuICAgIGZsb2F0OiBub25lO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpjbGVhcmZpeDphZnRlciB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgY2xlYXI6IGJvdGg7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvbnQtc2FucyB7XFxuICAgIGZvbnQtZmFtaWx5OiBzeXN0ZW0tdWksIEJsaW5rTWFjU3lzdGVtRm9udCwgLWFwcGxlLXN5c3RlbSwgU2Vnb2UgVUksIFJvYm90bywgT3h5Z2VuLCBVYnVudHUsIENhbnRhcmVsbCwgRmlyYSBTYW5zLCBEcm9pZCBTYW5zLCBIZWx2ZXRpY2EgTmV1ZSwgc2Fucy1zZXJpZjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9udC1zZXJpZiB7XFxuICAgIGZvbnQtZmFtaWx5OiBDb25zdGFudGlhLCBMdWNpZGEgQnJpZ2h0LCBMdWNpZGFicmlnaHQsIEx1Y2lkYSBTZXJpZiwgTHVjaWRhLCBEZWphVnUgU2VyaWYsIEJpdHN0cmVhbSBWZXJhIFNlcmlmLCBMaWJlcmF0aW9uIFNlcmlmLCBHZW9yZ2lhLCBzZXJpZjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9udC1tb25vIHtcXG4gICAgZm9udC1mYW1pbHk6IE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBMaWJlcmF0aW9uIE1vbm8sIENvdXJpZXIgTmV3LCBtb25vc3BhY2U7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvbnQtaGFpcmxpbmUge1xcbiAgICBmb250LXdlaWdodDogMTAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb250LXRoaW4ge1xcbiAgICBmb250LXdlaWdodDogMjAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb250LWxpZ2h0IHtcXG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9udC1ub3JtYWwge1xcbiAgICBmb250LXdlaWdodDogNDAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb250LW1lZGl1bSB7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvbnQtc2VtaWJvbGQge1xcbiAgICBmb250LXdlaWdodDogNjAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb250LWJvbGQge1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb250LWV4dHJhYm9sZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA4MDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvbnQtYmxhY2sge1xcbiAgICBmb250LXdlaWdodDogOTAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Zm9udC1oYWlybGluZTpob3ZlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiAxMDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpmb250LXRoaW46aG92ZXIge1xcbiAgICBmb250LXdlaWdodDogMjAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6Zm9udC1saWdodDpob3ZlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpmb250LW5vcm1hbDpob3ZlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpmb250LW1lZGl1bTpob3ZlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpmb250LXNlbWlib2xkOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmZvbnQtYm9sZDpob3ZlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpmb250LWV4dHJhYm9sZDpob3ZlciB7XFxuICAgIGZvbnQtd2VpZ2h0OiA4MDA7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpmb250LWJsYWNrOmhvdmVyIHtcXG4gICAgZm9udC13ZWlnaHQ6IDkwMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aC0wIHtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpoLTEge1xcbiAgICBoZWlnaHQ6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aC0yIHtcXG4gICAgaGVpZ2h0OiA0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmgtMyB7XFxuICAgIGhlaWdodDogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpoLTQge1xcbiAgICBoZWlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmgtNSB7XFxuICAgIGhlaWdodDogMjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aC02IHtcXG4gICAgaGVpZ2h0OiAzMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpoLTcge1xcbiAgICBoZWlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmgtOCB7XFxuICAgIGhlaWdodDogNDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aC05IHtcXG4gICAgaGVpZ2h0OiA2NHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpoLTEwIHtcXG4gICAgaGVpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpoLXNjcmVlbiB7XFxuICAgIGhlaWdodDogMTAwdmg7XFxuICB9XFxuXFxuICAueGxcXFxcOmgtYXV0byB7XFxuICAgIGhlaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6aC1mdWxsIHtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpoLXB4IHtcXG4gICAgaGVpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOmgtMVxcXFwvNiB7XFxuICAgIGhlaWdodDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bGVhZGluZy1ub25lIHtcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxuICB9XFxuXFxuICAueGxcXFxcOmxlYWRpbmctdGlnaHQge1xcbiAgICBsaW5lLWhlaWdodDogMS4yNTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bGVhZGluZy1ub3JtYWwge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpsZWFkaW5nLWxvb3NlIHtcXG4gICAgbGluZS1oZWlnaHQ6IDI7XFxuICB9XFxuXFxuICAueGxcXFxcOm0tMCB7XFxuICAgIG1hcmdpbjogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bS0xIHtcXG4gICAgbWFyZ2luOiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm0tMiB7XFxuICAgIG1hcmdpbjogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptLTMge1xcbiAgICBtYXJnaW46IDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bS00IHtcXG4gICAgbWFyZ2luOiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptLTUge1xcbiAgICBtYXJnaW46IDI0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm0tNiB7XFxuICAgIG1hcmdpbjogMzJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bS03IHtcXG4gICAgbWFyZ2luOiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptLTgge1xcbiAgICBtYXJnaW46IDQ4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm0tOSB7XFxuICAgIG1hcmdpbjogNjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bS0xMCB7XFxuICAgIG1hcmdpbjogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bS1hdXRvIHtcXG4gICAgbWFyZ2luOiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDptLWZ1bGwge1xcbiAgICBtYXJnaW46IDEwMCU7XFxuICB9XFxuXFxuICAueGxcXFxcOm0tcHgge1xcbiAgICBtYXJnaW46IDFweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bS0xXFxcXC82IHtcXG4gICAgbWFyZ2luOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpteS0wIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXgtMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOm15LTEge1xcbiAgICBtYXJnaW4tdG9wOiAycHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXgtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAycHg7XFxuICAgIG1hcmdpbi1yaWdodDogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpteS0yIHtcXG4gICAgbWFyZ2luLXRvcDogNHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiA0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm14LTIge1xcbiAgICBtYXJnaW4tbGVmdDogNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXktMyB7XFxuICAgIG1hcmdpbi10b3A6IDhweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpteC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm15LTQge1xcbiAgICBtYXJnaW4tdG9wOiAxNnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpteC00IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDE2cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXktNSB7XFxuICAgIG1hcmdpbi10b3A6IDI0cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDI0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm14LTUge1xcbiAgICBtYXJnaW4tbGVmdDogMjRweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpteS02IHtcXG4gICAgbWFyZ2luLXRvcDogMzJweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMzJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXgtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAzMnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm15LTcge1xcbiAgICBtYXJnaW4tdG9wOiAzNnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpteC03IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDM2cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMzZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXktOCB7XFxuICAgIG1hcmdpbi10b3A6IDQ4cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDQ4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm14LTgge1xcbiAgICBtYXJnaW4tbGVmdDogNDhweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpteS05IHtcXG4gICAgbWFyZ2luLXRvcDogNjRweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogNjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXgtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA2NHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm15LTEwIHtcXG4gICAgbWFyZ2luLXRvcDogOTZweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXgtMTAge1xcbiAgICBtYXJnaW4tbGVmdDogOTZweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiA5NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpteS1hdXRvIHtcXG4gICAgbWFyZ2luLXRvcDogYXV0bztcXG4gICAgbWFyZ2luLWJvdHRvbTogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXgtYXV0byB7XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOm15LWZ1bGwge1xcbiAgICBtYXJnaW4tdG9wOiAxMDAlO1xcbiAgICBtYXJnaW4tYm90dG9tOiAxMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpteC1mdWxsIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwMCU7XFxuICAgIG1hcmdpbi1yaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXktcHgge1xcbiAgICBtYXJnaW4tdG9wOiAxcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDFweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXgtcHgge1xcbiAgICBtYXJnaW4tbGVmdDogMXB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDFweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXktMVxcXFwvNiB7XFxuICAgIG1hcmdpbi10b3A6IDE2LjY2NjY2NjY2NyU7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAueGxcXFxcOm14LTFcXFxcLzYge1xcbiAgICBtYXJnaW4tbGVmdDogMTYuNjY2NjY2NjY3JTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDptdC0wIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXItMCB7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWItMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOm1sLTAge1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXQtMSB7XFxuICAgIG1hcmdpbi10b3A6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXItMSB7XFxuICAgIG1hcmdpbi1yaWdodDogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYi0xIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptbC0xIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXQtMiB7XFxuICAgIG1hcmdpbi10b3A6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXItMiB7XFxuICAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYi0yIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptbC0yIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXQtMyB7XFxuICAgIG1hcmdpbi10b3A6IDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXItMyB7XFxuICAgIG1hcmdpbi1yaWdodDogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYi0zIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptbC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXQtNCB7XFxuICAgIG1hcmdpbi10b3A6IDE2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1yLTQge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1iLTQge1xcbiAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptbC00IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDE2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm10LTUge1xcbiAgICBtYXJnaW4tdG9wOiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptci01IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYi01IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWwtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptdC02IHtcXG4gICAgbWFyZ2luLXRvcDogMzJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXItNiB7XFxuICAgIG1hcmdpbi1yaWdodDogMzJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWItNiB7XFxuICAgIG1hcmdpbi1ib3R0b206IDMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1sLTYge1xcbiAgICBtYXJnaW4tbGVmdDogMzJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXQtNyB7XFxuICAgIG1hcmdpbi10b3A6IDM2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1yLTcge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1iLTcge1xcbiAgICBtYXJnaW4tYm90dG9tOiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptbC03IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDM2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm10LTgge1xcbiAgICBtYXJnaW4tdG9wOiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptci04IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYi04IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogNDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWwtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptdC05IHtcXG4gICAgbWFyZ2luLXRvcDogNjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXItOSB7XFxuICAgIG1hcmdpbi1yaWdodDogNjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWItOSB7XFxuICAgIG1hcmdpbi1ib3R0b206IDY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1sLTkge1xcbiAgICBtYXJnaW4tbGVmdDogNjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXQtMTAge1xcbiAgICBtYXJnaW4tdG9wOiA5NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptci0xMCB7XFxuICAgIG1hcmdpbi1yaWdodDogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWItMTAge1xcbiAgICBtYXJnaW4tYm90dG9tOiA5NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptbC0xMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA5NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptdC1hdXRvIHtcXG4gICAgbWFyZ2luLXRvcDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXItYXV0byB7XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWItYXV0byB7XFxuICAgIG1hcmdpbi1ib3R0b206IGF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOm1sLWF1dG8ge1xcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXQtZnVsbCB7XFxuICAgIG1hcmdpbi10b3A6IDEwMCU7XFxuICB9XFxuXFxuICAueGxcXFxcOm1yLWZ1bGwge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDEwMCU7XFxuICB9XFxuXFxuICAueGxcXFxcOm1iLWZ1bGwge1xcbiAgICBtYXJnaW4tYm90dG9tOiAxMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDptbC1mdWxsIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwMCU7XFxuICB9XFxuXFxuICAueGxcXFxcOm10LXB4IHtcXG4gICAgbWFyZ2luLXRvcDogMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptci1weCB7XFxuICAgIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYi1weCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDFweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWwtcHgge1xcbiAgICBtYXJnaW4tbGVmdDogMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptdC0xXFxcXC82IHtcXG4gICAgbWFyZ2luLXRvcDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bXItMVxcXFwvNiB7XFxuICAgIG1hcmdpbi1yaWdodDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWItMVxcXFwvNiB7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAueGxcXFxcOm1sLTFcXFxcLzYge1xcbiAgICBtYXJnaW4tbGVmdDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LWgtMCB7XFxuICAgIG1heC1oZWlnaHQ6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOm1heC1oLTEge1xcbiAgICBtYXgtaGVpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1heC1oLTIge1xcbiAgICBtYXgtaGVpZ2h0OiA0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1heC1oLTMge1xcbiAgICBtYXgtaGVpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1heC1oLTQge1xcbiAgICBtYXgtaGVpZ2h0OiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtaC01IHtcXG4gICAgbWF4LWhlaWdodDogMjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LWgtNiB7XFxuICAgIG1heC1oZWlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1heC1oLTcge1xcbiAgICBtYXgtaGVpZ2h0OiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtaC04IHtcXG4gICAgbWF4LWhlaWdodDogNDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LWgtOSB7XFxuICAgIG1heC1oZWlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1heC1oLTEwIHtcXG4gICAgbWF4LWhlaWdodDogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LWgtc2NyZWVuIHtcXG4gICAgbWF4LWhlaWdodDogMTAwdmg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1heC1oLWF1dG8ge1xcbiAgICBtYXgtaGVpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtaC1mdWxsIHtcXG4gICAgbWF4LWhlaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LWgtcHgge1xcbiAgICBtYXgtaGVpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1heC1oLTFcXFxcLzYge1xcbiAgICBtYXgtaGVpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtdy0wIHtcXG4gICAgbWF4LXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtdy0xIHtcXG4gICAgbWF4LXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1heC13LTIge1xcbiAgICBtYXgtd2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LXctMyB7XFxuICAgIG1heC13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtdy00IHtcXG4gICAgbWF4LXdpZHRoOiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtdy01IHtcXG4gICAgbWF4LXdpZHRoOiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtdy02IHtcXG4gICAgbWF4LXdpZHRoOiAzMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtdy03IHtcXG4gICAgbWF4LXdpZHRoOiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtdy04IHtcXG4gICAgbWF4LXdpZHRoOiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtdy05IHtcXG4gICAgbWF4LXdpZHRoOiA2NHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptYXgtdy0xMCB7XFxuICAgIG1heC13aWR0aDogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LXctYXV0byB7XFxuICAgIG1heC13aWR0aDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LXctZnVsbCB7XFxuICAgIG1heC13aWR0aDogMTAwJTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LXctcHgge1xcbiAgICBtYXgtd2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWF4LXctMVxcXFwvNiB7XFxuICAgIG1heC13aWR0aDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLWgtMCB7XFxuICAgIG1pbi1oZWlnaHQ6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOm1pbi1oLTEge1xcbiAgICBtaW4taGVpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1pbi1oLTIge1xcbiAgICBtaW4taGVpZ2h0OiA0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1pbi1oLTMge1xcbiAgICBtaW4taGVpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1pbi1oLTQge1xcbiAgICBtaW4taGVpZ2h0OiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4taC01IHtcXG4gICAgbWluLWhlaWdodDogMjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLWgtNiB7XFxuICAgIG1pbi1oZWlnaHQ6IDMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1pbi1oLTcge1xcbiAgICBtaW4taGVpZ2h0OiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4taC04IHtcXG4gICAgbWluLWhlaWdodDogNDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLWgtOSB7XFxuICAgIG1pbi1oZWlnaHQ6IDY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1pbi1oLTEwIHtcXG4gICAgbWluLWhlaWdodDogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLWgtc2NyZWVuIHtcXG4gICAgbWluLWhlaWdodDogMTAwdmg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1pbi1oLWF1dG8ge1xcbiAgICBtaW4taGVpZ2h0OiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4taC1mdWxsIHtcXG4gICAgbWluLWhlaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLWgtcHgge1xcbiAgICBtaW4taGVpZ2h0OiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1pbi1oLTFcXFxcLzYge1xcbiAgICBtaW4taGVpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4tdy0wIHtcXG4gICAgbWluLXdpZHRoOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4tdy0xIHtcXG4gICAgbWluLXdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOm1pbi13LTIge1xcbiAgICBtaW4td2lkdGg6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLXctMyB7XFxuICAgIG1pbi13aWR0aDogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4tdy00IHtcXG4gICAgbWluLXdpZHRoOiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4tdy01IHtcXG4gICAgbWluLXdpZHRoOiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4tdy02IHtcXG4gICAgbWluLXdpZHRoOiAzMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4tdy03IHtcXG4gICAgbWluLXdpZHRoOiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4tdy04IHtcXG4gICAgbWluLXdpZHRoOiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4tdy05IHtcXG4gICAgbWluLXdpZHRoOiA2NHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDptaW4tdy0xMCB7XFxuICAgIG1pbi13aWR0aDogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLXctYXV0byB7XFxuICAgIG1pbi13aWR0aDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLXctZnVsbCB7XFxuICAgIG1pbi13aWR0aDogMTAwJTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLXctcHgge1xcbiAgICBtaW4td2lkdGg6IDFweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bWluLXctMVxcXFwvNiB7XFxuICAgIG1pbi13aWR0aDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW0tMCB7XFxuICAgIG1hcmdpbjogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW0tMSB7XFxuICAgIG1hcmdpbjogLTJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW0tMiB7XFxuICAgIG1hcmdpbjogLTRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW0tMyB7XFxuICAgIG1hcmdpbjogLThweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW0tNCB7XFxuICAgIG1hcmdpbjogLTE2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tLTUge1xcbiAgICBtYXJnaW46IC0yNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbS02IHtcXG4gICAgbWFyZ2luOiAtMzJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW0tNyB7XFxuICAgIG1hcmdpbjogLTM2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tLTgge1xcbiAgICBtYXJnaW46IC00OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbS05IHtcXG4gICAgbWFyZ2luOiAtNjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW0tMTAge1xcbiAgICBtYXJnaW46IC05NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbS1hdXRvIHtcXG4gICAgbWFyZ2luOiAtYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW0tZnVsbCB7XFxuICAgIG1hcmdpbjogLTEwMCU7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tLXB4IHtcXG4gICAgbWFyZ2luOiAtMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbS0xXFxcXC82IHtcXG4gICAgbWFyZ2luOiAtMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW15LTAge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXgtMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOi1teS0xIHtcXG4gICAgbWFyZ2luLXRvcDogLTJweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW14LTEge1xcbiAgICBtYXJnaW4tbGVmdDogLTJweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXktMiB7XFxuICAgIG1hcmdpbi10b3A6IC00cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC00cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1teC0yIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC00cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW15LTMge1xcbiAgICBtYXJnaW4tdG9wOiAtOHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXgtMyB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtOHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC04cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1teS00IHtcXG4gICAgbWFyZ2luLXRvcDogLTE2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC0xNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXgtNCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMTZweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW15LTUge1xcbiAgICBtYXJnaW4tdG9wOiAtMjRweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTI0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1teC01IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0yNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0yNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXktNiB7XFxuICAgIG1hcmdpbi10b3A6IC0zMnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMzJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW14LTYge1xcbiAgICBtYXJnaW4tbGVmdDogLTMycHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1teS03IHtcXG4gICAgbWFyZ2luLXRvcDogLTM2cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IC0zNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXgtNyB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMzZweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMzZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW15LTgge1xcbiAgICBtYXJnaW4tdG9wOiAtNDhweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTQ4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1teC04IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC00OHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC00OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXktOSB7XFxuICAgIG1hcmdpbi10b3A6IC02NHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtNjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW14LTkge1xcbiAgICBtYXJnaW4tbGVmdDogLTY0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1teS0xMCB7XFxuICAgIG1hcmdpbi10b3A6IC05NnB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAtOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW14LTEwIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC05NnB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC05NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXktYXV0byB7XFxuICAgIG1hcmdpbi10b3A6IC1hdXRvO1xcbiAgICBtYXJnaW4tYm90dG9tOiAtYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW14LWF1dG8ge1xcbiAgICBtYXJnaW4tbGVmdDogLWF1dG87XFxuICAgIG1hcmdpbi1yaWdodDogLWF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOi1teS1mdWxsIHtcXG4gICAgbWFyZ2luLXRvcDogLTEwMCU7XFxuICAgIG1hcmdpbi1ib3R0b206IC0xMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXgtZnVsbCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMTAwJTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMTAwJTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW15LXB4IHtcXG4gICAgbWFyZ2luLXRvcDogLTFweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTFweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW14LXB4IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xcHg7XFxuICAgIG1hcmdpbi1yaWdodDogLTFweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW15LTFcXFxcLzYge1xcbiAgICBtYXJnaW4tdG9wOiAtMTYuNjY2NjY2NjY3JTtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAueGxcXFxcOi1teC0xXFxcXC82IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xNi42NjY2NjY2NjclO1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXQtMCB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tci0wIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbWItMCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tbC0wIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tdC0xIHtcXG4gICAgbWFyZ2luLXRvcDogLTJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1yLTEge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0ycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tYi0xIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1sLTEge1xcbiAgICBtYXJnaW4tbGVmdDogLTJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW10LTIge1xcbiAgICBtYXJnaW4tdG9wOiAtNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXItMiB7XFxuICAgIG1hcmdpbi1yaWdodDogLTRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1iLTIge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbWwtMiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXQtMyB7XFxuICAgIG1hcmdpbi10b3A6IC04cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tci0zIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbWItMyB7XFxuICAgIG1hcmdpbi1ib3R0b206IC04cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tbC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC04cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tdC00IHtcXG4gICAgbWFyZ2luLXRvcDogLTE2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tci00IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1iLTQge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1sLTQge1xcbiAgICBtYXJnaW4tbGVmdDogLTE2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tdC01IHtcXG4gICAgbWFyZ2luLXRvcDogLTI0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tci01IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1iLTUge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1sLTUge1xcbiAgICBtYXJnaW4tbGVmdDogLTI0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tdC02IHtcXG4gICAgbWFyZ2luLXRvcDogLTMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tci02IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMzJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1iLTYge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMzJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1sLTYge1xcbiAgICBtYXJnaW4tbGVmdDogLTMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tdC03IHtcXG4gICAgbWFyZ2luLXRvcDogLTM2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tci03IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMzZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1iLTcge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtMzZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1sLTcge1xcbiAgICBtYXJnaW4tbGVmdDogLTM2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tdC04IHtcXG4gICAgbWFyZ2luLXRvcDogLTQ4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tci04IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1iLTgge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtNDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1sLTgge1xcbiAgICBtYXJnaW4tbGVmdDogLTQ4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tdC05IHtcXG4gICAgbWFyZ2luLXRvcDogLTY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tci05IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtNjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1iLTkge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtNjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1sLTkge1xcbiAgICBtYXJnaW4tbGVmdDogLTY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tdC0xMCB7XFxuICAgIG1hcmdpbi10b3A6IC05NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXItMTAge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC05NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbWItMTAge1xcbiAgICBtYXJnaW4tYm90dG9tOiAtOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6LW1sLTEwIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC05NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXQtYXV0byB7XFxuICAgIG1hcmdpbi10b3A6IC1hdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXItYXV0byB7XFxuICAgIG1hcmdpbi1yaWdodDogLWF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOi1tYi1hdXRvIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLWF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOi1tbC1hdXRvIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC1hdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXQtZnVsbCB7XFxuICAgIG1hcmdpbi10b3A6IC0xMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXItZnVsbCB7XFxuICAgIG1hcmdpbi1yaWdodDogLTEwMCU7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tYi1mdWxsIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTEwMCU7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tbC1mdWxsIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXQtcHgge1xcbiAgICBtYXJnaW4tdG9wOiAtMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXItcHgge1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0xcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tYi1weCB7XFxuICAgIG1hcmdpbi1ib3R0b206IC0xcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tbC1weCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXQtMVxcXFwvNiB7XFxuICAgIG1hcmdpbi10b3A6IC0xNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDotbXItMVxcXFwvNiB7XFxuICAgIG1hcmdpbi1yaWdodDogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tYi0xXFxcXC82IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogLTE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAueGxcXFxcOi1tbC0xXFxcXC82IHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0xNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpvcGFjaXR5LTAge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpvcGFjaXR5LTI1IHtcXG4gICAgb3BhY2l0eTogLjI1O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpvcGFjaXR5LTUwIHtcXG4gICAgb3BhY2l0eTogLjU7XFxuICB9XFxuXFxuICAueGxcXFxcOm9wYWNpdHktNzUge1xcbiAgICBvcGFjaXR5OiAuNzU7XFxuICB9XFxuXFxuICAueGxcXFxcOm9wYWNpdHktMTAwIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6b3ZlcmZsb3ctYXV0byB7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpvdmVyZmxvdy1oaWRkZW4ge1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpvdmVyZmxvdy12aXNpYmxlIHtcXG4gICAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICB9XFxuXFxuICAueGxcXFxcOm92ZXJmbG93LXNjcm9sbCB7XFxuICAgIG92ZXJmbG93OiBzY3JvbGw7XFxuICB9XFxuXFxuICAueGxcXFxcOm92ZXJmbG93LXgtYXV0byB7XFxuICAgIG92ZXJmbG93LXg6IGF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOm92ZXJmbG93LXktYXV0byB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOm92ZXJmbG93LXgtaGlkZGVuIHtcXG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpvdmVyZmxvdy15LWhpZGRlbiB7XFxuICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6b3ZlcmZsb3cteC12aXNpYmxlIHtcXG4gICAgb3ZlcmZsb3cteDogdmlzaWJsZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6b3ZlcmZsb3cteS12aXNpYmxlIHtcXG4gICAgb3ZlcmZsb3cteTogdmlzaWJsZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6b3ZlcmZsb3cteC1zY3JvbGwge1xcbiAgICBvdmVyZmxvdy14OiBzY3JvbGw7XFxuICB9XFxuXFxuICAueGxcXFxcOm92ZXJmbG93LXktc2Nyb2xsIHtcXG4gICAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpzY3JvbGxpbmctdG91Y2gge1xcbiAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XFxuICB9XFxuXFxuICAueGxcXFxcOnNjcm9sbGluZy1hdXRvIHtcXG4gICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IGF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOnAtMCB7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnAtMSB7XFxuICAgIHBhZGRpbmc6IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cC0yIHtcXG4gICAgcGFkZGluZzogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwLTMge1xcbiAgICBwYWRkaW5nOiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnAtNCB7XFxuICAgIHBhZGRpbmc6IDE2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnAtNSB7XFxuICAgIHBhZGRpbmc6IDI0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnAtNiB7XFxuICAgIHBhZGRpbmc6IDMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnAtNyB7XFxuICAgIHBhZGRpbmc6IDM2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnAtOCB7XFxuICAgIHBhZGRpbmc6IDQ4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnAtOSB7XFxuICAgIHBhZGRpbmc6IDY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnAtMTAge1xcbiAgICBwYWRkaW5nOiA5NnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwLWF1dG8ge1xcbiAgICBwYWRkaW5nOiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwLWZ1bGwge1xcbiAgICBwYWRkaW5nOiAxMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwLXB4IHtcXG4gICAgcGFkZGluZzogMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwLTFcXFxcLzYge1xcbiAgICBwYWRkaW5nOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS0wIHtcXG4gICAgcGFkZGluZy10b3A6IDA7XFxuICAgIHBhZGRpbmctYm90dG9tOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweC0wIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS0xIHtcXG4gICAgcGFkZGluZy10b3A6IDJweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHgtMSB7XFxuICAgIHBhZGRpbmctbGVmdDogMnB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnB5LTIge1xcbiAgICBwYWRkaW5nLXRvcDogNHB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweC0yIHtcXG4gICAgcGFkZGluZy1sZWZ0OiA0cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHktMyB7XFxuICAgIHBhZGRpbmctdG9wOiA4cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnB4LTMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDhweDtcXG4gICAgcGFkZGluZy1yaWdodDogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS00IHtcXG4gICAgcGFkZGluZy10b3A6IDE2cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweC00IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNnB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS01IHtcXG4gICAgcGFkZGluZy10b3A6IDI0cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweC01IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAyNHB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS02IHtcXG4gICAgcGFkZGluZy10b3A6IDMycHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiAzMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweC02IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAzMnB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAzMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS03IHtcXG4gICAgcGFkZGluZy10b3A6IDM2cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweC03IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAzNnB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS04IHtcXG4gICAgcGFkZGluZy10b3A6IDQ4cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweC04IHtcXG4gICAgcGFkZGluZy1sZWZ0OiA0OHB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS05IHtcXG4gICAgcGFkZGluZy10b3A6IDY0cHg7XFxuICAgIHBhZGRpbmctYm90dG9tOiA2NHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweC05IHtcXG4gICAgcGFkZGluZy1sZWZ0OiA2NHB4O1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA2NHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS0xMCB7XFxuICAgIHBhZGRpbmctdG9wOiA5NnB4O1xcbiAgICBwYWRkaW5nLWJvdHRvbTogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHgtMTAge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDk2cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDk2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnB5LWF1dG8ge1xcbiAgICBwYWRkaW5nLXRvcDogYXV0bztcXG4gICAgcGFkZGluZy1ib3R0b206IGF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOnB4LWF1dG8ge1xcbiAgICBwYWRkaW5nLWxlZnQ6IGF1dG87XFxuICAgIHBhZGRpbmctcmlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOnB5LWZ1bGwge1xcbiAgICBwYWRkaW5nLXRvcDogMTAwJTtcXG4gICAgcGFkZGluZy1ib3R0b206IDEwMCU7XFxuICB9XFxuXFxuICAueGxcXFxcOnB4LWZ1bGwge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDEwMCU7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDEwMCU7XFxuICB9XFxuXFxuICAueGxcXFxcOnB5LXB4IHtcXG4gICAgcGFkZGluZy10b3A6IDFweDtcXG4gICAgcGFkZGluZy1ib3R0b206IDFweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHgtcHgge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDFweDtcXG4gICAgcGFkZGluZy1yaWdodDogMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweS0xXFxcXC82IHtcXG4gICAgcGFkZGluZy10b3A6IDE2LjY2NjY2NjY2NyU7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpweC0xXFxcXC82IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxNi42NjY2NjY2NjclO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwdC0wIHtcXG4gICAgcGFkZGluZy10b3A6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnByLTAge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwYi0wIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnBsLTAge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnB0LTEge1xcbiAgICBwYWRkaW5nLXRvcDogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwci0xIHtcXG4gICAgcGFkZGluZy1yaWdodDogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwYi0xIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDJweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGwtMSB7XFxuICAgIHBhZGRpbmctbGVmdDogMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwdC0yIHtcXG4gICAgcGFkZGluZy10b3A6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHItMiB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGItMiB7XFxuICAgIHBhZGRpbmctYm90dG9tOiA0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnBsLTIge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHQtMyB7XFxuICAgIHBhZGRpbmctdG9wOiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnByLTMge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnBiLTMge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwbC0zIHtcXG4gICAgcGFkZGluZy1sZWZ0OiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnB0LTQge1xcbiAgICBwYWRkaW5nLXRvcDogMTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHItNCB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnBiLTQge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGwtNCB7XFxuICAgIHBhZGRpbmctbGVmdDogMTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHQtNSB7XFxuICAgIHBhZGRpbmctdG9wOiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwci01IHtcXG4gICAgcGFkZGluZy1yaWdodDogMjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGItNSB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwbC01IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAyNHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwdC02IHtcXG4gICAgcGFkZGluZy10b3A6IDMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnByLTYge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAzMnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwYi02IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnBsLTYge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnB0LTcge1xcbiAgICBwYWRkaW5nLXRvcDogMzZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHItNyB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDM2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnBiLTcge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGwtNyB7XFxuICAgIHBhZGRpbmctbGVmdDogMzZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHQtOCB7XFxuICAgIHBhZGRpbmctdG9wOiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwci04IHtcXG4gICAgcGFkZGluZy1yaWdodDogNDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGItOCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwbC04IHtcXG4gICAgcGFkZGluZy1sZWZ0OiA0OHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwdC05IHtcXG4gICAgcGFkZGluZy10b3A6IDY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnByLTkge1xcbiAgICBwYWRkaW5nLXJpZ2h0OiA2NHB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwYi05IHtcXG4gICAgcGFkZGluZy1ib3R0b206IDY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnBsLTkge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnB0LTEwIHtcXG4gICAgcGFkZGluZy10b3A6IDk2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnByLTEwIHtcXG4gICAgcGFkZGluZy1yaWdodDogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGItMTAge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGwtMTAge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDk2cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnB0LWF1dG8ge1xcbiAgICBwYWRkaW5nLXRvcDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHItYXV0byB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IGF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOnBiLWF1dG8ge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGwtYXV0byB7XFxuICAgIHBhZGRpbmctbGVmdDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHQtZnVsbCB7XFxuICAgIHBhZGRpbmctdG9wOiAxMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwci1mdWxsIHtcXG4gICAgcGFkZGluZy1yaWdodDogMTAwJTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGItZnVsbCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwbC1mdWxsIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxMDAlO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwdC1weCB7XFxuICAgIHBhZGRpbmctdG9wOiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnByLXB4IHtcXG4gICAgcGFkZGluZy1yaWdodDogMXB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwYi1weCB7XFxuICAgIHBhZGRpbmctYm90dG9tOiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnBsLXB4IHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnB0LTFcXFxcLzYge1xcbiAgICBwYWRkaW5nLXRvcDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cHItMVxcXFwvNiB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDE2LjY2NjY2NjY2NyU7XFxuICB9XFxuXFxuICAueGxcXFxcOnBiLTFcXFxcLzYge1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGwtMVxcXFwvNiB7XFxuICAgIHBhZGRpbmctbGVmdDogMTYuNjY2NjY2NjY3JTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cG9pbnRlci1ldmVudHMtbm9uZSB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwb2ludGVyLWV2ZW50cy1hdXRvIHtcXG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XFxuICB9XFxuXFxuICAueGxcXFxcOnN0YXRpYyB7XFxuICAgIHBvc2l0aW9uOiBzdGF0aWM7XFxuICB9XFxuXFxuICAueGxcXFxcOmZpeGVkIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgfVxcblxcbiAgLnhsXFxcXDphYnNvbHV0ZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cmVsYXRpdmUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB9XFxuXFxuICAueGxcXFxcOnN0aWNreSB7XFxuICAgIHBvc2l0aW9uOiBzdGlja3k7XFxuICB9XFxuXFxuICAueGxcXFxcOnBpbi1ub25lIHtcXG4gICAgdG9wOiBhdXRvO1xcbiAgICByaWdodDogYXV0bztcXG4gICAgYm90dG9tOiBhdXRvO1xcbiAgICBsZWZ0OiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwaW4ge1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnBpbi15IHtcXG4gICAgdG9wOiAwO1xcbiAgICBib3R0b206IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnBpbi14IHtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnBpbi10IHtcXG4gICAgdG9wOiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwaW4tciB7XFxuICAgIHJpZ2h0OiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpwaW4tYiB7XFxuICAgIGJvdHRvbTogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cGluLWwge1xcbiAgICBsZWZ0OiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyZXNpemUtbm9uZSB7XFxuICAgIHJlc2l6ZTogbm9uZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cmVzaXplLXkge1xcbiAgICByZXNpemU6IHZlcnRpY2FsO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyZXNpemUteCB7XFxuICAgIHJlc2l6ZTogaG9yaXpvbnRhbDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6cmVzaXplIHtcXG4gICAgcmVzaXplOiBib3RoO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpzaGFkb3cge1xcbiAgICBib3gtc2hhZG93OiAwIDJweCA0cHggMCByZ2JhKDAsIDAsIDAsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6c2hhZG93LW1kIHtcXG4gICAgYm94LXNoYWRvdzogIDAgOHB4IDIwcHggMCByZ2JhKDAsIDAsIDAsIC40Mik7XFxuICB9XFxuXFxuICAueGxcXFxcOnNoYWRvdy1ub25lIHtcXG4gICAgYm94LXNoYWRvdzogbm9uZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dGFibGUtYXV0byB7XFxuICAgIHRhYmxlLWxheW91dDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6dGFibGUtZml4ZWQge1xcbiAgICB0YWJsZS1sYXlvdXQ6IGZpeGVkO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LWxlZnQge1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LWNlbnRlciB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dGV4dC1yaWdodCB7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LWp1c3RpZnkge1xcbiAgICB0ZXh0LWFsaWduOiBqdXN0aWZ5O1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LWluaGVyaXQge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dGV4dC10cmFuc3BhcmVudCB7XFxuICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dGV4dC1ibGFjayB7XFxuICAgIGNvbG9yOiAjMjgyODI4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LXdoaXRlIHtcXG4gICAgY29sb3I6ICNmZmY7XFxuICB9XFxuXFxuICAueGxcXFxcOnRleHQtZ3JleS1saWdodGVyIHtcXG4gICAgY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAueGxcXFxcOnRleHQtZ3JleS1saWdodCB7XFxuICAgIGNvbG9yOiAjZTdlN2VjO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LWdyZXkge1xcbiAgICBjb2xvcjogI2MyYzJjNjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dGV4dC1wdXJwbGUtbGlnaHRlciB7XFxuICAgIGNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LXB1cnBsZS1saWdodCB7XFxuICAgIGNvbG9yOiAjODc4MDliO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LXB1cnBsZSB7XFxuICAgIGNvbG9yOiAjODM2MGQ2O1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LXB1cnBsZS1icmlnaHQge1xcbiAgICBjb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dGV4dC1wdXJwbGUtZGFyayB7XFxuICAgIGNvbG9yOiAjNDUzZjU2O1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LXB1cnBsZS1kYXJrLTEwIHtcXG4gICAgY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LXB1cnBsZS1kYXJrZXIge1xcbiAgICBjb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOnRleHQtaW5oZXJpdDpob3ZlciB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6dGV4dC10cmFuc3BhcmVudDpob3ZlciB7XFxuICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOnRleHQtYmxhY2s6aG92ZXIge1xcbiAgICBjb2xvcjogIzI4MjgyODtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOnRleHQtd2hpdGU6aG92ZXIge1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOnRleHQtZ3JleS1saWdodGVyOmhvdmVyIHtcXG4gICAgY29sb3I6ICNmM2YzZjc7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDp0ZXh0LWdyZXktbGlnaHQ6aG92ZXIge1xcbiAgICBjb2xvcjogI2U3ZTdlYztcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOnRleHQtZ3JleTpob3ZlciB7XFxuICAgIGNvbG9yOiAjYzJjMmM2O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGUtbGlnaHRlcjpob3ZlciB7XFxuICAgIGNvbG9yOiAjY2NjMmU5O1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6dGV4dC1wdXJwbGUtbGlnaHQ6aG92ZXIge1xcbiAgICBjb2xvcjogIzg3ODA5YjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOnRleHQtcHVycGxlOmhvdmVyIHtcXG4gICAgY29sb3I6ICM4MzYwZDY7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDp0ZXh0LXB1cnBsZS1icmlnaHQ6aG92ZXIge1xcbiAgICBjb2xvcjogIzRjMjliMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOnRleHQtcHVycGxlLWRhcms6aG92ZXIge1xcbiAgICBjb2xvcjogIzQ1M2Y1NjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOnRleHQtcHVycGxlLWRhcmstMTA6aG92ZXIge1xcbiAgICBjb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDp0ZXh0LXB1cnBsZS1kYXJrZXI6aG92ZXIge1xcbiAgICBjb2xvcjogIzJhMjUzODtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dGV4dC1zbSB7XFxuICAgIGZvbnQtc2l6ZTogMS40cmVtO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0ZXh0LWJhc2Uge1xcbiAgICBmb250LXNpemU6IDEuNnJlbTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aXRhbGljIHtcXG4gICAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpyb21hbiB7XFxuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dXBwZXJjYXNlIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bG93ZXJjYXNlIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IGxvd2VyY2FzZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Y2FwaXRhbGl6ZSB7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpub3JtYWwtY2FzZSB7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp1bmRlcmxpbmUge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6bGluZS10aHJvdWdoIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XFxuICB9XFxuXFxuICAueGxcXFxcOm5vLXVuZGVybGluZSB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YW50aWFsaWFzZWQge1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gICAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6c3VicGl4ZWwtYW50aWFsaWFzZWQge1xcbiAgICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhdXRvO1xcbiAgICAtbW96LW9zeC1mb250LXNtb290aGluZzogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOml0YWxpYzpob3ZlciB7XFxuICAgIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOnJvbWFuOmhvdmVyIHtcXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6dXBwZXJjYXNlOmhvdmVyIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmxvd2VyY2FzZTpob3ZlciB7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBsb3dlcmNhc2U7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpjYXBpdGFsaXplOmhvdmVyIHtcXG4gICAgdGV4dC10cmFuc2Zvcm06IGNhcGl0YWxpemU7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpub3JtYWwtY2FzZTpob3ZlciB7XFxuICAgIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6dW5kZXJsaW5lOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpsaW5lLXRocm91Z2g6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOm5vLXVuZGVybGluZTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmFudGlhbGlhc2VkOmhvdmVyIHtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAgIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpzdWJwaXhlbC1hbnRpYWxpYXNlZDpob3ZlciB7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGF1dG87XFxuICAgIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0cmFja2luZy10aWdodCB7XFxuICAgIGxldHRlci1zcGFjaW5nOiAtMC4wNWVtO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp0cmFja2luZy1ub3JtYWwge1xcbiAgICBsZXR0ZXItc3BhY2luZzogMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dHJhY2tpbmctd2lkZSB7XFxuICAgIGxldHRlci1zcGFjaW5nOiAuMDVlbTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6c2VsZWN0LW5vbmUge1xcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6c2VsZWN0LXRleHQge1xcbiAgICB1c2VyLXNlbGVjdDogdGV4dDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YWxpZ24tYmFzZWxpbmUge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICB9XFxuXFxuICAueGxcXFxcOmFsaWduLXRvcCB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICB9XFxuXFxuICAueGxcXFxcOmFsaWduLW1pZGRsZSB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICB9XFxuXFxuICAueGxcXFxcOmFsaWduLWJvdHRvbSB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiBib3R0b207XFxuICB9XFxuXFxuICAueGxcXFxcOmFsaWduLXRleHQtdG9wIHtcXG4gICAgdmVydGljYWwtYWxpZ246IHRleHQtdG9wO1xcbiAgfVxcblxcbiAgLnhsXFxcXDphbGlnbi10ZXh0LWJvdHRvbSB7XFxuICAgIHZlcnRpY2FsLWFsaWduOiB0ZXh0LWJvdHRvbTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dmlzaWJsZSB7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICB9XFxuXFxuICAueGxcXFxcOmludmlzaWJsZSB7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIH1cXG5cXG4gIC54bFxcXFw6d2hpdGVzcGFjZS1ub3JtYWwge1xcbiAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp3aGl0ZXNwYWNlLW5vLXdyYXAge1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp3aGl0ZXNwYWNlLXByZSB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmU7XFxuICB9XFxuXFxuICAueGxcXFxcOndoaXRlc3BhY2UtcHJlLWxpbmUge1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLWxpbmU7XFxuICB9XFxuXFxuICAueGxcXFxcOndoaXRlc3BhY2UtcHJlLXdyYXAge1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICB9XFxuXFxuICAueGxcXFxcOmJyZWFrLXdvcmRzIHtcXG4gICAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpicmVhay1ub3JtYWwge1xcbiAgICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dHJ1bmNhdGUge1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dy0wIHtcXG4gICAgd2lkdGg6IDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnctMSB7XFxuICAgIHdpZHRoOiAycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnctMiB7XFxuICAgIHdpZHRoOiA0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnctMyB7XFxuICAgIHdpZHRoOiA4cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnctNCB7XFxuICAgIHdpZHRoOiAxNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDp3LTUge1xcbiAgICB3aWR0aDogMjRweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dy02IHtcXG4gICAgd2lkdGg6IDMycHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnctNyB7XFxuICAgIHdpZHRoOiAzNnB4O1xcbiAgfVxcblxcbiAgLnhsXFxcXDp3LTgge1xcbiAgICB3aWR0aDogNDhweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dy05IHtcXG4gICAgd2lkdGg6IDY0cHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnctMTAge1xcbiAgICB3aWR0aDogOTZweDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dy1zY3JlZW4ge1xcbiAgICB3aWR0aDogMTAwdnc7XFxuICB9XFxuXFxuICAueGxcXFxcOnctYXV0byB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp3LWZ1bGwge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6dy1weCB7XFxuICAgIHdpZHRoOiAxcHg7XFxuICB9XFxuXFxuICAueGxcXFxcOnctMVxcXFwvNiB7XFxuICAgIHdpZHRoOiAxNi42NjY2NjY2NjclO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp6LTAge1xcbiAgICB6LWluZGV4OiAwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp6LTEwIHtcXG4gICAgei1pbmRleDogMTA7XFxuICB9XFxuXFxuICAueGxcXFxcOnotMjAge1xcbiAgICB6LWluZGV4OiAyMDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6ei0zMCB7XFxuICAgIHotaW5kZXg6IDMwO1xcbiAgfVxcblxcbiAgLnhsXFxcXDp6LTQwIHtcXG4gICAgei1pbmRleDogNDA7XFxuICB9XFxuXFxuICAueGxcXFxcOnotNTAge1xcbiAgICB6LWluZGV4OiA1MDtcXG4gIH1cXG5cXG4gIC54bFxcXFw6ei1hdXRvIHtcXG4gICAgei1pbmRleDogYXV0bztcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctYmxhY2stMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Ymctd2hpdGUtMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctZ3JleS1saWdodGVyLTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLWdyZXktbGlnaHQtMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctZ3JleS0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1wdXJwbGUtbGlnaHQtMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLTEwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLWJyaWdodC0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLWRhcmstMTAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLWRhcmtlci0xMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6YmctYmxhY2stMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQwLCA0MCwgNDAsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLXdoaXRlLTEwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0ZXItMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI0MywgMjQzLCAyNDcsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLWdyZXktbGlnaHQtMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzMSwgMjMxLCAyMzYsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLWdyZXktMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1saWdodGVyLTEwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMDQsIDE5NCwgMjMzLCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtbGlnaHQtMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzNSwgMTI4LCAxNTUsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS0xMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtYnJpZ2h0LTEwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3NiwgNDEsIDE3NiwgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWRhcmstMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDY5LCA2MywgODYsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrZXItMTA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9jdXNcXFxcOmJnLWJsYWNrLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MCwgNDAsIDQwLCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy13aGl0ZS0xMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctZ3JleS1saWdodGVyLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LWxpZ2h0LTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzEsIDIzMSwgMjM2LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1ncmV5LTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0xMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0LTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzUsIDEyOCwgMTU1LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtMTA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjEpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWJyaWdodC0xMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4xKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1kYXJrLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFya2VyLTEwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMSk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLWJsYWNrLTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MCwgNDAsIDQwLCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXdoaXRlLTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLWdyZXktbGlnaHRlci0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQzLCAyNDMsIDI0NywgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpiZy1ncmV5LWxpZ2h0LTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzEsIDIzMSwgMjM2LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLWdyZXktMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE5NCwgMTk0LCAxOTgsIC4zKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLWxpZ2h0ZXItMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwNCwgMTk0LCAyMzMsIC4zKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6YmctcHVycGxlLWxpZ2h0LTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzUsIDEyOCwgMTU1LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXB1cnBsZS0zMCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTMxLCA5NiwgMjE0LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXB1cnBsZS1icmlnaHQtMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDc2LCA0MSwgMTc2LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXB1cnBsZS1kYXJrLTMwIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmJnLXB1cnBsZS1kYXJrZXItMzAge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDQyLCAzNywgNTYsIC4zKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLWJsYWNrLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MCwgNDAsIDQwLCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy13aGl0ZS0zMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6YmctZ3JleS1saWdodGVyLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNDMsIDI0MywgMjQ3LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1ncmV5LWxpZ2h0LTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzEsIDIzMSwgMjM2LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1ncmV5LTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxOTQsIDE5NCwgMTk4LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtbGlnaHRlci0zMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjA0LCAxOTQsIDIzMywgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWxpZ2h0LTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzUsIDEyOCwgMTU1LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtMzA6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEzMSwgOTYsIDIxNCwgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpob3ZlclxcXFw6YmctcHVycGxlLWJyaWdodC0zMDpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDQxLCAxNzYsIC4zKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6aG92ZXJcXFxcOmJnLXB1cnBsZS1kYXJrLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg2OSwgNjMsIDg2LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmhvdmVyXFxcXDpiZy1wdXJwbGUtZGFya2VyLTMwOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg0MiwgMzcsIDU2LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1ibGFjay0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDAsIDQwLCA0MCwgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6Ymctd2hpdGUtMzA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9jdXNcXFxcOmJnLWdyZXktbGlnaHRlci0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjQzLCAyNDMsIDI0NywgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctZ3JleS1saWdodC0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjMxLCAyMzEsIDIzNiwgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctZ3JleS0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTk0LCAxOTQsIDE5OCwgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWxpZ2h0ZXItMzA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIwNCwgMTk0LCAyMzMsIC4zKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1saWdodC0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTM1LCAxMjgsIDE1NSwgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLTMwOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMzEsIDk2LCAyMTQsIC4zKTtcXG4gIH1cXG5cXG4gIC54bFxcXFw6Zm9jdXNcXFxcOmJnLXB1cnBsZS1icmlnaHQtMzA6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDc2LCA0MSwgMTc2LCAuMyk7XFxuICB9XFxuXFxuICAueGxcXFxcOmZvY3VzXFxcXDpiZy1wdXJwbGUtZGFyay0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNjksIDYzLCA4NiwgLjMpO1xcbiAgfVxcblxcbiAgLnhsXFxcXDpmb2N1c1xcXFw6YmctcHVycGxlLWRhcmtlci0zMDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNDIsIDM3LCA1NiwgLjMpO1xcbiAgfVxcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nOyIsInZhciBoYXNSQUYgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSB1bmRlZmluZWQ7XHJcbnZhciBwcmV2VGltZSA9IDA7XHJcbnZhciBvbk5leHRGcmFtZSA9IGhhc1JBRlxyXG4gICAgPyBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spOyB9XHJcbiAgICA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNi43IC0gKGN1cnJlbnRUaW1lIC0gcHJldlRpbWUpKTtcclxuICAgICAgICBwcmV2VGltZSA9IGN1cnJlbnRUaW1lICsgdGltZVRvQ2FsbDtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKHByZXZUaW1lKTsgfSwgdGltZVRvQ2FsbCk7XHJcbiAgICB9O1xuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJTdGVwKHN0YXJ0UmVuZGVyTG9vcCkge1xyXG4gICAgdmFyIGZ1bmN0aW9uc1RvUnVuID0gW107XHJcbiAgICB2YXIgZnVuY3Rpb25zVG9SdW5OZXh0RnJhbWUgPSBbXTtcclxuICAgIHZhciBudW1UaGlzRnJhbWUgPSAwO1xyXG4gICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXhPZkNhbGxiYWNrID0gZnVuY3Rpb25zVG9SdW5OZXh0RnJhbWUuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleE9mQ2FsbGJhY2sgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbnNUb1J1bk5leHRGcmFtZS5zcGxpY2UoaW5kZXhPZkNhbGxiYWNrLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBfYSA9IFtmdW5jdGlvbnNUb1J1bk5leHRGcmFtZSwgZnVuY3Rpb25zVG9SdW5dLCBmdW5jdGlvbnNUb1J1biA9IF9hWzBdLCBmdW5jdGlvbnNUb1J1bk5leHRGcmFtZSA9IF9hWzFdO1xyXG4gICAgICAgICAgICBmdW5jdGlvbnNUb1J1bk5leHRGcmFtZS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBudW1UaGlzRnJhbWUgPSBmdW5jdGlvbnNUb1J1bi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1UaGlzRnJhbWU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zVG9SdW5baV0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NoZWR1bGU6IGZ1bmN0aW9uIChjYWxsYmFjaywgaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChpbW1lZGlhdGUgPT09IHZvaWQgMCkgeyBpbW1lZGlhdGUgPSBmYWxzZTsgfVxyXG4gICAgICAgICAgICBzdGFydFJlbmRlckxvb3AoKTtcclxuICAgICAgICAgICAgdmFyIGFkZFRvQ3VycmVudEJ1ZmZlciA9IGltbWVkaWF0ZSAmJiBpc1Byb2Nlc3Npbmc7XHJcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBhZGRUb0N1cnJlbnRCdWZmZXIgPyBmdW5jdGlvbnNUb1J1biA6IGZ1bmN0aW9uc1RvUnVuTmV4dEZyYW1lO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmluZGV4T2YoY2FsbGJhY2spID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFkZFRvQ3VycmVudEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bVRoaXNGcmFtZSA9IGZ1bmN0aW9uc1RvUnVuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59XG5cbnZhciBIQVNfUEVSRk9STUFOQ0VfTk9XID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBwZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZDtcclxudmFyIGN1cnJlbnRUaW1lID0gSEFTX1BFUkZPUk1BTkNFX05PVyA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpOyB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGF0ZS5ub3coKTsgfTtcclxudmFyIHdpbGxSZW5kZXJOZXh0RnJhbWUgPSBmYWxzZTtcclxudmFyIE1BWF9FTEFQU0VEID0gNDA7XHJcbnZhciBkZWZhdWx0RWxhcHNlZCA9IDE2Ljc7XHJcbnZhciB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XHJcbnZhciBjdXJyZW50RnJhbWVzdGFtcCA9IDA7XHJcbnZhciBlbGFwc2VkID0gMDtcclxuZnVuY3Rpb24gc3RhcnRSZW5kZXJMb29wKCkge1xyXG4gICAgaWYgKHdpbGxSZW5kZXJOZXh0RnJhbWUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgd2lsbFJlbmRlck5leHRGcmFtZSA9IHRydWU7XHJcbiAgICB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XHJcbiAgICBvbk5leHRGcmFtZShwcm9jZXNzRnJhbWUpO1xyXG59XHJcbnZhciBmcmFtZVN0YXJ0ID0gY3JlYXRlUmVuZGVyU3RlcChzdGFydFJlbmRlckxvb3ApO1xyXG52YXIgZnJhbWVVcGRhdGUgPSBjcmVhdGVSZW5kZXJTdGVwKHN0YXJ0UmVuZGVyTG9vcCk7XHJcbnZhciBmcmFtZVJlbmRlciA9IGNyZWF0ZVJlbmRlclN0ZXAoc3RhcnRSZW5kZXJMb29wKTtcclxudmFyIGZyYW1lRW5kID0gY3JlYXRlUmVuZGVyU3RlcChzdGFydFJlbmRlckxvb3ApO1xyXG5mdW5jdGlvbiBwcm9jZXNzRnJhbWUoZnJhbWVzdGFtcCkge1xyXG4gICAgd2lsbFJlbmRlck5leHRGcmFtZSA9IGZhbHNlO1xyXG4gICAgZWxhcHNlZCA9IHVzZURlZmF1bHRFbGFwc2VkXHJcbiAgICAgICAgPyBkZWZhdWx0RWxhcHNlZFxyXG4gICAgICAgIDogTWF0aC5tYXgoTWF0aC5taW4oZnJhbWVzdGFtcCAtIGN1cnJlbnRGcmFtZXN0YW1wLCBNQVhfRUxBUFNFRCksIDEpO1xyXG4gICAgaWYgKCF1c2VEZWZhdWx0RWxhcHNlZClcclxuICAgICAgICBkZWZhdWx0RWxhcHNlZCA9IGVsYXBzZWQ7XHJcbiAgICBjdXJyZW50RnJhbWVzdGFtcCA9IGZyYW1lc3RhbXA7XHJcbiAgICBmcmFtZVN0YXJ0LnByb2Nlc3MoKTtcclxuICAgIGZyYW1lVXBkYXRlLnByb2Nlc3MoKTtcclxuICAgIGZyYW1lUmVuZGVyLnByb2Nlc3MoKTtcclxuICAgIGZyYW1lRW5kLnByb2Nlc3MoKTtcclxuICAgIGlmICh3aWxsUmVuZGVyTmV4dEZyYW1lKVxyXG4gICAgICAgIHVzZURlZmF1bHRFbGFwc2VkID0gZmFsc2U7XHJcbn1cclxudmFyIG9uRnJhbWVTdGFydCA9IGZyYW1lU3RhcnQuc2NoZWR1bGU7XHJcbnZhciBvbkZyYW1lVXBkYXRlID0gZnJhbWVVcGRhdGUuc2NoZWR1bGU7XHJcbnZhciBvbkZyYW1lUmVuZGVyID0gZnJhbWVSZW5kZXIuc2NoZWR1bGU7XHJcbnZhciBvbkZyYW1lRW5kID0gZnJhbWVFbmQuc2NoZWR1bGU7XHJcbnZhciBjYW5jZWxPbkZyYW1lU3RhcnQgPSBmcmFtZVN0YXJ0LmNhbmNlbDtcclxudmFyIGNhbmNlbE9uRnJhbWVVcGRhdGUgPSBmcmFtZVVwZGF0ZS5jYW5jZWw7XHJcbnZhciBjYW5jZWxPbkZyYW1lUmVuZGVyID0gZnJhbWVSZW5kZXIuY2FuY2VsO1xyXG52YXIgY2FuY2VsT25GcmFtZUVuZCA9IGZyYW1lRW5kLmNhbmNlbDtcclxudmFyIHRpbWVTaW5jZUxhc3RGcmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsYXBzZWQ7IH07XHJcbnZhciBjdXJyZW50RnJhbWVUaW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY3VycmVudEZyYW1lc3RhbXA7IH07XG5cbmV4cG9ydCB7IGN1cnJlbnRUaW1lLCBvbkZyYW1lU3RhcnQsIG9uRnJhbWVVcGRhdGUsIG9uRnJhbWVSZW5kZXIsIG9uRnJhbWVFbmQsIGNhbmNlbE9uRnJhbWVTdGFydCwgY2FuY2VsT25GcmFtZVVwZGF0ZSwgY2FuY2VsT25GcmFtZVJlbmRlciwgY2FuY2VsT25GcmFtZUVuZCwgdGltZVNpbmNlTGFzdEZyYW1lLCBjdXJyZW50RnJhbWVUaW1lIH07XG4iLCIvLyBAZmxvd1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5ID0gJ19fZ2xvYmFsX3VuaXF1ZV9pZF9fJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdsb2JhbFtrZXldID0gKGdsb2JhbFtrZXldIHx8IDApICsgMTtcbn07XG4iLCJ2YXIgSEVZX0xJU1RFTiA9ICdIZXksIGxpc3RlbiEgJztcclxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7IH07XHJcbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gKGNoZWNrLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCFjaGVjayAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKEhFWV9MSVNURU4gKyBtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaW52YXJpYW50ID0gZnVuY3Rpb24gKGNoZWNrLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCFjaGVjaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSEVZX0xJU1RFTi50b1VwcGVyQ2FzZSgpICsgbWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5leHBvcnQgeyB3YXJuaW5nLCBpbnZhcmlhbnQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCJpbXBvcnQgeyBzcHJpbmcsIHR3ZWVuLCBhY3Rpb24sIGVhc2luZywgcG9pbnRlciwgdHJhbnNmb3JtLCBkZWNheSwga2V5ZnJhbWVzLCBwaHlzaWNzLCB2YWx1ZSwgY2hhaW4sIGRlbGF5LCBsaXN0ZW4sIHN0eWxlciB9IGZyb20gJ3BvcG1vdGlvbic7XG5pbXBvcnQgeyBwZXJjZW50LCBudW1iZXIsIGRlZ3JlZXMsIHB4LCB2dywgdmggfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgcG9zZUZhY3RvcnkgZnJvbSAncG9zZS1jb3JlJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ2hleS1saXN0ZW4nO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgICByZXR1cm4gdDtcbn1cblxudmFyIEJvdW5kaW5nQm94RGltZW5zaW9uO1xuKGZ1bmN0aW9uIChCb3VuZGluZ0JveERpbWVuc2lvbikge1xuICAgIEJvdW5kaW5nQm94RGltZW5zaW9uW1wid2lkdGhcIl0gPSBcIndpZHRoXCI7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJoZWlnaHRcIl0gPSBcImhlaWdodFwiO1xuICAgIEJvdW5kaW5nQm94RGltZW5zaW9uW1wibGVmdFwiXSA9IFwibGVmdFwiO1xuICAgIEJvdW5kaW5nQm94RGltZW5zaW9uW1wicmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gICAgQm91bmRpbmdCb3hEaW1lbnNpb25bXCJ0b3BcIl0gPSBcInRvcFwiO1xuICAgIEJvdW5kaW5nQm94RGltZW5zaW9uW1wiYm90dG9tXCJdID0gXCJib3R0b21cIjtcbn0pKEJvdW5kaW5nQm94RGltZW5zaW9uIHx8IChCb3VuZGluZ0JveERpbWVuc2lvbiA9IHt9KSk7XG5cbnZhciBsaW5lYXIgPSBlYXNpbmcubGluZWFyO1xudmFyIGludGVycG9sYXRlID0gdHJhbnNmb3JtLmludGVycG9sYXRlO1xudmFyIHNpbmdsZUF4aXNQb2ludGVyID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGZyb20pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gcG9pbnRlcigoX2EgPSB7fSwgX2FbYXhpc10gPSB0eXBlb2YgZnJvbSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KGZyb20pIDogZnJvbSwgX2EpKS5waXBlKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gdltheGlzXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG52YXIgcG9pbnRlclggPSAvKiNfX1BVUkVfXyovc2luZ2xlQXhpc1BvaW50ZXIoJ3gnKTtcbnZhciBwb2ludGVyWSA9IC8qI19fUFVSRV9fKi9zaW5nbGVBeGlzUG9pbnRlcigneScpO1xudmFyIGNyZWF0ZVBvaW50ZXIgPSBmdW5jdGlvbiAoYXhpc1BvaW50ZXJDcmVhdG9yLCBtaW4sIG1heCwgbWVhc3VyZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBmcm9tID0gX2EuZnJvbSxcbiAgICAgICAgICAgIHR5cGUgPSBfYS50eXBlLFxuICAgICAgICAgICAgZGltZW5zaW9ucyA9IF9hLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICBkcmFnQm91bmRzID0gX2EuZHJhZ0JvdW5kcztcbiAgICAgICAgdmFyIGF4aXNQb2ludGVyID0gYXhpc1BvaW50ZXJDcmVhdG9yKGRpbWVuc2lvbnMubWVhc3VyZW1lbnRBc1BpeGVscyhtZWFzdXJlbWVudCwgZnJvbSwgdHlwZSkpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtUXVldWUgPSBbXTtcbiAgICAgICAgaWYgKGRyYWdCb3VuZHMpIHtcbiAgICAgICAgICAgIGlmIChkcmFnQm91bmRzW21pbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVF1ZXVlLnB1c2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHYsIGRpbWVuc2lvbnMubWVhc3VyZW1lbnRBc1BpeGVscyhtZWFzdXJlbWVudCwgZHJhZ0JvdW5kc1ttaW5dLCB0eXBlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ0JvdW5kc1ttYXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1RdWV1ZS5wdXNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih2LCBkaW1lbnNpb25zLm1lYXN1cmVtZW50QXNQaXhlbHMobWVhc3VyZW1lbnQsIGRyYWdCb3VuZHNbbWF4XSwgdHlwZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBwZXJjZW50KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1RdWV1ZS5wdXNoKGludGVycG9sYXRlKFswLCBkaW1lbnNpb25zLmdldChtZWFzdXJlbWVudCldLCBbMCwgMTAwXSksIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgKyAnJSc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUXVldWUubGVuZ3RoID8gYXhpc1BvaW50ZXIucGlwZS5hcHBseShheGlzUG9pbnRlciwgdHJhbnNmb3JtUXVldWUpIDogYXhpc1BvaW50ZXI7XG4gICAgfTtcbn07XG52YXIganVzdCA9IGZ1bmN0aW9uIChmcm9tKSB7XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IF9hLnVwZGF0ZSxcbiAgICAgICAgICAgIGNvbXBsZXRlID0gX2EuY29tcGxldGU7XG4gICAgICAgIHVwZGF0ZShmcm9tKTtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICB9KTtcbn07XG52YXIgdW5kZXJEYW1wZWRTcHJpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZnJvbSA9IF9hLmZyb20sXG4gICAgICAgIHZlbG9jaXR5ID0gX2EudmVsb2NpdHksXG4gICAgICAgIHRvID0gX2EudG87XG4gICAgcmV0dXJuIHNwcmluZyh7XG4gICAgICAgIGZyb206IGZyb20sXG4gICAgICAgIHRvOiB0byxcbiAgICAgICAgdmVsb2NpdHk6IHZlbG9jaXR5LFxuICAgICAgICBzdGlmZm5lc3M6IDUwMCxcbiAgICAgICAgZGFtcGluZzogMjUsXG4gICAgICAgIHJlc3REZWx0YTogMC41LFxuICAgICAgICByZXN0U3BlZWQ6IDEwXG4gICAgfSk7XG59O1xudmFyIG92ZXJEYW1wZWRTcHJpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZnJvbSA9IF9hLmZyb20sXG4gICAgICAgIHZlbG9jaXR5ID0gX2EudmVsb2NpdHksXG4gICAgICAgIHRvID0gX2EudG87XG4gICAgcmV0dXJuIHNwcmluZyh7IGZyb206IGZyb20sIHRvOiB0bywgdmVsb2NpdHk6IHZlbG9jaXR5LCBzdGlmZm5lc3M6IDcwMCwgZGFtcGluZzogdG8gPT09IDAgPyAxMDAgOiAzNSB9KTtcbn07XG52YXIgbGluZWFyVHdlZW4gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZnJvbSA9IF9hLmZyb20sXG4gICAgICAgIHRvID0gX2EudG87XG4gICAgcmV0dXJuIHR3ZWVuKHsgZnJvbTogZnJvbSwgdG86IHRvLCBlYXNlOiBsaW5lYXIgfSk7XG59O1xudmFyIGludGVsbGlnZW50VHJhbnNpdGlvbiA9IHtcbiAgICB4OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICB5OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICB6OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICByb3RhdGU6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZVg6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZVk6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZVo6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHNjYWxlWDogb3ZlckRhbXBlZFNwcmluZyxcbiAgICBzY2FsZVk6IG92ZXJEYW1wZWRTcHJpbmcsXG4gICAgc2NhbGU6IG92ZXJEYW1wZWRTcHJpbmcsXG4gICAgb3BhY2l0eTogbGluZWFyVHdlZW4sXG4gICAgZGVmYXVsdDogdHdlZW5cbn07XG52YXIgZHJhZ0FjdGlvbiA9IC8qI19fUFVSRV9fKi9fX2Fzc2lnbih7fSwgaW50ZWxsaWdlbnRUcmFuc2l0aW9uLCB7IHg6IC8qI19fUFVSRV9fKi9jcmVhdGVQb2ludGVyKHBvaW50ZXJYLCAnbGVmdCcsICdyaWdodCcsIEJvdW5kaW5nQm94RGltZW5zaW9uLndpZHRoKSwgeTogLyojX19QVVJFX18qL2NyZWF0ZVBvaW50ZXIocG9pbnRlclksICd0b3AnLCAnYm90dG9tJywgQm91bmRpbmdCb3hEaW1lbnNpb24uaGVpZ2h0KSB9KTtcbnZhciBqdXN0QXhpcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBmcm9tID0gX2EuZnJvbTtcbiAgICByZXR1cm4ganVzdChmcm9tKTtcbn07XG52YXIgaW50ZWxsaWdlbnREcmFnRW5kID0gLyojX19QVVJFX18qL19fYXNzaWduKHt9LCBpbnRlbGxpZ2VudFRyYW5zaXRpb24sIHsgeDoganVzdEF4aXMsIHk6IGp1c3RBeGlzIH0pO1xudmFyIGRlZmF1bHRUcmFuc2l0aW9ucyA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKFtbJ2RlZmF1bHQnLCBpbnRlbGxpZ2VudFRyYW5zaXRpb25dLCBbJ2RyYWcnLCBkcmFnQWN0aW9uXSwgWydkcmFnRW5kJywgaW50ZWxsaWdlbnREcmFnRW5kXV0pO1xuXG52YXIgYXV0byA9IHtcbiAgICB0ZXN0OiBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdiA9PT0gJ2F1dG8nO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn07XG52YXIgdmFsdWVUeXBlVGVzdHMgPSBbbnVtYmVyLCBkZWdyZWVzLCBwZXJjZW50LCBweCwgdncsIHZoLCBhdXRvXTtcbnZhciB0ZXN0VmFsdWVUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUudGVzdCh2KTtcbiAgICB9O1xufTtcbnZhciBnZXRWYWx1ZVR5cGUgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2YWx1ZVR5cGVUZXN0cy5maW5kKHRlc3RWYWx1ZVR5cGUodikpO1xufTtcblxudmFyIGNyZWF0ZVBhc3NpdmVWYWx1ZSA9IGZ1bmN0aW9uIChpbml0LCBwYXJlbnQsIHRyYW5zZm9ybSQkMSkge1xuICAgIHZhciByYXcgPSB2YWx1ZSh0cmFuc2Zvcm0kJDEoaW5pdCkpO1xuICAgIHBhcmVudC5yYXcuc3Vic2NyaWJlKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiByYXcudXBkYXRlKHRyYW5zZm9ybSQkMSh2KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcmF3OiByYXcgfTtcbn07XG52YXIgY3JlYXRlVmFsdWUgPSBmdW5jdGlvbiAoaW5pdCkge1xuICAgIHZhciB0eXBlID0gZ2V0VmFsdWVUeXBlKGluaXQpO1xuICAgIHZhciByYXcgPSB2YWx1ZShpbml0KTtcbiAgICByZXR1cm4geyByYXc6IHJhdywgdHlwZTogdHlwZSB9O1xufTtcbnZhciBhZGRBY3Rpb25EZWxheSA9IGZ1bmN0aW9uIChkZWxheSQkMSwgdHJhbnNpdGlvbikge1xuICAgIGlmIChkZWxheSQkMSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGF5JCQxID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYWluKGRlbGF5KGRlbGF5JCQxKSwgdHJhbnNpdGlvbik7XG59O1xudmFyIGFuaW1hdGlvbkxvb2t1cCA9IHtcbiAgICB0d2VlbjogdHdlZW4sXG4gICAgc3ByaW5nOiBzcHJpbmcsXG4gICAgZGVjYXk6IGRlY2F5LFxuICAgIGtleWZyYW1lczoga2V5ZnJhbWVzLFxuICAgIHBoeXNpY3M6IHBoeXNpY3Ncbn07XG52YXIgbGluZWFyJDEgPSBlYXNpbmcubGluZWFyLFxuICAgIGVhc2VJbiA9IGVhc2luZy5lYXNlSW4sXG4gICAgZWFzZU91dCA9IGVhc2luZy5lYXNlT3V0LFxuICAgIGVhc2VJbk91dCA9IGVhc2luZy5lYXNlSW5PdXQsXG4gICAgY2lyY0luID0gZWFzaW5nLmNpcmNJbixcbiAgICBjaXJjT3V0ID0gZWFzaW5nLmNpcmNPdXQsXG4gICAgY2lyY0luT3V0ID0gZWFzaW5nLmNpcmNJbk91dCxcbiAgICBiYWNrSW4gPSBlYXNpbmcuYmFja0luLFxuICAgIGJhY2tPdXQgPSBlYXNpbmcuYmFja091dCxcbiAgICBiYWNrSW5PdXQgPSBlYXNpbmcuYmFja0luT3V0LFxuICAgIGFudGljaXBhdGUgPSBlYXNpbmcuYW50aWNpcGF0ZTtcbnZhciBlYXNpbmdMb29rdXAgPSB7XG4gICAgbGluZWFyOiBsaW5lYXIkMSxcbiAgICBlYXNlSW46IGVhc2VJbixcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0LFxuICAgIGNpcmNJbjogY2lyY0luLFxuICAgIGNpcmNPdXQ6IGNpcmNPdXQsXG4gICAgY2lyY0luT3V0OiBjaXJjSW5PdXQsXG4gICAgYmFja0luOiBiYWNrSW4sXG4gICAgYmFja091dDogYmFja091dCxcbiAgICBiYWNrSW5PdXQ6IGJhY2tJbk91dCxcbiAgICBhbnRpY2lwYXRlOiBhbnRpY2lwYXRlXG59O1xudmFyIGdldEFjdGlvbiA9IGZ1bmN0aW9uICh2LCBfYSwgX2IpIHtcbiAgICB2YXIgZnJvbSA9IF9iLmZyb20sXG4gICAgICAgIHRvID0gX2IudG8sXG4gICAgICAgIHZlbG9jaXR5ID0gX2IudmVsb2NpdHk7XG4gICAgdmFyIF9jID0gX2EudHlwZSxcbiAgICAgICAgdHlwZSA9IF9jID09PSB2b2lkIDAgPyAndHdlZW4nIDogX2MsXG4gICAgICAgIGVhc2UgPSBfYS5lYXNlLFxuICAgICAgICBkZWYgPSBfX3Jlc3QoX2EsIFtcInR5cGVcIiwgXCJlYXNlXCJdKTtcbiAgICBpbnZhcmlhbnQoYW5pbWF0aW9uTG9va3VwW3R5cGVdICE9PSB1bmRlZmluZWQsIFwiSW52YWxpZCB0cmFuc2l0aW9uIHR5cGUgJ1wiICsgdHlwZSArIFwiJy4gVmFsaWQgdHJhbnNpdGlvbiB0eXBlcyBhcmU6IHR3ZWVuLCBzcHJpbmcsIGRlY2F5LCBwaHlzaWNzIGFuZCBrZXlmcmFtZXMuXCIpO1xuICAgIGlmICh0eXBlID09PSAndHdlZW4nKSB7XG4gICAgICAgIHZhciB0eXBlT2ZFYXNlID0gdHlwZW9mIGVhc2U7XG4gICAgICAgIGlmICh0eXBlT2ZFYXNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZU9mRWFzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnZhcmlhbnQoZWFzaW5nTG9va3VwW2Vhc2VdICE9PSB1bmRlZmluZWQsIFwiSW52YWxpZCBlYXNpbmcgdHlwZSAnXCIgKyBlYXNlICsgXCInLiBwb3Btb3Rpb24uaW8vcG9zZS9hcGkvY29uZmlnXCIpO1xuICAgICAgICAgICAgICAgIGVhc2UgPSBlYXNpbmdMb29rdXBbZWFzZV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZWFzZSkpIHtcbiAgICAgICAgICAgICAgICBpbnZhcmlhbnQoZWFzZS5sZW5ndGggPT09IDQsIFwiQ3ViaWMgYmV6aWVyIGFycmF5cyBtdXN0IGNvbnRhaW4gZm91ciBudW1lcmljYWwgdmFsdWVzLlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBlYXNlWzBdLFxuICAgICAgICAgICAgICAgICAgICB5MSA9IGVhc2VbMV0sXG4gICAgICAgICAgICAgICAgICAgIHgyID0gZWFzZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBlYXNlWzNdO1xuICAgICAgICAgICAgICAgIGVhc2UgPSBlYXNpbmcuY3ViaWNCZXppZXIoeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBiYXNlUHJvcHMgPSB0eXBlICE9PSAna2V5ZnJhbWVzJyA/IHtcbiAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgdG86IHRvLFxuICAgICAgICB2ZWxvY2l0eTogdmVsb2NpdHksXG4gICAgICAgIGVhc2U6IGVhc2VcbiAgICB9IDogeyBlYXNlOiBlYXNlIH07XG4gICAgcmV0dXJuIGFuaW1hdGlvbkxvb2t1cFt0eXBlXShfX2Fzc2lnbih7fSwgYmFzZVByb3BzLCBkZWYpKTtcbn07XG52YXIgaXNBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uJCQxKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhY3Rpb24kJDEuc3RhcnQgIT09ICd1bmRlZmluZWQnO1xufTtcbnZhciBwb3NlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHRyYW5zZm9ybVBvc2UgPSBfYS50cmFuc2Zvcm1Qb3NlLFxuICAgICAgICBhZGRMaXN0ZW5lclRvVmFsdWUgPSBfYS5hZGRMaXN0ZW5lclRvVmFsdWUsXG4gICAgICAgIGV4dGVuZEFQSSA9IF9hLmV4dGVuZEFQSSxcbiAgICAgICAgcmVhZFZhbHVlRnJvbVNvdXJjZSA9IF9hLnJlYWRWYWx1ZUZyb21Tb3VyY2UsXG4gICAgICAgIHBvc2VQcmlvcml0eSA9IF9hLnBvc2VQcmlvcml0eSxcbiAgICAgICAgc2V0VmFsdWVOYXRpdmUgPSBfYS5zZXRWYWx1ZU5hdGl2ZTtcbiAgICByZXR1cm4gcG9zZUZhY3Rvcnkoe1xuICAgICAgICBiaW5kT25DaGFuZ2U6IGZ1bmN0aW9uICh2YWx1ZXMsIG9uQ2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWVzLmhhcyhrZXkpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIHJhdyA9IHZhbHVlcy5nZXQoa2V5KS5yYXc7XG4gICAgICAgICAgICAgICAgcmF3LnN1YnNjcmliZShvbkNoYW5nZVtrZXldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRWYWx1ZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgcmF3ID0gX2EucmF3O1xuICAgICAgICAgICAgcmV0dXJuIHJhdy5nZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uIChfYSwgdG8pIHtcbiAgICAgICAgICAgIHZhciByYXcgPSBfYS5yYXc7XG4gICAgICAgICAgICByZXR1cm4gcmF3LnVwZGF0ZSh0byk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVZhbHVlOiBmdW5jdGlvbiAoaW5pdCwga2V5LCBfYSwgX2IpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50U3R5bGVyID0gX2EuZWxlbWVudFN0eWxlcjtcbiAgICAgICAgICAgIHZhciBfYyA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iLFxuICAgICAgICAgICAgICAgIHBhc3NpdmVQYXJlbnQgPSBfYy5wYXNzaXZlUGFyZW50LFxuICAgICAgICAgICAgICAgIHBhc3NpdmVQcm9wcyA9IF9jLnBhc3NpdmVQcm9wcztcbiAgICAgICAgICAgIHZhciB2YWwgPSBwYXNzaXZlUGFyZW50ID8gY3JlYXRlUGFzc2l2ZVZhbHVlKGluaXQsIHBhc3NpdmVQYXJlbnQsIHBhc3NpdmVQcm9wcykgOiBjcmVhdGVWYWx1ZShpbml0KTtcbiAgICAgICAgICAgIGlmIChhZGRMaXN0ZW5lclRvVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWwucmF3LnN1YnNjcmliZShhZGRMaXN0ZW5lclRvVmFsdWUoa2V5LCBlbGVtZW50U3R5bGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0VmFsdWU6IGZ1bmN0aW9uIChyYXcsIGtleSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50U3R5bGVyID0gX2EuZWxlbWVudFN0eWxlcjtcbiAgICAgICAgICAgIGlmIChhZGRMaXN0ZW5lclRvVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByYXcuc3Vic2NyaWJlKGFkZExpc3RlbmVyVG9WYWx1ZShrZXksIGVsZW1lbnRTdHlsZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0VmFsdWVUeXBlKHJhdy5nZXQoKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRyYW5zaXRpb25Qcm9wczogZnVuY3Rpb24gKF9hLCB0bykge1xuICAgICAgICAgICAgdmFyIHJhdyA9IF9hLnJhdyxcbiAgICAgICAgICAgICAgICB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogcmF3LmdldCgpLFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5OiByYXcuZ2V0VmVsb2NpdHkoKSxcbiAgICAgICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzb2x2ZVRhcmdldDogZnVuY3Rpb24gKF8sIHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdFZhbHVlVG9SZWFkOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciByYXcgPSBfYS5yYXc7XG4gICAgICAgICAgICByZXR1cm4gcmF3O1xuICAgICAgICB9LFxuICAgICAgICBzdGFydEFjdGlvbjogZnVuY3Rpb24gKF9hLCBhY3Rpb24kJDEsIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICB2YXIgcmF3ID0gX2EucmF3O1xuICAgICAgICAgICAgdmFyIHJlYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhdy51cGRhdGUodik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uJCQxLnN0YXJ0KHJlYWN0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcEFjdGlvbjogZnVuY3Rpb24gKGFjdGlvbiQkMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbiQkMS5zdG9wKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEluc3RhbnRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgICAgIHZhciB0byA9IF9hLnRvO1xuICAgICAgICAgICAgcmV0dXJuIGp1c3QodG8pO1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0VHJhbnNpdGlvbkRlZmluaXRpb246IGZ1bmN0aW9uICh2YWwsIGRlZiwgcHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChpc0FjdGlvbihkZWYpKSByZXR1cm4gZGVmO1xuICAgICAgICAgICAgdmFyIGRlbGF5JCQxID0gZGVmLmRlbGF5LFxuICAgICAgICAgICAgICAgIG1pbiA9IGRlZi5taW4sXG4gICAgICAgICAgICAgICAgbWF4ID0gZGVmLm1heCxcbiAgICAgICAgICAgICAgICByb3VuZCA9IGRlZi5yb3VuZCxcbiAgICAgICAgICAgICAgICByZW1haW5pbmdEZWYgPSBfX3Jlc3QoZGVmLCBbXCJkZWxheVwiLCBcIm1pblwiLCBcIm1heFwiLCBcInJvdW5kXCJdKTtcbiAgICAgICAgICAgIHZhciBhY3Rpb24kJDEgPSBnZXRBY3Rpb24odmFsLCByZW1haW5pbmdEZWYsIHByb3BzKTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRQaXBlID0gW107XG4gICAgICAgICAgICBpZiAoZGVsYXkkJDEpIGFjdGlvbiQkMSA9IGFkZEFjdGlvbkRlbGF5KGRlbGF5JCQxLCBhY3Rpb24kJDEpO1xuICAgICAgICAgICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkKSBvdXRwdXRQaXBlLnB1c2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodiwgbWluKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSBvdXRwdXRQaXBlLnB1c2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odiwgbWF4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJvdW5kKSBvdXRwdXRQaXBlLnB1c2goTWF0aC5yb3VuZCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0UGlwZS5sZW5ndGggPyBhY3Rpb24kJDEucGlwZS5hcHBseShhY3Rpb24kJDEsIG91dHB1dFBpcGUpIDogYWN0aW9uJCQxO1xuICAgICAgICB9LFxuICAgICAgICBzZXRWYWx1ZU5hdGl2ZTogc2V0VmFsdWVOYXRpdmUsXG4gICAgICAgIGFkZEFjdGlvbkRlbGF5OiBhZGRBY3Rpb25EZWxheSxcbiAgICAgICAgZGVmYXVsdFRyYW5zaXRpb25zOiBkZWZhdWx0VHJhbnNpdGlvbnMsXG4gICAgICAgIHRyYW5zZm9ybVBvc2U6IHRyYW5zZm9ybVBvc2UsXG4gICAgICAgIHJlYWRWYWx1ZUZyb21Tb3VyY2U6IHJlYWRWYWx1ZUZyb21Tb3VyY2UsXG4gICAgICAgIHBvc2VQcmlvcml0eTogcG9zZVByaW9yaXR5LFxuICAgICAgICBleHRlbmRBUEk6IGV4dGVuZEFQSVxuICAgIH0pO1xufTtcblxudmFyIGNyZWF0ZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBoYXNNZWFzdXJlZCA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50ID0ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgcmlnaHQ6IDBcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKG1lYXN1cmVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWVhc3VyZW1lbnQgPyBjdXJyZW50W21lYXN1cmVtZW50XSA6IGN1cnJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIG1lYXN1cmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaGFzTWVhc3VyZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIG1lYXN1cmVtZW50QXNQaXhlbHM6IGZ1bmN0aW9uIChtZWFzdXJlbWVudCwgdmFsdWUkJDEsIHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlID09PSBwZXJjZW50ID8gKHR5cGVvZiB2YWx1ZSQkMSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHZhbHVlJCQxKSA6IHZhbHVlJCQxKSAvIDEwMCAqIGN1cnJlbnRbbWVhc3VyZW1lbnRdIDogdmFsdWUkJDE7XG4gICAgICAgIH0sXG4gICAgICAgIGhhczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc01lYXN1cmVkO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbnZhciBtYWtlVUlFdmVudEFwcGxpY2F0b3IgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgc3RhcnRFdmVudHMgPSBfYS5zdGFydEV2ZW50cyxcbiAgICAgICAgZW5kRXZlbnRzID0gX2EuZW5kRXZlbnRzLFxuICAgICAgICBzdGFydFBvc2UgPSBfYS5zdGFydFBvc2UsXG4gICAgICAgIGVuZFBvc2UgPSBfYS5lbmRQb3NlLFxuICAgICAgICBzdGFydENhbGxiYWNrID0gX2Euc3RhcnRDYWxsYmFjayxcbiAgICAgICAgZW5kQ2FsbGJhY2sgPSBfYS5lbmRDYWxsYmFjayxcbiAgICAgICAgdXNlRG9jdW1lbnRUb0VuZCA9IF9hLnVzZURvY3VtZW50VG9FbmQsXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gX2EucHJldmVudERlZmF1bHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50LCBhY3RpdmVBY3Rpb25zLCBwb3NlciwgY29uZmlnKSB7XG4gICAgICAgIHZhciBzdGFydExpc3RlbmVyID0gc3RhcnRQb3NlICsgJ1N0YXJ0JztcbiAgICAgICAgdmFyIGVuZExpc3RlbmVyID0gc3RhcnRQb3NlICsgJ0VuZCc7XG4gICAgICAgIHZhciBldmVudFN0YXJ0TGlzdGVuZXIgPSBsaXN0ZW4oZWxlbWVudCwgc3RhcnRFdmVudHMpLnN0YXJ0KGZ1bmN0aW9uIChzdGFydEV2ZW50KSB7XG4gICAgICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHN0YXJ0RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHBvc2VyLnNldChzdGFydFBvc2UpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0Q2FsbGJhY2sgJiYgY29uZmlnW3N0YXJ0Q2FsbGJhY2tdKSBjb25maWdbc3RhcnRDYWxsYmFja10oc3RhcnRFdmVudCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRFbmRMaXN0ZW5lciA9IGxpc3Rlbih1c2VEb2N1bWVudFRvRW5kID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZWxlbWVudCwgZW5kRXZlbnRzICsgKHVzZURvY3VtZW50VG9FbmQgPyAnIG1vdXNlZW50ZXInIDogJycpKS5zdGFydChmdW5jdGlvbiAoZW5kRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlRG9jdW1lbnRUb0VuZCAmJiBlbmRFdmVudC50eXBlID09PSAnbW91c2VlbnRlcicgJiYgZW5kRXZlbnQuYnV0dG9ucyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkgZW5kRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBhY3RpdmVBY3Rpb25zLmdldChlbmRMaXN0ZW5lcikuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHBvc2VyLnVuc2V0KHN0YXJ0UG9zZSk7XG4gICAgICAgICAgICAgICAgcG9zZXIuc2V0KGVuZFBvc2UpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRDYWxsYmFjayAmJiBjb25maWdbZW5kQ2FsbGJhY2tdKSBjb25maWdbZW5kQ2FsbGJhY2tdKGVuZEV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWN0aXZlQWN0aW9ucy5zZXQoZW5kTGlzdGVuZXIsIGV2ZW50RW5kTGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aXZlQWN0aW9ucy5zZXQoc3RhcnRMaXN0ZW5lciwgZXZlbnRTdGFydExpc3RlbmVyKTtcbiAgICB9O1xufTtcbnZhciBldmVudHMgPSB7XG4gICAgZHJhZ2dhYmxlOiAvKiNfX1BVUkVfXyovbWFrZVVJRXZlbnRBcHBsaWNhdG9yKHtcbiAgICAgICAgc3RhcnRFdmVudHM6ICdtb3VzZWRvd24gdG91Y2hzdGFydCcsXG4gICAgICAgIGVuZEV2ZW50czogJ21vdXNldXAgdG91Y2hlbmQnLFxuICAgICAgICBzdGFydFBvc2U6ICdkcmFnJyxcbiAgICAgICAgZW5kUG9zZTogJ2RyYWdFbmQnLFxuICAgICAgICBzdGFydENhbGxiYWNrOiAnb25EcmFnU3RhcnQnLFxuICAgICAgICBlbmRDYWxsYmFjazogJ29uRHJhZ0VuZCcsXG4gICAgICAgIHVzZURvY3VtZW50VG9FbmQ6IHRydWUsXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgfSksXG4gICAgaG92ZXJhYmxlOiAvKiNfX1BVUkVfXyovbWFrZVVJRXZlbnRBcHBsaWNhdG9yKHtcbiAgICAgICAgc3RhcnRFdmVudHM6ICdtb3VzZWVudGVyJyxcbiAgICAgICAgZW5kRXZlbnRzOiAnbW91c2VsZWF2ZScsXG4gICAgICAgIHN0YXJ0UG9zZTogJ2hvdmVyJyxcbiAgICAgICAgZW5kUG9zZTogJ2hvdmVyRW5kJ1xuICAgIH0pLFxuICAgIGZvY3VzYWJsZTogLyojX19QVVJFX18qL21ha2VVSUV2ZW50QXBwbGljYXRvcih7XG4gICAgICAgIHN0YXJ0RXZlbnRzOiAnZm9jdXMnLFxuICAgICAgICBlbmRFdmVudHM6ICdibHVyJyxcbiAgICAgICAgc3RhcnRQb3NlOiAnZm9jdXMnLFxuICAgICAgICBlbmRQb3NlOiAnYmx1cidcbiAgICB9KSxcbiAgICBwcmVzc2FibGU6IC8qI19fUFVSRV9fKi9tYWtlVUlFdmVudEFwcGxpY2F0b3Ioe1xuICAgICAgICBzdGFydEV2ZW50czogJ21vdXNlZG93biB0b3VjaHN0YXJ0JyxcbiAgICAgICAgZW5kRXZlbnRzOiAnbW91c2V1cCB0b3VjaGVuZCcsXG4gICAgICAgIHN0YXJ0UG9zZTogJ3ByZXNzJyxcbiAgICAgICAgZW5kUG9zZTogJ3ByZXNzRW5kJyxcbiAgICAgICAgc3RhcnRDYWxsYmFjazogJ29uUHJlc3NTdGFydCcsXG4gICAgICAgIGVuZENhbGxiYWNrOiAnb25QcmVzc0VuZCcsXG4gICAgICAgIHVzZURvY3VtZW50VG9FbmQ6IHRydWVcbiAgICB9KVxufTtcbnZhciBldmVudEtleXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmtleXMoZXZlbnRzKTtcbnZhciBhcHBlbmRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIChlbGVtZW50LCBhY3RpdmVBY3Rpb25zLCBwb3NlciwgX2EpIHtcbiAgICB2YXIgcHJvcHMgPSBfYS5wcm9wcztcbiAgICByZXR1cm4gZXZlbnRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAocHJvcHNba2V5XSkgZXZlbnRzW2tleV0oZWxlbWVudCwgYWN0aXZlQWN0aW9ucywgcG9zZXIsIHByb3BzKTtcbiAgICB9KTtcbn07XG5cbnZhciBtZWFzdXJlV2l0aG91dFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIHRyYW5zZm9ybSQkMSA9IGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgdmFyIGJib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtJCQxO1xuICAgIHJldHVybiBiYm94O1xufTtcbnZhciByZXNvbHZlUHJvcCA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicgPyB0YXJnZXQocHJvcHMpIDogdGFyZ2V0O1xufTtcblxudmFyIE9SSUdJTl9TVEFSVCA9IDA7XG52YXIgT1JJR0lOX0NFTlRFUiA9ICc1MCUnO1xudmFyIE9SSUdJTl9FTkQgPSAnMTAwJSc7XG52YXIgZmluZENlbnRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciB0b3AgPSBfYS50b3AsXG4gICAgICAgIHJpZ2h0ID0gX2EucmlnaHQsXG4gICAgICAgIGJvdHRvbSA9IF9hLmJvdHRvbSxcbiAgICAgICAgbGVmdCA9IF9hLmxlZnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogKGxlZnQgKyByaWdodCkgLyAyLFxuICAgICAgICB5OiAodG9wICsgYm90dG9tKSAvIDJcbiAgICB9O1xufTtcbnZhciBwb3NpdGlvbmFsUHJvcHMgPSBbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAnbGVmdCcsICdib3R0b20nLCAncmlnaHQnXTtcbnZhciBwb3NpdGlvbmFsUHJvcHNEaWN0ID0gLyojX19QVVJFX18qL25ldyBTZXQocG9zaXRpb25hbFByb3BzKTtcbnZhciBjaGVja1Bvc2l0aW9uYWxQcm9wID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvbmFsUHJvcHNEaWN0LmhhcyhrZXkpO1xufTtcbnZhciBoYXNQb3NpdGlvbmFsUHJvcHMgPSBmdW5jdGlvbiAocG9zZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwb3NlKS5zb21lKGNoZWNrUG9zaXRpb25hbFByb3ApO1xufTtcbnZhciBpc0ZsaXBQb3NlID0gZnVuY3Rpb24gKGZsaXAsIGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUucHJvcHMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIChmbGlwID09PSB0cnVlIHx8IGtleSA9PT0gJ2ZsaXAnKTtcbn07XG52YXIgc2V0VmFsdWUgPSBmdW5jdGlvbiAoX2EsIGtleSwgdG8pIHtcbiAgICB2YXIgdmFsdWVzID0gX2EudmFsdWVzLFxuICAgICAgICBwcm9wcyA9IF9hLnByb3BzO1xuICAgIGlmICh2YWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgdmFyIHJhdyA9IHZhbHVlcy5nZXQoa2V5KS5yYXc7XG4gICAgICAgIHJhdy51cGRhdGUodG8pO1xuICAgICAgICByYXcudXBkYXRlKHRvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMuc2V0KGtleSwge1xuICAgICAgICAgICAgcmF3OiB2YWx1ZSh0bywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuZWxlbWVudFN0eWxlci5zZXQoa2V5LCB2KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG52YXIgZXhwbGljaXRseUZsaXBQb3NlID0gZnVuY3Rpb24gKHN0YXRlLCBuZXh0UG9zZSkge1xuICAgIHZhciBfYSA9IHN0YXRlLnByb3BzLFxuICAgICAgICBkaW1lbnNpb25zID0gX2EuZGltZW5zaW9ucyxcbiAgICAgICAgZWxlbWVudFN0eWxlciA9IF9hLmVsZW1lbnRTdHlsZXI7XG4gICAgZGltZW5zaW9ucy5tZWFzdXJlKCk7XG4gICAgdmFyIHdpZHRoID0gbmV4dFBvc2Uud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IG5leHRQb3NlLmhlaWdodCxcbiAgICAgICAgdG9wID0gbmV4dFBvc2UudG9wLFxuICAgICAgICBsZWZ0ID0gbmV4dFBvc2UubGVmdCxcbiAgICAgICAgYm90dG9tID0gbmV4dFBvc2UuYm90dG9tLFxuICAgICAgICByaWdodCA9IG5leHRQb3NlLnJpZ2h0LFxuICAgICAgICBwb3NpdGlvbiA9IG5leHRQb3NlLnBvc2l0aW9uLFxuICAgICAgICByZW1haW5pbmdQb3NlID0gX19yZXN0KG5leHRQb3NlLCBbXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInRvcFwiLCBcImxlZnRcIiwgXCJib3R0b21cIiwgXCJyaWdodFwiLCBcInBvc2l0aW9uXCJdKTtcbiAgICB2YXIgcHJvcHNUb1NldCA9IHBvc2l0aW9uYWxQcm9wcy5jb25jYXQoJ3Bvc2l0aW9uJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBpZiAobmV4dFBvc2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHJlc29sdmVQcm9wKG5leHRQb3NlW2tleV0sIHN0YXRlLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBlbGVtZW50U3R5bGVyLnNldChwcm9wc1RvU2V0KS5yZW5kZXIoKTtcbiAgICByZXR1cm4gaW1wbGljaXRseUZsaXBQb3NlKHN0YXRlLCByZW1haW5pbmdQb3NlKTtcbn07XG52YXIgaW1wbGljaXRseUZsaXBQb3NlID0gZnVuY3Rpb24gKHN0YXRlLCBuZXh0UG9zZSkge1xuICAgIHZhciBfYSA9IHN0YXRlLnByb3BzLFxuICAgICAgICBkaW1lbnNpb25zID0gX2EuZGltZW5zaW9ucyxcbiAgICAgICAgZWxlbWVudCA9IF9hLmVsZW1lbnQsXG4gICAgICAgIGVsZW1lbnRTdHlsZXIgPSBfYS5lbGVtZW50U3R5bGVyO1xuICAgIGlmICghZGltZW5zaW9ucy5oYXMoKSkgcmV0dXJuIHt9O1xuICAgIHZhciBwcmV2ID0gZGltZW5zaW9ucy5nZXQoKTtcbiAgICB2YXIgbmV4dCA9IG1lYXN1cmVXaXRob3V0VHJhbnNmb3JtKGVsZW1lbnQpO1xuICAgIHZhciBvcmlnaW5YID0gcHJldi5sZWZ0ID09PSBuZXh0LmxlZnQgPyBPUklHSU5fU1RBUlQgOiBwcmV2LnJpZ2h0ID09PSBuZXh0LnJpZ2h0ID8gT1JJR0lOX0VORCA6IE9SSUdJTl9DRU5URVI7XG4gICAgdmFyIG9yaWdpblkgPSBwcmV2LnRvcCA9PT0gbmV4dC50b3AgPyBPUklHSU5fU1RBUlQgOiBwcmV2LmJvdHRvbSA9PT0gbmV4dC5ib3R0b20gPyBPUklHSU5fRU5EIDogT1JJR0lOX0NFTlRFUjtcbiAgICBlbGVtZW50U3R5bGVyLnNldCh7IG9yaWdpblg6IG9yaWdpblgsIG9yaWdpblk6IG9yaWdpblkgfSk7XG4gICAgdmFyIGZsaXBQb3NlUHJvcHMgPSB7fTtcbiAgICBpZiAocHJldi53aWR0aCAhPT0gbmV4dC53aWR0aCkge1xuICAgICAgICBzZXRWYWx1ZShzdGF0ZSwgJ3NjYWxlWCcsIHByZXYud2lkdGggLyBuZXh0LndpZHRoKTtcbiAgICAgICAgZmxpcFBvc2VQcm9wcy5zY2FsZVggPSAxO1xuICAgIH1cbiAgICBpZiAocHJldi5oZWlnaHQgIT09IG5leHQuaGVpZ2h0KSB7XG4gICAgICAgIHNldFZhbHVlKHN0YXRlLCAnc2NhbGVZJywgcHJldi5oZWlnaHQgLyBuZXh0LmhlaWdodCk7XG4gICAgICAgIGZsaXBQb3NlUHJvcHMuc2NhbGVZID0gMTtcbiAgICB9XG4gICAgdmFyIHByZXZDZW50ZXIgPSBmaW5kQ2VudGVyKHByZXYpO1xuICAgIHZhciBuZXh0Q2VudGVyID0gZmluZENlbnRlcihuZXh0KTtcbiAgICBpZiAob3JpZ2luWCA9PT0gT1JJR0lOX0NFTlRFUikge1xuICAgICAgICBzZXRWYWx1ZShzdGF0ZSwgJ3gnLCBwcmV2Q2VudGVyLnggLSBuZXh0Q2VudGVyLngpO1xuICAgICAgICBmbGlwUG9zZVByb3BzLnggPSAwO1xuICAgIH1cbiAgICBpZiAob3JpZ2luWSA9PT0gT1JJR0lOX0NFTlRFUikge1xuICAgICAgICBzZXRWYWx1ZShzdGF0ZSwgJ3knLCBwcmV2Q2VudGVyLnkgLSBuZXh0Q2VudGVyLnkpO1xuICAgICAgICBmbGlwUG9zZVByb3BzLnkgPSAwO1xuICAgIH1cbiAgICBlbGVtZW50U3R5bGVyLnJlbmRlcigpO1xuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgbmV4dFBvc2UsIGZsaXBQb3NlUHJvcHMpO1xufTtcbnZhciBmbGlwUG9zZSA9IGZ1bmN0aW9uIChwcm9wcywgbmV4dFBvc2UpIHtcbiAgICByZXR1cm4gaGFzUG9zaXRpb25hbFByb3BzKG5leHRQb3NlKSA/IGV4cGxpY2l0bHlGbGlwUG9zZShwcm9wcywgbmV4dFBvc2UpIDogaW1wbGljaXRseUZsaXBQb3NlKHByb3BzLCBuZXh0UG9zZSk7XG59O1xuXG52YXIgZ2V0UG9zRnJvbU1hdHJpeCA9IGZ1bmN0aW9uIChtYXRyaXgsIHBvcykge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdHJpeC5zcGxpdCgnLCAnKVtwb3NdKTtcbn07XG52YXIgZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCA9IGZ1bmN0aW9uIChwb3MyLCBwb3MzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50LCBiYm94LCBfYSkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtJCQxID0gX2EudHJhbnNmb3JtO1xuICAgICAgICBpZiAodHJhbnNmb3JtJCQxID09PSAnbm9uZScpIHJldHVybiAwO1xuICAgICAgICB2YXIgbWF0cml4M2QgPSB0cmFuc2Zvcm0kJDEubWF0Y2goL15tYXRyaXgzZFxcKCguKylcXCkkLyk7XG4gICAgICAgIGlmIChtYXRyaXgzZCkgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4M2RbMV0sIHBvczMpO1xuICAgICAgICByZXR1cm4gZ2V0UG9zRnJvbU1hdHJpeCh0cmFuc2Zvcm0kJDEubWF0Y2goL15tYXRyaXhcXCgoLispXFwpJC8pWzFdLCBwb3MyKTtcbiAgICB9O1xufTtcbnZhciBwb3NpdGlvbmFsVmFsdWVzID0ge1xuICAgIHdpZHRoOiBmdW5jdGlvbiAoZWxlbWVudCwgX2EpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuICAgIGhlaWdodDogZnVuY3Rpb24gKGVsZW1lbnQsIF9hKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfSxcbiAgICB0b3A6IGZ1bmN0aW9uIChlbGVtZW50LCBiYm94LCBfYSkge1xuICAgICAgICB2YXIgdG9wID0gX2EudG9wO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0b3ApO1xuICAgIH0sXG4gICAgbGVmdDogZnVuY3Rpb24gKGVsZW1lbnQsIGJib3gsIF9hKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gX2EubGVmdDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobGVmdCk7XG4gICAgfSxcbiAgICBib3R0b206IGZ1bmN0aW9uIChlbGVtZW50LCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgdmFyIHRvcCA9IF9iLnRvcDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodG9wKSArIGhlaWdodDtcbiAgICB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbiAoZWxlbWVudCwgX2EsIF9iKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xuICAgICAgICB2YXIgbGVmdCA9IF9iLmxlZnQ7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGxlZnQpICsgd2lkdGg7XG4gICAgfSxcbiAgICB4OiAvKiNfX1BVUkVfXyovZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg0LCAxMyksXG4gICAgeTogLyojX19QVVJFX18qL2dldFRyYW5zbGF0ZUZyb21NYXRyaXgoNSwgMTQpXG59O1xudmFyIGlzUG9zaXRpb25hbEtleSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uYWxWYWx1ZXNbdl0gIT09IHVuZGVmaW5lZDtcbn07XG52YXIgaXNQb3NpdGlvbmFsID0gZnVuY3Rpb24gKHBvc2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocG9zZSkuc29tZShpc1Bvc2l0aW9uYWxLZXkpO1xufTtcbnZhciBjb252ZXJ0UG9zaXRpb25hbFVuaXRzID0gZnVuY3Rpb24gKHN0YXRlLCBwb3NlKSB7XG4gICAgdmFyIHZhbHVlcyA9IHN0YXRlLnZhbHVlcyxcbiAgICAgICAgcHJvcHMgPSBzdGF0ZS5wcm9wcztcbiAgICB2YXIgZWxlbWVudCA9IHByb3BzLmVsZW1lbnQsXG4gICAgICAgIGVsZW1lbnRTdHlsZXIgPSBwcm9wcy5lbGVtZW50U3R5bGVyO1xuICAgIHZhciBwb3NpdGlvbmFsUG9zZUtleXMgPSBPYmplY3Qua2V5cyhwb3NlKS5maWx0ZXIoaXNQb3NpdGlvbmFsS2V5KTtcbiAgICB2YXIgY2hhbmdlZFBvc2l0aW9uYWxLZXlzID0gW107XG4gICAgdmFyIGVsZW1lbnRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICBwb3NpdGlvbmFsUG9zZUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSQkMSA9IHZhbHVlcy5nZXQoa2V5KTtcbiAgICAgICAgdmFyIGZyb21WYWx1ZVR5cGUgPSBnZXRWYWx1ZVR5cGUodmFsdWUkJDEucmF3LmdldCgpKTtcbiAgICAgICAgdmFyIHRvID0gcmVzb2x2ZVByb3AocG9zZVtrZXldLCBwcm9wcyk7XG4gICAgICAgIHZhciB0b1ZhbHVlVHlwZSA9IGdldFZhbHVlVHlwZSh0byk7XG4gICAgICAgIGlmIChmcm9tVmFsdWVUeXBlICE9PSB0b1ZhbHVlVHlwZSkge1xuICAgICAgICAgICAgY2hhbmdlZFBvc2l0aW9uYWxLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHBvc2UuYXBwbHlBdEVuZCA9IHBvc2UuYXBwbHlBdEVuZCB8fCB7fTtcbiAgICAgICAgICAgIHBvc2UuYXBwbHlBdEVuZFtrZXldID0gcG9zZVtrZXldO1xuICAgICAgICAgICAgc2V0VmFsdWUoc3RhdGUsIGtleSwgdG8pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFjaGFuZ2VkUG9zaXRpb25hbEtleXMubGVuZ3RoKSByZXR1cm4gcG9zZTtcbiAgICB2YXIgb3JpZ2luQmJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHRvcCA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLnRvcCxcbiAgICAgICAgbGVmdCA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLmxlZnQsXG4gICAgICAgIGJvdHRvbSA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLmJvdHRvbSxcbiAgICAgICAgcmlnaHQgPSBlbGVtZW50Q29tcHV0ZWRTdHlsZS5yaWdodCxcbiAgICAgICAgdHJhbnNmb3JtJCQxID0gZWxlbWVudENvbXB1dGVkU3R5bGUudHJhbnNmb3JtO1xuICAgIHZhciBvcmlnaW5Db21wdXRlZFN0eWxlID0geyB0b3A6IHRvcCwgbGVmdDogbGVmdCwgYm90dG9tOiBib3R0b20sIHJpZ2h0OiByaWdodCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0kJDEgfTtcbiAgICBlbGVtZW50U3R5bGVyLnJlbmRlcigpO1xuICAgIHZhciB0YXJnZXRCYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbmV3UG9zZSA9IF9fYXNzaWduKHt9LCBwb3NlKTtcbiAgICBjaGFuZ2VkUG9zaXRpb25hbEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHNldFZhbHVlKHN0YXRlLCBrZXksIHBvc2l0aW9uYWxWYWx1ZXNba2V5XShlbGVtZW50LCBvcmlnaW5CYm94LCBvcmlnaW5Db21wdXRlZFN0eWxlKSk7XG4gICAgICAgIG5ld1Bvc2Vba2V5XSA9IHBvc2l0aW9uYWxWYWx1ZXNba2V5XShlbGVtZW50LCB0YXJnZXRCYm94LCBlbGVtZW50Q29tcHV0ZWRTdHlsZSk7XG4gICAgfSk7XG4gICAgZWxlbWVudFN0eWxlci5yZW5kZXIoKTtcbiAgICByZXR1cm4gbmV3UG9zZTtcbn07XG5cbnZhciBkcmFnUG9zZXMgPSBmdW5jdGlvbiAoZHJhZ2dhYmxlKSB7XG4gICAgdmFyIGRyYWcgPSB7XG4gICAgICAgIHByZVRyYW5zaXRpb246IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBfYS5kaW1lbnNpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnMubWVhc3VyZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZHJhZ0VuZCA9IHt9O1xuICAgIGlmIChkcmFnZ2FibGUgPT09IHRydWUgfHwgZHJhZ2dhYmxlID09PSAneCcpIGRyYWcueCA9IGRyYWdFbmQueCA9IDA7XG4gICAgaWYgKGRyYWdnYWJsZSA9PT0gdHJ1ZSB8fCBkcmFnZ2FibGUgPT09ICd5JykgZHJhZy55ID0gZHJhZ0VuZC55ID0gMDtcbiAgICByZXR1cm4geyBkcmFnOiBkcmFnLCBkcmFnRW5kOiBkcmFnRW5kIH07XG59O1xudmFyIGNyZWF0ZVBvc2VDb25maWcgPSBmdW5jdGlvbiAoZWxlbWVudCwgX2EpIHtcbiAgICB2YXIgb25EcmFnU3RhcnQgPSBfYS5vbkRyYWdTdGFydCxcbiAgICAgICAgb25EcmFnRW5kID0gX2Eub25EcmFnRW5kLFxuICAgICAgICBvblByZXNzU3RhcnQgPSBfYS5vblByZXNzU3RhcnQsXG4gICAgICAgIG9uUHJlc3NFbmQgPSBfYS5vblByZXNzRW5kLFxuICAgICAgICBkcmFnZ2FibGUgPSBfYS5kcmFnZ2FibGUsXG4gICAgICAgIGhvdmVyYWJsZSA9IF9hLmhvdmVyYWJsZSxcbiAgICAgICAgZm9jdXNhYmxlID0gX2EuZm9jdXNhYmxlLFxuICAgICAgICBwcmVzc2FibGUgPSBfYS5wcmVzc2FibGUsXG4gICAgICAgIGRyYWdCb3VuZHMgPSBfYS5kcmFnQm91bmRzLFxuICAgICAgICBjb25maWcgPSBfX3Jlc3QoX2EsIFtcIm9uRHJhZ1N0YXJ0XCIsIFwib25EcmFnRW5kXCIsIFwib25QcmVzc1N0YXJ0XCIsIFwib25QcmVzc0VuZFwiLCBcImRyYWdnYWJsZVwiLCBcImhvdmVyYWJsZVwiLCBcImZvY3VzYWJsZVwiLCBcInByZXNzYWJsZVwiLCBcImRyYWdCb3VuZHNcIl0pO1xuICAgIHZhciBwb3NlQ29uZmlnID0gX19hc3NpZ24oeyBmbGlwOiB7fSB9LCBjb25maWcsIHsgcHJvcHM6IF9fYXNzaWduKHt9LCBjb25maWcucHJvcHMsIHsgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgb25EcmFnRW5kOiBvbkRyYWdFbmQsXG4gICAgICAgICAgICBvblByZXNzU3RhcnQ6IG9uUHJlc3NTdGFydCxcbiAgICAgICAgICAgIG9uUHJlc3NFbmQ6IG9uUHJlc3NFbmQsXG4gICAgICAgICAgICBkcmFnQm91bmRzOiBkcmFnQm91bmRzLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBkcmFnZ2FibGUsXG4gICAgICAgICAgICBob3ZlcmFibGU6IGhvdmVyYWJsZSxcbiAgICAgICAgICAgIGZvY3VzYWJsZTogZm9jdXNhYmxlLFxuICAgICAgICAgICAgcHJlc3NhYmxlOiBwcmVzc2FibGUsXG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LCBlbGVtZW50U3R5bGVyOiBzdHlsZXIoZWxlbWVudCwgeyBwcmVwYXJzZU91dHB1dDogZmFsc2UgfSksIGRpbWVuc2lvbnM6IGNyZWF0ZURpbWVuc2lvbnMoZWxlbWVudCkgfSkgfSk7XG4gICAgaWYgKGRyYWdnYWJsZSkge1xuICAgICAgICB2YXIgX2IgPSBkcmFnUG9zZXMoZHJhZ2dhYmxlKSxcbiAgICAgICAgICAgIGRyYWcgPSBfYi5kcmFnLFxuICAgICAgICAgICAgZHJhZ0VuZCA9IF9iLmRyYWdFbmQ7XG4gICAgICAgIHBvc2VDb25maWcuZHJhZyA9IF9fYXNzaWduKHt9LCBwb3NlQ29uZmlnLmRyYWcsIGRyYWcpO1xuICAgICAgICBwb3NlQ29uZmlnLmRyYWdFbmQgPSBfX2Fzc2lnbih7fSwgcG9zZUNvbmZpZy5kcmFnRW5kLCBkcmFnRW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2VDb25maWc7XG59O1xudmFyIGRvbVBvc2UgPSAvKiNfX1BVUkVfXyovcG9zZSh7XG4gICAgcG9zZVByaW9yaXR5OiBbJ2RyYWcnLCAncHJlc3MnLCAnZm9jdXMnLCAnaG92ZXInXSxcbiAgICB0cmFuc2Zvcm1Qb3NlOiBmdW5jdGlvbiAoX2EsIG5hbWUsIHN0YXRlKSB7XG4gICAgICAgIHZhciBmbGlwID0gX2EuZmxpcCxcbiAgICAgICAgICAgIHBvc2UkJDEgPSBfX3Jlc3QoX2EsIFtcImZsaXBcIl0pO1xuICAgICAgICBpZiAoaXNGbGlwUG9zZShmbGlwLCBuYW1lLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmbGlwUG9zZShzdGF0ZSwgcG9zZSQkMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQb3NpdGlvbmFsKHBvc2UkJDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFBvc2l0aW9uYWxVbml0cyhzdGF0ZSwgcG9zZSQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2UkJDE7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lclRvVmFsdWU6IGZ1bmN0aW9uIChrZXksIGVsZW1lbnRTdHlsZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudFN0eWxlci5zZXQoa2V5LCB2KTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlYWRWYWx1ZUZyb21Tb3VyY2U6IGZ1bmN0aW9uIChrZXksIF9hKSB7XG4gICAgICAgIHZhciBlbGVtZW50U3R5bGVyID0gX2EuZWxlbWVudFN0eWxlcixcbiAgICAgICAgICAgIGRyYWdCb3VuZHMgPSBfYS5kcmFnQm91bmRzO1xuICAgICAgICB2YXIgdmFsdWUkJDEgPSBlbGVtZW50U3R5bGVyLmdldChrZXkpO1xuICAgICAgICBpZiAoZHJhZ0JvdW5kcyAmJiAoa2V5ID09PSAneCcgfHwga2V5ID09PSAneScpKSB7XG4gICAgICAgICAgICB2YXIgYm91bmQgPSBrZXkgPT09ICd4JyA/IGRyYWdCb3VuZHMubGVmdCB8fCBkcmFnQm91bmRzLnJpZ2h0IDogZHJhZ0JvdW5kcy50b3AgfHwgZHJhZ0JvdW5kcy5ib3R0b207XG4gICAgICAgICAgICBpZiAoYm91bmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmRUeXBlID0gZ2V0VmFsdWVUeXBlKGJvdW5kKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSQkMSA9IGJvdW5kVHlwZS50cmFuc2Zvcm0odmFsdWUkJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSQkMSkgPyB2YWx1ZSQkMSA6IHBhcnNlRmxvYXQodmFsdWUkJDEpO1xuICAgIH0sXG4gICAgc2V0VmFsdWVOYXRpdmU6IGZ1bmN0aW9uIChrZXksIHRvLCBfYSkge1xuICAgICAgICB2YXIgZWxlbWVudFN0eWxlciA9IF9hLmVsZW1lbnRTdHlsZXI7XG4gICAgICAgIHJldHVybiBlbGVtZW50U3R5bGVyLnNldChrZXksIHRvKTtcbiAgICB9LFxuICAgIGV4dGVuZEFQSTogZnVuY3Rpb24gKGFwaSwgX2EsIGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcHMgPSBfYS5wcm9wcyxcbiAgICAgICAgICAgIGFjdGl2ZUFjdGlvbnMgPSBfYS5hY3RpdmVBY3Rpb25zO1xuICAgICAgICB2YXIgbWVhc3VyZSA9IHByb3BzLmRpbWVuc2lvbnMubWVhc3VyZTtcbiAgICAgICAgdmFyIHBvc2VyQXBpID0gX19hc3NpZ24oe30sIGFwaSwgeyBhZGRDaGlsZDogZnVuY3Rpb24gKGVsZW1lbnQsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5fYWRkQ2hpbGQoY3JlYXRlUG9zZUNvbmZpZyhlbGVtZW50LCBjaGlsZENvbmZpZyksIGRvbVBvc2UpO1xuICAgICAgICAgICAgfSwgbWVhc3VyZTogbWVhc3VyZSwgZmxpcDogZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5zZXQoJ2ZsaXAnKTtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgICAgIHByb3BzLmVsZW1lbnRTdHlsZXIucmVuZGVyKCk7XG4gICAgICAgIGFwcGVuZEV2ZW50TGlzdGVuZXJzKHByb3BzLmVsZW1lbnQsIGFjdGl2ZUFjdGlvbnMsIHBvc2VyQXBpLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gcG9zZXJBcGk7XG4gICAgfVxufSk7XG52YXIgZG9tUG9zZSQxID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHJldHVybiBkb21Qb3NlKGNyZWF0ZVBvc2VDb25maWcoZWxlbWVudCwgY29uZmlnKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBkb21Qb3NlJDE7XG4iLCJpbXBvcnQgeyBfX3Jlc3QsIF9fZXh0ZW5kcywgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBjdXJyZW50RnJhbWVUaW1lLCB0aW1lU2luY2VMYXN0RnJhbWUsIG9uRnJhbWVFbmQsIG9uRnJhbWVVcGRhdGUsIGN1cnJlbnRUaW1lLCBjYW5jZWxPbkZyYW1lVXBkYXRlIH0gZnJvbSAnZnJhbWVzeW5jJztcbmltcG9ydCAqIGFzIHN0eWxlVmFsdWVUeXBlcyBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgeyBjb2xvciwgaHNsYSwgY29tcGxleCwgcGVyY2VudCwgZGVncmVlcywgdmgsIHZ3LCBweCwgbnVtYmVyIH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuZXhwb3J0IHsgc3R5bGVWYWx1ZVR5cGVzIGFzIHZhbHVlVHlwZXMgfTtcbmltcG9ydCB7IGludmFyaWFudCwgd2FybmluZyB9IGZyb20gJ2hleS1saXN0ZW4nO1xuaW1wb3J0ICogYXMgZWFzaW5nIGZyb20gJ0Bwb3Btb3Rpb24vZWFzaW5nJztcbmltcG9ydCB7IGxpbmVhciwgZWFzZU91dCwgZWFzZUluT3V0IH0gZnJvbSAnQHBvcG1vdGlvbi9lYXNpbmcnO1xuZXhwb3J0IHsgZWFzaW5nIH07XG5pbXBvcnQgc3R5bGVyIGZyb20gJ3N0eWxlZmlyZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0eWxlciB9IGZyb20gJ3N0eWxlZmlyZSc7XG5cbnZhciBpc051bSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnbnVtYmVyJztcbn07XG52YXIgaXNQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHJldHVybiBwb2ludC54ICE9PSB1bmRlZmluZWQgJiYgcG9pbnQueSAhPT0gdW5kZWZpbmVkO1xufTtcbnZhciBpc1BvaW50M0QgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnQueiAhPT0gdW5kZWZpbmVkO1xufTtcbnZhciB0b0RlY2ltYWwgPSBmdW5jdGlvbiAobnVtLCBwcmVjaXNpb24pIHtcbiAgICBpZiAocHJlY2lzaW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJlY2lzaW9uID0gMjtcbiAgICB9XG4gICAgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobnVtICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbn07XG52YXIgWkVST19QT0lOVCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgejogMFxufTtcbnZhciBkaXN0YW5jZTFEID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpO1xufTtcbnZhciBhbmdsZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGIgPT09IHZvaWQgMCkge1xuICAgICAgICBiID0gWkVST19QT0lOVDtcbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbnNUb0RlZ3JlZXMoTWF0aC5hdGFuMihiLnkgLSBhLnksIGIueCAtIGEueCkpO1xufTtcbnZhciBkZWdyZWVzVG9SYWRpYW5zID0gZnVuY3Rpb24gKGRlZ3JlZXMkJDEpIHtcbiAgICByZXR1cm4gZGVncmVlcyQkMSAqIE1hdGguUEkgLyAxODA7XG59O1xudmFyIGRpbGF0ZSA9IGZ1bmN0aW9uIChhLCBiLCBkaWxhdGlvbikge1xuICAgIHJldHVybiBhICsgKGIgLSBhKSAqIGRpbGF0aW9uO1xufTtcbnZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGIgPT09IHZvaWQgMCkge1xuICAgICAgICBiID0gWkVST19QT0lOVDtcbiAgICB9XG4gICAgaWYgKGlzTnVtKGEpICYmIGlzTnVtKGIpKSB7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZTFEKGEsIGIpO1xuICAgIH0gZWxzZSBpZiAoaXNQb2ludChhKSAmJiBpc1BvaW50KGIpKSB7XG4gICAgICAgIHZhciB4RGVsdGEgPSBkaXN0YW5jZTFEKGEueCwgYi54KTtcbiAgICAgICAgdmFyIHlEZWx0YSA9IGRpc3RhbmNlMUQoYS55LCBiLnkpO1xuICAgICAgICB2YXIgekRlbHRhID0gaXNQb2ludDNEKGEpICYmIGlzUG9pbnQzRChiKSA/IGRpc3RhbmNlMUQoYS56LCBiLnopIDogMDtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4RGVsdGEsIDIpICsgTWF0aC5wb3coeURlbHRhLCAyKSArIE1hdGgucG93KHpEZWx0YSwgMikpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG52YXIgZ2V0UHJvZ3Jlc3NGcm9tVmFsdWUgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgdmFyIHRvRnJvbURpZmZlcmVuY2UgPSB0byAtIGZyb207XG4gICAgcmV0dXJuIHRvRnJvbURpZmZlcmVuY2UgPT09IDAgPyAxIDogKHZhbHVlIC0gZnJvbSkgLyB0b0Zyb21EaWZmZXJlbmNlO1xufTtcbnZhciBnZXRWYWx1ZUZyb21Qcm9ncmVzcyA9IGZ1bmN0aW9uIChmcm9tLCB0bywgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gLXByb2dyZXNzICogZnJvbSArIHByb2dyZXNzICogdG8gKyBmcm9tO1xufTtcbnZhciBwb2ludEZyb21BbmdsZUFuZERpc3RhbmNlID0gZnVuY3Rpb24gKG9yaWdpbiwgYW5nbGUsIGRpc3RhbmNlKSB7XG4gICAgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKGFuZ2xlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKSArIG9yaWdpbi54LFxuICAgICAgICB5OiBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKSArIG9yaWdpbi55XG4gICAgfTtcbn07XG52YXIgcmFkaWFuc1RvRGVncmVlcyA9IGZ1bmN0aW9uIChyYWRpYW5zKSB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJO1xufTtcbnZhciBzbW9vdGggPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBkdXJhdGlvbiwgc21vb3RoaW5nKSB7XG4gICAgaWYgKHNtb290aGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNtb290aGluZyA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0b0RlY2ltYWwob2xkVmFsdWUgKyBkdXJhdGlvbiAqIChuZXdWYWx1ZSAtIG9sZFZhbHVlKSAvIE1hdGgubWF4KHNtb290aGluZywgZHVyYXRpb24pKTtcbn07XG52YXIgc3BlZWRQZXJGcmFtZSA9IGZ1bmN0aW9uICh4cHMsIGZyYW1lRHVyYXRpb24pIHtcbiAgICByZXR1cm4gaXNOdW0oeHBzKSA/IHhwcyAvICgxMDAwIC8gZnJhbWVEdXJhdGlvbikgOiAwO1xufTtcbnZhciBzcGVlZFBlclNlY29uZCA9IGZ1bmN0aW9uICh2ZWxvY2l0eSwgZnJhbWVEdXJhdGlvbikge1xuICAgIHJldHVybiBmcmFtZUR1cmF0aW9uID8gdmVsb2NpdHkgKiAoMTAwMCAvIGZyYW1lRHVyYXRpb24pIDogMDtcbn07XG52YXIgc3RlcFByb2dyZXNzID0gZnVuY3Rpb24gKHN0ZXBzLCBwcm9ncmVzcykge1xuICAgIHZhciBzZWdtZW50ID0gMSAvIChzdGVwcyAtIDEpO1xuICAgIHZhciB0YXJnZXQgPSAxIC0gMSAvIHN0ZXBzO1xuICAgIHZhciBwcm9ncmVzc09mVGFyZ2V0ID0gTWF0aC5taW4ocHJvZ3Jlc3MgLyB0YXJnZXQsIDEpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKHByb2dyZXNzT2ZUYXJnZXQgLyBzZWdtZW50KSAqIHNlZ21lbnQ7XG59O1xuXG52YXIgY2FsYyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBpc1BvaW50OiBpc1BvaW50LFxuICAgIGlzUG9pbnQzRDogaXNQb2ludDNELFxuICAgIGFuZ2xlOiBhbmdsZSxcbiAgICBkZWdyZWVzVG9SYWRpYW5zOiBkZWdyZWVzVG9SYWRpYW5zLFxuICAgIGRpbGF0ZTogZGlsYXRlLFxuICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICBnZXRQcm9ncmVzc0Zyb21WYWx1ZTogZ2V0UHJvZ3Jlc3NGcm9tVmFsdWUsXG4gICAgZ2V0VmFsdWVGcm9tUHJvZ3Jlc3M6IGdldFZhbHVlRnJvbVByb2dyZXNzLFxuICAgIHBvaW50RnJvbUFuZ2xlQW5kRGlzdGFuY2U6IHBvaW50RnJvbUFuZ2xlQW5kRGlzdGFuY2UsXG4gICAgcmFkaWFuc1RvRGVncmVlczogcmFkaWFuc1RvRGVncmVlcyxcbiAgICBzbW9vdGg6IHNtb290aCxcbiAgICBzcGVlZFBlckZyYW1lOiBzcGVlZFBlckZyYW1lLFxuICAgIHNwZWVkUGVyU2Vjb25kOiBzcGVlZFBlclNlY29uZCxcbiAgICBzdGVwUHJvZ3Jlc3M6IHN0ZXBQcm9ncmVzc1xufSk7XG5cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHY7XG59O1xudmFyIGFwcGVuZFVuaXQgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gXCJcIiArIHYgKyB1bml0O1xuICAgIH07XG59O1xudmFyIGFwcGx5T2Zmc2V0ID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgdmFyIGhhc1JlY2VpdmVkRnJvbSA9IHRydWU7XG4gICAgaWYgKHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgICBoYXNSZWNlaXZlZEZyb20gPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGdldE9mZnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2IC0gZnJvbTtcbiAgICB9O1xuICAgIHZhciBhcHBseU9mZnNldFRvID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgKyB0bztcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAoaGFzUmVjZWl2ZWRGcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlPZmZzZXRUbyhnZXRPZmZzZXQodikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHY7XG4gICAgICAgICAgICBoYXNSZWNlaXZlZEZyb20gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgfTtcbn07XG52YXIgYmxlbmQgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHYpIHtcbiAgICB2YXIgZnJvbUV4cG8gPSBmcm9tICogZnJvbTtcbiAgICB2YXIgdG9FeHBvID0gdG8gKiB0bztcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHYgKiAodG9FeHBvIC0gZnJvbUV4cG8pICsgZnJvbUV4cG8pO1xufTtcbnZhciBibGVuZENvbG9yID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgdmFyIGZyb21Db2xvciA9IHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyA/IGNvbG9yLnBhcnNlKGZyb20pIDogZnJvbTtcbiAgICB2YXIgdG9Db2xvciA9IHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyBjb2xvci5wYXJzZSh0bykgOiB0bztcbiAgICB2YXIgYmxlbmRlZCA9IF9fYXNzaWduKHt9LCBmcm9tQ29sb3IpO1xuICAgIHZhciBibGVuZEZ1bmMgPSBmcm9tLmh1ZSAhPT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyAmJiBoc2xhLnRlc3QoZnJvbSkgPyBnZXRWYWx1ZUZyb21Qcm9ncmVzcyA6IGJsZW5kO1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICBibGVuZGVkID0gX19hc3NpZ24oe30sIGJsZW5kZWQpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYmxlbmRlZCkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2FscGhhJyAmJiBibGVuZGVkLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBibGVuZGVkW2tleV0gPSBibGVuZEZ1bmMoZnJvbUNvbG9yW2tleV0sIHRvQ29sb3Jba2V5XSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmxlbmRlZC5hbHBoYSA9IGdldFZhbHVlRnJvbVByb2dyZXNzKGZyb21Db2xvci5hbHBoYSwgdG9Db2xvci5hbHBoYSwgdik7XG4gICAgICAgIHJldHVybiBibGVuZGVkO1xuICAgIH07XG59O1xudmFyIGJsZW5kQXJyYXkgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICB2YXIgb3V0cHV0ID0gZnJvbS5zbGljZSgpO1xuICAgIHZhciBudW1WYWx1ZXMgPSBvdXRwdXQubGVuZ3RoO1xuICAgIHZhciBibGVuZFZhbHVlID0gZnJvbS5tYXAoZnVuY3Rpb24gKGZyb21UaGlzLCBpKSB7XG4gICAgICAgIHZhciB0b1RoaXMgPSB0b1tpXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmcm9tVGhpcyA9PT0gJ251bWJlcicgPyBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlRnJvbVByb2dyZXNzKGZyb21UaGlzLCB0b1RoaXMsIHYpO1xuICAgICAgICB9IDogYmxlbmRDb2xvcihmcm9tVGhpcywgdG9UaGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gYmxlbmRWYWx1ZVtpXSh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59O1xudmFyIGNsYW1wID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuICAgIH07XG59O1xudmFyIGNvbWJpbmVGdW5jdGlvbnMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gYihhKHYpKTtcbiAgICB9O1xufTtcbnZhciBwaXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0cmFuc2Zvcm1lcnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0cmFuc2Zvcm1lcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVycy5yZWR1Y2UoY29tYmluZUZ1bmN0aW9ucyk7XG59O1xudmFyIGNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGNoZWNrLCBhcHBseSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gY2hlY2sodikgPyBhcHBseSh2KSA6IHY7XG4gICAgfTtcbn07XG52YXIgc2xvd0ludGVycG9sYXRlID0gZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQsIHJhbmdlTGVuZ3RoLCByYW5nZUVhc2luZykge1xuICAgIHZhciBmaW5hbEluZGV4ID0gcmFuZ2VMZW5ndGggLSAxO1xuICAgIGlmIChpbnB1dFswXSA+IGlucHV0W2ZpbmFsSW5kZXhdKSB7XG4gICAgICAgIGlucHV0LnJldmVyc2UoKTtcbiAgICAgICAgb3V0cHV0LnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICh2IDw9IGlucHV0WzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0WzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ID49IGlucHV0W2ZpbmFsSW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0W2ZpbmFsSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgZm9yICg7IGkgPCByYW5nZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXRbaV0gPiB2IHx8IGkgPT09IGZpbmFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvZ3Jlc3NJblJhbmdlID0gZ2V0UHJvZ3Jlc3NGcm9tVmFsdWUoaW5wdXRbaSAtIDFdLCBpbnB1dFtpXSwgdik7XG4gICAgICAgIHZhciBlYXNlZFByb2dyZXNzID0gcmFuZ2VFYXNpbmcgPyByYW5nZUVhc2luZ1tpIC0gMV0ocHJvZ3Jlc3NJblJhbmdlKSA6IHByb2dyZXNzSW5SYW5nZTtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlRnJvbVByb2dyZXNzKG91dHB1dFtpIC0gMV0sIG91dHB1dFtpXSwgZWFzZWRQcm9ncmVzcyk7XG4gICAgfTtcbn07XG52YXIgZmFzdEludGVycG9sYXRlID0gZnVuY3Rpb24gKG1pbkEsIG1heEEsIG1pbkIsIG1heEIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuICh2IC0gbWluQSkgKiAobWF4QiAtIG1pbkIpIC8gKG1heEEgLSBtaW5BKSArIG1pbkI7XG4gICAgfTtcbn07XG52YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCwgcmFuZ2VFYXNpbmcpIHtcbiAgICB2YXIgcmFuZ2VMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgcmV0dXJuIHJhbmdlTGVuZ3RoICE9PSAyID8gc2xvd0ludGVycG9sYXRlKGlucHV0LCBvdXRwdXQsIHJhbmdlTGVuZ3RoLCByYW5nZUVhc2luZykgOiBmYXN0SW50ZXJwb2xhdGUoaW5wdXRbMF0sIGlucHV0WzFdLCBvdXRwdXRbMF0sIG91dHB1dFsxXSk7XG59O1xudmFyIGdlbmVyYXRlU3RhdGljU3ByaW5nID0gZnVuY3Rpb24gKGFsdGVyRGlzcGxhY2VtZW50KSB7XG4gICAgaWYgKGFsdGVyRGlzcGxhY2VtZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgYWx0ZXJEaXNwbGFjZW1lbnQgPSBpZGVudGl0eTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb25zdGFudCwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IG9yaWdpbiAtIHY7XG4gICAgICAgICAgICB2YXIgc3ByaW5nTW9kaWZpZWREaXNwbGFjZW1lbnQgPSAtY29uc3RhbnQgKiAoMCAtIGFsdGVyRGlzcGxhY2VtZW50KE1hdGguYWJzKGRpc3BsYWNlbWVudCkpKTtcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGFjZW1lbnQgPD0gMCA/IG9yaWdpbiArIHNwcmluZ01vZGlmaWVkRGlzcGxhY2VtZW50IDogb3JpZ2luIC0gc3ByaW5nTW9kaWZpZWREaXNwbGFjZW1lbnQ7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG52YXIgbGluZWFyU3ByaW5nID0gLyojX19QVVJFX18qL2dlbmVyYXRlU3RhdGljU3ByaW5nKCk7XG52YXIgbm9ubGluZWFyU3ByaW5nID0gLyojX19QVVJFX18qL2dlbmVyYXRlU3RhdGljU3ByaW5nKE1hdGguc3FydCk7XG52YXIgd3JhcCA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgcmFuZ2VTaXplID0gbWF4IC0gbWluO1xuICAgICAgICByZXR1cm4gKCh2IC0gbWluKSAlIHJhbmdlU2l6ZSArIHJhbmdlU2l6ZSkgJSByYW5nZVNpemUgKyBtaW47XG4gICAgfTtcbn07XG52YXIgc21vb3RoJDEgPSBmdW5jdGlvbiAoc3RyZW5ndGgpIHtcbiAgICBpZiAoc3RyZW5ndGggPT09IHZvaWQgMCkge1xuICAgICAgICBzdHJlbmd0aCA9IDUwO1xuICAgIH1cbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IDA7XG4gICAgdmFyIGxhc3RVcGRhdGVkID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRGcmFtZXN0YW1wID0gY3VycmVudEZyYW1lVGltZSgpO1xuICAgICAgICB2YXIgdGltZURlbHRhID0gY3VycmVudEZyYW1lc3RhbXAgIT09IGxhc3RVcGRhdGVkID8gY3VycmVudEZyYW1lc3RhbXAgLSBsYXN0VXBkYXRlZCA6IDA7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRpbWVEZWx0YSA/IHNtb290aCh2LCBwcmV2aW91c1ZhbHVlLCB0aW1lRGVsdGEsIHN0cmVuZ3RoKSA6IHByZXZpb3VzVmFsdWU7XG4gICAgICAgIGxhc3RVcGRhdGVkID0gY3VycmVudEZyYW1lc3RhbXA7XG4gICAgICAgIHByZXZpb3VzVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH07XG59O1xudmFyIHNuYXAgPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgaWYgKHR5cGVvZiBwb2ludHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodiAvIHBvaW50cykgKiBwb2ludHM7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlfMSA9IDA7XG4gICAgICAgIHZhciBudW1Qb2ludHNfMSA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIGxhc3REaXN0YW5jZSA9IE1hdGguYWJzKHBvaW50c1swXSAtIHYpO1xuICAgICAgICAgICAgZm9yIChpXzEgPSAxOyBpXzEgPCBudW1Qb2ludHNfMTsgaV8xKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV8xXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UkJDEgPSBNYXRoLmFicyhwb2ludCAtIHYpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSQkMSA9PT0gMCkgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSQkMSA+IGxhc3REaXN0YW5jZSkgcmV0dXJuIHBvaW50c1tpXzEgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaV8xID09PSBudW1Qb2ludHNfMSAtIDEpIHJldHVybiBwb2ludDtcbiAgICAgICAgICAgICAgICBsYXN0RGlzdGFuY2UgPSBkaXN0YW5jZSQkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xudmFyIHN0ZXBzID0gZnVuY3Rpb24gKHN0LCBtaW4sIG1heCkge1xuICAgIGlmIChtaW4gPT09IHZvaWQgMCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICBpZiAobWF4ID09PSB2b2lkIDApIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IGdldFByb2dyZXNzRnJvbVZhbHVlKG1pbiwgbWF4LCB2KTtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlRnJvbVByb2dyZXNzKG1pbiwgbWF4LCBzdGVwUHJvZ3Jlc3Moc3QsIHByb2dyZXNzKSk7XG4gICAgfTtcbn07XG52YXIgdHJhbnNmb3JtTWFwID0gZnVuY3Rpb24gKGNoaWxkVHJhbnNmb3JtZXJzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBfX2Fzc2lnbih7fSwgdik7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjaGlsZFRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgaWYgKGNoaWxkVHJhbnNmb3JtZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRUcmFuc2Zvcm1lciA9IGNoaWxkVHJhbnNmb3JtZXJzW2tleV07XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBjaGlsZFRyYW5zZm9ybWVyKHZba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufTtcblxudmFyIHRyYW5zZm9ybWVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBhcHBlbmRVbml0OiBhcHBlbmRVbml0LFxuICAgIGFwcGx5T2Zmc2V0OiBhcHBseU9mZnNldCxcbiAgICBibGVuZENvbG9yOiBibGVuZENvbG9yLFxuICAgIGJsZW5kQXJyYXk6IGJsZW5kQXJyYXksXG4gICAgY2xhbXA6IGNsYW1wLFxuICAgIHBpcGU6IHBpcGUsXG4gICAgY29uZGl0aW9uYWw6IGNvbmRpdGlvbmFsLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICBnZW5lcmF0ZVN0YXRpY1NwcmluZzogZ2VuZXJhdGVTdGF0aWNTcHJpbmcsXG4gICAgbGluZWFyU3ByaW5nOiBsaW5lYXJTcHJpbmcsXG4gICAgbm9ubGluZWFyU3ByaW5nOiBub25saW5lYXJTcHJpbmcsXG4gICAgd3JhcDogd3JhcCxcbiAgICBzbW9vdGg6IHNtb290aCQxLFxuICAgIHNuYXA6IHNuYXAsXG4gICAgc3RlcHM6IHN0ZXBzLFxuICAgIHRyYW5zZm9ybU1hcDogdHJhbnNmb3JtTWFwXG59KTtcblxudmFyIENoYWluYWJsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhaW5hYmxlKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBwcm9wcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB9XG4gICAgQ2hhaW5hYmxlLnByb3RvdHlwZS5hcHBseU1pZGRsZXdhcmUgPSBmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoX19hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgbWlkZGxld2FyZTogdGhpcy5wcm9wcy5taWRkbGV3YXJlID8gW21pZGRsZXdhcmVdLmNvbmNhdCh0aGlzLnByb3BzLm1pZGRsZXdhcmUpIDogW21pZGRsZXdhcmVdIH0pKTtcbiAgICB9O1xuICAgIENoYWluYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZ1bmNzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBmdW5jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwaXBlZFVwZGF0ZSA9IGZ1bmNzLmxlbmd0aCA9PT0gMSA/IGZ1bmNzWzBdIDogcGlwZS5hcHBseSh2b2lkIDAsIGZ1bmNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlNaWRkbGV3YXJlKGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGUocGlwZWRVcGRhdGUodikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFpbmFibGUucHJvdG90eXBlLndoaWxlID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU1pZGRsZXdhcmUoZnVuY3Rpb24gKHVwZGF0ZSwgY29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUodikgPyB1cGRhdGUodikgOiBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFpbmFibGUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlNaWRkbGV3YXJlKGZ1bmN0aW9uICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUodikgJiYgdXBkYXRlKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhaW5hYmxlO1xufSgpO1xuXG52YXIgT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVyKF9hLCBvYnNlcnZlcikge1xuICAgICAgICB2YXIgbWlkZGxld2FyZSA9IF9hLm1pZGRsZXdhcmUsXG4gICAgICAgICAgICBvbkNvbXBsZXRlID0gX2Eub25Db21wbGV0ZTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vYnNlcnZlci51cGRhdGUpIF90aGlzLnVwZGF0ZU9ic2VydmVyKHYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9ic2VydmVyLmNvbXBsZXRlICYmIF90aGlzLmlzQWN0aXZlKSBfdGhpcy5vYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgaWYgKF90aGlzLm9uQ29tcGxldGUpIF90aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIF90aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub2JzZXJ2ZXIuZXJyb3IgJiYgX3RoaXMuaXNBY3RpdmUpIF90aGlzLm9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMudXBkYXRlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLnVwZGF0ZSh2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZTtcbiAgICAgICAgaWYgKG9ic2VydmVyLnVwZGF0ZSAmJiBtaWRkbGV3YXJlICYmIG1pZGRsZXdhcmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBtaWRkbGV3YXJlLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlT2JzZXJ2ZXIgPSBtKF90aGlzLnVwZGF0ZU9ic2VydmVyLCBfdGhpcy5jb21wbGV0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JzZXJ2ZXI7XG59KCk7XG52YXIgY3JlYXRlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXJDYW5kaWRhdGUsIF9hLCBvbkNvbXBsZXRlKSB7XG4gICAgdmFyIG1pZGRsZXdhcmUgPSBfYS5taWRkbGV3YXJlO1xuICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXJDYW5kaWRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZlcih7IG1pZGRsZXdhcmU6IG1pZGRsZXdhcmUsIG9uQ29tcGxldGU6IG9uQ29tcGxldGUgfSwgeyB1cGRhdGU6IG9ic2VydmVyQ2FuZGlkYXRlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2ZXIoeyBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlLCBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlIH0sIG9ic2VydmVyQ2FuZGlkYXRlKTtcbiAgICB9XG59O1xuXG52YXIgQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBY3Rpb24ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGlvbihwcm9wcyk7XG4gICAgfTtcbiAgICBBY3Rpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKG9ic2VydmVyQ2FuZGlkYXRlKSB7XG4gICAgICAgIGlmIChvYnNlcnZlckNhbmRpZGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBvYnNlcnZlckNhbmRpZGF0ZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluaXQgPSBfYS5pbml0LFxuICAgICAgICAgICAgb2JzZXJ2ZXJQcm9wcyA9IF9fcmVzdChfYSwgW1wiaW5pdFwiXSk7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IGNyZWF0ZU9ic2VydmVyKG9ic2VydmVyQ2FuZGlkYXRlLCBvYnNlcnZlclByb3BzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5zdG9wKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYXBpID0gaW5pdChvYnNlcnZlcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IGFwaSA/IF9fYXNzaWduKHt9LCBzdWJzY3JpcHRpb24sIGFwaSkgOiBzdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChvYnNlcnZlckNhbmRpZGF0ZS5yZWdpc3RlclBhcmVudCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJDYW5kaWRhdGUucmVnaXN0ZXJQYXJlbnQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb21wbGV0ZSkgc3Vic2NyaXB0aW9uLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBBY3Rpb247XG59KENoYWluYWJsZSk7XG52YXIgYWN0aW9uID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgICByZXR1cm4gbmV3IEFjdGlvbih7IGluaXQ6IGluaXQgfSk7XG59O1xuXG52YXIgQmFzZU11bHRpY2FzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VNdWx0aWNhc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmFzZU11bHRpY2FzdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN1YnNjcmliZXJzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmFzZU11bHRpY2FzdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCYXNlTXVsdGljYXN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEJhc2VNdWx0aWNhc3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzY3JpYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyc1tpXS51cGRhdGUodik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhc2VNdWx0aWNhc3QucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlckNhbmRpZGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBjcmVhdGVPYnNlcnZlcihvYnNlcnZlckNhbmRpZGF0ZSwgdGhpcy5wcm9wcyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLnN1YnNjcmliZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIF90aGlzLnN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICBCYXNlTXVsdGljYXN0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHRoaXMucGFyZW50LnN0b3AoKTtcbiAgICB9O1xuICAgIEJhc2VNdWx0aWNhc3QucHJvdG90eXBlLnJlZ2lzdGVyUGFyZW50ID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZU11bHRpY2FzdDtcbn0oQ2hhaW5hYmxlKTtcblxudmFyIE11bHRpY2FzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE11bHRpY2FzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aWNhc3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTXVsdGljYXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWNhc3QocHJvcHMpO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpY2FzdDtcbn0oQmFzZU11bHRpY2FzdCk7XG52YXIgbXVsdGljYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTXVsdGljYXN0KCk7XG59O1xuXG52YXIgaXNWYWx1ZUxpc3QgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpO1xufTtcbnZhciBpc1NpbmdsZVZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgdHlwZU9mViA9IHR5cGVvZiB2O1xuICAgIHJldHVybiB0eXBlT2ZWID09PSAnc3RyaW5nJyB8fCB0eXBlT2ZWID09PSAnbnVtYmVyJztcbn07XG52YXIgVmFsdWVSZWFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhbHVlUmVhY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFsdWVSZWFjdGlvbihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uRnJhbWVFbmQoX3RoaXMudmVsb2NpdHlDaGVjayk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnZlbG9jaXR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lVGltZSgpICE9PSBfdGhpcy5sYXN0VXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByZXYgPSBfdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5wcmV2ID0gX3RoaXMuY3VycmVudCA9IHByb3BzLnZhbHVlIHx8IDA7XG4gICAgICAgIGlmIChpc1NpbmdsZVZhbHVlKF90aGlzLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVDdXJyZW50ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY3VycmVudCA9IHY7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuZ2V0VmVsb2NpdHlPZkN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFNpbmdsZVZlbG9jaXR5KF90aGlzLmN1cnJlbnQsIF90aGlzLnByZXYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlTGlzdChfdGhpcy5jdXJyZW50KSkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlQ3VycmVudCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmN1cnJlbnQgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuZ2V0VmVsb2NpdHlPZkN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldExpc3RWZWxvY2l0eSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUN1cnJlbnQgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnQgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50W2tleV0gPSB2W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuZ2V0VmVsb2NpdHlPZkN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldE1hcFZlbG9jaXR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5pbml0aWFsU3Vic2NyaXB0aW9uKSBfdGhpcy5zdWJzY3JpYmUocHJvcHMuaW5pdGlhbFN1YnNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmFsdWVSZWFjdGlvbi5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVSZWFjdGlvbihwcm9wcyk7XG4gICAgfTtcbiAgICBWYWx1ZVJlYWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfTtcbiAgICBWYWx1ZVJlYWN0aW9uLnByb3RvdHlwZS5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVsb2NpdHlPZkN1cnJlbnQoKTtcbiAgICB9O1xuICAgIFZhbHVlUmVhY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgdik7XG4gICAgICAgIHRoaXMucHJldiA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50KHYpO1xuICAgICAgICB0aGlzLnRpbWVEZWx0YSA9IHRpbWVTaW5jZUxhc3RGcmFtZSgpO1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGVkID0gY3VycmVudEZyYW1lVGltZSgpO1xuICAgICAgICBvbkZyYW1lRW5kKHRoaXMuc2NoZWR1bGVWZWxvY2l0eUNoZWNrKTtcbiAgICB9O1xuICAgIFZhbHVlUmVhY3Rpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlckNhbmRpZGF0ZSkge1xuICAgICAgICB2YXIgc3ViID0gX3N1cGVyLnByb3RvdHlwZS5zdWJzY3JpYmUuY2FsbCh0aGlzLCBvYnNlcnZlckNhbmRpZGF0ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMuY3VycmVudCk7XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfTtcbiAgICBWYWx1ZVJlYWN0aW9uLnByb3RvdHlwZS5nZXRTaW5nbGVWZWxvY2l0eSA9IGZ1bmN0aW9uIChjdXJyZW50LCBwcmV2KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHByZXYgPT09ICdudW1iZXInID8gc3BlZWRQZXJTZWNvbmQoY3VycmVudCAtIHByZXYsIHRoaXMudGltZURlbHRhKSA6IHNwZWVkUGVyU2Vjb25kKHBhcnNlRmxvYXQoY3VycmVudCkgLSBwYXJzZUZsb2F0KHByZXYpLCB0aGlzLnRpbWVEZWx0YSkgfHwgMDtcbiAgICB9O1xuICAgIFZhbHVlUmVhY3Rpb24ucHJvdG90eXBlLmdldExpc3RWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudC5tYXAoZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRTaW5nbGVWZWxvY2l0eShjLCBfdGhpcy5wcmV2W2ldKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBWYWx1ZVJlYWN0aW9uLnByb3RvdHlwZS5nZXRNYXBWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZlbG9jaXR5ID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZlbG9jaXR5W2tleV0gPSB0aGlzLmdldFNpbmdsZVZlbG9jaXR5KHRoaXMuY3VycmVudFtrZXldLCB0aGlzLnByZXZba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlbG9jaXR5O1xuICAgIH07XG4gICAgcmV0dXJuIFZhbHVlUmVhY3Rpb247XG59KEJhc2VNdWx0aWNhc3QpO1xudmFyIHZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsU3Vic2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZVJlYWN0aW9uKHsgdmFsdWU6IHZhbHVlLCBpbml0aWFsU3Vic2NyaXB0aW9uOiBpbml0aWFsU3Vic2NyaXB0aW9uIH0pO1xufTtcblxudmFyIG11bHRpID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGdldENvdW50ID0gX2EuZ2V0Q291bnQsXG4gICAgICAgIGdldEZpcnN0ID0gX2EuZ2V0Rmlyc3QsXG4gICAgICAgIGdldE91dHB1dCA9IF9hLmdldE91dHB1dCxcbiAgICAgICAgbWFwQXBpID0gX2EubWFwQXBpLFxuICAgICAgICBzZXRQcm9wID0gX2Euc2V0UHJvcCxcbiAgICAgICAgc3RhcnRBY3Rpb25zID0gX2Euc3RhcnRBY3Rpb25zO1xuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IF9hLnVwZGF0ZSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IF9hLmNvbXBsZXRlLFxuICAgICAgICAgICAgICAgIGVycm9yID0gX2EuZXJyb3I7XG4gICAgICAgICAgICB2YXIgbnVtQWN0aW9ucyA9IGdldENvdW50KGFjdGlvbnMpO1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGdldE91dHB1dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZU91dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlKG91dHB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG51bUNvbXBsZXRlZEFjdGlvbnMgPSAwO1xuICAgICAgICAgICAgdmFyIHN1YnMgPSBzdGFydEFjdGlvbnMoYWN0aW9ucywgZnVuY3Rpb24gKGEsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQoe1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUNvbXBsZXRlZEFjdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtQ29tcGxldGVkQWN0aW9ucyA9PT0gbnVtQWN0aW9ucykgb25GcmFtZVVwZGF0ZShjb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvcChvdXRwdXQsIG5hbWUsIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25GcmFtZVVwZGF0ZSh1cGRhdGVPdXRwdXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhnZXRGaXJzdChzdWJzKSkucmVkdWNlKGZ1bmN0aW9uIChhcGksIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBhcGlbbWV0aG9kTmFtZV0gPSBtYXBBcGkoc3VicywgbWV0aG9kTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cbnZhciBjb21wb3NpdGUgPSAvKiNfX1BVUkVfXyovbXVsdGkoe1xuICAgIGdldE91dHB1dDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICBnZXRDb3VudDogZnVuY3Rpb24gKHN1YnMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN1YnMpLmxlbmd0aDtcbiAgICB9LFxuICAgIGdldEZpcnN0OiBmdW5jdGlvbiAoc3Vicykge1xuICAgICAgICByZXR1cm4gc3Vic1tPYmplY3Qua2V5cyhzdWJzKVswXV07XG4gICAgfSxcbiAgICBtYXBBcGk6IGZ1bmN0aW9uIChzdWJzLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3VicykucmVkdWNlKGZ1bmN0aW9uIChvdXRwdXQsIHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNbcHJvcEtleV1bbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1swXSAmJiBhcmdzWzBdW3Byb3BLZXldICE9PSB1bmRlZmluZWQgPyBvdXRwdXRbcHJvcEtleV0gPSBzdWJzW3Byb3BLZXldW21ldGhvZE5hbWVdKGFyZ3NbMF1bcHJvcEtleV0pIDogb3V0cHV0W3Byb3BLZXldID0gKF9hID0gc3Vic1twcm9wS2V5XSlbbWV0aG9kTmFtZV0uYXBwbHkoX2EsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgc2V0UHJvcDogZnVuY3Rpb24gKG91dHB1dCwgbmFtZSwgdikge1xuICAgICAgICByZXR1cm4gb3V0cHV0W25hbWVdID0gdjtcbiAgICB9LFxuICAgIHN0YXJ0QWN0aW9uczogZnVuY3Rpb24gKGFjdGlvbnMsIHN0YXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFjdGlvbnMpLnJlZHVjZShmdW5jdGlvbiAoc3Vicywga2V5KSB7XG4gICAgICAgICAgICBzdWJzW2tleV0gPSBzdGFydGVyKGFjdGlvbnNba2V5XSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxufSk7XG5cbnZhciBwYXJhbGxlbCA9IC8qI19fUFVSRV9fKi9tdWx0aSh7XG4gICAgZ2V0T3V0cHV0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGdldENvdW50OiBmdW5jdGlvbiAoc3Vicykge1xuICAgICAgICByZXR1cm4gc3Vicy5sZW5ndGg7XG4gICAgfSxcbiAgICBnZXRGaXJzdDogZnVuY3Rpb24gKHN1YnMpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNbMF07XG4gICAgfSxcbiAgICBtYXBBcGk6IGZ1bmN0aW9uIChzdWJzLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3Vicy5tYXAoZnVuY3Rpb24gKHN1YiwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBzdWJbbWV0aG9kTmFtZV0oYXJnc1swXVtpXSkgOiBzdWJbbWV0aG9kTmFtZV0uYXBwbHkoc3ViLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNldFByb3A6IGZ1bmN0aW9uIChvdXRwdXQsIG5hbWUsIHYpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dFtuYW1lXSA9IHY7XG4gICAgfSxcbiAgICBzdGFydEFjdGlvbnM6IGZ1bmN0aW9uIChhY3Rpb25zLCBzdGFydGVyKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25zLm1hcChmdW5jdGlvbiAoYWN0aW9uLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRlcihhY3Rpb24sIGkpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcbnZhciBwYXJhbGxlbCQxID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYWN0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYWxsZWwoYWN0aW9ucyk7XG59O1xuXG52YXIgY3JlYXRlVmVjdG9yVGVzdHMgPSBmdW5jdGlvbiAodHlwZVRlc3RzKSB7XG4gICAgdmFyIHRlc3ROYW1lcyA9IE9iamVjdC5rZXlzKHR5cGVUZXN0cyk7XG4gICAgdmFyIGlzVmVjdG9yUHJvcCA9IGZ1bmN0aW9uIChwcm9wLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByb3AgIT09IHVuZGVmaW5lZCAmJiAhdHlwZVRlc3RzW2tleV0ocHJvcCk7XG4gICAgfTtcbiAgICB2YXIgZ2V0VmVjdG9yS2V5cyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICByZXR1cm4gdGVzdE5hbWVzLnJlZHVjZShmdW5jdGlvbiAodmVjdG9yS2V5cywga2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNWZWN0b3JQcm9wKHByb3BzW2tleV0sIGtleSkpIHZlY3RvcktleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHZlY3RvcktleXM7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuICAgIHZhciB0ZXN0VmVjdG9yUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzICYmIHRlc3ROYW1lcy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ZlY3RvclByb3AocHJvcHNba2V5XSwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4geyBnZXRWZWN0b3JLZXlzOiBnZXRWZWN0b3JLZXlzLCB0ZXN0VmVjdG9yUHJvcHM6IHRlc3RWZWN0b3JQcm9wcyB9O1xufTtcbnZhciB1bml0VHlwZXMgPSBbcHgsIHBlcmNlbnQsIGRlZ3JlZXMsIHZoLCB2d107XG52YXIgZmluZFVuaXRUeXBlID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gdW5pdFR5cGVzLmZpbmQoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUudGVzdChwcm9wKTtcbiAgICB9KTtcbn07XG52YXIgaXNVbml0UHJvcCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZmluZFVuaXRUeXBlKHByb3ApKTtcbn07XG52YXIgY3JlYXRlQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbiwgcHJvcHMpIHtcbiAgICByZXR1cm4gYWN0aW9uKHByb3BzKTtcbn07XG52YXIgcmVkdWNlQXJyYXlWYWx1ZSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcywga2V5KSB7XG4gICAgICAgIHByb3BzW2tleV0gPSBwcm9wc1trZXldW2ldO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcbn07XG52YXIgY3JlYXRlQXJyYXlBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uLCBwcm9wcywgdmVjdG9yS2V5cykge1xuICAgIHZhciBmaXJzdFZlY3RvcktleSA9IHZlY3RvcktleXNbMF07XG4gICAgdmFyIGFjdGlvbkxpc3QgPSBwcm9wc1tmaXJzdFZlY3RvcktleV0ubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgIHZhciBjaGlsZEFjdGlvblByb3BzID0gdmVjdG9yS2V5cy5yZWR1Y2UocmVkdWNlQXJyYXlWYWx1ZShpKSwgX19hc3NpZ24oe30sIHByb3BzKSk7XG4gICAgICAgIHJldHVybiBnZXRBY3Rpb25DcmVhdG9yKHYpKGFjdGlvbiwgY2hpbGRBY3Rpb25Qcm9wcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcmFsbGVsJDEuYXBwbHkodm9pZCAwLCBhY3Rpb25MaXN0KTtcbn07XG52YXIgcmVkdWNlT2JqZWN0VmFsdWUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcywgcHJvcEtleSkge1xuICAgICAgICBwcm9wc1twcm9wS2V5XSA9IHByb3BzW3Byb3BLZXldW2tleV07XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xufTtcbnZhciBjcmVhdGVPYmplY3RBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uLCBwcm9wcywgdmVjdG9yS2V5cykge1xuICAgIHZhciBmaXJzdFZlY3RvcktleSA9IHZlY3RvcktleXNbMF07XG4gICAgdmFyIGFjdGlvbk1hcCA9IE9iamVjdC5rZXlzKHByb3BzW2ZpcnN0VmVjdG9yS2V5XSkucmVkdWNlKGZ1bmN0aW9uIChtYXAsIGtleSkge1xuICAgICAgICB2YXIgY2hpbGRBY3Rpb25Qcm9wcyA9IHZlY3RvcktleXMucmVkdWNlKHJlZHVjZU9iamVjdFZhbHVlKGtleSksIF9fYXNzaWduKHt9LCBwcm9wcykpO1xuICAgICAgICBtYXBba2V5XSA9IGdldEFjdGlvbkNyZWF0b3IocHJvcHNbZmlyc3RWZWN0b3JLZXldW2tleV0pKGFjdGlvbiwgY2hpbGRBY3Rpb25Qcm9wcyk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBjb21wb3NpdGUoYWN0aW9uTWFwKTtcbn07XG52YXIgY3JlYXRlVW5pdEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24sIF9hKSB7XG4gICAgdmFyIGZyb20gPSBfYS5mcm9tLFxuICAgICAgICB0byA9IF9hLnRvLFxuICAgICAgICBwcm9wcyA9IF9fcmVzdChfYSwgW1wiZnJvbVwiLCBcInRvXCJdKTtcbiAgICB2YXIgdW5pdFR5cGUgPSBmaW5kVW5pdFR5cGUoZnJvbSkgfHwgZmluZFVuaXRUeXBlKHRvKTtcbiAgICB2YXIgdHJhbnNmb3JtID0gdW5pdFR5cGUudHJhbnNmb3JtLFxuICAgICAgICBwYXJzZSA9IHVuaXRUeXBlLnBhcnNlO1xuICAgIHJldHVybiBhY3Rpb24oX19hc3NpZ24oe30sIHByb3BzLCB7IGZyb206IHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyA/IHBhcnNlKGZyb20pIDogZnJvbSwgdG86IHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyBwYXJzZSh0bykgOiB0byB9KSkucGlwZSh0cmFuc2Zvcm0pO1xufTtcbnZhciBjcmVhdGVDb2xvckFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24sIF9hKSB7XG4gICAgdmFyIGZyb20gPSBfYS5mcm9tLFxuICAgICAgICB0byA9IF9hLnRvLFxuICAgICAgICBwcm9wcyA9IF9fcmVzdChfYSwgW1wiZnJvbVwiLCBcInRvXCJdKTtcbiAgICByZXR1cm4gYWN0aW9uKF9fYXNzaWduKHt9LCBwcm9wcywgeyBmcm9tOiAwLCB0bzogMSB9KSkucGlwZShibGVuZENvbG9yKGZyb20sIHRvKSwgY29sb3IudHJhbnNmb3JtKTtcbn07XG52YXIgY3JlYXRlQ29tcGxleEFjdGlvbiA9IGZ1bmN0aW9uIChhY3Rpb24sIF9hKSB7XG4gICAgdmFyIGZyb20gPSBfYS5mcm9tLFxuICAgICAgICB0byA9IF9hLnRvLFxuICAgICAgICBwcm9wcyA9IF9fcmVzdChfYSwgW1wiZnJvbVwiLCBcInRvXCJdKTtcbiAgICB2YXIgdmFsdWVUZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIoZnJvbSk7XG4gICAgaW52YXJpYW50KHZhbHVlVGVtcGxhdGUoZnJvbSkgPT09IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIodG8pKGZyb20pLCBcIlZhbHVlcyAnXCIgKyBmcm9tICsgXCInIGFuZCAnXCIgKyB0byArIFwiJyBhcmUgb2YgZGlmZmVyZW50IGZvcm1hdCwgb3IgYSB2YWx1ZSBtaWdodCBoYXZlIGNoYW5nZWQgdmFsdWUgdHlwZS5cIik7XG4gICAgcmV0dXJuIGFjdGlvbihfX2Fzc2lnbih7fSwgcHJvcHMsIHsgZnJvbTogMCwgdG86IDEgfSkpLnBpcGUoYmxlbmRBcnJheShjb21wbGV4LnBhcnNlKGZyb20pLCBjb21wbGV4LnBhcnNlKHRvKSksIHZhbHVlVGVtcGxhdGUpO1xufTtcbnZhciBjcmVhdGVWZWN0b3JBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uLCB0eXBlVGVzdHMpIHtcbiAgICB2YXIgX2EgPSBjcmVhdGVWZWN0b3JUZXN0cyh0eXBlVGVzdHMpLFxuICAgICAgICB0ZXN0VmVjdG9yUHJvcHMgPSBfYS50ZXN0VmVjdG9yUHJvcHMsXG4gICAgICAgIGdldFZlY3RvcktleXMgPSBfYS5nZXRWZWN0b3JLZXlzO1xuICAgIHZhciB2ZWN0b3JBY3Rpb24gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgdmFyIGlzVmVjdG9yID0gdGVzdFZlY3RvclByb3BzKHByb3BzKTtcbiAgICAgICAgaWYgKCFpc1ZlY3RvcikgcmV0dXJuIGFjdGlvbihwcm9wcyk7XG4gICAgICAgIHZhciB2ZWN0b3JLZXlzID0gZ2V0VmVjdG9yS2V5cyhwcm9wcyk7XG4gICAgICAgIHZhciB0ZXN0S2V5ID0gdmVjdG9yS2V5c1swXTtcbiAgICAgICAgdmFyIHRlc3RQcm9wID0gcHJvcHNbdGVzdEtleV07XG4gICAgICAgIHJldHVybiBnZXRBY3Rpb25DcmVhdG9yKHRlc3RQcm9wKShhY3Rpb24sIHByb3BzLCB2ZWN0b3JLZXlzKTtcbiAgICB9O1xuICAgIHJldHVybiB2ZWN0b3JBY3Rpb247XG59O1xudmFyIGdldEFjdGlvbkNyZWF0b3IgPSBmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gY3JlYXRlQWN0aW9uO1xuICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYWN0aW9uQ3JlYXRvciA9IGNyZWF0ZUFjdGlvbjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgYWN0aW9uQ3JlYXRvciA9IGNyZWF0ZUFycmF5QWN0aW9uO1xuICAgIH0gZWxzZSBpZiAoaXNVbml0UHJvcChwcm9wKSkge1xuICAgICAgICBhY3Rpb25DcmVhdG9yID0gY3JlYXRlVW5pdEFjdGlvbjtcbiAgICB9IGVsc2UgaWYgKGNvbG9yLnRlc3QocHJvcCkpIHtcbiAgICAgICAgYWN0aW9uQ3JlYXRvciA9IGNyZWF0ZUNvbG9yQWN0aW9uO1xuICAgIH0gZWxzZSBpZiAoY29tcGxleC50ZXN0KHByb3ApKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3IgPSBjcmVhdGVDb21wbGV4QWN0aW9uO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3AgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3IgPSBjcmVhdGVPYmplY3RBY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb25DcmVhdG9yO1xufTtcblxudmFyIGZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhY3Rpb24oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSBfYS51cGRhdGU7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBjdXJyZW50VGltZSgpO1xuICAgICAgICB2YXIgbmV4dEZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFpc0FjdGl2ZSkgcmV0dXJuO1xuICAgICAgICAgICAgdXBkYXRlKE1hdGgubWF4KGN1cnJlbnRGcmFtZVRpbWUoKSAtIHN0YXJ0VGltZSwgMCkpO1xuICAgICAgICAgICAgb25GcmFtZVVwZGF0ZShuZXh0RnJhbWUpO1xuICAgICAgICB9O1xuICAgICAgICBvbkZyYW1lVXBkYXRlKG5leHRGcmFtZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG52YXIgZGVjYXkgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgICBwcm9wcyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgY29tcGxldGUgPSBfYS5jb21wbGV0ZSxcbiAgICAgICAgICAgIHVwZGF0ZSA9IF9hLnVwZGF0ZTtcbiAgICAgICAgdmFyIF9iID0gcHJvcHMudmVsb2NpdHksXG4gICAgICAgICAgICB2ZWxvY2l0eSA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICAgICAgICBfYyA9IHByb3BzLmZyb20sXG4gICAgICAgICAgICBmcm9tID0gX2MgPT09IHZvaWQgMCA/IDAgOiBfYyxcbiAgICAgICAgICAgIF9kID0gcHJvcHMucG93ZXIsXG4gICAgICAgICAgICBwb3dlciA9IF9kID09PSB2b2lkIDAgPyAwLjggOiBfZCxcbiAgICAgICAgICAgIF9lID0gcHJvcHMudGltZUNvbnN0YW50LFxuICAgICAgICAgICAgdGltZUNvbnN0YW50ID0gX2UgPT09IHZvaWQgMCA/IDM1MCA6IF9lLFxuICAgICAgICAgICAgX2YgPSBwcm9wcy5yZXN0RGVsdGEsXG4gICAgICAgICAgICByZXN0RGVsdGEgPSBfZiA9PT0gdm9pZCAwID8gMC41IDogX2YsXG4gICAgICAgICAgICBtb2RpZnlUYXJnZXQgPSBwcm9wcy5tb2RpZnlUYXJnZXQ7XG4gICAgICAgIHZhciBlbGFwc2VkID0gMDtcbiAgICAgICAgdmFyIGFtcGxpdHVkZSA9IHBvd2VyICogdmVsb2NpdHk7XG4gICAgICAgIHZhciBpZGVhbFRhcmdldCA9IE1hdGgucm91bmQoZnJvbSArIGFtcGxpdHVkZSk7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0eXBlb2YgbW9kaWZ5VGFyZ2V0ID09PSAndW5kZWZpbmVkJyA/IGlkZWFsVGFyZ2V0IDogbW9kaWZ5VGFyZ2V0KGlkZWFsVGFyZ2V0KTtcbiAgICAgICAgdmFyIHRpbWVyID0gZnJhbWUoKS5zdGFydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbGFwc2VkICs9IHRpbWVTaW5jZUxhc3RGcmFtZSgpO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gLWFtcGxpdHVkZSAqIE1hdGguZXhwKC1lbGFwc2VkIC8gdGltZUNvbnN0YW50KTtcbiAgICAgICAgICAgIHZhciBpc01vdmluZyA9IGRlbHRhID4gcmVzdERlbHRhIHx8IGRlbHRhIDwgLXJlc3REZWx0YTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gaXNNb3ZpbmcgPyB0YXJnZXQgKyBkZWx0YSA6IHRhcmdldDtcbiAgICAgICAgICAgIHVwZGF0ZShjdXJyZW50KTtcbiAgICAgICAgICAgIGlmICghaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aW1lci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG52YXIgdmVjdG9yRGVjYXkgPSAvKiNfX1BVUkVfXyovY3JlYXRlVmVjdG9yQWN0aW9uKGRlY2F5LCB7XG4gICAgZnJvbTogbnVtYmVyLnRlc3QsXG4gICAgbW9kaWZ5VGFyZ2V0OiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7XG4gICAgfSxcbiAgICB2ZWxvY2l0eTogbnVtYmVyLnRlc3Rcbn0pO1xuXG52YXIgc2NydWJiZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5mcm9tLFxuICAgICAgICBmcm9tID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYixcbiAgICAgICAgX2MgPSBfYS50byxcbiAgICAgICAgdG8gPSBfYyA9PT0gdm9pZCAwID8gMSA6IF9jLFxuICAgICAgICBfZCA9IF9hLmVhc2UsXG4gICAgICAgIGVhc2UgPSBfZCA9PT0gdm9pZCAwID8gbGluZWFyIDogX2Q7XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IF9hLnVwZGF0ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlZWs6IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGUocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pLnBpcGUoZWFzZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlRnJvbVByb2dyZXNzKGZyb20sIHRvLCB2KTtcbiAgICB9KTtcbn07XG52YXIgdmVjdG9yU2NydWJiZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlVmVjdG9yQWN0aW9uKHNjcnViYmVyLCB7XG4gICAgZWFzZTogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG4gICAgZnJvbTogbnVtYmVyLnRlc3QsXG4gICAgdG86IG51bWJlci50ZXN0XG59KTtcblxudmFyIGNsYW1wUHJvZ3Jlc3MgPSAvKiNfX1BVUkVfXyovY2xhbXAoMCwgMSk7XG52YXIgdHdlZW4gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgICBwcm9wcyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdXBkYXRlID0gX2EudXBkYXRlLFxuICAgICAgICAgICAgY29tcGxldGUgPSBfYS5jb21wbGV0ZTtcbiAgICAgICAgdmFyIF9iID0gcHJvcHMuZHVyYXRpb24sXG4gICAgICAgICAgICBkdXJhdGlvbiA9IF9iID09PSB2b2lkIDAgPyAzMDAgOiBfYixcbiAgICAgICAgICAgIF9jID0gcHJvcHMuZWFzZSxcbiAgICAgICAgICAgIGVhc2UgPSBfYyA9PT0gdm9pZCAwID8gZWFzZU91dCA6IF9jLFxuICAgICAgICAgICAgX2QgPSBwcm9wcy5mbGlwLFxuICAgICAgICAgICAgZmxpcCA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsXG4gICAgICAgICAgICBfZSA9IHByb3BzLmxvb3AsXG4gICAgICAgICAgICBsb29wID0gX2UgPT09IHZvaWQgMCA/IDAgOiBfZSxcbiAgICAgICAgICAgIF9mID0gcHJvcHMueW95byxcbiAgICAgICAgICAgIHlveW8gPSBfZiA9PT0gdm9pZCAwID8gMCA6IF9mO1xuICAgICAgICB2YXIgX2cgPSBwcm9wcy5mcm9tLFxuICAgICAgICAgICAgZnJvbSA9IF9nID09PSB2b2lkIDAgPyAwIDogX2csXG4gICAgICAgICAgICBfaCA9IHByb3BzLnRvLFxuICAgICAgICAgICAgdG8gPSBfaCA9PT0gdm9pZCAwID8gMSA6IF9oLFxuICAgICAgICAgICAgX2ogPSBwcm9wcy5lbGFwc2VkLFxuICAgICAgICAgICAgZWxhcHNlZCA9IF9qID09PSB2b2lkIDAgPyAwIDogX2osXG4gICAgICAgICAgICBfayA9IHByb3BzLnBsYXlEaXJlY3Rpb24sXG4gICAgICAgICAgICBwbGF5RGlyZWN0aW9uID0gX2sgPT09IHZvaWQgMCA/IDEgOiBfayxcbiAgICAgICAgICAgIF9sID0gcHJvcHMuZmxpcENvdW50LFxuICAgICAgICAgICAgZmxpcENvdW50ID0gX2wgPT09IHZvaWQgMCA/IDAgOiBfbCxcbiAgICAgICAgICAgIF9tID0gcHJvcHMueW95b0NvdW50LFxuICAgICAgICAgICAgeW95b0NvdW50ID0gX20gPT09IHZvaWQgMCA/IDAgOiBfbSxcbiAgICAgICAgICAgIF9vID0gcHJvcHMubG9vcENvdW50LFxuICAgICAgICAgICAgbG9vcENvdW50ID0gX28gPT09IHZvaWQgMCA/IDAgOiBfbztcbiAgICAgICAgdmFyIHBsYXloZWFkID0gdmVjdG9yU2NydWJiZXIoeyBmcm9tOiBmcm9tLCB0bzogdG8sIGVhc2U6IGVhc2UgfSkuc3RhcnQodXBkYXRlKTtcbiAgICAgICAgdmFyIHByb2dyZXNzID0gMDtcbiAgICAgICAgdmFyIHR3ZWVuVGltZXI7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcmV2ZXJzZVR3ZWVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBsYXlEaXJlY3Rpb24gKj0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc1R3ZWVuQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgaXNDb21wbGV0ZSA9IHBsYXlEaXJlY3Rpb24gPT09IDEgPyBpc0FjdGl2ZSAmJiBlbGFwc2VkID49IGR1cmF0aW9uIDogaXNBY3RpdmUgJiYgZWxhcHNlZCA8PSAwO1xuICAgICAgICAgICAgaWYgKCFpc0NvbXBsZXRlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaXNDb21wbGV0ZSAmJiAhbG9vcCAmJiAhZmxpcCAmJiAheW95bykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB2YXIgaXNTdGVwVGFrZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChsb29wICYmIGxvb3BDb3VudCA8IGxvb3ApIHtcbiAgICAgICAgICAgICAgICBlbGFwc2VkID0gMDtcbiAgICAgICAgICAgICAgICBsb29wQ291bnQrKztcbiAgICAgICAgICAgICAgICBpc1N0ZXBUYWtlbiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZsaXAgJiYgZmxpcENvdW50IDwgZmxpcCkge1xuICAgICAgICAgICAgICAgIGVsYXBzZWQgPSBkdXJhdGlvbiAtIGVsYXBzZWQ7XG4gICAgICAgICAgICAgICAgX2EgPSBbdG8sIGZyb21dLCBmcm9tID0gX2FbMF0sIHRvID0gX2FbMV07XG4gICAgICAgICAgICAgICAgcGxheWhlYWQgPSB2ZWN0b3JTY3J1YmJlcih7IGZyb206IGZyb20sIHRvOiB0bywgZWFzZTogZWFzZSB9KS5zdGFydCh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIGZsaXBDb3VudCsrO1xuICAgICAgICAgICAgICAgIGlzU3RlcFRha2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeW95byAmJiB5b3lvQ291bnQgPCB5b3lvKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZVR3ZWVuKCk7XG4gICAgICAgICAgICAgICAgeW95b0NvdW50Kys7XG4gICAgICAgICAgICAgICAgaXNTdGVwVGFrZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFpc1N0ZXBUYWtlbjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVwZGF0ZVR3ZWVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBjbGFtcFByb2dyZXNzKGdldFByb2dyZXNzRnJvbVZhbHVlKDAsIGR1cmF0aW9uLCBlbGFwc2VkKSk7XG4gICAgICAgICAgICBwbGF5aGVhZC5zZWVrKHByb2dyZXNzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0d2VlblRpbWVyID0gZnJhbWUoKS5zdGFydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZWxhcHNlZCArPSB0aW1lU2luY2VMYXN0RnJhbWUoKSAqIHBsYXlEaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgdXBkYXRlVHdlZW4oKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUd2VlbkNvbXBsZXRlKCkgJiYgY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHdlZW5UaW1lci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uRnJhbWVVcGRhdGUoY29tcGxldGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc3RvcFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0d2VlblRpbWVyKSB0d2VlblRpbWVyLnN0b3AoKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3RhcnRUaW1lcigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNBY3RpdmU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWxhcHNlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGFtcCgwLCBkdXJhdGlvbikoZWxhcHNlZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UHJvZ3Jlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3BUaW1lcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RvcFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FjdGl2ZSkgc3RhcnRUaW1lcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlZWs6IGZ1bmN0aW9uIChuZXdQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGVsYXBzZWQgPSBnZXRWYWx1ZUZyb21Qcm9ncmVzcygwLCBkdXJhdGlvbiwgbmV3UHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIG9uRnJhbWVVcGRhdGUodXBkYXRlVHdlZW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldmVyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlVHdlZW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbnZhciBjbGFtcFByb2dyZXNzJDEgPSAvKiNfX1BVUkVfXyovY2xhbXAoMCwgMSk7XG52YXIgZGVmYXVsdEVhc2luZ3MgPSBmdW5jdGlvbiAodmFsdWVzLCBlYXNpbmckJDEpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlYXNpbmckJDEgfHwgZWFzZU91dDtcbiAgICB9KS5zcGxpY2UoMCwgdmFsdWVzLmxlbmd0aCAtIDEpO1xufTtcbnZhciBkZWZhdWx0VGltaW5ncyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICB2YXIgbnVtVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcbiAgICByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgcmV0dXJuIGkgIT09IDAgPyBpIC8gKG51bVZhbHVlcyAtIDEpIDogMDtcbiAgICB9KTtcbn07XG52YXIgaW50ZXJwb2xhdGVTY3J1YmJlcnMgPSBmdW5jdGlvbiAoaW5wdXQsIHNjcnViYmVycywgdXBkYXRlKSB7XG4gICAgdmFyIHJhbmdlTGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHZhciBmaW5hbElucHV0SW5kZXggPSByYW5nZUxlbmd0aCAtIDE7XG4gICAgdmFyIGZpbmFsU2NydWJiZXJJbmRleCA9IGZpbmFsSW5wdXRJbmRleCAtIDE7XG4gICAgdmFyIHN1YnMgPSBzY3J1YmJlcnMubWFwKGZ1bmN0aW9uIChzY3J1Yikge1xuICAgICAgICByZXR1cm4gc2NydWIuc3RhcnQodXBkYXRlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHYgPD0gaW5wdXRbMF0pIHtcbiAgICAgICAgICAgIHN1YnNbMF0uc2VlaygwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodiA+PSBpbnB1dFtmaW5hbElucHV0SW5kZXhdKSB7XG4gICAgICAgICAgICBzdWJzW2ZpbmFsU2NydWJiZXJJbmRleF0uc2VlaygxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgIGZvciAoOyBpIDwgcmFuZ2VMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlucHV0W2ldID4gdiB8fCBpID09PSBmaW5hbElucHV0SW5kZXgpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmVzc0luUmFuZ2UgPSBnZXRQcm9ncmVzc0Zyb21WYWx1ZShpbnB1dFtpIC0gMV0sIGlucHV0W2ldLCB2KTtcbiAgICAgICAgc3Vic1tpIC0gMV0uc2VlayhjbGFtcFByb2dyZXNzJDEocHJvZ3Jlc3NJblJhbmdlKSk7XG4gICAgfTtcbn07XG52YXIga2V5ZnJhbWVzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGVhc2luZ3MgPSBfYS5lYXNpbmdzLFxuICAgICAgICBfYiA9IF9hLmVhc2UsXG4gICAgICAgIGVhc2UgPSBfYiA9PT0gdm9pZCAwID8gbGluZWFyIDogX2IsXG4gICAgICAgIHRpbWVzID0gX2EudGltZXMsXG4gICAgICAgIHZhbHVlcyA9IF9hLnZhbHVlcyxcbiAgICAgICAgdHdlZW5Qcm9wcyA9IF9fcmVzdChfYSwgW1wiZWFzaW5nc1wiLCBcImVhc2VcIiwgXCJ0aW1lc1wiLCBcInZhbHVlc1wiXSk7XG4gICAgZWFzaW5ncyA9IEFycmF5LmlzQXJyYXkoZWFzaW5ncykgPyBlYXNpbmdzIDogZGVmYXVsdEVhc2luZ3ModmFsdWVzLCBlYXNpbmdzKTtcbiAgICB0aW1lcyA9IHRpbWVzIHx8IGRlZmF1bHRUaW1pbmdzKHZhbHVlcyk7XG4gICAgdmFyIHNjcnViYmVycyA9IGVhc2luZ3MubWFwKGZ1bmN0aW9uIChlYXNpbmckJDEsIGkpIHtcbiAgICAgICAgcmV0dXJuIHZlY3RvclNjcnViYmVyKHtcbiAgICAgICAgICAgIGZyb206IHZhbHVlc1tpXSxcbiAgICAgICAgICAgIHRvOiB2YWx1ZXNbaSArIDFdLFxuICAgICAgICAgICAgZWFzZTogZWFzaW5nJCQxXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0d2VlbihfX2Fzc2lnbih7fSwgdHdlZW5Qcm9wcywgeyBlYXNlOiBlYXNlIH0pKS5hcHBseU1pZGRsZXdhcmUoZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTY3J1YmJlcnModGltZXMsIHNjcnViYmVycywgdXBkYXRlKTtcbiAgICB9KTtcbn07XG5cbnZhciBwaHlzaWNzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlID0gX2EuY29tcGxldGUsXG4gICAgICAgICAgICB1cGRhdGUgPSBfYS51cGRhdGU7XG4gICAgICAgIHZhciBfYiA9IHByb3BzLmFjY2VsZXJhdGlvbixcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbiA9IF9iID09PSB2b2lkIDAgPyAwIDogX2IsXG4gICAgICAgICAgICBfYyA9IHByb3BzLmZyaWN0aW9uLFxuICAgICAgICAgICAgZnJpY3Rpb24gPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jLFxuICAgICAgICAgICAgX2QgPSBwcm9wcy52ZWxvY2l0eSxcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCxcbiAgICAgICAgICAgIHNwcmluZ1N0cmVuZ3RoID0gcHJvcHMuc3ByaW5nU3RyZW5ndGgsXG4gICAgICAgICAgICB0byA9IHByb3BzLnRvO1xuICAgICAgICB2YXIgX2UgPSBwcm9wcy5yZXN0U3BlZWQsXG4gICAgICAgICAgICByZXN0U3BlZWQgPSBfZSA9PT0gdm9pZCAwID8gMC4wMDEgOiBfZSxcbiAgICAgICAgICAgIF9mID0gcHJvcHMuZnJvbSxcbiAgICAgICAgICAgIGZyb20gPSBfZiA9PT0gdm9pZCAwID8gMCA6IF9mO1xuICAgICAgICB2YXIgY3VycmVudCA9IGZyb207XG4gICAgICAgIHZhciB0aW1lciA9IGZyYW1lKCkuc3RhcnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVsYXBzZWQgPSBNYXRoLm1heCh0aW1lU2luY2VMYXN0RnJhbWUoKSwgMTYpO1xuICAgICAgICAgICAgaWYgKGFjY2VsZXJhdGlvbikgdmVsb2NpdHkgKz0gc3BlZWRQZXJGcmFtZShhY2NlbGVyYXRpb24sIGVsYXBzZWQpO1xuICAgICAgICAgICAgaWYgKGZyaWN0aW9uKSB2ZWxvY2l0eSAqPSBNYXRoLnBvdygxIC0gZnJpY3Rpb24sIGVsYXBzZWQgLyAxMDApO1xuICAgICAgICAgICAgaWYgKHNwcmluZ1N0cmVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZVRvVGFyZ2V0ID0gdG8gLSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHZlbG9jaXR5ICs9IGRpc3RhbmNlVG9UYXJnZXQgKiBzcGVlZFBlckZyYW1lKHNwcmluZ1N0cmVuZ3RoLCBlbGFwc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgKz0gc3BlZWRQZXJGcmFtZSh2ZWxvY2l0eSwgZWxhcHNlZCk7XG4gICAgICAgICAgICB1cGRhdGUoY3VycmVudCk7XG4gICAgICAgICAgICB2YXIgaXNDb21wbGV0ZSA9IHJlc3RTcGVlZCAhPT0gZmFsc2UgJiYgKCF2ZWxvY2l0eSB8fCBNYXRoLmFicyh2ZWxvY2l0eSkgPD0gcmVzdFNwZWVkKTtcbiAgICAgICAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdGltZXIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEFjY2VsZXJhdGlvbjogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBhY2NlbGVyYXRpb24gPSB2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEZyaWN0aW9uOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGZyaWN0aW9uID0gdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRTcHJpbmdTdHJlbmd0aDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBzcHJpbmdTdHJlbmd0aCA9IHY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0U3ByaW5nVGFyZ2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHRvID0gdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRWZWxvY2l0eTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IHY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aW1lci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xudmFyIHZlY3RvclBoeXNpY3MgPSAvKiNfX1BVUkVfXyovY3JlYXRlVmVjdG9yQWN0aW9uKHBoeXNpY3MsIHtcbiAgICBhY2NlbGVyYXRpb246IG51bWJlci50ZXN0LFxuICAgIGZyaWN0aW9uOiBudW1iZXIudGVzdCxcbiAgICB2ZWxvY2l0eTogbnVtYmVyLnRlc3QsXG4gICAgZnJvbTogbnVtYmVyLnRlc3QsXG4gICAgdG86IG51bWJlci50ZXN0LFxuICAgIHNwcmluZ1N0cmVuZ3RoOiBudW1iZXIudGVzdFxufSk7XG5cbnZhciBzcHJpbmcgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgICBwcm9wcyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdXBkYXRlID0gX2EudXBkYXRlLFxuICAgICAgICAgICAgY29tcGxldGUgPSBfYS5jb21wbGV0ZTtcbiAgICAgICAgdmFyIF9iID0gcHJvcHMudmVsb2NpdHksXG4gICAgICAgICAgICB2ZWxvY2l0eSA9IF9iID09PSB2b2lkIDAgPyAwLjAgOiBfYjtcbiAgICAgICAgdmFyIF9jID0gcHJvcHMuZnJvbSxcbiAgICAgICAgICAgIGZyb20gPSBfYyA9PT0gdm9pZCAwID8gMC4wIDogX2MsXG4gICAgICAgICAgICBfZCA9IHByb3BzLnRvLFxuICAgICAgICAgICAgdG8gPSBfZCA9PT0gdm9pZCAwID8gMC4wIDogX2QsXG4gICAgICAgICAgICBfZSA9IHByb3BzLnN0aWZmbmVzcyxcbiAgICAgICAgICAgIHN0aWZmbmVzcyA9IF9lID09PSB2b2lkIDAgPyAxMDAgOiBfZSxcbiAgICAgICAgICAgIF9mID0gcHJvcHMuZGFtcGluZyxcbiAgICAgICAgICAgIGRhbXBpbmcgPSBfZiA9PT0gdm9pZCAwID8gMTAgOiBfZixcbiAgICAgICAgICAgIF9nID0gcHJvcHMubWFzcyxcbiAgICAgICAgICAgIG1hc3MgPSBfZyA9PT0gdm9pZCAwID8gMS4wIDogX2csXG4gICAgICAgICAgICBfaCA9IHByb3BzLnJlc3RTcGVlZCxcbiAgICAgICAgICAgIHJlc3RTcGVlZCA9IF9oID09PSB2b2lkIDAgPyAwLjAxIDogX2gsXG4gICAgICAgICAgICBfaiA9IHByb3BzLnJlc3REZWx0YSxcbiAgICAgICAgICAgIHJlc3REZWx0YSA9IF9qID09PSB2b2lkIDAgPyAwLjAxIDogX2o7XG4gICAgICAgIHZhciBpbml0aWFsVmVsb2NpdHkgPSB2ZWxvY2l0eSA/IC0odmVsb2NpdHkgLyAxMDAwKSA6IDAuMDtcbiAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICB2YXIgZGVsdGEgPSB0byAtIGZyb207XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGZyb207XG4gICAgICAgIHZhciBwcmV2UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdmFyIHNwcmluZ1RpbWVyID0gZnJhbWUoKS5zdGFydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGltZURlbHRhID0gdGltZVNpbmNlTGFzdEZyYW1lKCk7XG4gICAgICAgICAgICB0ICs9IHRpbWVEZWx0YTtcbiAgICAgICAgICAgIHZhciBkYW1waW5nUmF0aW8gPSBkYW1waW5nIC8gKDIgKiBNYXRoLnNxcnQoc3RpZmZuZXNzICogbWFzcykpO1xuICAgICAgICAgICAgdmFyIGFuZ3VsYXJGcmVxID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpIC8gMTAwMDtcbiAgICAgICAgICAgIHByZXZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKGRhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogYW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwb0RlY2F5ID0gYW5ndWxhckZyZXEgKiBNYXRoLnNxcnQoMS4wIC0gZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRvIC0gZW52ZWxvcGUgKiAoKGluaXRpYWxWZWxvY2l0eSArIGRhbXBpbmdSYXRpbyAqIGFuZ3VsYXJGcmVxICogZGVsdGEpIC8gZXhwb0RlY2F5ICogTWF0aC5zaW4oZXhwb0RlY2F5ICogdCkgKyBkZWx0YSAqIE1hdGguY29zKGV4cG9EZWNheSAqIHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudmVsb3BlID0gTWF0aC5leHAoLWFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0byAtIGVudmVsb3BlICogKGRlbHRhICsgKGluaXRpYWxWZWxvY2l0eSArIGFuZ3VsYXJGcmVxICogZGVsdGEpICogdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IHNwZWVkUGVyU2Vjb25kKHBvc2l0aW9uIC0gcHJldlBvc2l0aW9uLCB0aW1lRGVsdGEpO1xuICAgICAgICAgICAgdmFyIGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCA9IE1hdGguYWJzKHZlbG9jaXR5KSA8PSByZXN0U3BlZWQ7XG4gICAgICAgICAgICB2YXIgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZCA9IE1hdGguYWJzKHRvIC0gcG9zaXRpb24pIDw9IHJlc3REZWx0YTtcbiAgICAgICAgICAgIGlmIChpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgJiYgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdG87XG4gICAgICAgICAgICAgICAgdXBkYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBzcHJpbmdUaW1lci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwcmluZ1RpbWVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG52YXIgdmVjdG9yU3ByaW5nID0gLyojX19QVVJFX18qL2NyZWF0ZVZlY3RvckFjdGlvbihzcHJpbmcsIHtcbiAgICBmcm9tOiBudW1iZXIudGVzdCxcbiAgICB0bzogbnVtYmVyLnRlc3QsXG4gICAgc3RpZmZuZXNzOiBudW1iZXIudGVzdCxcbiAgICBkYW1waW5nOiBudW1iZXIudGVzdCxcbiAgICBtYXNzOiBudW1iZXIudGVzdCxcbiAgICB2ZWxvY2l0eTogbnVtYmVyLnRlc3Rcbn0pO1xuXG52YXIgREVGQVVMVF9EVVJBVElPTiA9IDMwMDtcbnZhciBmbGF0dGVuVGltaW5ncyA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbnMpIHtcbiAgICB2YXIgZmxhdEluc3RydWN0aW9ucyA9IFtdO1xuICAgIHZhciBsYXN0QXJnID0gaW5zdHJ1Y3Rpb25zW2luc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaXNTdGFnZ2VyZWQgPSB0eXBlb2YgbGFzdEFyZyA9PT0gJ251bWJlcic7XG4gICAgdmFyIHN0YWdnZXJEZWxheSA9IGlzU3RhZ2dlcmVkID8gbGFzdEFyZyA6IDA7XG4gICAgdmFyIHNlZ21lbnRzID0gaXNTdGFnZ2VyZWQgPyBpbnN0cnVjdGlvbnMuc2xpY2UoMCwgLTEpIDogaW5zdHJ1Y3Rpb25zO1xuICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIGZsYXRJbnN0cnVjdGlvbnMucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKGkgIT09IG51bVNlZ21lbnRzIC0gMSkge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gaXRlbS5kdXJhdGlvbiB8fCBERUZBVUxUX0RVUkFUSU9OO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0YWdnZXJEZWxheTtcbiAgICAgICAgICAgIGZsYXRJbnN0cnVjdGlvbnMucHVzaChcIi1cIiArIChkdXJhdGlvbiAtIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZsYXRJbnN0cnVjdGlvbnM7XG59O1xudmFyIGZsYXR0ZW5BcnJheUluc3RydWN0aW9ucyA9IGZ1bmN0aW9uIChpbnN0cnVjdGlvbnMsIGluc3RydWN0aW9uKSB7XG4gICAgQXJyYXkuaXNBcnJheShpbnN0cnVjdGlvbikgPyBpbnN0cnVjdGlvbnMucHVzaC5hcHBseShpbnN0cnVjdGlvbnMsIGZsYXR0ZW5UaW1pbmdzKGluc3RydWN0aW9uKSkgOiBpbnN0cnVjdGlvbnMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucztcbn07XG52YXIgY29udmVydERlZlRvUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMsIGRlZiwgaSkge1xuICAgIHZhciBkdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uLFxuICAgICAgICBlYXNpbmdzID0gcHJvcHMuZWFzaW5ncyxcbiAgICAgICAgdGltZXMgPSBwcm9wcy50aW1lcyxcbiAgICAgICAgdmFsdWVzID0gcHJvcHMudmFsdWVzO1xuICAgIHZhciBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBwcmV2VGltZVRvID0gdGltZXNbbnVtVmFsdWVzIC0gMV07XG4gICAgdmFyIHRpbWVGcm9tID0gZGVmLmF0ID09PSAwID8gMCA6IGRlZi5hdCAvIGR1cmF0aW9uO1xuICAgIHZhciB0aW1lVG8gPSAoZGVmLmF0ICsgZGVmLmR1cmF0aW9uKSAvIGR1cmF0aW9uO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGRlZi5mcm9tKTtcbiAgICAgICAgdGltZXMucHVzaCh0aW1lRnJvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZUaW1lVG8gIT09IHRpbWVGcm9tKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlc1tudW1WYWx1ZXMgLSAxXSk7XG4gICAgICAgICAgICAgICAgdGltZXMucHVzaCh0aW1lRnJvbSk7XG4gICAgICAgICAgICAgICAgZWFzaW5ncy5wdXNoKGxpbmVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJvbSA9IGRlZi5mcm9tICE9PSB1bmRlZmluZWQgPyBkZWYuZnJvbSA6IHZhbHVlc1tudW1WYWx1ZXMgLSAxXTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGZyb20pO1xuICAgICAgICAgICAgdGltZXMucHVzaCh0aW1lRnJvbSk7XG4gICAgICAgICAgICBlYXNpbmdzLnB1c2gobGluZWFyKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWYuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChkZWYuZnJvbSk7XG4gICAgICAgICAgICB0aW1lcy5wdXNoKHRpbWVGcm9tKTtcbiAgICAgICAgICAgIGVhc2luZ3MucHVzaChsaW5lYXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbHVlcy5wdXNoKGRlZi50byk7XG4gICAgdGltZXMucHVzaCh0aW1lVG8pO1xuICAgIGVhc2luZ3MucHVzaChkZWYuZWFzZSB8fCBlYXNlSW5PdXQpO1xuICAgIHJldHVybiBwcm9wcztcbn07XG52YXIgdGltZWxpbmUgPSBmdW5jdGlvbiAoaW5zdHJ1Y3Rpb25zLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgICBkdXJhdGlvbiA9IF9iLmR1cmF0aW9uLFxuICAgICAgICBlbGFwc2VkID0gX2IuZWxhcHNlZCxcbiAgICAgICAgZWFzZSA9IF9iLmVhc2UsXG4gICAgICAgIGxvb3AgPSBfYi5sb29wLFxuICAgICAgICBmbGlwID0gX2IuZmxpcCxcbiAgICAgICAgeW95byA9IF9iLnlveW87XG4gICAgdmFyIHBsYXloZWFkID0gMDtcbiAgICB2YXIgY2FsY3VsYXRlZER1cmF0aW9uID0gMDtcbiAgICB2YXIgZmxhdEluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5yZWR1Y2UoZmxhdHRlbkFycmF5SW5zdHJ1Y3Rpb25zLCBbXSk7XG4gICAgdmFyIGFuaW1hdGlvbkRlZnMgPSBbXTtcbiAgICBmbGF0SW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwbGF5aGVhZCArPSBwYXJzZUZsb2F0KGluc3RydWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwbGF5aGVhZCA9IGluc3RydWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlZiA9IF9fYXNzaWduKHt9LCBpbnN0cnVjdGlvbiwgeyBhdDogcGxheWhlYWQgfSk7XG4gICAgICAgICAgICBkZWYuZHVyYXRpb24gPSBkZWYuZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfRFVSQVRJT04gOiBkZWYuZHVyYXRpb247XG4gICAgICAgICAgICBhbmltYXRpb25EZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgIHBsYXloZWFkICs9IGRlZi5kdXJhdGlvbjtcbiAgICAgICAgICAgIGNhbGN1bGF0ZWREdXJhdGlvbiA9IE1hdGgubWF4KGNhbGN1bGF0ZWREdXJhdGlvbiwgZGVmLmF0ICsgZGVmLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciB0cmFja3MgPSB7fTtcbiAgICB2YXIgbnVtRGVmcyA9IGFuaW1hdGlvbkRlZnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGVmczsgaSsrKSB7XG4gICAgICAgIHZhciBkZWYgPSBhbmltYXRpb25EZWZzW2ldO1xuICAgICAgICB2YXIgdHJhY2sgPSBkZWYudHJhY2s7XG4gICAgICAgIGlmICh0cmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRyYWNrIGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRyYWNrcy5oYXNPd25Qcm9wZXJ0eSh0cmFjaykpIHRyYWNrc1t0cmFja10gPSBbXTtcbiAgICAgICAgdHJhY2tzW3RyYWNrXS5wdXNoKGRlZik7XG4gICAgfVxuICAgIHZhciB0cmFja0tleWZyYW1lcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB0cmFja3MpIHtcbiAgICAgICAgaWYgKHRyYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIga2V5ZnJhbWVQcm9wcyA9IHRyYWNrc1trZXldLnJlZHVjZShjb252ZXJ0RGVmVG9Qcm9wcywge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBjYWxjdWxhdGVkRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgZWFzaW5nczogW10sXG4gICAgICAgICAgICAgICAgdGltZXM6IFtdLFxuICAgICAgICAgICAgICAgIHZhbHVlczogW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJhY2tLZXlmcmFtZXNba2V5XSA9IGtleWZyYW1lcyhfX2Fzc2lnbih7fSwga2V5ZnJhbWVQcm9wcywgeyBkdXJhdGlvbjogZHVyYXRpb24gfHwgY2FsY3VsYXRlZER1cmF0aW9uLCBlYXNlOiBlYXNlLFxuICAgICAgICAgICAgICAgIGVsYXBzZWQ6IGVsYXBzZWQsXG4gICAgICAgICAgICAgICAgbG9vcDogbG9vcCxcbiAgICAgICAgICAgICAgICB5b3lvOiB5b3lvLFxuICAgICAgICAgICAgICAgIGZsaXA6IGZsaXAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wb3NpdGUodHJhY2tLZXlmcmFtZXMpO1xufTtcblxudmFyIGxpc3RlbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdXBkYXRlID0gX2EudXBkYXRlO1xuICAgICAgICB2YXIgZXZlbnROYW1lcyA9IGV2ZW50cy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB1cGRhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB1cGRhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxudmFyIGRlZmF1bHRQb2ludGVyUG9zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsaWVudFg6IDAsXG4gICAgICAgIGNsaWVudFk6IDAsXG4gICAgICAgIHBhZ2VYOiAwLFxuICAgICAgICBwYWdlWTogMCxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgIH07XG59O1xudmFyIGV2ZW50VG9Qb2ludCA9IGZ1bmN0aW9uIChlLCBwb2ludCkge1xuICAgIGlmIChwb2ludCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBvaW50ID0gZGVmYXVsdFBvaW50ZXJQb3MoKTtcbiAgICB9XG4gICAgcG9pbnQuY2xpZW50WCA9IHBvaW50LnggPSBlLmNsaWVudFg7XG4gICAgcG9pbnQuY2xpZW50WSA9IHBvaW50LnkgPSBlLmNsaWVudFk7XG4gICAgcG9pbnQucGFnZVggPSBlLnBhZ2VYO1xuICAgIHBvaW50LnBhZ2VZID0gZS5wYWdlWTtcbiAgICByZXR1cm4gcG9pbnQ7XG59O1xuXG52YXIgcG9pbnRzID0gWy8qI19fUFVSRV9fKi9kZWZhdWx0UG9pbnRlclBvcygpXTtcbnZhciBpc1RvdWNoRGV2aWNlID0gZmFsc2U7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1cGRhdGVQb2ludHNMb2NhdGlvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IF9hLnRvdWNoZXM7XG4gICAgICAgIGlzVG91Y2hEZXZpY2UgPSB0cnVlO1xuICAgICAgICB2YXIgbnVtVG91Y2hlcyA9IHRvdWNoZXMubGVuZ3RoO1xuICAgICAgICBwb2ludHMubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ub3VjaGVzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aGlzVG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goZXZlbnRUb1BvaW50KHRoaXNUb3VjaCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsaXN0ZW4oZG9jdW1lbnQsICd0b3VjaHN0YXJ0IHRvdWNobW92ZScsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pLnN0YXJ0KHVwZGF0ZVBvaW50c0xvY2F0aW9uKTtcbn1cbnZhciBtdWx0aXRvdWNoID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsXG4gICAgICAgIF9jID0gX2IucHJldmVudERlZmF1bHQsXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYyxcbiAgICAgICAgX2QgPSBfYi5zY2FsZSxcbiAgICAgICAgc2NhbGUgPSBfZCA9PT0gdm9pZCAwID8gMS4wIDogX2QsXG4gICAgICAgIF9lID0gX2Iucm90YXRlLFxuICAgICAgICByb3RhdGUgPSBfZSA9PT0gdm9pZCAwID8gMC4wIDogX2U7XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IF9hLnVwZGF0ZTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHtcbiAgICAgICAgICAgIHRvdWNoZXM6IHBvaW50cyxcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgIHJvdGF0ZTogcm90YXRlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbml0aWFsRGlzdGFuY2UgPSAwLjA7XG4gICAgICAgIHZhciBpbml0aWFsUm90YXRpb24gPSAwLjA7XG4gICAgICAgIHZhciBpc0dlc3R1cmUgPSBwb2ludHMubGVuZ3RoID4gMTtcbiAgICAgICAgaWYgKGlzR2VzdHVyZSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0VG91Y2ggPSBwb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgc2Vjb25kVG91Y2ggPSBwb2ludHNbMV07XG4gICAgICAgICAgICBpbml0aWFsRGlzdGFuY2UgPSBkaXN0YW5jZShmaXJzdFRvdWNoLCBzZWNvbmRUb3VjaCk7XG4gICAgICAgICAgICBpbml0aWFsUm90YXRpb24gPSBhbmdsZShmaXJzdFRvdWNoLCBzZWNvbmRUb3VjaCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzR2VzdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFRvdWNoID0gcG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRUb3VjaCA9IHBvaW50c1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGlzdGFuY2UgPSBkaXN0YW5jZShmaXJzdFRvdWNoLCBzZWNvbmRUb3VjaCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1JvdGF0aW9uID0gYW5nbGUoZmlyc3RUb3VjaCwgc2Vjb25kVG91Y2gpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zY2FsZSA9IHNjYWxlICogKG5ld0Rpc3RhbmNlIC8gaW5pdGlhbERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucm90YXRlID0gcm90YXRlICsgKG5ld1JvdGF0aW9uIC0gaW5pdGlhbFJvdGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZShvdXRwdXQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25Nb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCB8fCBlLnRvdWNoZXMubGVuZ3RoID4gMSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25GcmFtZVVwZGF0ZSh1cGRhdGVQb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1cGRhdGVPbk1vdmUgPSBsaXN0ZW4oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiAhcHJldmVudERlZmF1bHRcbiAgICAgICAgfSkuc3RhcnQob25Nb3ZlKTtcbiAgICAgICAgaWYgKGlzVG91Y2hEZXZpY2UpIG9uRnJhbWVVcGRhdGUodXBkYXRlUG9pbnQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbmNlbE9uRnJhbWVVcGRhdGUodXBkYXRlUG9pbnQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU9uTW92ZS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xudmFyIGdldElzVG91Y2hEZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzVG91Y2hEZXZpY2U7XG59O1xuXG52YXIgcG9pbnQgPSAvKiNfX1BVUkVfXyovZGVmYXVsdFBvaW50ZXJQb3MoKTtcbnZhciBpc01vdXNlRGV2aWNlID0gZmFsc2U7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1cGRhdGVQb2ludExvY2F0aW9uID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaXNNb3VzZURldmljZSA9IHRydWU7XG4gICAgICAgIGV2ZW50VG9Qb2ludChlLCBwb2ludCk7XG4gICAgfTtcbiAgICBsaXN0ZW4oZG9jdW1lbnQsICdtb3VzZWRvd24gbW91c2Vtb3ZlJywgdHJ1ZSkuc3RhcnQodXBkYXRlUG9pbnRMb2NhdGlvbik7XG59XG52YXIgbW91c2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLnByZXZlbnREZWZhdWx0LFxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IF9hLnVwZGF0ZTtcbiAgICAgICAgdmFyIHVwZGF0ZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZShwb2ludCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbk1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbkZyYW1lVXBkYXRlKHVwZGF0ZVBvaW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVwZGF0ZU9uTW92ZSA9IGxpc3Rlbihkb2N1bWVudCwgJ21vdXNlbW92ZScpLnN0YXJ0KG9uTW92ZSk7XG4gICAgICAgIGlmIChpc01vdXNlRGV2aWNlKSBvbkZyYW1lVXBkYXRlKHVwZGF0ZVBvaW50KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxPbkZyYW1lVXBkYXRlKHVwZGF0ZVBvaW50KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVPbk1vdmUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxudmFyIGdldEZpcnN0VG91Y2ggPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZmlyc3RUb3VjaCA9IF9hWzBdO1xuICAgIHJldHVybiBmaXJzdFRvdWNoO1xufTtcbnZhciBwb2ludGVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGdldElzVG91Y2hEZXZpY2UoKSA/IG11bHRpdG91Y2gocHJvcHMpLnBpcGUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gX2EudG91Y2hlcztcbiAgICAgICAgcmV0dXJuIHRvdWNoZXM7XG4gICAgfSwgZ2V0Rmlyc3RUb3VjaCkgOiBtb3VzZShwcm9wcyk7XG59O1xudmFyIGluZGV4ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgaWYgKF9hID09PSB2b2lkIDApIHtcbiAgICAgICAgX2EgPSB7fTtcbiAgICB9XG4gICAgdmFyIHggPSBfYS54LFxuICAgICAgICB5ID0gX2EueSxcbiAgICAgICAgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcInhcIiwgXCJ5XCJdKTtcbiAgICBpZiAoeCAhPT0gdW5kZWZpbmVkIHx8IHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYXBwbHlYT2Zmc2V0XzEgPSBhcHBseU9mZnNldCh4IHx8IDApO1xuICAgICAgICB2YXIgYXBwbHlZT2Zmc2V0XzEgPSBhcHBseU9mZnNldCh5IHx8IDApO1xuICAgICAgICB2YXIgZGVsdGFfMSA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICByZXR1cm4gcG9pbnRlcihwcm9wcykucGlwZShmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIGRlbHRhXzEueCA9IGFwcGx5WE9mZnNldF8xKHBvaW50LngpO1xuICAgICAgICAgICAgZGVsdGFfMS55ID0gYXBwbHlZT2Zmc2V0XzEocG9pbnQueSk7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGFfMTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBvaW50ZXIocHJvcHMpO1xuICAgIH1cbn07XG5cbnZhciBjaGFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFjdGlvbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IF9hLnVwZGF0ZSxcbiAgICAgICAgICAgIGNvbXBsZXRlID0gX2EuY29tcGxldGU7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnQ7XG4gICAgICAgIHZhciBwbGF5Q3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBhY3Rpb25zW2ldLnN0YXJ0KHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGkgPj0gYWN0aW9ucy5sZW5ndGggPyBjb21wbGV0ZSgpIDogcGxheUN1cnJlbnQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcGxheUN1cnJlbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudCAmJiBjdXJyZW50LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbnZhciBjcm9zc2ZhZGUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhY3Rpb24oZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHZhciBiYWxhbmNlID0gMDtcbiAgICAgICAgdmFyIGZhZGFibGUgPSBwYXJhbGxlbCQxKGEsIGIpLnN0YXJ0KF9fYXNzaWduKHt9LCBvYnNlcnZlciwgeyB1cGRhdGU6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB2YSA9IF9hWzBdLFxuICAgICAgICAgICAgICAgICAgICB2YiA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLnVwZGF0ZShnZXRWYWx1ZUZyb21Qcm9ncmVzcyh2YSwgdmIsIGJhbGFuY2UpKTtcbiAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0QmFsYW5jZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFsYW5jZSA9IHY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWRhYmxlLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbnZhciBkZWxheSA9IGZ1bmN0aW9uICh0aW1lVG9EZWxheSkge1xuICAgIHJldHVybiBhY3Rpb24oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZSA9IF9hLmNvbXBsZXRlO1xuICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY29tcGxldGUsIHRpbWVUb0RlbGF5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYWN0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgc3VicyA9IGFjdGlvbnMubWFwKGZ1bmN0aW9uICh0aGlzQWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc0FjdGlvbi5zdGFydChvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzLmZvckVhY2goZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbnZhciBzY2hlZHVsZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIHNjaGVkdWxlZSkge1xuICAgIHJldHVybiBhY3Rpb24oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB1cGRhdGUgPSBfYS51cGRhdGUsXG4gICAgICAgICAgICBjb21wbGV0ZSA9IF9hLmNvbXBsZXRlO1xuICAgICAgICB2YXIgbGF0ZXN0O1xuICAgICAgICB2YXIgc2NoZWR1bGVyU3ViID0gc2NoZWR1bGVyLnN0YXJ0KHtcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXRlc3QgIT09IHVuZGVmaW5lZCAmJiB1cGRhdGUobGF0ZXN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzY2hlZHVsZWVTdWIgPSBzY2hlZHVsZWUuc3RhcnQoe1xuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXRlc3QgPSB2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJTdWIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZVN1Yi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG52YXIgc3RhZ2dlciA9IGZ1bmN0aW9uIChhY3Rpb25zLCBpbnRlcnZhbCkge1xuICAgIHZhciBpbnRlcnZhbElzTnVtYmVyID0gdHlwZW9mIGludGVydmFsID09PSAnbnVtYmVyJztcbiAgICB2YXIgYWN0aW9uc1dpdGhEZWxheSA9IGFjdGlvbnMubWFwKGZ1bmN0aW9uIChhLCBpKSB7XG4gICAgICAgIHZhciB0aW1lVG9EZWxheSA9IGludGVydmFsSXNOdW1iZXIgPyBpbnRlcnZhbCAqIGkgOiBpbnRlcnZhbChpKTtcbiAgICAgICAgcmV0dXJuIGNoYWluKGRlbGF5KHRpbWVUb0RlbGF5KSwgYSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcmFsbGVsJDEuYXBwbHkodm9pZCAwLCBhY3Rpb25zV2l0aERlbGF5KTtcbn07XG5cbnZhciBjc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnY3NzKCkgaXMgZGVwcmVjYXRlZCwgdXNlIHN0eWxlciBpbnN0ZWFkJyk7XG4gICAgcmV0dXJuIHN0eWxlcihlbGVtZW50LCBwcm9wcyk7XG59O1xudmFyIHN2ZyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdzdmcoKSBpcyBkZXByZWNhdGVkLCB1c2Ugc3R5bGVyIGluc3RlYWQnKTtcbiAgICByZXR1cm4gc3R5bGVyKGVsZW1lbnQsIHByb3BzKTtcbn07XG5cbmV4cG9ydCB7IGFjdGlvbiwgbXVsdGljYXN0LCB2YWx1ZSwgdmVjdG9yRGVjYXkgYXMgZGVjYXksIGtleWZyYW1lcywgZnJhbWUgYXMgZXZlcnlGcmFtZSwgdmVjdG9yUGh5c2ljcyBhcyBwaHlzaWNzLCB2ZWN0b3JTcHJpbmcgYXMgc3ByaW5nLCB0aW1lbGluZSwgdHdlZW4sIGxpc3RlbiwgaW5kZXggYXMgcG9pbnRlciwgbW91c2UsIG11bHRpdG91Y2gsIGNoYWluLCBjb21wb3NpdGUsIGNyb3NzZmFkZSwgZGVsYXksIG1lcmdlLCBwYXJhbGxlbCQxIGFzIHBhcmFsbGVsLCBzY2hlZHVsZSwgc3RhZ2dlciwgY2FsYywgdHJhbnNmb3JtZXJzIGFzIHRyYW5zZm9ybSwgY3NzLCBzdmcsIEFjdGlvbiwgVmFsdWVSZWFjdGlvbiB9O1xuIiwiaW1wb3J0IHsgX19yZXN0LCBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ2hleS1saXN0ZW4nO1xuXG52YXIgZ2V0UG9zZVZhbHVlcyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciB0cmFuc2l0aW9uID0gX2EudHJhbnNpdGlvbixcbiAgICAgICAgZGVsYXkgPSBfYS5kZWxheSxcbiAgICAgICAgZGVsYXlDaGlsZHJlbiA9IF9hLmRlbGF5Q2hpbGRyZW4sXG4gICAgICAgIHN0YWdnZXJDaGlsZHJlbiA9IF9hLnN0YWdnZXJDaGlsZHJlbixcbiAgICAgICAgc3RhZ2dlckRpcmVjdGlvbiA9IF9hLnN0YWdnZXJEaXJlY3Rpb24sXG4gICAgICAgIGFmdGVyQ2hpbGRyZW4gPSBfYS5hZnRlckNoaWxkcmVuLFxuICAgICAgICBiZWZvcmVDaGlsZHJlbiA9IF9hLmJlZm9yZUNoaWxkcmVuLFxuICAgICAgICBwcmVUcmFuc2l0aW9uID0gX2EucHJlVHJhbnNpdGlvbixcbiAgICAgICAgYXBwbHlBdFN0YXJ0ID0gX2EuYXBwbHlBdFN0YXJ0LFxuICAgICAgICBhcHBseUF0RW5kID0gX2EuYXBwbHlBdEVuZCxcbiAgICAgICAgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcInRyYW5zaXRpb25cIiwgXCJkZWxheVwiLCBcImRlbGF5Q2hpbGRyZW5cIiwgXCJzdGFnZ2VyQ2hpbGRyZW5cIiwgXCJzdGFnZ2VyRGlyZWN0aW9uXCIsIFwiYWZ0ZXJDaGlsZHJlblwiLCBcImJlZm9yZUNoaWxkcmVuXCIsIFwicHJlVHJhbnNpdGlvblwiLCBcImFwcGx5QXRTdGFydFwiLCBcImFwcGx5QXRFbmRcIl0pO1xuICAgIHJldHVybiBwcm9wcztcbn07XG52YXIgc2VsZWN0UG9zZXMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgbGFiZWwgPSBfYS5sYWJlbCxcbiAgICAgICAgcHJvcHMgPSBfYS5wcm9wcyxcbiAgICAgICAgdmFsdWVzID0gX2EudmFsdWVzLFxuICAgICAgICBwYXJlbnRWYWx1ZXMgPSBfYS5wYXJlbnRWYWx1ZXMsXG4gICAgICAgIGFuY2VzdG9yVmFsdWVzID0gX2EuYW5jZXN0b3JWYWx1ZXMsXG4gICAgICAgIG9uQ2hhbmdlID0gX2Eub25DaGFuZ2UsXG4gICAgICAgIHBhc3NpdmUgPSBfYS5wYXNzaXZlLFxuICAgICAgICBpbml0aWFsUG9zZSA9IF9hLmluaXRpYWxQb3NlLFxuICAgICAgICBwb3NlcyA9IF9fcmVzdChfYSwgW1wibGFiZWxcIiwgXCJwcm9wc1wiLCBcInZhbHVlc1wiLCBcInBhcmVudFZhbHVlc1wiLCBcImFuY2VzdG9yVmFsdWVzXCIsIFwib25DaGFuZ2VcIiwgXCJwYXNzaXZlXCIsIFwiaW5pdGlhbFBvc2VcIl0pO1xuICAgIHJldHVybiBwb3Nlcztcbn07XG52YXIgc2VsZWN0QWxsVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcywgc2VsZWN0VmFsdWUpIHtcbiAgICB2YXIgYWxsVmFsdWVzID0ge307XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGFsbFZhbHVlc1trZXldID0gc2VsZWN0VmFsdWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhbGxWYWx1ZXM7XG59O1xuXG52YXIgcmVzb2x2ZVByb3AgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wcykge1xuICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gdGFyZ2V0KHByb3BzKSA6IHRhcmdldDtcbn07XG52YXIgcG9zZURlZmF1bHQgPSBmdW5jdGlvbiAocG9zZSwgcHJvcCwgZGVmYXVsdFZhbHVlLCByZXNvbHZlUHJvcHMpIHtcbiAgICByZXR1cm4gcG9zZSAmJiBwb3NlW3Byb3BdICE9PSB1bmRlZmluZWQgPyByZXNvbHZlUHJvcChwb3NlW3Byb3BdLCByZXNvbHZlUHJvcHMpIDogZGVmYXVsdFZhbHVlO1xufTtcbnZhciBzdGFydENoaWxkQW5pbWF0aW9ucyA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgbmV4dCwgcG9zZSwgcHJvcHMpIHtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xuICAgIHZhciBkZWxheSA9IHBvc2VEZWZhdWx0KHBvc2UsICdkZWxheUNoaWxkcmVuJywgMCwgcHJvcHMpO1xuICAgIHZhciBzdGFnZ2VyID0gcG9zZURlZmF1bHQocG9zZSwgJ3N0YWdnZXJDaGlsZHJlbicsIDAsIHByb3BzKTtcbiAgICB2YXIgc3RhZ2dlckRpcmVjdGlvbiA9IHBvc2VEZWZhdWx0KHBvc2UsICdzdGFnZ2VyRGlyZWN0aW9uJywgMSwgcHJvcHMpO1xuICAgIHZhciBtYXhTdGFnZ2VyRHVyYXRpb24gPSAoY2hpbGRyZW4uc2l6ZSAtIDEpICogc3RhZ2dlcjtcbiAgICB2YXIgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24gPSBzdGFnZ2VyRGlyZWN0aW9uID09PSAxID8gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkgKiBzdGFnZ2VyO1xuICAgIH0gOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gbWF4U3RhZ2dlckR1cmF0aW9uIC0gaSAqIHN0YWdnZXI7XG4gICAgfTtcbiAgICBBcnJheS5mcm9tKGNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goY2hpbGQuc2V0KG5leHQsIF9fYXNzaWduKHt9LCBwcm9wcywgeyBkZWxheTogZGVsYXkgKyBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbihpKSB9KSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBhbmltYXRpb25zO1xufTtcbnZhciByZXNvbHZlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBrZXksIHZhbHVlLCBwcm9wcywgY29udmVydFRyYW5zaXRpb25EZWZpbml0aW9uLCBnZXRJbnN0YW50VHJhbnNpdGlvbikge1xuICAgIHZhciByZXNvbHZlZFRyYW5zaXRpb247XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlc29sdmVkVHJhbnNpdGlvbiA9IHRyYW5zaXRpb24ocHJvcHMpO1xuICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbltrZXldIHx8IHRyYW5zaXRpb24uZGVmYXVsdCkge1xuICAgICAgICB2YXIga2V5VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSB8fCB0cmFuc2l0aW9uLmRlZmF1bHQ7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5VHJhbnNpdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzb2x2ZWRUcmFuc2l0aW9uID0ga2V5VHJhbnNpdGlvbihwcm9wcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlZFRyYW5zaXRpb24gPSBrZXlUcmFuc2l0aW9uO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZWRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkVHJhbnNpdGlvbiA9PT0gZmFsc2UgPyBnZXRJbnN0YW50VHJhbnNpdGlvbih2YWx1ZSwgcHJvcHMpIDogY29udmVydFRyYW5zaXRpb25EZWZpbml0aW9uKHZhbHVlLCByZXNvbHZlZFRyYW5zaXRpb24sIHByb3BzKTtcbn07XG52YXIgZmluZEluc2VydGlvbkluZGV4ID0gZnVuY3Rpb24gKHBvc2VMaXN0LCBwcmlvcml0eUxpc3QsIHByaW9yaXR5SW5kZXgpIHtcbiAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSAwO1xuICAgIGZvciAodmFyIGkgPSBwcmlvcml0eUluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5leHRIaWdoZXN0UHJpb3JpdHlJbmRleCA9IHBvc2VMaXN0LmluZGV4T2YocHJpb3JpdHlMaXN0W2ldKTtcbiAgICAgICAgaWYgKG5leHRIaWdoZXN0UHJpb3JpdHlJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gbmV4dEhpZ2hlc3RQcmlvcml0eUluZGV4ICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnNlcnRpb25JbmRleDtcbn07XG52YXIgYXBwbHlWYWx1ZXMgPSBmdW5jdGlvbiAodG9BcHBseSwgdmFsdWVzLCBwcm9wcywgc2V0VmFsdWUsIHNldFZhbHVlTmF0aXZlKSB7XG4gICAgaW52YXJpYW50KHR5cGVvZiB0b0FwcGx5ID09PSAnb2JqZWN0JywgJ2FwcGx5QXRTdGFydCBhbmQgYXBwbHlBdEVuZCBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0Jyk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRvQXBwbHkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWVUb1NldCA9IHJlc29sdmVQcm9wKHRvQXBwbHlba2V5XSwgcHJvcHMpO1xuICAgICAgICB2YWx1ZXMuaGFzKGtleSkgPyBzZXRWYWx1ZSh2YWx1ZXMuZ2V0KGtleSksIHZhbHVlVG9TZXQpIDogc2V0VmFsdWVOYXRpdmUoa2V5LCB2YWx1ZVRvU2V0LCBwcm9wcyk7XG4gICAgfSk7XG59O1xudmFyIGNyZWF0ZVBvc2VTZXR0ZXIgPSBmdW5jdGlvbiAoc2V0dGVyUHJvcHMpIHtcbiAgICB2YXIgc3RhdGUgPSBzZXR0ZXJQcm9wcy5zdGF0ZSxcbiAgICAgICAgcG9zZXMgPSBzZXR0ZXJQcm9wcy5wb3NlcyxcbiAgICAgICAgc3RhcnRBY3Rpb24gPSBzZXR0ZXJQcm9wcy5zdGFydEFjdGlvbixcbiAgICAgICAgc3RvcEFjdGlvbiA9IHNldHRlclByb3BzLnN0b3BBY3Rpb24sXG4gICAgICAgIGdldEluc3RhbnRUcmFuc2l0aW9uID0gc2V0dGVyUHJvcHMuZ2V0SW5zdGFudFRyYW5zaXRpb24sXG4gICAgICAgIGFkZEFjdGlvbkRlbGF5ID0gc2V0dGVyUHJvcHMuYWRkQWN0aW9uRGVsYXksXG4gICAgICAgIGdldFRyYW5zaXRpb25Qcm9wcyA9IHNldHRlclByb3BzLmdldFRyYW5zaXRpb25Qcm9wcyxcbiAgICAgICAgcmVzb2x2ZVRhcmdldCA9IHNldHRlclByb3BzLnJlc29sdmVUYXJnZXQsXG4gICAgICAgIHRyYW5zZm9ybVBvc2UgPSBzZXR0ZXJQcm9wcy50cmFuc2Zvcm1Qb3NlLFxuICAgICAgICBwb3NlUHJpb3JpdHkgPSBzZXR0ZXJQcm9wcy5wb3NlUHJpb3JpdHksXG4gICAgICAgIGNvbnZlcnRUcmFuc2l0aW9uRGVmaW5pdGlvbiA9IHNldHRlclByb3BzLmNvbnZlcnRUcmFuc2l0aW9uRGVmaW5pdGlvbixcbiAgICAgICAgc2V0VmFsdWUgPSBzZXR0ZXJQcm9wcy5zZXRWYWx1ZSxcbiAgICAgICAgc2V0VmFsdWVOYXRpdmUgPSBzZXR0ZXJQcm9wcy5zZXRWYWx1ZU5hdGl2ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQsIG5leHRQcm9wcywgcHJvcGFnYXRlKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbmV4dFByb3BzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BhZ2F0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBwcm9wYWdhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHN0YXRlLmNoaWxkcmVuLFxuICAgICAgICAgICAgdmFsdWVzID0gc3RhdGUudmFsdWVzLFxuICAgICAgICAgICAgcHJvcHMgPSBzdGF0ZS5wcm9wcyxcbiAgICAgICAgICAgIGFjdGl2ZUFjdGlvbnMgPSBzdGF0ZS5hY3RpdmVBY3Rpb25zLFxuICAgICAgICAgICAgYWN0aXZlUG9zZXMgPSBzdGF0ZS5hY3RpdmVQb3NlcztcbiAgICAgICAgdmFyIF9hID0gbmV4dFByb3BzLmRlbGF5LFxuICAgICAgICAgICAgZGVsYXkgPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hO1xuICAgICAgICB2YXIgaGFzQ2hpbGRyZW4gPSBjaGlsZHJlbi5zaXplO1xuICAgICAgICB2YXIgYmFzZVRyYW5zaXRpb25Qcm9wcyA9IF9fYXNzaWduKHt9LCBwcm9wcywgbmV4dFByb3BzKTtcbiAgICAgICAgdmFyIG5leHRQb3NlID0gcG9zZXNbbmV4dF07XG4gICAgICAgIHZhciBnZXRDaGlsZEFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzQ2hpbGRyZW4gJiYgcHJvcGFnYXRlID8gc3RhcnRDaGlsZEFuaW1hdGlvbnMoY2hpbGRyZW4sIG5leHQsIG5leHRQb3NlLCBiYXNlVHJhbnNpdGlvblByb3BzKSA6IFtdO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0UGFyZW50QW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghbmV4dFBvc2UpIHJldHVybiBbXTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1Qb3NlKSBuZXh0UG9zZSA9IHRyYW5zZm9ybVBvc2UobmV4dFBvc2UsIG5leHQsIHN0YXRlKTtcbiAgICAgICAgICAgIHZhciBwcmVUcmFuc2l0aW9uID0gbmV4dFBvc2UucHJlVHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBnZXRUcmFuc2l0aW9uID0gbmV4dFBvc2UudHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBhcHBseUF0U3RhcnQgPSBuZXh0UG9zZS5hcHBseUF0U3RhcnQsXG4gICAgICAgICAgICAgICAgYXBwbHlBdEVuZCA9IG5leHRQb3NlLmFwcGx5QXRFbmQ7XG4gICAgICAgICAgICBpZiAocHJlVHJhbnNpdGlvbikgcHJlVHJhbnNpdGlvbihiYXNlVHJhbnNpdGlvblByb3BzKTtcbiAgICAgICAgICAgIGlmIChhcHBseUF0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICBhcHBseVZhbHVlcyhhcHBseUF0U3RhcnQsIHZhbHVlcywgYmFzZVRyYW5zaXRpb25Qcm9wcywgc2V0VmFsdWUsIHNldFZhbHVlTmF0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhbmltYXRpb25zID0gT2JqZWN0LmtleXMoZ2V0UG9zZVZhbHVlcyhuZXh0UG9zZSkpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlUG9zZXMgPSBhY3RpdmVQb3Nlcy5oYXMoa2V5KSA/IGFjdGl2ZVBvc2VzLmdldChrZXkpIDogKGFjdGl2ZVBvc2VzLnNldChrZXksIFtdKSwgYWN0aXZlUG9zZXMuZ2V0KGtleSkpO1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0luZGV4ID0gdmFsdWVQb3Nlcy5pbmRleE9mKG5leHQpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0luZGV4ICE9PSAtMSkgdmFsdWVQb3Nlcy5zcGxpY2UoZXhpc3RpbmdJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHByaW9yaXR5ID0gcG9zZVByaW9yaXR5ID8gcG9zZVByaW9yaXR5LmluZGV4T2YobmV4dCkgOiAwO1xuICAgICAgICAgICAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IHByaW9yaXR5IDw9IDAgPyAwIDogZmluZEluc2VydGlvbkluZGV4KHZhbHVlUG9zZXMsIHBvc2VQcmlvcml0eSwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIHZhbHVlUG9zZXMuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCBuZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0aW9uSW5kZXggPT09IDAgPyBuZXcgUHJvbWlzZShmdW5jdGlvbiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvblByb3BzID0gX19hc3NpZ24oe30sIGJhc2VUcmFuc2l0aW9uUHJvcHMsIHsga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHZhbHVlLCByZXNvbHZlUHJvcChuZXh0UG9zZVtrZXldLCB0cmFuc2l0aW9uUHJvcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUFjdGlvbnMuaGFzKGtleSkpIHN0b3BBY3Rpb24oYWN0aXZlQWN0aW9ucy5nZXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlVHJhbnNpdGlvblByb3BzID0gX19hc3NpZ24oeyB0bzogdGFyZ2V0IH0sIHRyYW5zaXRpb25Qcm9wcywgZ2V0VHJhbnNpdGlvblByb3BzKHZhbHVlLCB0YXJnZXQsIHRyYW5zaXRpb25Qcm9wcykpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHJlc29sdmVUcmFuc2l0aW9uKGdldFRyYW5zaXRpb24sIGtleSwgdmFsdWUsIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMsIGNvbnZlcnRUcmFuc2l0aW9uRGVmaW5pdGlvbiwgZ2V0SW5zdGFudFRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zZURlbGF5ID0gcmVzb2x2ZVByb3AobmV4dFBvc2UuZGVsYXksIHRyYW5zaXRpb25Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxheSB8fCBwb3NlRGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gPSBhZGRBY3Rpb25EZWxheShkZWxheSB8fCBwb3NlRGVsYXksIHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUFjdGlvbnMuc2V0KGtleSwgc3RhcnRBY3Rpb24odmFsdWUsIHRyYW5zaXRpb24sIGNvbXBsZXRlKSk7XG4gICAgICAgICAgICAgICAgfSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5QXRFbmQgPyBbUHJvbWlzZS5hbGwoYW5pbWF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlWYWx1ZXMoYXBwbHlBdEVuZCwgdmFsdWVzLCBiYXNlVHJhbnNpdGlvblByb3BzLCBzZXRWYWx1ZSwgc2V0VmFsdWVOYXRpdmUpO1xuICAgICAgICAgICAgfSldIDogYW5pbWF0aW9ucztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5leHRQb3NlICYmIGhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZVByb3AobmV4dFBvc2UuYmVmb3JlQ2hpbGRyZW4sIGJhc2VUcmFuc2l0aW9uUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGdldFBhcmVudEFuaW1hdGlvbnMoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChnZXRDaGlsZEFuaW1hdGlvbnMoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc29sdmVQcm9wKG5leHRQb3NlLmFmdGVyQ2hpbGRyZW4sIGJhc2VUcmFuc2l0aW9uUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGdldENoaWxkQW5pbWF0aW9ucygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGdldFBhcmVudEFuaW1hdGlvbnMoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGdldFBhcmVudEFuaW1hdGlvbnMoKS5jb25jYXQoZ2V0Q2hpbGRBbmltYXRpb25zKCkpKTtcbiAgICB9O1xufTtcblxudmFyIERFRkFVTFRfSU5JVElBTF9QT1NFID0gJ2luaXQnO1xudmFyIGlzU2NhbGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5pbmNsdWRlcygnc2NhbGUnKTtcbn07XG52YXIgZGVmYXVsdFJlYWRWYWx1ZUZyb21Tb3VyY2UgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGlzU2NhbGUoa2V5KSA/IDEgOiAwO1xufTtcbnZhciBnZXRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiAocG9zZXMsIGtleSwgaW5pdGlhbFBvc2UsIHByb3BzLCByZWFkVmFsdWVGcm9tU291cmNlLCBhY3RpdmVQb3Nlcykge1xuICAgIGlmIChyZWFkVmFsdWVGcm9tU291cmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmVhZFZhbHVlRnJvbVNvdXJjZSA9IGRlZmF1bHRSZWFkVmFsdWVGcm9tU291cmNlO1xuICAgIH1cbiAgICB2YXIgcG9zZXNUb1NlYXJjaCA9IEFycmF5LmlzQXJyYXkoaW5pdGlhbFBvc2UpID8gaW5pdGlhbFBvc2UgOiBbaW5pdGlhbFBvc2VdO1xuICAgIHBvc2VzVG9TZWFyY2gucHVzaChERUZBVUxUX0lOSVRJQUxfUE9TRSk7XG4gICAgdmFyIHBvc2UgPSBwb3Nlc1RvU2VhcmNoLmZpbHRlcihCb29sZWFuKS5maW5kKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBwb3Nlc1tuYW1lXSAmJiBwb3Nlc1tuYW1lXVtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgYWN0aXZlUG9zZXMuc2V0KGtleSwgW3Bvc2UgfHwgREVGQVVMVF9JTklUSUFMX1BPU0VdKTtcbiAgICByZXR1cm4gcG9zZSA/IHJlc29sdmVQcm9wKHBvc2VzW3Bvc2VdW2tleV0sIHByb3BzKSA6IHJlYWRWYWx1ZUZyb21Tb3VyY2Uoa2V5LCBwcm9wcyk7XG59O1xudmFyIGNyZWF0ZVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMsIF9hKSB7XG4gICAgdmFyIHVzZXJTZXRWYWx1ZXMgPSBfYS51c2VyU2V0VmFsdWVzLFxuICAgICAgICBjcmVhdGVWYWx1ZSA9IF9hLmNyZWF0ZVZhbHVlLFxuICAgICAgICBjb252ZXJ0VmFsdWUgPSBfYS5jb252ZXJ0VmFsdWUsXG4gICAgICAgIHJlYWRWYWx1ZUZyb21Tb3VyY2UgPSBfYS5yZWFkVmFsdWVGcm9tU291cmNlLFxuICAgICAgICBpbml0aWFsUG9zZSA9IF9hLmluaXRpYWxQb3NlLFxuICAgICAgICBwb3NlcyA9IF9hLnBvc2VzLFxuICAgICAgICBhY3RpdmVQb3NlcyA9IF9hLmFjdGl2ZVBvc2VzLFxuICAgICAgICBwcm9wcyA9IF9hLnByb3BzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh2YWx1ZXMuaGFzKGtleSkpIHJldHVybjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAodXNlclNldFZhbHVlcyAmJiB1c2VyU2V0VmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJ0VmFsdWUodXNlclNldFZhbHVlc1trZXldLCBrZXksIHByb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbml0VmFsdWUgPSBnZXRJbml0aWFsVmFsdWUocG9zZXMsIGtleSwgaW5pdGlhbFBvc2UsIHByb3BzLCByZWFkVmFsdWVGcm9tU291cmNlLCBhY3RpdmVQb3Nlcyk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNyZWF0ZVZhbHVlKGluaXRWYWx1ZSwga2V5LCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnNldChrZXksIHZhbHVlKTtcbiAgICB9O1xufTtcbnZhciBzY3JhcGVWYWx1ZXNGcm9tUG9zZSA9IGZ1bmN0aW9uICh2YWx1ZXMsIHByb3BzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHBvc2UgPSBwcm9wcy5wb3Nlc1trZXldO1xuICAgICAgICBPYmplY3Qua2V5cyhnZXRQb3NlVmFsdWVzKHBvc2UpKS5mb3JFYWNoKGNyZWF0ZVZhbHVlcyh2YWx1ZXMsIHByb3BzKSk7XG4gICAgfTtcbn07XG52YXIgZ2V0QW5jZXN0b3JWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIGZyb21QYXJlbnQsIGFuY2VzdG9ycykge1xuICAgIGlmIChmcm9tUGFyZW50ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhbmNlc3RvcnNbMF0gJiYgYW5jZXN0b3JzWzBdLnZhbHVlcy5nZXQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZm91bmRBbmNlc3RvciA9IGFuY2VzdG9ycy5maW5kKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gX2EubGFiZWw7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWwgPT09IGZyb21QYXJlbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmRBbmNlc3RvciAmJiBmb3VuZEFuY2VzdG9yLnZhbHVlcy5nZXQoa2V5KTtcbiAgICB9XG59O1xudmFyIGJpbmRQYXNzaXZlVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcywgX2EpIHtcbiAgICB2YXIgcGFzc2l2ZSA9IF9hLnBhc3NpdmUsXG4gICAgICAgIGFuY2VzdG9yVmFsdWVzID0gX2EuYW5jZXN0b3JWYWx1ZXMsXG4gICAgICAgIGNyZWF0ZVZhbHVlID0gX2EuY3JlYXRlVmFsdWUsXG4gICAgICAgIHJlYWRWYWx1ZSA9IF9hLnJlYWRWYWx1ZSxcbiAgICAgICAgcHJvcHMgPSBfYS5wcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX2EgPSBwYXNzaXZlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZUtleSA9IF9hWzBdLFxuICAgICAgICAgICAgcGFzc2l2ZVByb3BzID0gX2FbMV0sXG4gICAgICAgICAgICBmcm9tUGFyZW50ID0gX2FbMl07XG4gICAgICAgIHZhciB2YWx1ZVRvQmluZCA9IGZyb21QYXJlbnQgJiYgYW5jZXN0b3JWYWx1ZXMubGVuZ3RoID8gZ2V0QW5jZXN0b3JWYWx1ZSh2YWx1ZUtleSwgZnJvbVBhcmVudCwgYW5jZXN0b3JWYWx1ZXMpIDogdmFsdWVzLmhhcyh2YWx1ZUtleSkgPyB2YWx1ZXMuZ2V0KHZhbHVlS2V5KSA6IGZhbHNlO1xuICAgICAgICBpZiAoIXZhbHVlVG9CaW5kKSByZXR1cm47XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGNyZWF0ZVZhbHVlKHJlYWRWYWx1ZSh2YWx1ZVRvQmluZCksIGtleSwgcHJvcHMsIHtcbiAgICAgICAgICAgIHBhc3NpdmVQYXJlbnRLZXk6IHZhbHVlS2V5LFxuICAgICAgICAgICAgcGFzc2l2ZVBhcmVudDogdmFsdWVUb0JpbmQsXG4gICAgICAgICAgICBwYXNzaXZlUHJvcHM6IHBhc3NpdmVQcm9wc1xuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWVzLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICB9O1xufTtcbnZhciBjcmVhdGVWYWx1ZU1hcCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBwb3NlcyA9IHByb3BzLnBvc2VzLFxuICAgICAgICBwYXNzaXZlID0gcHJvcHMucGFzc2l2ZTtcbiAgICB2YXIgdmFsdWVzID0gbmV3IE1hcCgpO1xuICAgIE9iamVjdC5rZXlzKHBvc2VzKS5mb3JFYWNoKHNjcmFwZVZhbHVlc0Zyb21Qb3NlKHZhbHVlcywgcHJvcHMpKTtcbiAgICBpZiAocGFzc2l2ZSkgT2JqZWN0LmtleXMocGFzc2l2ZSkuZm9yRWFjaChiaW5kUGFzc2l2ZVZhbHVlcyh2YWx1ZXMsIHByb3BzKSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbnZhciBhcHBseURlZmF1bHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKHBvc2UsIGtleSwgZGVmYXVsdFRyYW5zaXRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXNzaWduKHt9LCBwb3NlLCB7IHRyYW5zaXRpb246IGRlZmF1bHRUcmFuc2l0aW9ucy5oYXMoa2V5KSA/IGRlZmF1bHRUcmFuc2l0aW9ucy5nZXQoa2V5KSA6IGRlZmF1bHRUcmFuc2l0aW9ucy5nZXQoJ2RlZmF1bHQnKSB9KTtcbn07XG52YXIgZ2VuZXJhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uIChwb3NlcywgZGVmYXVsdFRyYW5zaXRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMocG9zZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcG9zZSA9IHBvc2VzW2tleV07XG4gICAgICAgIGludmFyaWFudCh0eXBlb2YgcG9zZSA9PT0gJ29iamVjdCcsIFwiUG9zZSAnXCIgKyBrZXkgKyBcIicgaXMgb2YgaW52YWxpZCB0eXBlLiBBbGwgcG9zZXMgc2hvdWxkIGJlIG9iamVjdHMuXCIpO1xuICAgICAgICBwb3Nlc1trZXldID0gcG9zZS50cmFuc2l0aW9uICE9PSB1bmRlZmluZWQgPyBwb3NlIDogYXBwbHlEZWZhdWx0VHJhbnNpdGlvbihwb3NlLCBrZXksIGRlZmF1bHRUcmFuc2l0aW9ucyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvc2VzO1xufTtcblxudmFyIHNvcnRCeVJldmVyc2VQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eU9yZGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBhUCA9IHByaW9yaXR5T3JkZXIuaW5kZXhPZihhKTtcbiAgICAgICAgdmFyIGJQID0gcHJpb3JpdHlPcmRlci5pbmRleE9mKGIpO1xuICAgICAgICBpZiAoYVAgPT09IC0xICYmIGJQICE9PSAtMSkgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYVAgIT09IC0xICYmIGJQID09PSAtMSkgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiBhUCAtIGJQO1xuICAgIH07XG59O1xuXG52YXIgcG9zZUZhY3RvcnkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZ2V0RGVmYXVsdFByb3BzID0gX2EuZ2V0RGVmYXVsdFByb3BzLFxuICAgICAgICBkZWZhdWx0VHJhbnNpdGlvbnMgPSBfYS5kZWZhdWx0VHJhbnNpdGlvbnMsXG4gICAgICAgIGJpbmRPbkNoYW5nZSA9IF9hLmJpbmRPbkNoYW5nZSxcbiAgICAgICAgc3RhcnRBY3Rpb24gPSBfYS5zdGFydEFjdGlvbixcbiAgICAgICAgc3RvcEFjdGlvbiA9IF9hLnN0b3BBY3Rpb24sXG4gICAgICAgIHJlYWRWYWx1ZSA9IF9hLnJlYWRWYWx1ZSxcbiAgICAgICAgcmVhZFZhbHVlRnJvbVNvdXJjZSA9IF9hLnJlYWRWYWx1ZUZyb21Tb3VyY2UsXG4gICAgICAgIHJlc29sdmVUYXJnZXQgPSBfYS5yZXNvbHZlVGFyZ2V0LFxuICAgICAgICBzZXRWYWx1ZSA9IF9hLnNldFZhbHVlLFxuICAgICAgICBzZXRWYWx1ZU5hdGl2ZSA9IF9hLnNldFZhbHVlTmF0aXZlLFxuICAgICAgICBjcmVhdGVWYWx1ZSA9IF9hLmNyZWF0ZVZhbHVlLFxuICAgICAgICBjb252ZXJ0VmFsdWUgPSBfYS5jb252ZXJ0VmFsdWUsXG4gICAgICAgIGdldEluc3RhbnRUcmFuc2l0aW9uID0gX2EuZ2V0SW5zdGFudFRyYW5zaXRpb24sXG4gICAgICAgIGdldFRyYW5zaXRpb25Qcm9wcyA9IF9hLmdldFRyYW5zaXRpb25Qcm9wcyxcbiAgICAgICAgYWRkQWN0aW9uRGVsYXkgPSBfYS5hZGRBY3Rpb25EZWxheSxcbiAgICAgICAgc2VsZWN0VmFsdWVUb1JlYWQgPSBfYS5zZWxlY3RWYWx1ZVRvUmVhZCxcbiAgICAgICAgY29udmVydFRyYW5zaXRpb25EZWZpbml0aW9uID0gX2EuY29udmVydFRyYW5zaXRpb25EZWZpbml0aW9uLFxuICAgICAgICB0cmFuc2Zvcm1Qb3NlID0gX2EudHJhbnNmb3JtUG9zZSxcbiAgICAgICAgcG9zZVByaW9yaXR5ID0gX2EucG9zZVByaW9yaXR5LFxuICAgICAgICBleHRlbmRBUEkgPSBfYS5leHRlbmRBUEk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdmFyIHBhcmVudFZhbHVlcyA9IGNvbmZpZy5wYXJlbnRWYWx1ZXMsXG4gICAgICAgICAgICBfYSA9IGNvbmZpZy5hbmNlc3RvclZhbHVlcyxcbiAgICAgICAgICAgIGFuY2VzdG9yVmFsdWVzID0gX2EgPT09IHZvaWQgMCA/IFtdIDogX2E7XG4gICAgICAgIGlmIChwYXJlbnRWYWx1ZXMpIGFuY2VzdG9yVmFsdWVzLnVuc2hpZnQoeyB2YWx1ZXM6IHBhcmVudFZhbHVlcyB9KTtcbiAgICAgICAgdmFyIGFjdGl2ZUFjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBhY3RpdmVQb3NlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgcG9zZXMgPSBnZW5lcmF0ZVRyYW5zaXRpb25zKHNlbGVjdFBvc2VzKGNvbmZpZyksIGRlZmF1bHRUcmFuc2l0aW9ucyk7XG4gICAgICAgIHZhciBwcm9wcyA9IGNvbmZpZy5wcm9wcyB8fCB7fTtcbiAgICAgICAgaWYgKGdldERlZmF1bHRQcm9wcykgcHJvcHMgPSBfX2Fzc2lnbih7fSwgcHJvcHMsIGdldERlZmF1bHRQcm9wcyhjb25maWcpKTtcbiAgICAgICAgdmFyIHBhc3NpdmUgPSBjb25maWcucGFzc2l2ZSxcbiAgICAgICAgICAgIHVzZXJTZXRWYWx1ZXMgPSBjb25maWcudmFsdWVzLFxuICAgICAgICAgICAgX2IgPSBjb25maWcuaW5pdGlhbFBvc2UsXG4gICAgICAgICAgICBpbml0aWFsUG9zZSA9IF9iID09PSB2b2lkIDAgPyBERUZBVUxUX0lOSVRJQUxfUE9TRSA6IF9iO1xuICAgICAgICB2YXIgdmFsdWVzID0gY3JlYXRlVmFsdWVNYXAoe1xuICAgICAgICAgICAgcG9zZXM6IHBvc2VzLFxuICAgICAgICAgICAgcGFzc2l2ZTogcGFzc2l2ZSxcbiAgICAgICAgICAgIGFuY2VzdG9yVmFsdWVzOiBhbmNlc3RvclZhbHVlcyxcbiAgICAgICAgICAgIHJlYWRWYWx1ZTogcmVhZFZhbHVlLFxuICAgICAgICAgICAgY3JlYXRlVmFsdWU6IGNyZWF0ZVZhbHVlLFxuICAgICAgICAgICAgY29udmVydFZhbHVlOiBjb252ZXJ0VmFsdWUsXG4gICAgICAgICAgICByZWFkVmFsdWVGcm9tU291cmNlOiByZWFkVmFsdWVGcm9tU291cmNlLFxuICAgICAgICAgICAgdXNlclNldFZhbHVlczogdXNlclNldFZhbHVlcyxcbiAgICAgICAgICAgIGluaXRpYWxQb3NlOiBpbml0aWFsUG9zZSxcbiAgICAgICAgICAgIGFjdGl2ZVBvc2VzOiBhY3RpdmVQb3NlcyxcbiAgICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgYWN0aXZlQWN0aW9uczogYWN0aXZlQWN0aW9ucyxcbiAgICAgICAgICAgIGFjdGl2ZVBvc2VzOiBhY3RpdmVQb3NlcyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkNoYW5nZSA9IGNvbmZpZy5vbkNoYW5nZTtcbiAgICAgICAgaWYgKG9uQ2hhbmdlKSBPYmplY3Qua2V5cyhvbkNoYW5nZSkuZm9yRWFjaChiaW5kT25DaGFuZ2UodmFsdWVzLCBvbkNoYW5nZSkpO1xuICAgICAgICB2YXIgc2V0ID0gY3JlYXRlUG9zZVNldHRlcih7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBwb3NlczogcG9zZXMsXG4gICAgICAgICAgICBnZXRJbnN0YW50VHJhbnNpdGlvbjogZ2V0SW5zdGFudFRyYW5zaXRpb24sXG4gICAgICAgICAgICBnZXRUcmFuc2l0aW9uUHJvcHM6IGdldFRyYW5zaXRpb25Qcm9wcyxcbiAgICAgICAgICAgIGNvbnZlcnRUcmFuc2l0aW9uRGVmaW5pdGlvbjogY29udmVydFRyYW5zaXRpb25EZWZpbml0aW9uLFxuICAgICAgICAgICAgc2V0VmFsdWU6IHNldFZhbHVlLFxuICAgICAgICAgICAgc2V0VmFsdWVOYXRpdmU6IHNldFZhbHVlTmF0aXZlLFxuICAgICAgICAgICAgc3RhcnRBY3Rpb246IHN0YXJ0QWN0aW9uLFxuICAgICAgICAgICAgc3RvcEFjdGlvbjogc3RvcEFjdGlvbixcbiAgICAgICAgICAgIHJlc29sdmVUYXJnZXQ6IHJlc29sdmVUYXJnZXQsXG4gICAgICAgICAgICBhZGRBY3Rpb25EZWxheTogYWRkQWN0aW9uRGVsYXksXG4gICAgICAgICAgICB0cmFuc2Zvcm1Qb3NlOiB0cmFuc2Zvcm1Qb3NlLFxuICAgICAgICAgICAgcG9zZVByaW9yaXR5OiBwb3NlUHJpb3JpdHlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBoYXMgPSBmdW5jdGlvbiAocG9zZU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXBvc2VzW3Bvc2VOYW1lXTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFwaSA9IHtcbiAgICAgICAgICAgIHNldDogc2V0LFxuICAgICAgICAgICAgdW5zZXQ6IGZ1bmN0aW9uIChwb3NlTmFtZSwgcG9zZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2VzVG9TZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBhY3RpdmVQb3Nlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZVBvc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NlSW5kZXggPSB2YWx1ZVBvc2VzLmluZGV4T2YocG9zZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zZUluZGV4ID09PSAtMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBvc2UgPSB2YWx1ZVBvc2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVBvc2VzLnNwbGljZShwb3NlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFBvc2UgPSB2YWx1ZVBvc2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFBvc2UgPT09IGN1cnJlbnRQb3NlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3Nlc1RvU2V0LmluZGV4T2YobmV4dFBvc2UpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zZXNUb1NldC5wdXNoKG5leHRQb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25zVG9SZXNvbHZlID0gcG9zZXNUb1NldC5zb3J0KHNvcnRCeVJldmVyc2VQcmlvcml0eShwb3NlUHJpb3JpdHkpKS5tYXAoZnVuY3Rpb24gKHBvc2VUb1NldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0KHBvc2VUb1NldCwgcG9zZVByb3BzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbnNUb1Jlc29sdmUucHVzaChjaGlsZC51bnNldChwb3NlTmFtZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zVG9SZXNvbHZlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICh2YWx1ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVOYW1lID8gc2VsZWN0VmFsdWVUb1JlYWQodmFsdWVzLmdldCh2YWx1ZU5hbWUpKSA6IHNlbGVjdEFsbFZhbHVlcyh2YWx1ZXMsIHNlbGVjdFZhbHVlVG9SZWFkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXM6IGhhcyxcbiAgICAgICAgICAgIHNldFByb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUucHJvcHMgPSBfX2Fzc2lnbih7fSwgc3RhdGUucHJvcHMsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYWRkQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZENvbmZpZywgZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGZhY3RvcnkoX19hc3NpZ24oeyBpbml0aWFsUG9zZTogaW5pdGlhbFBvc2UgfSwgY2hpbGRDb25maWcsIHsgYW5jZXN0b3JWYWx1ZXM6IFt7IGxhYmVsOiBjb25maWcubGFiZWwsIHZhbHVlczogdmFsdWVzIH1dLmNvbmNhdChhbmNlc3RvclZhbHVlcykgfSkpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4uZGVsZXRlKGNoaWxkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhckNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5jbGVhcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVBY3Rpb25zLmZvckVhY2goc3RvcEFjdGlvbik7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZEFQSShhcGksIHN0YXRlLCBjb25maWcpO1xuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwb3NlRmFjdG9yeTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjUuMFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcbnZhciBzY2hlZHVsZSA9IHJlcXVpcmUoJ3NjaGVkdWxlJyk7XG52YXIgdHJhY2tpbmcgPSByZXF1aXJlKCdzY2hlZHVsZS90cmFja2luZycpO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBSZWx5aW5nIG9uIHRoZSBgaW52YXJpYW50KClgIGltcGxlbWVudGF0aW9uIGxldHMgdXNcbi8vIHByZXNlcnZlIHRoZSBmb3JtYXQgYW5kIHBhcmFtcyBpbiB0aGUgd3d3IGJ1aWxkcy5cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW50aW50dWl0aXZlLCB0aG91Z2gsIGJlY2F1c2UgZXZlbiB0aG91Z2ggUmVhY3QgaGFzIGNhdWdodCB0aGUgZXJyb3IsIGZyb21cbiAgLy8gdGhlIGRldmVsb3BlcidzIHBlcnNwZWN0aXZlLCB0aGUgZXJyb3IgaXMgdW5jYXVnaHQuXG4gIC8vXG4gIC8vIFRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvciwgd2UgZG9uJ3QgdXNlIGFcbiAgLy8gdHJ5LWNhdGNoIGluIERFVi4gSW5zdGVhZCwgd2Ugc3luY2hyb25vdXNseSBkaXNwYXRjaCBhIGZha2UgZXZlbnQgdG8gYSBmYWtlXG4gIC8vIERPTSBub2RlLCBhbmQgY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayBmcm9tIGluc2lkZSBhbiBldmVudCBoYW5kbGVyXG4gIC8vIGZvciB0aGF0IGZha2UgZXZlbnQuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MsIHRoZSBlcnJvciBpcyBcImNhcHR1cmVkXCIgdXNpbmdcbiAgLy8gYSBnbG9iYWwgZXZlbnQgaGFuZGxlci4gQnV0IGJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbnMgaW4gYSBkaWZmZXJlbnRcbiAgLy8gZXZlbnQgbG9vcCBjb250ZXh0LCBpdCBkb2VzIG5vdCBpbnRlcnJ1cHQgdGhlIG5vcm1hbCBwcm9ncmFtIGZsb3cuXG4gIC8vIEVmZmVjdGl2ZWx5LCB0aGlzIGdpdmVzIHVzIHRyeS1jYXRjaCBiZWhhdmlvciB3aXRob3V0IGFjdHVhbGx5IHVzaW5nXG4gIC8vIHRyeS1jYXRjaC4gTmVhdCFcblxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIHZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gSWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdCB3ZSBrbm93IGZvciBzdXJlIHdlIHdpbGwgY3Jhc2ggaW4gdGhpcyBtZXRob2RcbiAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzQ4MlxuICAgICAgLy8gU28gd2UgcHJlZW1wdGl2ZWx5IHRocm93IHdpdGggYSBiZXR0ZXIgbWVzc2FnZSBpbnN0ZWFkLlxuICAgICAgISh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCBkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgc2NoZWR1bGVzIGFuIHVwZGF0ZSBmcm9tIGFuIGFzeW5jaHJvbm91cyBjYWxsYmFjaywgYnV0IHRoZSB0ZXN0IGhhcyBhbHJlYWR5IGZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCB0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgY2FuY2VsZWQgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YCksIG9yIHlvdSBjYW4gY2hhbmdlIHRoZSB0ZXN0IGl0c2VsZiB0byBiZSBhc3luY2hyb25vdXMuJykgOiB2b2lkIDA7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG5cbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7XG5cbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVzZXQgaXRcbiAgICAgIC8vIGR1cmluZyB0aGUgY2FsbGJhY2sgdG8gbGV0IHVzZXIgY29kZSBhY2Nlc3Mgd2luZG93LmV2ZW50IGluIHRoZVxuICAgICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LlxuICAgICAgdmFyIHdpbmRvd0V2ZW50ID0gd2luZG93LmV2ZW50O1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5ldmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpKSB7XG4gICAgICAgICAgd2luZG93LmV2ZW50ID0gd2luZG93RXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuICAgICAgdmFyIGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVdpbmRvd0Vycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBTb21lIG90aGVyIGVycm9yIGhhbmRsZXIgaGFzIHByZXZlbnRlZCBkZWZhdWx0LlxuICAgICAgICAgIC8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4gICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHtcbiAgICAgICAgICAgICAgLy8gSWdub3JlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgKG5hbWUgPyBuYW1lIDogJ2ludm9rZWd1YXJkZWRjYWxsYmFjaycpO1xuXG4gICAgICAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlV2luZG93RXJyb3IpO1xuICAgIH07XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsO1xuXG4vLyBVc2VkIGJ5IEZpYmVyIHRvIHNpbXVsYXRlIGEgdHJ5LWNhdGNoLlxudmFyIGhhc0Vycm9yID0gZmFsc2U7XG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4vLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxudmFyIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xudmFyIHJldGhyb3dFcnJvciA9IG51bGw7XG5cbnZhciByZXBvcnRlciA9IHtcbiAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGhhc0Vycm9yID0gZmFsc2U7XG4gIGNhdWdodEVycm9yID0gbnVsbDtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxLmFwcGx5KHJlcG9ydGVyLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhbWUgYXMgaW52b2tlR3VhcmRlZENhbGxiYWNrLCBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gZXJyb3IsIGl0IHN0b3Jlc1xuICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICogVE9ETzogU2VlIGlmIGNhdWdodEVycm9yIGFuZCByZXRocm93RXJyb3IgY2FuIGJlIHVuaWZpZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgIGlmICghaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICBoYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgcmV0aHJvd0Vycm9yID0gZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gKi9cbmZ1bmN0aW9uIHJldGhyb3dDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IHJldGhyb3dFcnJvcjtcbiAgICBoYXNSZXRocm93RXJyb3IgPSBmYWxzZTtcbiAgICByZXRocm93RXJyb3IgPSBudWxsO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NhdWdodEVycm9yKCkge1xuICByZXR1cm4gaGFzRXJyb3I7XG59XG5cbmZ1bmN0aW9uIGNsZWFyQ2F1Z2h0RXJyb3IoKSB7XG4gIGlmIChoYXNFcnJvcikge1xuICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfSBlbHNlIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgd2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nV2l0aG91dFN0YWNrKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBfY29uc29sZTtcblxuICAgICAgdmFyIHN0cmluZ0FyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgICAgfSk7XG4gICAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS5lcnJvci5hcHBseShfY29uc29sZSwgWydXYXJuaW5nOiAnICsgZm9ybWF0XS5jb25jYXQoc3RyaW5nQXJncykpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG52YXIgd2FybmluZ1dpdGhvdXRTdGFjayQxID0gd2FybmluZ1dpdGhvdXRTdGFjaztcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBzZXRDb21wb25lbnRUcmVlKGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGVJbXBsLCBnZXRJbnN0YW5jZUZyb21Ob2RlSW1wbCwgZ2V0Tm9kZUZyb21JbnN0YW5jZUltcGwpIHtcbiAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGVJbXBsO1xuICBnZXRJbnN0YW5jZUZyb21Ob2RlID0gZ2V0SW5zdGFuY2VGcm9tTm9kZUltcGw7XG4gIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBnZXROb2RlRnJvbUluc3RhbmNlSW1wbDtcbiAge1xuICAgICEoZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V2ZW50UGx1Z2luVXRpbHMuc2V0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSB2b2lkIDA7XG57XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgIShpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4pID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICB9XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayBpbnZva2VkIHdpdGggZWFjaCBlbGVtZW50IG9yIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7P30gW3Njb3BlXSBTY29wZSB1c2VkIGFzIGB0aGlzYCBpbiBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgICByZXR1cm4gISEocHJvcHMuZGlzYWJsZWQgJiYgaXNJbnRlcmFjdGl2ZSh0eXBlKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICovXG52YXIgaW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgbGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gIHZhciBzdGF0ZU5vZGUgPSBpbnN0LnN0YXRlTm9kZTtcbiAgaWYgKCFzdGF0ZU5vZGUpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7XG4gIGlmICghcHJvcHMpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0LnR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gICEoIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gKlxuICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRzSW5CYXRjaChldmVudHMsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnRzICE9PSBudWxsKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cblxuICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbiAgaWYgKCFwcm9jZXNzaW5nRXZlbnRRdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzaW11bGF0ZWQpIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XG4gIH1cbiAgISFldmVudFF1ZXVlID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nIGFuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG4gIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICByZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxuZnVuY3Rpb24gcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50c0luQmF0Y2goZXZlbnRzLCBmYWxzZSk7XG59XG5cbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMDtcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50TGF6eSA9IDE7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAyO1xudmFyIENsYXNzQ29tcG9uZW50TGF6eSA9IDM7XG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDQ7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb25hbCBvciBjbGFzc1xudmFyIEhvc3RSb290ID0gNTsgLy8gUm9vdCBvZiBhIGhvc3QgdHJlZS4gQ291bGQgYmUgbmVzdGVkIGluc2lkZSBhbm90aGVyIG5vZGUuXG52YXIgSG9zdFBvcnRhbCA9IDY7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG52YXIgSG9zdENvbXBvbmVudCA9IDc7XG52YXIgSG9zdFRleHQgPSA4O1xudmFyIEZyYWdtZW50ID0gOTtcbnZhciBNb2RlID0gMTA7XG52YXIgQ29udGV4dENvbnN1bWVyID0gMTE7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTI7XG52YXIgRm9yd2FyZFJlZiA9IDEzO1xudmFyIEZvcndhcmRSZWZMYXp5ID0gMTQ7XG52YXIgUHJvZmlsZXIgPSAxNTtcbnZhciBQbGFjZWhvbGRlckNvbXBvbmVudCA9IDE2O1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZShob3N0SW5zdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdCkge1xuICAgIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UkMShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH1cblxuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gIGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJyk7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShub2RlKSB7XG4gIHJldHVybiBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyhub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0LnJldHVybjtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGZyb20gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBhbHRlcm5hdGUgPSBmcm9tLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZ2V0UGFyZW50KGZyb20pO1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRvID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgX2FsdGVybmF0ZSA9IHRvLmFsdGVybmF0ZTtcbiAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCAmJiBfYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSBnZXRQYXJlbnQodG8pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IHBhdGhUby5sZW5ndGg7IF9pLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tfaV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbiBhXG4gKiBzaW5nbGUgb25lLlxuICovXG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgIWluc3QgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vLyBEbyBub3QgdXNlcyB0aGUgYmVsb3cgdHdvIG1ldGhvZHMgZGlyZWN0bHkhXG4vLyBJbnN0ZWFkIHVzZSBjb25zdGFudHMgZXhwb3J0ZWQgZnJvbSBET01Ub3BMZXZlbEV2ZW50VHlwZXMgaW4gUmVhY3RET00uXG4vLyAoSXQgaXMgdGhlIG9ubHkgbW9kdWxlIHRoYXQgaXMgYWxsb3dlZCB0byBhY2Nlc3MgdGhlc2UgbWV0aG9kcy4pXG5cbmZ1bmN0aW9uIHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZTtcbn1cblxuZnVuY3Rpb24gdW5zYWZlQ2FzdERPTVRvcExldmVsVHlwZVRvU3RyaW5nKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcblxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vKipcbiAqIFRvIGlkZW50aWZ5IHRvcCBsZXZlbCBldmVudHMgaW4gUmVhY3RET00sIHdlIHVzZSBjb25zdGFudHMgZGVmaW5lZCBieSB0aGlzXG4gKiBtb2R1bGUuIFRoaXMgaXMgdGhlIG9ubHkgbW9kdWxlIHRoYXQgdXNlcyB0aGUgdW5zYWZlKiBtZXRob2RzIHRvIGV4cHJlc3NcbiAqIHRoYXQgdGhlIGNvbnN0YW50cyBhY3R1YWxseSBjb3JyZXNwb25kIHRvIHRoZSBicm93c2VyIGV2ZW50IG5hbWVzLiBUaGlzIGxldHNcbiAqIHVzIHNhdmUgc29tZSBidW5kbGUgc2l6ZSBieSBhdm9pZGluZyBhIHRvcCBsZXZlbCB0eXBlIC0+IGV2ZW50IG5hbWUgbWFwLlxuICogVGhlIHJlc3Qgb2YgUmVhY3RET00gY29kZSBzaG91bGQgaW1wb3J0IHRvcCBsZXZlbCB0eXBlcyBmcm9tIHRoaXMgZmlsZS5cbiAqL1xudmFyIFRPUF9BQk9SVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnYWJvcnQnKTtcbnZhciBUT1BfQU5JTUFUSU9OX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykpO1xudmFyIFRPUF9BTklNQVRJT05fSVRFUkFUSU9OID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSk7XG52YXIgVE9QX0FOSU1BVElPTl9TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSk7XG52YXIgVE9QX0JMVVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2JsdXInKTtcbnZhciBUT1BfQ0FOX1BMQVkgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NhbnBsYXknKTtcbnZhciBUT1BfQ0FOX1BMQVlfVEhST1VHSCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2FucGxheXRocm91Z2gnKTtcbnZhciBUT1BfQ0FOQ0VMID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjYW5jZWwnKTtcbnZhciBUT1BfQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjaGFuZ2UnKTtcbnZhciBUT1BfQ0xJQ0sgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NsaWNrJyk7XG52YXIgVE9QX0NMT1NFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjbG9zZScpO1xudmFyIFRPUF9DT01QT1NJVElPTl9FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NvbXBvc2l0aW9uZW5kJyk7XG52YXIgVE9QX0NPTVBPU0lUSU9OX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjb21wb3NpdGlvbnN0YXJ0Jyk7XG52YXIgVE9QX0NPTVBPU0lUSU9OX1VQREFURSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29tcG9zaXRpb251cGRhdGUnKTtcbnZhciBUT1BfQ09OVEVYVF9NRU5VID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjb250ZXh0bWVudScpO1xudmFyIFRPUF9DT1BZID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjb3B5Jyk7XG52YXIgVE9QX0NVVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY3V0Jyk7XG52YXIgVE9QX0RPVUJMRV9DTElDSyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZGJsY2xpY2snKTtcbnZhciBUT1BfQVVYX0NMSUNLID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdhdXhjbGljaycpO1xudmFyIFRPUF9EUkFHID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcmFnJyk7XG52YXIgVE9QX0RSQUdfRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcmFnZW5kJyk7XG52YXIgVE9QX0RSQUdfRU5URVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdlbnRlcicpO1xudmFyIFRPUF9EUkFHX0VYSVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdleGl0Jyk7XG52YXIgVE9QX0RSQUdfTEVBVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdsZWF2ZScpO1xudmFyIFRPUF9EUkFHX09WRVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdvdmVyJyk7XG52YXIgVE9QX0RSQUdfU1RBUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdzdGFydCcpO1xudmFyIFRPUF9EUk9QID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkcm9wJyk7XG52YXIgVE9QX0RVUkFUSU9OX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHVyYXRpb25jaGFuZ2UnKTtcbnZhciBUT1BfRU1QVElFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZW1wdGllZCcpO1xudmFyIFRPUF9FTkNSWVBURUQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2VuY3J5cHRlZCcpO1xudmFyIFRPUF9FTkRFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZW5kZWQnKTtcbnZhciBUT1BfRVJST1IgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2Vycm9yJyk7XG52YXIgVE9QX0ZPQ1VTID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdmb2N1cycpO1xudmFyIFRPUF9HT1RfUE9JTlRFUl9DQVBUVVJFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdnb3Rwb2ludGVyY2FwdHVyZScpO1xudmFyIFRPUF9JTlBVVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnaW5wdXQnKTtcbnZhciBUT1BfSU5WQUxJRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnaW52YWxpZCcpO1xudmFyIFRPUF9LRVlfRE9XTiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgna2V5ZG93bicpO1xudmFyIFRPUF9LRVlfUFJFU1MgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2tleXByZXNzJyk7XG52YXIgVE9QX0tFWV9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgna2V5dXAnKTtcbnZhciBUT1BfTE9BRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbG9hZCcpO1xudmFyIFRPUF9MT0FEX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb2Fkc3RhcnQnKTtcbnZhciBUT1BfTE9BREVEX0RBVEEgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2xvYWRlZGRhdGEnKTtcbnZhciBUT1BfTE9BREVEX01FVEFEQVRBID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb2FkZWRtZXRhZGF0YScpO1xudmFyIFRPUF9MT1NUX1BPSU5URVJfQ0FQVFVSRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbG9zdHBvaW50ZXJjYXB0dXJlJyk7XG52YXIgVE9QX01PVVNFX0RPV04gPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlZG93bicpO1xudmFyIFRPUF9NT1VTRV9NT1ZFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdtb3VzZW1vdmUnKTtcbnZhciBUT1BfTU9VU0VfT1VUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdtb3VzZW91dCcpO1xudmFyIFRPUF9NT1VTRV9PVkVSID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdtb3VzZW92ZXInKTtcbnZhciBUT1BfTU9VU0VfVVAgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNldXAnKTtcbnZhciBUT1BfUEFTVEUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3Bhc3RlJyk7XG52YXIgVE9QX1BBVVNFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwYXVzZScpO1xudmFyIFRPUF9QTEFZID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwbGF5Jyk7XG52YXIgVE9QX1BMQVlJTkcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BsYXlpbmcnKTtcbnZhciBUT1BfUE9JTlRFUl9DQU5DRUwgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJjYW5jZWwnKTtcbnZhciBUT1BfUE9JTlRFUl9ET1dOID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwb2ludGVyZG93bicpO1xuXG5cbnZhciBUT1BfUE9JTlRFUl9NT1ZFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwb2ludGVybW92ZScpO1xudmFyIFRPUF9QT0lOVEVSX09VVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcm91dCcpO1xudmFyIFRPUF9QT0lOVEVSX09WRVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJvdmVyJyk7XG52YXIgVE9QX1BPSU5URVJfVVAgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJ1cCcpO1xudmFyIFRPUF9QUk9HUkVTUyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncHJvZ3Jlc3MnKTtcbnZhciBUT1BfUkFURV9DSEFOR0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3JhdGVjaGFuZ2UnKTtcbnZhciBUT1BfUkVTRVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3Jlc2V0Jyk7XG52YXIgVE9QX1NDUk9MTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2Nyb2xsJyk7XG52YXIgVE9QX1NFRUtFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2Vla2VkJyk7XG52YXIgVE9QX1NFRUtJTkcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3NlZWtpbmcnKTtcbnZhciBUT1BfU0VMRUNUSU9OX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2VsZWN0aW9uY2hhbmdlJyk7XG52YXIgVE9QX1NUQUxMRUQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3N0YWxsZWQnKTtcbnZhciBUT1BfU1VCTUlUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzdWJtaXQnKTtcbnZhciBUT1BfU1VTUEVORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc3VzcGVuZCcpO1xudmFyIFRPUF9URVhUX0lOUFVUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0ZXh0SW5wdXQnKTtcbnZhciBUT1BfVElNRV9VUERBVEUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RpbWV1cGRhdGUnKTtcbnZhciBUT1BfVE9HR0xFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0b2dnbGUnKTtcbnZhciBUT1BfVE9VQ0hfQ0FOQ0VMID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0b3VjaGNhbmNlbCcpO1xudmFyIFRPUF9UT1VDSF9FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvdWNoZW5kJyk7XG52YXIgVE9QX1RPVUNIX01PVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvdWNobW92ZScpO1xudmFyIFRPUF9UT1VDSF9TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2hzdGFydCcpO1xudmFyIFRPUF9UUkFOU0lUSU9OX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZShnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpKTtcbnZhciBUT1BfVk9MVU1FX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndm9sdW1lY2hhbmdlJyk7XG52YXIgVE9QX1dBSVRJTkcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3dhaXRpbmcnKTtcbnZhciBUT1BfV0hFRUwgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3doZWVsJyk7XG5cbi8vIExpc3Qgb2YgZXZlbnRzIHRoYXQgbmVlZCB0byBiZSBpbmRpdmlkdWFsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudHMuXG4vLyBOb3RlIHRoYXQgZXZlbnRzIGluIHRoaXMgbGlzdCB3aWxsICpub3QqIGJlIGxpc3RlbmVkIHRvIGF0IHRoZSB0b3AgbGV2ZWxcbi8vIHVubGVzcyB0aGV5J3JlIGV4cGxpY2l0bHkgd2hpdGVsaXN0ZWQgaW4gYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5Ub2AuXG52YXIgbWVkaWFFdmVudFR5cGVzID0gW1RPUF9BQk9SVCwgVE9QX0NBTl9QTEFZLCBUT1BfQ0FOX1BMQVlfVEhST1VHSCwgVE9QX0RVUkFUSU9OX0NIQU5HRSwgVE9QX0VNUFRJRUQsIFRPUF9FTkNSWVBURUQsIFRPUF9FTkRFRCwgVE9QX0VSUk9SLCBUT1BfTE9BREVEX0RBVEEsIFRPUF9MT0FERURfTUVUQURBVEEsIFRPUF9MT0FEX1NUQVJULCBUT1BfUEFVU0UsIFRPUF9QTEFZLCBUT1BfUExBWUlORywgVE9QX1BST0dSRVNTLCBUT1BfUkFURV9DSEFOR0UsIFRPUF9TRUVLRUQsIFRPUF9TRUVLSU5HLCBUT1BfU1RBTExFRCwgVE9QX1NVU1BFTkQsIFRPUF9USU1FX1VQREFURSwgVE9QX1ZPTFVNRV9DSEFOR0UsIFRPUF9XQUlUSU5HXTtcblxuZnVuY3Rpb24gZ2V0UmF3RXZlbnROYW1lKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdW5zYWZlQ2FzdERPTVRvcExldmVsVHlwZVRvU3RyaW5nKHRvcExldmVsVHlwZSk7XG59XG5cbi8qKlxuICogVGhlc2UgdmFyaWFibGVzIHN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL1xuXG52YXIgcm9vdCA9IG51bGw7XG52YXIgc3RhcnRUZXh0ID0gbnVsbDtcbnZhciBmYWxsYmFja1RleHQgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJvb3QgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgc3RhcnRUZXh0ID0gZ2V0VGV4dCgpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJvb3QgPSBudWxsO1xuICBzdGFydFRleHQgPSBudWxsO1xuICBmYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhKCkge1xuICBpZiAoZmFsbGJhY2tUZXh0KSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbiAgfVxuXG4gIHZhciBzdGFydCA9IHZvaWQgMDtcbiAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFRleHQ7XG4gIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICB2YXIgZW5kID0gdm9pZCAwO1xuICB2YXIgZW5kVmFsdWUgPSBnZXRUZXh0KCk7XG4gIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gIHJldHVybiBmYWxsYmFja1RleHQ7XG59XG5cbmZ1bmN0aW9uIGdldFRleHQoKSB7XG4gIGlmICgndmFsdWUnIGluIHJvb3QpIHtcbiAgICByZXR1cm4gcm9vdC52YWx1ZTtcbiAgfVxuICByZXR1cm4gcm9vdC50ZXh0Q29udGVudDtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgRVZFTlRfUE9PTF9TSVpFID0gMTA7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICAgIGRlbGV0ZSB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZDtcbiAgICBkZWxldGUgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZDtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5fYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5fdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB0aGlzLl9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gICAgdGhpcy5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNEZWZhdWx0UHJldmVudGVkJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignaXNEZWZhdWx0UHJldmVudGVkJywgZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignaXNQcm9wYWdhdGlvblN0b3BwZWQnLCBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0b3BQcm9wYWdhdGlvbicsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3N0b3BQcm9wYWdhdGlvbicsIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgfVxuICB9XG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKi9cblN5bnRoZXRpY0V2ZW50LmV4dGVuZCA9IGZ1bmN0aW9uIChJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgZnVuY3Rpb24gQ2xhc3MoKSB7XG4gICAgcmV0dXJuIFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gIGFkZEV2ZW50UG9vbGluZ1RvKENsYXNzKTtcblxuICByZXR1cm4gQ2xhc3M7XG59O1xuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbi8qKlxuICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gKiBAcGFyYW0gez9vYmplY3R9IGdldFZhbFxuICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICAhd2FybmluZ0NvbmRpdGlvbiA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogdm9pZCAwO1xuICBldmVudC5kZXN0cnVjdG9yKCk7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGggPCBFVkVOVF9QT09MX1NJWkUpIHtcbiAgICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wdXNoKGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudFBvb2xpbmdUbyhFdmVudENvbnN0cnVjdG9yKSB7XG4gIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sID0gW107XG4gIEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkID0gZ2V0UG9vbGVkRXZlbnQ7XG4gIEV2ZW50Q29uc3RydWN0b3IucmVsZWFzZSA9IHJlbGVhc2VQb29sZWRFdmVudDtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gU3ludGhldGljRXZlbnQuZXh0ZW5kKHtcbiAgZGF0YTogbnVsbFxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmV4dGVuZCh7XG4gIGRhdGE6IG51bGxcbn0pO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKGNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBjYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBjYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0NPTVBPU0lUSU9OX0VORCwgVE9QX0tFWV9QUkVTUywgVE9QX1RFWFRfSU5QVVQsIFRPUF9QQVNURV1cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09NUE9TSVRJT05fRU5ELCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfUFJFU1MsIFRPUF9LRVlfVVAsIFRPUF9NT1VTRV9ET1dOXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0JMVVIsIFRPUF9DT01QT1NJVElPTl9TVEFSVCwgVE9QX0tFWV9ET1dOLCBUT1BfS0VZX1BSRVNTLCBUT1BfS0VZX1VQLCBUT1BfTU9VU0VfRE9XTl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ09NUE9TSVRJT05fVVBEQVRFLCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfUFJFU1MsIFRPUF9LRVlfVVAsIFRPUF9NT1VTRV9ET1dOXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX1NUQVJUOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9FTkQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIFRPUF9DT01QT1NJVElPTl9VUERBVEU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSBUT1BfS0VZX0RPV04gJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIFRPUF9LRVlfVVA6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSBUT1BfS0VZX0RPV046XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgVE9QX0tFWV9QUkVTUzpcbiAgICBjYXNlIFRPUF9NT1VTRV9ET1dOOlxuICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9zaXRpb24gZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBLb3JlYW4gSU1FLlxuICogT3VyIGZhbGxiYWNrIG1vZGUgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggSUUncyBLb3JlYW4gSU1FLFxuICogc28ganVzdCB1c2UgbmF0aXZlIGNvbXBvc2l0aW9uIGV2ZW50cyB3aGVuIEtvcmVhbiBJTUUgaXMgdXNlZC5cbiAqIEFsdGhvdWdoIENvbXBvc2l0aW9uRXZlbnQubG9jYWxlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsXG4gKiBpdCBpcyBhdmFpbGFibGUgaW4gSUUsIHdoZXJlIG91ciBmYWxsYmFjayBtb2RlIGlzIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBuYXRpdmVFdmVudC5sb2NhbGUgPT09ICdrbyc7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cbnZhciBpc0NvbXBvc2luZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZSA9IHZvaWQgMDtcbiAgdmFyIGZhbGxiYWNrRGF0YSA9IHZvaWQgMDtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBpc0NvbXBvc2luZyA9IGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGV9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxUeXBlYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgVE9QX1RFWFRfSU5QVVQ6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BMZXZlbFR5cGUgTnVtYmVyIGZyb20gYFRvcExldmVsRXZlbnRUeXBlc2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0NPTVBPU0lUSU9OX0VORCB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGdldERhdGEoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICBpc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSBUT1BfUEFTVEU6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSAmJiAhaXNVc2luZ0tvcmVhbklNRShuYXRpdmVFdmVudCkgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnMgPSB2b2lkIDA7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGNvbXBvc2l0aW9uID0gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgdmFyIGJlZm9yZUlucHV0ID0gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgaWYgKGNvbXBvc2l0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYmVmb3JlSW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZUlucHV0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIFtjb21wb3NpdGlvbiwgYmVmb3JlSW5wdXRdO1xuICB9XG59O1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxudmFyIHJlc3RvcmVJbXBsID0gbnVsbDtcbnZhciByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbnZhciByZXN0b3JlUXVldWUgPSBudWxsO1xuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgLy8gV2UgcGVyZm9ybSB0aGlzIHRyYW5zbGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdCB3ZVxuICAvLyBhbHdheXMgcmVjZWl2ZSB0aGUgY29ycmVjdCBmaWJlciBoZXJlXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXQpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAvLyBVbm1vdW50ZWRcbiAgICByZXR1cm47XG4gIH1cbiAgISh0eXBlb2YgcmVzdG9yZUltcGwgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKCkgbmVlZHMgdG8gYmUgY2FsbGVkIHRvIGhhbmRsZSBhIHRhcmdldCBmb3IgY29udHJvbGxlZCBldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpO1xuICByZXN0b3JlSW1wbChpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSwgaW50ZXJuYWxJbnN0YW5jZS50eXBlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbihpbXBsKSB7XG4gIHJlc3RvcmVJbXBsID0gaW1wbDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkc1N0YXRlUmVzdG9yZSgpIHtcbiAgcmV0dXJuIHJlc3RvcmVUYXJnZXQgIT09IG51bGwgfHwgcmVzdG9yZVF1ZXVlICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVJZk5lZWRlZCgpIHtcbiAgaWYgKCFyZXN0b3JlVGFyZ2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0YXJnZXQgPSByZXN0b3JlVGFyZ2V0O1xuICB2YXIgcXVldWVkVGFyZ2V0cyA9IHJlc3RvcmVRdWV1ZTtcbiAgcmVzdG9yZVRhcmdldCA9IG51bGw7XG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbiAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKHF1ZXVlZFRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZFRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBVc2VkIGFzIGEgd2F5IHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMgd2hlbiB3ZSBkb24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvXG4vLyB0aGUgcmVuZGVyZXIuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cblxuLy8gRGVmYXVsdHNcbnZhciBfYmF0Y2hlZFVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcbnZhciBfaW50ZXJhY3RpdmVVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uIChmbiwgYSwgYikge1xuICByZXR1cm4gZm4oYSwgYik7XG59O1xudmFyIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGlzQmF0Y2hpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNCYXRjaGluZykge1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIGFub3RoZXIgYmF0Y2gsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdFxuICAgIC8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLlxuICAgIHJldHVybiBmbihib29ra2VlcGluZyk7XG4gIH1cbiAgaXNCYXRjaGluZyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIF9iYXRjaGVkVXBkYXRlc0ltcGwoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNCYXRjaGluZyA9IGZhbHNlO1xuICAgIHZhciBjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyA9IG5lZWRzU3RhdGVSZXN0b3JlKCk7XG4gICAgaWYgKGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBJZiBhIGNvbnRyb2xsZWQgZXZlbnQgd2FzIGZpcmVkLCB3ZSBtYXkgbmVlZCB0byByZXN0b3JlIHRoZSBzdGF0ZSBvZlxuICAgICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAgIC8vIGJhaWxzIG91dCBvZiB0aGUgdXBkYXRlIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICAgIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwoKTtcbiAgICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludGVyYWN0aXZlVXBkYXRlcyhmbiwgYSwgYikge1xuICByZXR1cm4gX2ludGVyYWN0aXZlVXBkYXRlc0ltcGwoZm4sIGEsIGIpO1xufVxuXG5cblxuZnVuY3Rpb24gc2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbihiYXRjaGVkVXBkYXRlc0ltcGwsIGludGVyYWN0aXZlVXBkYXRlc0ltcGwsIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCkge1xuICBfYmF0Y2hlZFVwZGF0ZXNJbXBsID0gYmF0Y2hlZFVwZGF0ZXNJbXBsO1xuICBfaW50ZXJhY3RpdmVVcGRhdGVzSW1wbCA9IGludGVyYWN0aXZlVXBkYXRlc0ltcGw7XG4gIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwgPSBmbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGw7XG59XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICAvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgpIHtcbiAgaWYgKCFjYW5Vc2VET00pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZ2V0ID0gZGVzY3JpcHRvci5nZXQsXG4gICAgICBzZXQgPSBkZXNjcmlwdG9yLnNldDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIC8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4gIC8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuICAvLyBDYWxsaW5nIGRlZmluZVByb3BlcnR5KCkgYWdhaW4gc2hvdWxkIGJlIGVxdWl2YWxlbnQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3NjhcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGVcbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBCRUZPUkVfU0xBU0hfUkUgPSAvXiguKilbXFxcXFxcL10vO1xuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICB2YXIgc291cmNlSW5mbyA9ICcnO1xuICBpZiAoc291cmNlKSB7XG4gICAgdmFyIHBhdGggPSBzb3VyY2UuZmlsZU5hbWU7XG4gICAgdmFyIGZpbGVOYW1lID0gcGF0aC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgJycpO1xuICAgIHtcbiAgICAgIC8vIEluIERFViwgaW5jbHVkZSBjb2RlIGZvciBhIGNvbW1vbiBzcGVjaWFsIGNhc2U6XG4gICAgICAvLyBwcmVmZXIgXCJmb2xkZXIvaW5kZXguanNcIiBpbnN0ZWFkIG9mIGp1c3QgXCJpbmRleC5qc1wiLlxuICAgICAgaWYgKC9eaW5kZXhcXC4vLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2goQkVGT1JFX1NMQVNIX1JFKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIHBhdGhCZWZvcmVTbGFzaCA9IG1hdGNoWzFdO1xuICAgICAgICAgIGlmIChwYXRoQmVmb3JlU2xhc2gpIHtcbiAgICAgICAgICAgIHZhciBmb2xkZXJOYW1lID0gcGF0aEJlZm9yZVNsYXNoLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCAnJyk7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IGZvbGRlck5hbWUgKyAnLycgKyBmaWxlTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlSW5mbyA9ICcgKGF0ICcgKyBmaWxlTmFtZSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknO1xuICB9IGVsc2UgaWYgKG93bmVyTmFtZSkge1xuICAgIHNvdXJjZUluZm8gPSAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKSc7XG4gIH1cbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyBzb3VyY2VJbmZvO1xufTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1BMQUNFSE9MREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wbGFjZWhvbGRlcicpIDogMHhlYWQxO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUodGhlbmFibGUpIHtcbiAgcmV0dXJuIHRoZW5hYmxlLl9yZWFjdFJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVmaW5lUmVzb2x2ZWRUaGVuYWJsZSh0aGVuYWJsZSkge1xuICByZXR1cm4gdGhlbmFibGUuX3JlYWN0U3RhdHVzID09PSBSZXNvbHZlZCA/IHRoZW5hYmxlLl9yZWFjdFJlc3VsdCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ0FzeW5jTW9kZSc7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgIGNhc2UgUkVBQ1RfUExBQ0VIT0xERVJfVFlQRTpcbiAgICAgIHJldHVybiAnUGxhY2Vob2xkZXInO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuQ29uc3VtZXInO1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuUHJvdmlkZXInO1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICB2YXIgcmVuZGVyRm4gPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHJlbmRlckZuLmRpc3BsYXlOYW1lIHx8IHJlbmRlckZuLm5hbWUgfHwgJyc7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0aGVuYWJsZSA9IHR5cGU7XG4gICAgICB2YXIgcmVzb2x2ZWRUaGVuYWJsZSA9IHJlZmluZVJlc29sdmVkVGhlbmFibGUodGhlbmFibGUpO1xuICAgICAgaWYgKHJlc29sdmVkVGhlbmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUocmVzb2x2ZWRUaGVuYWJsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudExhenk6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgY2FzZSBNb2RlOlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpO1xuICAgICAgdmFyIG93bmVyTmFtZSA9IG51bGw7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgb3duZXJOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG52YXIgY3VycmVudCA9IG51bGw7XG52YXIgcGhhc2UgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cbiAgICByZXR1cm4gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgY3VycmVudCA9IG51bGw7XG4gICAgcGhhc2UgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlcikge1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgIGN1cnJlbnQgPSBmaWJlcjtcbiAgICBwaGFzZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudFBoYXNlKGxpZmVDeWNsZVBoYXNlKSB7XG4gIHtcbiAgICBwaGFzZSA9IGxpZmVDeWNsZVBoYXNlO1xuICB9XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gd2FybmluZ1dpdGhvdXRTdGFjayQxO1xuXG57XG4gIHdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvd2FybmluZy1hbmQtaW52YXJpYW50LWFyZ3NcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxLmFwcGx5KHVuZGVmaW5lZCwgW2ZhbHNlLCBmb3JtYXQgKyAnJXMnXS5jb25jYXQoYXJncywgW3N0YWNrXSkpO1xuICB9O1xufVxuXG52YXIgd2FybmluZyQxID0gd2FybmluZztcblxuLy8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgUkVTRVJWRUQgPSAwO1xuXG4vLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgd2hpdGVsaXN0IGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cbnZhciBTVFJJTkcgPSAxO1xuXG4vLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7XG5cbi8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxudmFyIEJPT0xFQU4gPSAzO1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0O1xuXG4vLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG52YXIgTlVNRVJJQyA9IDU7XG5cbi8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbnZhciBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSAnOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCc7XG5cblxudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuICAgICAgY2FzZSBPVkVSTE9BREVEX0JPT0xFQU46XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgICBjYXNlIE5VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSk7XG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICB0aGlzLmFjY2VwdHNCb29sZWFucyA9IHR5cGUgPT09IEJPT0xFQU5JU0hfU1RSSU5HIHx8IHR5cGUgPT09IEJPT0xFQU4gfHwgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgdGhpcy5tdXN0VXNlUHJvcGVydHkgPSBtdXN0VXNlUHJvcGVydHk7XG4gIHRoaXMucHJvcGVydHlOYW1lID0gbmFtZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vLyBUaGVzZSBwcm9wcyBhcmUgcmVzZXJ2ZWQgYnkgUmVhY3QuIFRoZXkgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cblsnY2hpbGRyZW4nLCAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBSRVNFUlZFRCwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIEEgZmV3IFJlYWN0IHN0cmluZyBhdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbi8vIFRoaXMgaXMgYSBtYXBwaW5nIGZyb20gUmVhY3QgcHJvcCBuYW1lcyB0byB0aGUgYXR0cmlidXRlIG5hbWVzLlxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcblxuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuWydhbGxvd0Z1bGxTY3JlZW4nLCAnYXN5bmMnLFxuLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuJ2F1dG9Gb2N1cycsICdhdXRvUGxheScsICdjb250cm9scycsICdkZWZhdWx0JywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Zvcm1Ob1ZhbGlkYXRlJywgJ2hpZGRlbicsICdsb29wJywgJ25vTW9kdWxlJywgJ25vVmFsaWRhdGUnLCAnb3BlbicsICdwbGF5c0lubGluZScsICdyZWFkT25seScsICdyZXF1aXJlZCcsICdyZXZlcnNlZCcsICdzY29wZWQnLCAnc2VhbWxlc3MnLFxuLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgdGhlIGZldyBSZWFjdCBwcm9wcyB0aGF0IHdlIHNldCBhcyBET00gcHJvcGVydGllc1xuLy8gcmF0aGVyIHRoYW4gYXR0cmlidXRlcy4gVGhlc2UgYXJlIGFsbCBib29sZWFucy5cblsnY2hlY2tlZCcsXG4vLyBOb3RlOiBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC4gV2UgaGF2ZSBzcGVjaWFsIGxvZ2ljIGZvciBoYW5kbGluZyB0aGlzLlxuJ211bHRpcGxlJywgJ211dGVkJywgJ3NlbGVjdGVkJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCB0cnVlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYXJlIFwib3ZlcmxvYWRlZCBib29sZWFuc1wiOiB0aGV5IGJlaGF2ZSBsaWtlXG4vLyBib29sZWFucywgYnV0IGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyB2YWx1ZS5cblsnY2FwdHVyZScsICdkb3dubG9hZCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbiddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5bJ3Jvd1NwYW4nLCAnc3RhcnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE5VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblsxXS50b1VwcGVyQ2FzZSgpO1xufTtcblxuLy8gVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIFNWRyBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBzcGVjaWFsIGNhc2luZywgbmFtZXNwYWNpbmcsXG4vLyBvciBib29sZWFuIHZhbHVlIGFzc2lnbm1lbnQuIFJlZ3VsYXIgYXR0cmlidXRlcyB0aGF0IGp1c3QgYWNjZXB0IHN0cmluZ3Ncbi8vIGFuZCBoYXZlIHRoZSBzYW1lIG5hbWVzIGFyZSBvbWl0dGVkLCBqdXN0IGxpa2UgaW4gdGhlIEhUTUwgd2hpdGVsaXN0LlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBwaW5nIHRoZSBNRE4gZG9jdW1lbnRhdGlvbi5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5bJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycpO1xufSk7XG5cbi8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bWwgbmFtZXNwYWNlLlxuWyd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnKTtcbn0pO1xuXG4vLyBTcGVjaWFsIGNhc2U6IHRoaXMgYXR0cmlidXRlIGV4aXN0cyBib3RoIGluIEhUTUwgYW5kIFNWRy5cbi8vIEl0cyBcInRhYmluZGV4XCIgYXR0cmlidXRlIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUgaW4gU1ZHIHNvIHdlIGNhbid0IGp1c3QgdXNlXG4vLyBpdHMgUmVhY3QgYHRhYkluZGV4YCBuYW1lLCBsaWtlIHdlIGRvIGZvciBhdHRyaWJ1dGVzIHRoYXQgZXhpc3Qgb25seSBpbiBIVE1MLlxucHJvcGVydGllcy50YWJJbmRleCA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3RhYkluZGV4JywgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4ndGFiaW5kZXgnLCAvLyBhdHRyaWJ1dGVOYW1lXG5udWxsKTtcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgXCJleHBlY3RlZFwiIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLlxuICogU29tZSBwcm9wZXJ0aWVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbykge1xuICB7XG4gICAgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuXG4gICAgICByZXR1cm4gbm9kZVtwcm9wZXJ0eU5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuXG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICBpZiAocHJvcGVydHlJbmZvLnR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTikge1xuICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGEgYm9vbGVhbiwgaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgYXNzdW1lIGl0cyBuYW1lc3BhY2VkIG5hbWUgaXMgdGhlIHNhbWUgYXMgb3VyIGNvbmZpZy5cbiAgICAgICAgLy8gVG8gdXNlIGdldEF0dHJpYnV0ZU5TIHdlIG5lZWQgdGhlIGxvY2FsIG5hbWUgd2hpY2ggd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cbiAgICAgICAgc3RyaW5nVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nVmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG51bGw7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICBpZiAoc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgdmFsdWUgPSBudWxsO1xuICB9XG4gIC8vIElmIHRoZSBwcm9wIGlzbid0IGluIHRoZSBzcGVjaWFsIGxpc3QsIHRyZWF0IGl0IGFzIGEgc2ltcGxlIGF0dHJpYnV0ZS5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHByb3BlcnR5SW5mbyA9PT0gbnVsbCkge1xuICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICB2YXIgX2F0dHJpYnV0ZU5hbWUgPSBuYW1lO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtdXN0VXNlUHJvcGVydHkgPSBwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5O1xuXG4gIGlmIChtdXN0VXNlUHJvcGVydHkpIHtcbiAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIHR5cGUgPSBwcm9wZXJ0eUluZm8udHlwZTtcblxuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdHlwZSA9PT0gQk9PTEVBTiA/IGZhbHNlIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVGhlIHJlc3QgYXJlIHRyZWF0ZWQgYXMgYXR0cmlidXRlcyB3aXRoIHNwZWNpYWwgY2FzZXMuXG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUsXG4gICAgICBhdHRyaWJ1dGVOYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuXG4gICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gdm9pZCAwO1xuICAgIGlmIChfdHlwZSA9PT0gQk9PTEVBTiB8fCBfdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVOYW1lc3BhY2UpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoYXR0cmlidXRlTmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRmxvdyBkb2VzIG5vdCBhbGxvdyBzdHJpbmcgY29uY2F0ZW5hdGlvbiBvZiBtb3N0IG5vbi1zdHJpbmcgdHlwZXMuIFRvIHdvcmtcbi8vIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24sIHdlIHVzZSBhbiBvcGFxdWUgdHlwZSB0aGF0IGNhbiBvbmx5IGJlIG9idGFpbmVkIGJ5XG4vLyBwYXNzaW5nIHRoZSB2YWx1ZSB0aHJvdWdoIGdldFRvU3RyaW5nVmFsdWUgZmlyc3QuXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9TdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2wgYXJlIGFzc2lnbmVkIGFzIGVtcHR5IHN0cmluZ3NcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gbnVsbDtcblxudmFyIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzID0ge1xuICBjaGVja1Byb3BUeXBlczogbnVsbFxufTtcblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG4gIHZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICBjaGVja2JveDogdHJ1ZSxcbiAgICBpbWFnZTogdHJ1ZSxcbiAgICBoaWRkZW46IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgcmVzZXQ6IHRydWUsXG4gICAgc3VibWl0OiB0cnVlXG4gIH07XG5cbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAgICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAgICovXG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCB0YWdOYW1lLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0U3RhY2tBZGRlbmR1bSk7XG4gIH07XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPSBudWxsIDogcHJvcHMudmFsdWUgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgdmFyIF9jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgX2NvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFfY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciB0eXBlID0gcHJvcHMudHlwZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnIHx8XG4gICAgICAvLyBXZSBleHBsaWNpdGx5IHdhbnQgdG8gY29lcmNlIHRvIG51bWJlciBoZXJlIGlmIHBvc3NpYmxlLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSB0b1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdWJtaXQnIHx8IHR5cGUgPT09ICdyZXNldCcpIHtcbiAgICAvLyBTdWJtaXQvcmVzZXQgaW5wdXRzIG5lZWQgdGhlIGF0dHJpYnV0ZSByZW1vdmVkIGNvbXBsZXRlbHkgdG8gYXZvaWRcbiAgICAvLyBibGFuay10ZXh0IGJ1dHRvbnMuXG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpKTtcbiAgfVxuXG4gIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIoZWxlbWVudCwgcHJvcHMsIGlzSHlkcmF0aW5nKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgfHwgcHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgLy8gQXZvaWQgc2V0dGluZyB2YWx1ZSBhdHRyaWJ1dGUgb24gc3VibWl0L3Jlc2V0IGlucHV0cyBhcyBpdCBvdmVycmlkZXMgdGhlXG4gICAgLy8gZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCBieSB0aGUgYnJvd3Nlci4gU2VlOiAjMTI4NzJcbiAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG4gICAgaWYgKCh0eXBlID09PSAnc3VibWl0JyB8fCB0eXBlID09PSAncmVzZXQnKSAmJiAocHJvcHMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy52YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX2luaXRpYWxWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO1xuICAgIHZhciBjdXJyZW50VmFsdWUgPSBub2RlLnZhbHVlO1xuXG4gICAgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgICAvLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gRG8gbm90IHJlLWFzc2lnbiB0aGUgdmFsdWUgcHJvcGVydHkgaWYgdGhlcmUgaXMgbm8gY2hhbmdlLiBUaGlzXG4gICAgICAvLyBwb3RlbnRpYWxseSBhdm9pZHMgYSBET00gd3JpdGUgYW5kIHByZXZlbnRzIEZpcmVmb3ggKH42MC4wLjEpIGZyb21cbiAgICAgIC8vIHByZW1hdHVyZWx5IG1hcmtpbmcgcmVxdWlyZWQgaW5wdXRzIGFzIGludmFsaWRcbiAgICAgIGlmIChfaW5pdGlhbFZhbHVlICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IF9pbml0aWFsVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdmFsdWUgbXVzdCBiZSBhc3NpZ25lZCBiZWZvcmUgZGVmYXVsdFZhbHVlLiBUaGlzIGZpeGVzIGFuIGlzc3VlIHdoZXJlIHRoZVxuICAgIC8vIHZpc3VhbGx5IGRpc3BsYXllZCB2YWx1ZSBvZiBkYXRlIGlucHV0cyBkaXNhcHBlYXJzIG9uIG1vYmlsZSBTYWZhcmkgYW5kIENocm9tZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IF9pbml0aWFsVmFsdWU7XG4gIH1cblxuICAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSAnJztcbiAgfVxuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIW5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZDtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShvdGhlck5vZGUpO1xuICAgICAgIW90aGVyUHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcblxuICAgICAgLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIEluIENocm9tZSwgYXNzaWduaW5nIGRlZmF1bHRWYWx1ZSB0byBjZXJ0YWluIGlucHV0IHR5cGVzIHRyaWdnZXJzIGlucHV0IHZhbGlkYXRpb24uXG4vLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4vLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuLy9cbi8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4vLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKFxuICAvLyBGb2N1c2VkIG51bWJlciBpbnB1dHMgc3luY2hyb25pemUgb24gYmx1ci4gU2VlIENoYW5nZUV2ZW50UGx1Z2luLmpzXG4gIHR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBub2RlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gdG9TdHJpbmcodmFsdWUpKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGV2ZW50VHlwZXMkMSA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9CTFVSLCBUT1BfQ0hBTkdFLCBUT1BfQ0xJQ0ssIFRPUF9GT0NVUywgVE9QX0lOUFVULCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfVVAsIFRPUF9TRUxFQ1RJT05fQ0hBTkdFXVxuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcyQxLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCk7XG4gIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIGJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgcnVuRXZlbnRzSW5CYXRjaChldmVudCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCkge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KTtcbiAgaWYgKHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKHRhcmdldE5vZGUpKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQ0hBTkdFKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfRk9DVVMpIHtcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQkxVUikge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX1NFTEVDVElPTl9DSEFOR0UgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfS0VZX1VQIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX0tFWV9ET1dOKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9DTElDSykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0lOUFVUIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX0NIQU5HRSkge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihub2RlKSB7XG4gIHZhciBzdGF0ZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG4gIHNldERlZmF1bHRWYWx1ZShub2RlLCAnbnVtYmVyJywgbm9kZS52YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQxLFxuXG4gIF9pc0lucHV0RXZlbnRTdXBwb3J0ZWQ6IGlzSW5wdXRFdmVudFN1cHBvcnRlZCxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSB2b2lkIDAsXG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IHZvaWQgMDtcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICAgIHZhciBpbnN0ID0gZ2V0VGFyZ2V0SW5zdEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SW5zdCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBibHVycmluZywgc2V0IHRoZSB2YWx1ZSBhdHRyaWJ1dGUgZm9yIG51bWJlciBpbnB1dHNcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQkxVUikge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmV4dGVuZCh7XG4gIHZpZXc6IG51bGwsXG4gIGRldGFpbDogbnVsbFxufSk7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICBBbHQ6ICdhbHRLZXknLFxuICBDb250cm9sOiAnY3RybEtleScsXG4gIE1ldGE6ICdtZXRhS2V5JyxcbiAgU2hpZnQ6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbnZhciBwcmV2aW91c1NjcmVlblggPSAwO1xudmFyIHByZXZpb3VzU2NyZWVuWSA9IDA7XG4vLyBVc2UgZmxhZ3MgdG8gc2lnbmFsIG1vdmVtZW50WC9ZIGhhcyBhbHJlYWR5IGJlZW4gc2V0XG52YXIgaXNNb3ZlbWVudFhTZXQgPSBmYWxzZTtcbnZhciBpc01vdmVtZW50WVNldCA9IGZhbHNlO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBudWxsLFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFgnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgIH1cblxuICAgIHZhciBzY3JlZW5YID0gcHJldmlvdXNTY3JlZW5YO1xuICAgIHByZXZpb3VzU2NyZWVuWCA9IGV2ZW50LnNjcmVlblg7XG5cbiAgICBpZiAoIWlzTW92ZW1lbnRYU2V0KSB7XG4gICAgICBpc01vdmVtZW50WFNldCA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgPyBldmVudC5zY3JlZW5YIC0gc2NyZWVuWCA6IDA7XG4gIH0sXG4gIG1vdmVtZW50WTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFknIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRZO1xuICAgIH1cblxuICAgIHZhciBzY3JlZW5ZID0gcHJldmlvdXNTY3JlZW5ZO1xuICAgIHByZXZpb3VzU2NyZWVuWSA9IGV2ZW50LnNjcmVlblk7XG5cbiAgICBpZiAoIWlzTW92ZW1lbnRZU2V0KSB7XG4gICAgICBpc01vdmVtZW50WVNldCA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScgPyBldmVudC5zY3JlZW5ZIC0gc2NyZWVuWSA6IDA7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgUG9pbnRlckV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNQb2ludGVyRXZlbnQgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmV4dGVuZCh7XG4gIHBvaW50ZXJJZDogbnVsbCxcbiAgd2lkdGg6IG51bGwsXG4gIGhlaWdodDogbnVsbCxcbiAgcHJlc3N1cmU6IG51bGwsXG4gIHRhbmdlbnRpYWxQcmVzc3VyZTogbnVsbCxcbiAgdGlsdFg6IG51bGwsXG4gIHRpbHRZOiBudWxsLFxuICB0d2lzdDogbnVsbCxcbiAgcG9pbnRlclR5cGU6IG51bGwsXG4gIGlzUHJpbWFyeTogbnVsbFxufSk7XG5cbnZhciBldmVudFR5cGVzJDIgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUVudGVyJyxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfTU9VU0VfT1VULCBUT1BfTU9VU0VfT1ZFUl1cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlTGVhdmUnLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9NT1VTRV9PVVQsIFRPUF9NT1VTRV9PVkVSXVxuICB9LFxuICBwb2ludGVyRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Qb2ludGVyRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9QT0lOVEVSX09VVCwgVE9QX1BPSU5URVJfT1ZFUl1cbiAgfSxcbiAgcG9pbnRlckxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uUG9pbnRlckxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfUE9JTlRFUl9PVVQsIFRPUF9QT0lOVEVSX09WRVJdXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGlzT3ZlckV2ZW50ID0gdG9wTGV2ZWxUeXBlID09PSBUT1BfTU9VU0VfT1ZFUiB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9QT0lOVEVSX09WRVI7XG4gICAgdmFyIGlzT3V0RXZlbnQgPSB0b3BMZXZlbFR5cGUgPT09IFRPUF9NT1VTRV9PVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfUE9JTlRFUl9PVVQ7XG5cbiAgICBpZiAoaXNPdmVyRXZlbnQgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWlzT3V0RXZlbnQgJiYgIWlzT3ZlckV2ZW50KSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luID0gdm9pZCAwO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSB2b2lkIDA7XG4gICAgdmFyIHRvID0gdm9pZCAwO1xuICAgIGlmIChpc091dEV2ZW50KSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBldmVudEludGVyZmFjZSA9IHZvaWQgMCxcbiAgICAgICAgbGVhdmVFdmVudFR5cGUgPSB2b2lkIDAsXG4gICAgICAgIGVudGVyRXZlbnRUeXBlID0gdm9pZCAwLFxuICAgICAgICBldmVudFR5cGVQcmVmaXggPSB2b2lkIDA7XG5cbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfTU9VU0VfT1VUIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX01PVVNFX09WRVIpIHtcbiAgICAgIGV2ZW50SW50ZXJmYWNlID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgIGxlYXZlRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLm1vdXNlTGVhdmU7XG4gICAgICBlbnRlckV2ZW50VHlwZSA9IGV2ZW50VHlwZXMkMi5tb3VzZUVudGVyO1xuICAgICAgZXZlbnRUeXBlUHJlZml4ID0gJ21vdXNlJztcbiAgICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX1BPSU5URVJfT1VUIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX1BPSU5URVJfT1ZFUikge1xuICAgICAgZXZlbnRJbnRlcmZhY2UgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgICBsZWF2ZUV2ZW50VHlwZSA9IGV2ZW50VHlwZXMkMi5wb2ludGVyTGVhdmU7XG4gICAgICBlbnRlckV2ZW50VHlwZSA9IGV2ZW50VHlwZXMkMi5wb2ludGVyRW50ZXI7XG4gICAgICBldmVudFR5cGVQcmVmaXggPSAncG9pbnRlcic7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IGV2ZW50SW50ZXJmYWNlLmdldFBvb2xlZChsZWF2ZUV2ZW50VHlwZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gZXZlbnRUeXBlUHJlZml4ICsgJ2xlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xuXG4gICAgdmFyIGVudGVyID0gZXZlbnRJbnRlcmZhY2UuZ2V0UG9vbGVkKGVudGVyRXZlbnRUeXBlLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gZXZlbnRUeXBlUHJlZml4ICsgJ2VudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG52YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSQxLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9FZmZlY3QgPSAvKiAgICAgICAgICAgICAgKi8wO1xudmFyIFBlcmZvcm1lZFdvcmsgPSAvKiAgICAgICAgICovMTtcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gLyogICAgICAgICAgICAgKi8yO1xudmFyIFVwZGF0ZSA9IC8qICAgICAgICAgICAgICAgICovNDtcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSAvKiAgICAqLzY7XG52YXIgRGVsZXRpb24gPSAvKiAgICAgICAgICAgICAgKi84O1xudmFyIENvbnRlbnRSZXNldCA9IC8qICAgICAgICAgICovMTY7XG52YXIgQ2FsbGJhY2sgPSAvKiAgICAgICAgICAgICAgKi8zMjtcbnZhciBEaWRDYXB0dXJlID0gLyogICAgICAgICAgICAqLzY0O1xudmFyIFJlZiA9IC8qICAgICAgICAgICAgICAgICAgICovMTI4O1xudmFyIFNuYXBzaG90ID0gLyogICAgICAgICAgICAgICovMjU2O1xuXG4vLyBVcGRhdGUgJiBDYWxsYmFjayAmIFJlZiAmIFNuYXBzaG90XG52YXIgTGlmZWN5Y2xlRWZmZWN0TWFzayA9IC8qICAgKi80MjA7XG5cbi8vIFVuaW9uIG9mIGFsbCBob3N0IGVmZmVjdHNcbnZhciBIb3N0RWZmZWN0TWFzayA9IC8qICAgICAgICAqLzUxMTtcblxudmFyIEluY29tcGxldGUgPSAvKiAgICAgICAgICAgICovNTEyO1xudmFyIFNob3VsZENhcHR1cmUgPSAvKiAgICAgICAgICovMTAyNDtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgKG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpKSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAhaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyLnR5cGUpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICEoaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBzdGF0ZSA9IGlzRmliZXJNb3VudGVkSW1wbChmaWJlcik7XG4gICAgIShzdGF0ZSAhPT0gVU5NT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBID8gcGFyZW50QS5hbHRlcm5hdGUgOiBudWxsO1xuICAgIGlmICghcGFyZW50QSB8fCAhcGFyZW50Qikge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGEucmV0dXJuICE9PSBiLnJldHVybikge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgICFkaWRGaW5kQ2hpbGQgPyBpbnZhcmlhbnQoZmFsc2UsICdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShhLmFsdGVybmF0ZSA9PT0gYikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnNcXCcgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgfVxuICAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG4gICEoYS50YWcgPT09IEhvc3RSb290KSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKGVsZW1lbnQsIGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIoZWxlbWVudCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gU3ludGhldGljRXZlbnQuZXh0ZW5kKHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmV4dGVuZCh7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59KTtcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGUgPSB2b2lkIDA7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIElFIGFuZCBFZGdlIChvbiBXaW5kb3dzKSBhbmQgQ2hyb21lIC8gU2FmYXJpIChvbiBXaW5kb3dzIGFuZCBMaW51eClcbiAgLy8gcmVwb3J0IEVudGVyIGFzIGNoYXJDb2RlIDEwIHdoZW4gY3RybCBpcyBwcmVzc2VkLlxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAnOCc6ICdCYWNrc3BhY2UnLFxuICAnOSc6ICdUYWInLFxuICAnMTInOiAnQ2xlYXInLFxuICAnMTMnOiAnRW50ZXInLFxuICAnMTYnOiAnU2hpZnQnLFxuICAnMTcnOiAnQ29udHJvbCcsXG4gICcxOCc6ICdBbHQnLFxuICAnMTknOiAnUGF1c2UnLFxuICAnMjAnOiAnQ2Fwc0xvY2snLFxuICAnMjcnOiAnRXNjYXBlJyxcbiAgJzMyJzogJyAnLFxuICAnMzMnOiAnUGFnZVVwJyxcbiAgJzM0JzogJ1BhZ2VEb3duJyxcbiAgJzM1JzogJ0VuZCcsXG4gICczNic6ICdIb21lJyxcbiAgJzM3JzogJ0Fycm93TGVmdCcsXG4gICczOCc6ICdBcnJvd1VwJyxcbiAgJzM5JzogJ0Fycm93UmlnaHQnLFxuICAnNDAnOiAnQXJyb3dEb3duJyxcbiAgJzQ1JzogJ0luc2VydCcsXG4gICc0Nic6ICdEZWxldGUnLFxuICAnMTEyJzogJ0YxJyxcbiAgJzExMyc6ICdGMicsXG4gICcxMTQnOiAnRjMnLFxuICAnMTE1JzogJ0Y0JyxcbiAgJzExNic6ICdGNScsXG4gICcxMTcnOiAnRjYnLFxuICAnMTE4JzogJ0Y3JyxcbiAgJzExOSc6ICdGOCcsXG4gICcxMjAnOiAnRjknLFxuICAnMTIxJzogJ0YxMCcsXG4gICcxMjInOiAnRjExJyxcbiAgJzEyMyc6ICdGMTInLFxuICAnMTQ0JzogJ051bUxvY2snLFxuICAnMTQ1JzogJ1Njcm9sbExvY2snLFxuICAnMjI0JzogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gU3ludGhldGljTW91c2VFdmVudC5leHRlbmQoe1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gU3ludGhldGljVUlFdmVudC5leHRlbmQoe1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IFN5bnRoZXRpY0V2ZW50LmV4dGVuZCh7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gU3ludGhldGljTW91c2VFdmVudC5leHRlbmQoe1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufSk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbVE9QX0FCT1JUXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0gbmV3IE1hcChbXG4gKiAgIFtUT1BfQUJPUlQsIHsgc2FtZUNvbmZpZyB9XSxcbiAqIF0pO1xuICovXG5cbnZhciBpbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzID0gW1tUT1BfQkxVUiwgJ2JsdXInXSwgW1RPUF9DQU5DRUwsICdjYW5jZWwnXSwgW1RPUF9DTElDSywgJ2NsaWNrJ10sIFtUT1BfQ0xPU0UsICdjbG9zZSddLCBbVE9QX0NPTlRFWFRfTUVOVSwgJ2NvbnRleHRNZW51J10sIFtUT1BfQ09QWSwgJ2NvcHknXSwgW1RPUF9DVVQsICdjdXQnXSwgW1RPUF9BVVhfQ0xJQ0ssICdhdXhDbGljayddLCBbVE9QX0RPVUJMRV9DTElDSywgJ2RvdWJsZUNsaWNrJ10sIFtUT1BfRFJBR19FTkQsICdkcmFnRW5kJ10sIFtUT1BfRFJBR19TVEFSVCwgJ2RyYWdTdGFydCddLCBbVE9QX0RST1AsICdkcm9wJ10sIFtUT1BfRk9DVVMsICdmb2N1cyddLCBbVE9QX0lOUFVULCAnaW5wdXQnXSwgW1RPUF9JTlZBTElELCAnaW52YWxpZCddLCBbVE9QX0tFWV9ET1dOLCAna2V5RG93biddLCBbVE9QX0tFWV9QUkVTUywgJ2tleVByZXNzJ10sIFtUT1BfS0VZX1VQLCAna2V5VXAnXSwgW1RPUF9NT1VTRV9ET1dOLCAnbW91c2VEb3duJ10sIFtUT1BfTU9VU0VfVVAsICdtb3VzZVVwJ10sIFtUT1BfUEFTVEUsICdwYXN0ZSddLCBbVE9QX1BBVVNFLCAncGF1c2UnXSwgW1RPUF9QTEFZLCAncGxheSddLCBbVE9QX1BPSU5URVJfQ0FOQ0VMLCAncG9pbnRlckNhbmNlbCddLCBbVE9QX1BPSU5URVJfRE9XTiwgJ3BvaW50ZXJEb3duJ10sIFtUT1BfUE9JTlRFUl9VUCwgJ3BvaW50ZXJVcCddLCBbVE9QX1JBVEVfQ0hBTkdFLCAncmF0ZUNoYW5nZSddLCBbVE9QX1JFU0VULCAncmVzZXQnXSwgW1RPUF9TRUVLRUQsICdzZWVrZWQnXSwgW1RPUF9TVUJNSVQsICdzdWJtaXQnXSwgW1RPUF9UT1VDSF9DQU5DRUwsICd0b3VjaENhbmNlbCddLCBbVE9QX1RPVUNIX0VORCwgJ3RvdWNoRW5kJ10sIFtUT1BfVE9VQ0hfU1RBUlQsICd0b3VjaFN0YXJ0J10sIFtUT1BfVk9MVU1FX0NIQU5HRSwgJ3ZvbHVtZUNoYW5nZSddXTtcbnZhciBub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzID0gW1tUT1BfQUJPUlQsICdhYm9ydCddLCBbVE9QX0FOSU1BVElPTl9FTkQsICdhbmltYXRpb25FbmQnXSwgW1RPUF9BTklNQVRJT05fSVRFUkFUSU9OLCAnYW5pbWF0aW9uSXRlcmF0aW9uJ10sIFtUT1BfQU5JTUFUSU9OX1NUQVJULCAnYW5pbWF0aW9uU3RhcnQnXSwgW1RPUF9DQU5fUExBWSwgJ2NhblBsYXknXSwgW1RPUF9DQU5fUExBWV9USFJPVUdILCAnY2FuUGxheVRocm91Z2gnXSwgW1RPUF9EUkFHLCAnZHJhZyddLCBbVE9QX0RSQUdfRU5URVIsICdkcmFnRW50ZXInXSwgW1RPUF9EUkFHX0VYSVQsICdkcmFnRXhpdCddLCBbVE9QX0RSQUdfTEVBVkUsICdkcmFnTGVhdmUnXSwgW1RPUF9EUkFHX09WRVIsICdkcmFnT3ZlciddLCBbVE9QX0RVUkFUSU9OX0NIQU5HRSwgJ2R1cmF0aW9uQ2hhbmdlJ10sIFtUT1BfRU1QVElFRCwgJ2VtcHRpZWQnXSwgW1RPUF9FTkNSWVBURUQsICdlbmNyeXB0ZWQnXSwgW1RPUF9FTkRFRCwgJ2VuZGVkJ10sIFtUT1BfRVJST1IsICdlcnJvciddLCBbVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkUsICdnb3RQb2ludGVyQ2FwdHVyZSddLCBbVE9QX0xPQUQsICdsb2FkJ10sIFtUT1BfTE9BREVEX0RBVEEsICdsb2FkZWREYXRhJ10sIFtUT1BfTE9BREVEX01FVEFEQVRBLCAnbG9hZGVkTWV0YWRhdGEnXSwgW1RPUF9MT0FEX1NUQVJULCAnbG9hZFN0YXJ0J10sIFtUT1BfTE9TVF9QT0lOVEVSX0NBUFRVUkUsICdsb3N0UG9pbnRlckNhcHR1cmUnXSwgW1RPUF9NT1VTRV9NT1ZFLCAnbW91c2VNb3ZlJ10sIFtUT1BfTU9VU0VfT1VULCAnbW91c2VPdXQnXSwgW1RPUF9NT1VTRV9PVkVSLCAnbW91c2VPdmVyJ10sIFtUT1BfUExBWUlORywgJ3BsYXlpbmcnXSwgW1RPUF9QT0lOVEVSX01PVkUsICdwb2ludGVyTW92ZSddLCBbVE9QX1BPSU5URVJfT1VULCAncG9pbnRlck91dCddLCBbVE9QX1BPSU5URVJfT1ZFUiwgJ3BvaW50ZXJPdmVyJ10sIFtUT1BfUFJPR1JFU1MsICdwcm9ncmVzcyddLCBbVE9QX1NDUk9MTCwgJ3Njcm9sbCddLCBbVE9QX1NFRUtJTkcsICdzZWVraW5nJ10sIFtUT1BfU1RBTExFRCwgJ3N0YWxsZWQnXSwgW1RPUF9TVVNQRU5ELCAnc3VzcGVuZCddLCBbVE9QX1RJTUVfVVBEQVRFLCAndGltZVVwZGF0ZSddLCBbVE9QX1RPR0dMRSwgJ3RvZ2dsZSddLCBbVE9QX1RPVUNIX01PVkUsICd0b3VjaE1vdmUnXSwgW1RPUF9UUkFOU0lUSU9OX0VORCwgJ3RyYW5zaXRpb25FbmQnXSwgW1RPUF9XQUlUSU5HLCAnd2FpdGluZyddLCBbVE9QX1dIRUVMLCAnd2hlZWwnXV07XG5cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblxuZnVuY3Rpb24gYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnKF9yZWYsIGlzSW50ZXJhY3RpdmUpIHtcbiAgdmFyIHRvcEV2ZW50ID0gX3JlZlswXSxcbiAgICAgIGV2ZW50ID0gX3JlZlsxXTtcblxuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF0sXG4gICAgaXNJbnRlcmFjdGl2ZTogaXNJbnRlcmFjdGl2ZVxuICB9O1xuICBldmVudFR5cGVzJDRbZXZlbnRdID0gdHlwZTtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcEV2ZW50XSA9IHR5cGU7XG59XG5cbmludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUdXBsZSkge1xuICBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoZXZlbnRUdXBsZSwgdHJ1ZSk7XG59KTtcbm5vbkludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUdXBsZSkge1xuICBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoZXZlbnRUdXBsZSwgZmFsc2UpO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG52YXIga25vd25IVE1MVG9wTGV2ZWxUeXBlcyA9IFtUT1BfQUJPUlQsIFRPUF9DQU5DRUwsIFRPUF9DQU5fUExBWSwgVE9QX0NBTl9QTEFZX1RIUk9VR0gsIFRPUF9DTE9TRSwgVE9QX0RVUkFUSU9OX0NIQU5HRSwgVE9QX0VNUFRJRUQsIFRPUF9FTkNSWVBURUQsIFRPUF9FTkRFRCwgVE9QX0VSUk9SLCBUT1BfSU5QVVQsIFRPUF9JTlZBTElELCBUT1BfTE9BRCwgVE9QX0xPQURFRF9EQVRBLCBUT1BfTE9BREVEX01FVEFEQVRBLCBUT1BfTE9BRF9TVEFSVCwgVE9QX1BBVVNFLCBUT1BfUExBWSwgVE9QX1BMQVlJTkcsIFRPUF9QUk9HUkVTUywgVE9QX1JBVEVfQ0hBTkdFLCBUT1BfUkVTRVQsIFRPUF9TRUVLRUQsIFRPUF9TRUVLSU5HLCBUT1BfU1RBTExFRCwgVE9QX1NVQk1JVCwgVE9QX1NVU1BFTkQsIFRPUF9USU1FX1VQREFURSwgVE9QX1RPR0dMRSwgVE9QX1ZPTFVNRV9DSEFOR0UsIFRPUF9XQUlUSU5HXTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDQsXG5cbiAgaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIHJldHVybiBjb25maWcgIT09IHVuZGVmaW5lZCAmJiBjb25maWcuaXNJbnRlcmFjdGl2ZSA9PT0gdHJ1ZTtcbiAgfSxcblxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSBUT1BfS0VZX1BSRVNTOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUT1BfS0VZX0RPV046XG4gICAgICBjYXNlIFRPUF9LRVlfVVA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0JMVVI6XG4gICAgICBjYXNlIFRPUF9GT0NVUzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQ0xJQ0s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUT1BfQVVYX0NMSUNLOlxuICAgICAgY2FzZSBUT1BfRE9VQkxFX0NMSUNLOlxuICAgICAgY2FzZSBUT1BfTU9VU0VfRE9XTjpcbiAgICAgIGNhc2UgVE9QX01PVVNFX01PVkU6XG4gICAgICBjYXNlIFRPUF9NT1VTRV9VUDpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVE9QX01PVVNFX09VVDpcbiAgICAgIGNhc2UgVE9QX01PVVNFX09WRVI6XG4gICAgICBjYXNlIFRPUF9DT05URVhUX01FTlU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0RSQUc6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VORDpcbiAgICAgIGNhc2UgVE9QX0RSQUdfRU5URVI6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VYSVQ6XG4gICAgICBjYXNlIFRPUF9EUkFHX0xFQVZFOlxuICAgICAgY2FzZSBUT1BfRFJBR19PVkVSOlxuICAgICAgY2FzZSBUT1BfRFJBR19TVEFSVDpcbiAgICAgIGNhc2UgVE9QX0RST1A6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfVE9VQ0hfQ0FOQ0VMOlxuICAgICAgY2FzZSBUT1BfVE9VQ0hfRU5EOlxuICAgICAgY2FzZSBUT1BfVE9VQ0hfTU9WRTpcbiAgICAgIGNhc2UgVE9QX1RPVUNIX1NUQVJUOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9BTklNQVRJT05fRU5EOlxuICAgICAgY2FzZSBUT1BfQU5JTUFUSU9OX0lURVJBVElPTjpcbiAgICAgIGNhc2UgVE9QX0FOSU1BVElPTl9TVEFSVDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX1RSQU5TSVRJT05fRU5EOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX1NDUk9MTDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfV0hFRUw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0NPUFk6XG4gICAgICBjYXNlIFRPUF9DVVQ6XG4gICAgICBjYXNlIFRPUF9QQVNURTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkU6XG4gICAgICBjYXNlIFRPUF9MT1NUX1BPSU5URVJfQ0FQVFVSRTpcbiAgICAgIGNhc2UgVE9QX1BPSU5URVJfQ0FOQ0VMOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9ET1dOOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9NT1ZFOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9PVVQ6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX09WRVI6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX1VQOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuIFRoaXMgd2FybmluZyAnICsgJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIHRvcExldmVsVHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbnZhciBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUgPSBTaW1wbGVFdmVudFBsdWdpbi5pc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGU7XG5cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QucmV0dXJuKSB7XG4gICAgaW5zdCA9IGluc3QucmV0dXJuO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbChib29rS2VlcGluZykge1xuICB2YXIgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBmaW5kUm9vdENvbnRhaW5lck5vZGUoYW5jZXN0b3IpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJvb3QpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIHJ1bkV4dHJhY3RlZEV2ZW50c0luQmF0Y2goYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgcmV0dXJuIF9lbmFibGVkO1xufVxuXG4vKipcbiAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxFdmVudFR5cGVzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIoZWxlbWVudCwgZ2V0UmF3RXZlbnROYW1lKHRvcExldmVsVHlwZSksXG4gIC8vIENoZWNrIGlmIGludGVyYWN0aXZlIGFuZCB3cmFwIGluIGludGVyYWN0aXZlVXBkYXRlc1xuICBkaXNwYXRjaC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wTGV2ZWxUeXBlIE51bWJlciBmcm9tIGBUb3BMZXZlbEV2ZW50VHlwZXNgLlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGRpc3BhdGNoID0gaXNJbnRlcmFjdGl2ZVRvcExldmVsRXZlbnRUeXBlKHRvcExldmVsVHlwZSkgPyBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQgOiBkaXNwYXRjaEV2ZW50O1xuXG4gIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKGVsZW1lbnQsIGdldFJhd0V2ZW50TmFtZSh0b3BMZXZlbFR5cGUpLFxuICAvLyBDaGVjayBpZiBpbnRlcmFjdGl2ZSBhbmQgd3JhcCBpbiBpbnRlcmFjdGl2ZVVwZGF0ZXNcbiAgZGlzcGF0Y2guYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hJbnRlcmFjdGl2ZUV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaW50ZXJhY3RpdmVVcGRhdGVzKGRpc3BhdGNoRXZlbnQsIHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXRJbnN0LnRhZyA9PT0gJ251bWJlcicgJiYgIWlzRmliZXJNb3VudGVkKHRhcmdldEluc3QpKSB7XG4gICAgLy8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4gICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgIC8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxuICAgIHRhcmdldEluc3QgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJvb2tLZWVwaW5nID0gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpO1xuXG4gIHRyeSB7XG4gICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gbW91bnRBdCBDb250YWluZXIgd2hlcmUgdG8gbW91bnQgdGhlIGxpc3RlbmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIG1vdW50QXQpIHtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICBzd2l0Y2ggKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgY2FzZSBUT1BfU0NST0xMOlxuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KFRPUF9TQ1JPTEwsIG1vdW50QXQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRPUF9GT0NVUzpcbiAgICAgICAgY2FzZSBUT1BfQkxVUjpcbiAgICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudChUT1BfRk9DVVMsIG1vdW50QXQpO1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KFRPUF9CTFVSLCBtb3VudEF0KTtcbiAgICAgICAgICAvLyBXZSBzZXQgdGhlIGZsYWcgZm9yIGEgc2luZ2xlIGRlcGVuZGVuY3kgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvbixcbiAgICAgICAgICAvLyBidXQgdGhpcyBlbnN1cmVzIHdlIG1hcmsgYm90aCBhcyBhdHRhY2hlZCByYXRoZXIgdGhhbiBqdXN0IG9uZS5cbiAgICAgICAgICBpc0xpc3RlbmluZ1tUT1BfQkxVUl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW1RPUF9GT0NVU10gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRPUF9DQU5DRUw6XG4gICAgICAgIGNhc2UgVE9QX0NMT1NFOlxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKGdldFJhd0V2ZW50TmFtZShkZXBlbmRlbmN5KSkpIHtcbiAgICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KGRlcGVuZGVuY3ksIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUT1BfSU5WQUxJRDpcbiAgICAgICAgY2FzZSBUT1BfU1VCTUlUOlxuICAgICAgICBjYXNlIFRPUF9SRVNFVDpcbiAgICAgICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlbSBvbiB0aGUgdGFyZ2V0IERPTSBlbGVtZW50cy5cbiAgICAgICAgICAvLyBTb21lIG9mIHRoZW0gYnViYmxlIHNvIHdlIGRvbid0IHdhbnQgdGhlbSB0byBmaXJlIHR3aWNlLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIGxpc3RlbiBvbiB0aGUgdG9wIGxldmVsIHRvIGFsbCBub24tbWVkaWEgZXZlbnRzLlxuICAgICAgICAgIC8vIE1lZGlhIGV2ZW50cyBkb24ndCBidWJibGUgc28gYWRkaW5nIHRoZSBsaXN0ZW5lciB3b3VsZG4ndCBkbyBhbnl0aGluZy5cbiAgICAgICAgICB2YXIgaXNNZWRpYUV2ZW50ID0gbWVkaWFFdmVudFR5cGVzLmluZGV4T2YoZGVwZW5kZW5jeSkgIT09IC0xO1xuICAgICAgICAgIGlmICghaXNNZWRpYUV2ZW50KSB7XG4gICAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyhyZWdpc3RyYXRpb25OYW1lLCBtb3VudEF0KSB7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gIGRvYyA9IGRvYyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IG91dGVyTm9kZS5vd25lckRvY3VtZW50O1xuXG4gIHZhciB3aW4gPSBvd25lckRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbiAmJiB3aW4uZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIC8vIEluIEZpcmVmb3gsIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBjYW4gYmUgXCJhbm9ueW1vdXMgZGl2c1wiLCBlLmcuIHRoZVxuICAvLyB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91cyBkaXZzIGRvIG5vdCBzZWVtIHRvXG4gIC8vIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZCBlcnJvclwiIGlmIGFueSBvZiBpdHNcbiAgLy8gcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZSB3YXkgdG8gYXZvaWQgZXJyb3JpbmdcbiAgLy8gaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmRcbiAgLy8gY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuXG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgYW5jaG9yTm9kZS5ub2RlVHlwZTtcbiAgICBmb2N1c05vZGUubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgaW5kZXhXaXRoaW5BbmNob3IgPSAwO1xuICB2YXIgaW5kZXhXaXRoaW5Gb2N1cyA9IDA7XG4gIHZhciBub2RlID0gb3V0ZXJOb2RlO1xuICB2YXIgcGFyZW50Tm9kZSA9IG51bGw7XG5cbiAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHQgPSBudWxsO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBhbmNob3JOb2RlICYmIChhbmNob3JPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aCArIGFuY2hvck9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGZvY3VzTm9kZSAmJiArK2luZGV4V2l0aGluRm9jdXMgPT09IGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgbmV4dCBzaWJsaW5nIGBuZXh0YC5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICB2YXIgd2luID0gZG9jID8gZG9jLmRlZmF1bHRWaWV3IDogd2luZG93O1xuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREU7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJ2NvbnRhaW5zJyBpbiBvdXRlck5vZGUpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLm93bmVyRG9jdW1lbnQgJiYgY29udGFpbnNOb2RlKG5vZGUub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50RGVlcCgpIHtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHdoaWxlIChlbGVtZW50IGluc3RhbmNlb2Ygd2luLkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgLy8gQWNjZXNzaW5nIHRoZSBjb250ZW50RG9jdW1lbnQgb2YgYSBIVE1MSWZyYW1lRWxlbWVudCBjYW4gY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyB0byB0aHJvdywgZS5nLiBpZiBpdCBoYXMgYSBjcm9zcy1vcmlnaW4gc3JjIGF0dHJpYnV0ZVxuICAgIHRyeSB7XG4gICAgICB3aW4gPSBlbGVtZW50LmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQod2luLmRvY3VtZW50KTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuLyoqXG4gKiBAaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiB3ZSBnZXQgdGhlIGVsZW1lbnQgdHlwZXMgdGhhdCBzdXBwb3J0IHNlbGVjdGlvblxuICogZnJvbSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNkby1ub3QtYXBwbHksIGxvb2tpbmcgYXQgYHNlbGVjdGlvblN0YXJ0YFxuICogYW5kIGBzZWxlY3Rpb25FbmRgIHJvd3MuXG4gKi9cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IGVsZW0udHlwZSA9PT0gJ3NlYXJjaCcgfHwgZWxlbS50eXBlID09PSAndGVsJyB8fCBlbGVtLnR5cGUgPT09ICd1cmwnIHx8IGVsZW0udHlwZSA9PT0gJ3Bhc3N3b3JkJykgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCkge1xuICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcCgpO1xuICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChwcmlvclNlbGVjdGlvblJhbmdlICE9PSBudWxsICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcmlvckZvY3VzZWRFbGVtLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcmlvckZvY3VzZWRFbGVtLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEoaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbn1cblxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQsXG4gICAgICBlbmQgPSBvZmZzZXRzLmVuZDtcblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IGNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzJDMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfQkxVUiwgVE9QX0NPTlRFWFRfTUVOVSwgVE9QX0RSQUdfRU5ELCBUT1BfRk9DVVMsIFRPUF9LRVlfRE9XTiwgVE9QX0tFWV9VUCwgVE9QX01PVVNFX0RPV04sIFRPUF9NT1VTRV9VUCwgVE9QX1NFTEVDVElPTl9DSEFOR0VdXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZG9jdW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudCB0YXJnZXQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gKiBAcmV0dXJuIHtEb2N1bWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChldmVudFRhcmdldCkge1xuICByZXR1cm4gZXZlbnRUYXJnZXQud2luZG93ID09PSBldmVudFRhcmdldCA/IGV2ZW50VGFyZ2V0LmRvY3VtZW50IDogZXZlbnRUYXJnZXQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyBldmVudFRhcmdldCA6IGV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICB2YXIgZG9jID0gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50JDEgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50JDEgIT09IGdldEFjdGl2ZUVsZW1lbnQoZG9jKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50JDEpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJbnN0JDEsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudCQxO1xuXG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZG9jID0gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgLy8gVHJhY2sgd2hldGhlciBhbGwgbGlzdGVuZXJzIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4gICAgLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG4gICAgaWYgKCFkb2MgfHwgIWlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMoJ29uU2VsZWN0JywgZG9jKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSBUT1BfRk9DVVM6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9CTFVSOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgVE9QX01PVVNFX0RPV046XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQ09OVEVYVF9NRU5VOlxuICAgICAgY2FzZSBUT1BfTU9VU0VfVVA6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VORDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSBUT1BfU0VMRUNUSU9OX0NIQU5HRTpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFRPUF9LRVlfRE9XTjpcbiAgICAgIGNhc2UgVE9QX0tFWV9VUDpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERPTUV2ZW50UGx1Z2luT3JkZXIpO1xuc2V0Q29tcG9uZW50VHJlZShnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEsIGdldEluc3RhbmNlRnJvbU5vZGUkMSwgZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG52YXIgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZENoaWxkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4uIFdlJ2xsIHdhcm4gaWYgdGhleSBhcmUgaW52YWxpZFxuICAvLyBkdXJpbmcgdmFsaWRhdGVQcm9wcygpIHdoaWNoIHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHRocm93IG9uIG5vbi1lbGVtZW50IG9iamVjdHMuXG4gIC8vIEVsZW1lbnRzIGFyZSBzdHJpbmdpZmllZCAod2hpY2ggaXMgbm9ybWFsbHkgaXJyZWxldmFudFxuICAvLyBidXQgbWF0dGVycyBmb3IgPGZidD4pLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIC8vIE5vdGU6IHdlIGRvbid0IHdhcm4gYWJvdXQgaW52YWxpZCBjaGlsZHJlbiBoZXJlLlxuICAgIC8vIEluc3RlYWQsIHRoaXMgaXMgZG9uZSBzZXBhcmF0ZWx5IGJlbG93IHNvIHRoYXRcbiAgICAvLyBpdCBoYXBwZW5zIGR1cmluZyB0aGUgaHlkcmF0aW9uIGNvZGVwYXRoIHRvby5cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBjb2RlcGF0aCBhYm92ZSwgYnV0IHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gICAgLy8gV2FybiBhYm91dCBpbnZhbGlkIGNoaWxkcmVuIGhlcmUgc28gdGhhdCBjbGllbnQgYW5kIGh5ZHJhdGlvbiBhcmUgY29uc2lzdGVudC5cbiAgICAvLyBUT0RPOiB0aGlzIHNlZW1zIGxpa2UgaXQgY291bGQgY2F1c2UgYSBERVYtb25seSB0aHJvdyBmb3IgaHlkcmF0aW9uXG4gICAgLy8gaWYgY2hpbGRyZW4gY29udGFpbnMgYSBub24tZWxlbWVudCBvYmplY3QuIFdlIHNob3VsZCB0cnkgdG8gYXZvaWQgdGhhdC5cbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnb2JqZWN0JyAmJiBwcm9wcy5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkQ2hpbGQpIHtcbiAgICAgICAgICBkaWRXYXJuSW52YWxpZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb3BzLnNlbGVjdGVkICE9IG51bGwgJiYgIWRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcbiAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHByb3BWYWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9wdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KCckJyArIG9wdGlvbnNbX2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW19pXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7XG4gICAgdmFyIGRlZmF1bHRTZWxlY3RlZCA9IG51bGw7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgb3B0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBpZiAob3B0aW9uc1tfaTJdLnZhbHVlID09PSBfc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW19pMl0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZCA9PT0gbnVsbCAmJiAhb3B0aW9uc1tfaTJdLmRpc2FibGVkKSB7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZCA9IG9wdGlvbnNbX2kyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgd2FzTXVsdGlwbGUgPSBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSAhIXByb3BzLm11bHRpcGxlKSB7XG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLm11bHRpcGxlID8gW10gOiAnJywgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG5cbiAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuICAvLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbiAgLy8gdG8gYmUgYSBzdHJpbmcuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcyk7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICclcyBjb250YWlucyBhIHRleHRhcmVhIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUoaW5pdGlhbFZhbHVlKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUuIEZvciB0ZXh0IHVwZGF0ZXMsIGl0J3MgZmFzdGVyXG4gKiB0byBzZXQgdGhlIGBub2RlVmFsdWVgIG9mIHRoZSBUZXh0IG5vZGUgZGlyZWN0bHkgaW5zdGVhZCBvZiB1c2luZ1xuICogYC50ZXh0Q29udGVudGAgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGV4aXN0aW5nIG5vZGUgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbiAgdmFyIG1zUGF0dGVybiQxID0gL14tbXMtLztcbiAgdmFyIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSxcbiAgICAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG4gIC8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBUT0RPOiBXZSBjYW4gcmVtb3ZlIHRoaXMgaWYgd2UgYWRkIGludmFyaWFudFdpdGhTdGFjaygpXG4vLyBvciBhZGQgc3RhY2sgYnkgZGVmYXVsdCB0byBpbnZhcmlhbnRzIHdoZXJlIHBvc3NpYmxlLlxudmFyIEhUTUwkMSA9ICdfX2h0bWwnO1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQyID0gbnVsbDtcbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1t0YWddKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIHRhZywgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQyLmdldFN0YWNrQWRkZW5kdW0oKSkgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwkMSBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgICEocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyB3YXJuaW5nJDEoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB2b2lkIDA7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMi5nZXRTdGFja0FkZGVuZHVtKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIHdoaXRlbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBmb3I6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9tb2R1bGU6ICdub01vZHVsZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG5cbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkkMi5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJywgbmFtZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgY29ycmVjdE5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cbiAgICBpZiAoY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcblxuICAgIC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcbiAgICBpZiAoKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpICYmIHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJyArICclcyAnICsgJ0RpZCB5b3UgbWVhbiAlcz17JXN9PycsIHZhbHVlLCBuYW1lLCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS4nIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJywgbmFtZSwgdmFsdWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FyblNoYWR5RE9NID0gZmFsc2U7XG5cbnZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCA9ICdkYW5nZXJvdXNseVNldElubmVySFRNTCc7XG52YXIgU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HID0gJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7XG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xudmFyIEFVVE9GT0NVUyA9ICdhdXRvRm9jdXMnO1xudmFyIENISUxEUkVOID0gJ2NoaWxkcmVuJztcbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSBOYW1lc3BhY2VzLmh0bWw7XG5cblxudmFyIHdhcm5lZFVua25vd25UYWdzID0gdm9pZCAwO1xudmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHZvaWQgMDtcblxudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSB2b2lkIDA7XG52YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IHZvaWQgMDtcbnZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IHZvaWQgMDtcbnZhciBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nID0gdm9pZCAwO1xuXG52YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gdm9pZCAwO1xudmFyIG5vcm1hbGl6ZUhUTUwgPSB2b2lkIDA7XG5cbntcbiAgd2FybmVkVW5rbm93blRhZ3MgPSB7XG4gICAgLy8gQ2hyb21lIGlzIHRoZSBvbmx5IG1ham9yIGJyb3dzZXIgbm90IHNoaXBwaW5nIDx0aW1lPi4gQnV0IGFzIG9mIEp1bHlcbiAgICAvLyAyMDE3IGl0IGludGVuZHMgdG8gc2hpcCBpdCBkdWUgdG8gd2lkZXNwcmVhZCB1c2FnZS4gV2UgaW50ZW50aW9uYWxseVxuICAgIC8vICpkb24ndCogd2FybiBmb3IgPHRpbWU+IGV2ZW4gaWYgaXQncyB1bnJlY29nbml6ZWQgYnkgQ2hyb21lIGJlY2F1c2VcbiAgICAvLyBpdCBzb29uIHdpbGwgYmUsIGFuZCBtYW55IGFwcHMgaGF2ZSBiZWVuIHVzaW5nIGl0IGFueXdheS5cbiAgICB0aW1lOiB0cnVlLFxuICAgIC8vIFRoZXJlIGFyZSB3b3JraW5nIHBvbHlmaWxscyBmb3IgPGRpYWxvZz4uIExldCBwZW9wbGUgdXNlIGl0LlxuICAgIGRpYWxvZzogdHJ1ZSxcbiAgICAvLyBFbGVjdHJvbiBzaGlwcyBhIGN1c3RvbSA8d2Vidmlldz4gdGFnIHRvIGRpc3BsYXkgZXh0ZXJuYWwgd2ViIGNvbnRlbnQgaW5cbiAgICAvLyBhbiBpc29sYXRlZCBmcmFtZSBhbmQgcHJvY2Vzcy5cbiAgICAvLyBUaGlzIHRhZyBpcyBub3QgcHJlc2VudCBpbiBub24gRWxlY3Ryb24gZW52aXJvbm1lbnRzIHN1Y2ggYXMgSlNEb20gd2hpY2hcbiAgICAvLyBpcyBvZnRlbiB1c2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy9kb2NzL2FwaS93ZWJ2aWV3LXRhZ1xuICAgIHdlYnZpZXc6IHRydWVcbiAgfTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIC8qIGNhblVzZUV2ZW50U3lzdGVtICovdHJ1ZSk7XG4gIH07XG5cbiAgLy8gSUUgMTEgcGFyc2VzICYgbm9ybWFsaXplcyB0aGUgc3R5bGUgYXR0cmlidXRlIGFzIG9wcG9zZWQgdG8gb3RoZXJcbiAgLy8gYnJvd3NlcnMuIEl0IGFkZHMgc3BhY2VzIGFuZCBzb3J0cyB0aGUgcHJvcGVydGllcyBpbiBzb21lXG4gIC8vIG5vbi1hbHBoYWJldGljYWwgb3JkZXIuIEhhbmRsaW5nIHRoYXQgd291bGQgcmVxdWlyZSBzb3J0aW5nIENTU1xuICAvLyBwcm9wZXJ0aWVzIGluIHRoZSBjbGllbnQgJiBzZXJ2ZXIgdmVyc2lvbnMgb3IgYXBwbHlpbmdcbiAgLy8gYGV4cGVjdGVkU3R5bGVgIHRvIGEgdGVtcG9yYXJ5IERPTSBub2RlIHRvIHJlYWQgaXRzIGBzdHlsZWAgYXR0cmlidXRlXG4gIC8vIG5vcm1hbGl6ZWQuIFNpbmNlIGl0IG9ubHkgYWZmZWN0cyBJRSwgd2UncmUgc2tpcHBpbmcgc3R5bGUgd2FybmluZ3NcbiAgLy8gaW4gdGhhdCBicm93c2VyIGNvbXBsZXRlbHkgaW4gZmF2b3Igb2YgZG9pbmcgYWxsIHRoYXQgd29yay5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE4MDdcbiAgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyA9IGNhblVzZURPTSAmJiAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuXG4gIC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIG1hcmt1cFN0cmluZyA9IHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnID8gbWFya3VwIDogJycgKyBtYXJrdXA7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG4gIH07XG5cbiAgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVmFsdWUgPT09IG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsIG5hbWVzKTtcbiAgfTtcblxuICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4gICAgICAgIC8vIHRleHRDb250ZW50IG9uIGEgPHRleHRhcmVhPiB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIDx0ZXh0YXJlYT4gdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbiAgICAgICAgdmFyIGNhblNldFRleHRDb250ZW50ID0gdGFnICE9PSAndGV4dGFyZWEnIHx8IG5leHRQcm9wICE9PSAnJztcbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBXZSBwb2x5ZmlsbCBpdCBzZXBhcmF0ZWx5IG9uIHRoZSBjbGllbnQgZHVyaW5nIGNvbW1pdC5cbiAgICAgIC8vIFdlIGJsYWNrbGlzdCBpdCBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBwcm9wZXJ0eSBsaXN0IGJlY2F1c2Ugd2UgZW1pdCBpdCBpbiBTU1IuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gdm9pZCAwO1xuXG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuICB2YXIgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIHZhciBkb21FbGVtZW50ID0gdm9pZCAwO1xuICB2YXIgbmFtZXNwYWNlVVJJID0gcGFyZW50TmFtZXNwYWNlO1xuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIHtcbiAgICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpO1xuICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuICAgICAgIShpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCB0eXBlID09PSB0eXBlLnRvTG93ZXJDYXNlKCkpID8gd2FybmluZyQxKGZhbHNlLCAnPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIHR5cGUpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc2NyaXB0Jykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmlubmVySFRNTCA9ICc8c2NyaXB0PjwnICsgJy9zY3JpcHQ+JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIHlpZWxkIGEgc2NyaXB0IGVsZW1lbnQuXG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgZG9tRWxlbWVudCA9IGRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLCB7IGlzOiBwcm9wcy5pcyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VwYXJhdGUgZWxzZSBicmFuY2ggaW5zdGVhZCBvZiB1c2luZyBgcHJvcHMuaXMgfHwgdW5kZWZpbmVkYCBhYm92ZSBiZWNhdXNlIG9mIGEgRmlyZWZveCBidWcuXG4gICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC82ODk2XG4gICAgICAvLyBhbmQgZGlzY3Vzc2lvbiBpbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjc2MjQwXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgLy8gTm9ybWFsbHkgYXR0cmlidXRlcyBhcmUgYXNzaWduZWQgaW4gYHNldEluaXRpYWxET01Qcm9wZXJ0aWVzYCwgaG93ZXZlciB0aGUgYG11bHRpcGxlYFxuICAgICAgLy8gYXR0cmlidXRlIG9uIGBzZWxlY3RgcyBuZWVkcyB0byBiZSBhZGRlZCBiZWZvcmUgYG9wdGlvbmBzIGFyZSBpbnNlcnRlZC4gVGhpcyBwcmV2ZW50c1xuICAgICAgLy8gYSBidWcgd2hlcmUgdGhlIGBzZWxlY3RgIGRvZXMgbm90IHNjcm9sbCB0byB0aGUgY29ycmVjdCBvcHRpb24gYmVjYXVzZSBzaW5ndWxhclxuICAgICAgLy8gYHNlbGVjdGAgZWxlbWVudHMgYXV0b21hdGljYWxseSBwaWNrIHRoZSBmaXJzdCBpdGVtLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMyMjJcbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICB2YXIgbm9kZSA9IGRvbUVsZW1lbnQ7XG4gICAgICAgIG5vZGUubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0eXBlKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0nICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsIHR5cGUpKSB7XG4gICAgICAgIHdhcm5lZFVua25vd25UYWdzW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGlzIHVzaW5nIHNoYWR5IERPTS4gVXNpbmcgc2hhZHkgRE9NIHdpdGggUmVhY3QgY2FuICcgKyAnY2F1c2UgdGhpbmdzIHRvIGJyZWFrIHN1YnRseS4nLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgZGlkV2FyblNoYWR5RE9NID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuICB2YXIgcHJvcHMgPSB2b2lkIDA7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfTE9BRCwgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYUV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaV0sIGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9FUlJPUiwgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9FUlJPUiwgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9MT0FELCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1JFU0VULCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1NVQk1JVCwgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9UT0dHTEUsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpO1xuXG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG5cbiAgdmFyIGxhc3RQcm9wcyA9IHZvaWQgMDtcbiAgdmFyIG5leHRQcm9wcyA9IHZvaWQgMDtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMpO1xuXG4gIHZhciBwcm9wS2V5ID0gdm9pZCAwO1xuICB2YXIgc3R5bGVOYW1lID0gdm9pZCAwO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgIC8vIGluc2VydGVkIGFscmVhZHkuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKGxhc3RQcm9wICE9PSBuZXh0UHJvcCAmJiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSkge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2goU1RZTEUsIHN0eWxlVXBkYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8vIEFwcGx5IHRoZSBkaWZmLlxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICB1cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUocHJvcE5hbWUpIHtcbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV0gfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IHZvaWQgMDtcbiAgdmFyIGV4dHJhQXR0cmlidXRlTmFtZXMgPSB2b2lkIDA7XG5cbiAge1xuICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdID09PSB0cnVlO1xuICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcgJiYgIWRpZFdhcm5TaGFkeURPTSAmJiBkb21FbGVtZW50LnNoYWR5Um9vdCkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfTE9BRCwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSwgZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfRVJST1IsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9FUlJPUiwgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9MT0FELCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfUkVTRVQsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfU1VCTUlULCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfVE9HR0xFLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9JTlZBTElELCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcmF3UHJvcHMpO1xuXG4gIHtcbiAgICBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW19pXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbX2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghcmF3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSAnJyArIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgJycgKyBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRydWUgJiZcbiAgICAvLyBDb252aW5jZSBGbG93IHdlJ3ZlIGNhbGN1bGF0ZWQgaXQgKGl0J3MgREVWLW9ubHkgaW4gdGhpcyBtZXRob2QuKVxuICAgIHR5cGVvZiBpc0N1c3RvbUNvbXBvbmVudFRhZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlID0gdm9pZCAwO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhwcm9wS2V5KTtcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCAhPSBudWxsID8gbmV4dEh0bWwgOiAnJyk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuXG4gICAgICAgIGlmIChjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkU3R5bGUgPSBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMobmV4dFByb3ApO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkSWdub3JlQXR0cmlidXRlKHByb3BLZXksIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpICYmICFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgICAgIHZhciBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBwcm9wZXJ0eUluZm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BLZXkpO1xuICAgICAgICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbnVsbCAmJiBzdGFuZGFyZE5hbWUgIT09IHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYW4gU1ZHIHByb3AgaXMgc3VwcGxpZWQgd2l0aCBiYWQgY2FzaW5nLCBpdCB3aWxsXG4gICAgICAgICAgICAgIC8vIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgZnJvbSBIVE1MLCBidXQgd2lsbCBwcm9kdWNlIGEgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgLy8gKGFuZCB3b3VsZCBiZSBpbmNvcnJlY3RseSByZW5kZXJlZCBvbiB0aGUgY2xpZW50KS5cbiAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2UgYWxyZWFkeSB3YXJuIGFib3V0IGJhZCBjYXNpbmcgZWxzZXdoZXJlLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSdsbCBza2lwIHRoZSBtaXNsZWFkaW5nIGV4dHJhIG1pc21hdGNoIHdhcm5pbmcgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHN0YW5kYXJkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlICYmICFpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgaWYgKGV4dHJhQXR0cmlidXRlTmFtZXMuc2l6ZSA+IDAgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgd2FybkZvckV4dHJhQXR0cmlidXRlcyhleHRyYUF0dHJpYnV0ZU5hbWVzKTtcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIC8vIEZvciBpbnB1dCBhbmQgdGV4dGFyZWEgd2UgY3VycmVudCBhbHdheXMgc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBhdFxuICAgICAgLy8gcG9zdCBtb3VudCB0byBmb3JjZSBpdCB0byBkaXZlcmdlIGZyb20gYXR0cmlidXRlcy4gSG93ZXZlciwgZm9yXG4gICAgICAvLyBvcHRpb24gYW5kIHNlbGVjdCB3ZSBkb24ndCBxdWl0ZSBkbyB0aGUgc2FtZSB0aGluZyBhbmQgc2VsZWN0XG4gICAgICAvLyBpcyBub3QgcmVzaWxpZW50IHRvIHRoZSBET00gc3RhdGUgY2hhbmdpbmcgc28gd2UgZG9uJ3QgZG8gdGhhdCBoZXJlLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbm90IGRvaW5nIHRoaXMgZm9yIGlucHV0IGFuZCB0ZXh0YXJlYS5cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0KHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnROb2RlLCBjaGlsZCkge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnROb2RlLCBjaGlsZCkge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnROb2RlLCB0YWcsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgIC8vIFdlIGV4cGVjdCB0byBpbnNlcnQgZW1wdHkgdGV4dCBub2RlcyBzaW5jZSB0aGV5J3JlIG5vdCByZXByZXNlbnRlZCBpblxuICAgICAgLy8gdGhlIEhUTUwuXG4gICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgaWYgd2UgY2FuIGp1c3QgYXZvaWQgaW5zZXJ0aW5nIGVtcHR5XG4gICAgICAvLyB0ZXh0IG5vZGVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoKSB7fTtcbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZyB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgICEoY2hpbGRUYWcgPT0gbnVsbCkgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW52YWxpZFBhcmVudE9yQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcbiAgICBpZiAoIWludmFsaWRQYXJlbnRPckFuY2VzdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIHZhciBhZGRlbmR1bSA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKTtcblxuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIGFkZGVuZHVtO1xuICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgfVxuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzJXMlcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgd2hpdGVzcGFjZUluZm8sIGluZm8sIGFkZGVuZHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gUmVuZGVyZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBwZXJzaXN0ZW5jZVxuLy8gY2FuIHJlLWV4cG9ydCBldmVyeXRoaW5nIGZyb20gdGhpcyBtb2R1bGUuXG5cbmZ1bmN0aW9uIHNoaW0oKSB7XG4gIGludmFyaWFudChmYWxzZSwgJ1RoZSBjdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgcGVyc2lzdGVuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbi8vIFBlcnNpc3RlbmNlICh3aGVuIHVuc3VwcG9ydGVkKVxudmFyIHN1cHBvcnRzUGVyc2lzdGVuY2UgPSBmYWxzZTtcbnZhciBjbG9uZUluc3RhbmNlID0gc2hpbTtcbnZhciBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHNoaW07XG52YXIgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0ID0gc2hpbTtcbnZhciBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gc2hpbTtcbnZhciByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4gPSBzaGltO1xuXG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSB2b2lkIDA7XG57XG4gIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG59XG5cbnZhciBldmVudHNFbmFibGVkID0gbnVsbDtcbnZhciBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSb290SG9zdENvbnRleHQocm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gIHZhciB0eXBlID0gdm9pZCAwO1xuICB2YXIgbmFtZXNwYWNlID0gdm9pZCAwO1xuICB2YXIgbm9kZVR5cGUgPSByb290Q29udGFpbmVySW5zdGFuY2Uubm9kZVR5cGU7XG4gIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAge1xuICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICB2YXIgcm9vdCA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICB7XG4gICAgdmFyIHZhbGlkYXRlZFRhZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgX2FuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdmFsaWRhdGVkVGFnKTtcbiAgICByZXR1cm4geyBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvIH07XG4gIH1cbiAgcmV0dXJuIG5hbWVzcGFjZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRIb3N0Q29udGV4dChwYXJlbnRIb3N0Q29udGV4dCwgdHlwZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gIHtcbiAgICB2YXIgcGFyZW50SG9zdENvbnRleHREZXYgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICB2YXIgX25hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudEhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZSwgdHlwZSk7XG4gICAgdmFyIF9hbmNlc3RvckluZm8yID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRIb3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUpO1xuICAgIHJldHVybiB7IG5hbWVzcGFjZTogX25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvMiB9O1xuICB9XG4gIHZhciBwYXJlbnROYW1lc3BhY2UgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgcmV0dXJuIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZvckNvbW1pdChjb250YWluZXJJbmZvKSB7XG4gIGV2ZW50c0VuYWJsZWQgPSBpc0VuYWJsZWQoKTtcbiAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICBzZXRFbmFibGVkKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRBZnRlckNvbW1pdChjb250YWluZXJJbmZvKSB7XG4gIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24pO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG4gIHNldEVuYWJsZWQoZXZlbnRzRW5hYmxlZCk7XG4gIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICB7XG4gICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH1cbiAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXBkYXRlKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlID09PSAnb3B0aW9uJyB8fCB0eXBlID09PSAnbm9zY3JpcHQnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIHByb3BzKSB7XG4gIHJldHVybiAhIXByb3BzLmhpZGRlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dEluc3RhbmNlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICB9XG4gIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgcmV0dXJuIHRleHROb2RlO1xufVxuXG52YXIgaXNQcmltYXJ5UmVuZGVyZXIgPSB0cnVlO1xudmFyIHNjaGVkdWxlVGltZW91dCA9IHNldFRpbWVvdXQ7XG52YXIgY2FuY2VsVGltZW91dCA9IGNsZWFyVGltZW91dDtcbnZhciBub1RpbWVvdXQgPSAtMTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIE11dGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBzdXBwb3J0c011dGF0aW9uID0gdHJ1ZTtcblxuZnVuY3Rpb24gY29tbWl0TW91bnQoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gRGVzcGl0ZSB0aGUgbmFtaW5nIHRoYXQgbWlnaHQgaW1wbHkgb3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCBvbmx5XG4gIC8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuICAvLyBUaGlzIGhhcHBlbnMgaWYgYGZpbmFsaXplSW5pdGlhbENoaWxkcmVuYCByZXR1cm5zIGB0cnVlYCAod2hpY2ggaXRcbiAgLy8gZG9lcyB0byBpbXBsZW1lbnQgdGhlIGBhdXRvRm9jdXNgIGF0dHJpYnV0ZSBvbiB0aGUgY2xpZW50KS4gQnV0XG4gIC8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbiAgLy8gdXAgdGV4dCBjb250ZW50IGR1cmluZyBoeWRyYXRpb24gbWlzbWF0Y2gpLiBTbyB3ZSdsbCBjaGVjayB0aGlzIGFnYWluLlxuICBpZiAoc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBuZXdQcm9wcykpIHtcbiAgICBkb21FbGVtZW50LmZvY3VzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0VXBkYXRlKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgLy8gd2l0aCBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxuICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCkge1xuICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCAnJyk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSBuZXdUZXh0O1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgdmFyIHBhcmVudE5vZGUgPSB2b2lkIDA7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIHBhcmVudE5vZGUgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyO1xuICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG4gIC8vIFRoaXMgY29udGFpbmVyIG1pZ2h0IGJlIHVzZWQgZm9yIGEgcG9ydGFsLlxuICAvLyBJZiBzb21ldGhpbmcgaW5zaWRlIGEgcG9ydGFsIGlzIGNsaWNrZWQsIHRoYXQgY2xpY2sgc2hvdWxkIGJ1YmJsZVxuICAvLyB0aHJvdWdoIHRoZSBSZWFjdCB0cmVlLiBIb3dldmVyLCBvbiBNb2JpbGUgU2FmYXJpIHRoZSBjbGljayB3b3VsZFxuICAvLyBuZXZlciBidWJibGUgdGhyb3VnaCB0aGUgKkRPTSogdHJlZSB1bmxlc3MgYW4gYW5jZXN0b3Igd2l0aCBvbmNsaWNrXG4gIC8vIGV2ZW50IGV4aXN0cy4gU28gd2Ugd291bGRuJ3Qgc2VlIGl0IGFuZCBkaXNwYXRjaCBpdC5cbiAgLy8gVGhpcyBpcyB3aHkgd2UgZW5zdXJlIHRoYXQgY29udGFpbmVycyBoYXZlIGlubGluZSBvbmNsaWNrIGRlZmluZWQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE5MThcbiAgaWYgKHBhcmVudE5vZGUub25jbGljayA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGluc2VydEluQ29udGFpbmVyQmVmb3JlKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY29udGFpbmVyLCBjaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgSHlkcmF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBzdXBwb3J0c0h5ZHJhdGlvbiA9IHRydWU7XG5cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgaWYgKGluc3RhbmNlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBpbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhbiBlbGVtZW50IG5vZGUuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShpbnN0YW5jZSwgdGV4dCkge1xuICBpZiAodGV4dCA9PT0gJycgfHwgaW5zdGFuY2Uubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgIC8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGEgdGV4dCBub2RlLlxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhpbnN0YW5jZSkge1xuICB2YXIgbm9kZSA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKSB7XG4gIHZhciBuZXh0ID0gcGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZDtcbiAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTtcbiAgLy8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4gIC8vIGdldCBhdHRhY2hlZC5cbiAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICB9XG4gIHJldHVybiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0SW5zdGFuY2UpO1xuICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xufVxuXG5mdW5jdGlvbiBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKSB7XG4gIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0KSB7XG4gIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIEV4cGVyaW1lbnRhbCBlcnJvci1ib3VuZGFyeSBBUEkgdGhhdCBjYW4gcmVjb3ZlciBmcm9tIGVycm9ycyB3aXRoaW4gYSBzaW5nbGVcbi8vIHJlbmRlciBwaGFzZVxudmFyIGVuYWJsZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IGZhbHNlO1xuLy8gU3VzcGVuc2VcbnZhciBlbmFibGVTdXNwZW5zZSA9IGZhbHNlO1xuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG52YXIgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzID0gZmFsc2U7XG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgPSB0cnVlO1xuXG4vLyBUbyBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBkZWJ1Z2dlciwgd2Vcbi8vIHJlcGxheSB0aGUgYmVnaW4gcGhhc2Ugb2YgYSBmYWlsZWQgY29tcG9uZW50IGluc2lkZSBpbnZva2VHdWFyZGVkQ2FsbGJhY2suXG52YXIgcmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSB0cnVlO1xuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcbnZhciB3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IGZhbHNlO1xuXG4vLyBXYXJuIGFib3V0IGxlZ2FjeSBjb250ZXh0IEFQSVxudmFyIHdhcm5BYm91dExlZ2FjeUNvbnRleHRBUEkgPSBmYWxzZTtcblxuLy8gR2F0aGVyIGFkdmFuY2VkIHRpbWluZyBtZXRyaWNzIGZvciBQcm9maWxlciBzdWJ0cmVlcy5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTtcblxuLy8gVHJhY2sgd2hpY2ggaW50ZXJhY3Rpb25zIHRyaWdnZXIgZWFjaCBjb21taXQuXG52YXIgZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcgPSB0cnVlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmcpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmcgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyA/ICcgV2FybmluZzogJyArIHdhcm5pbmcgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmcpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcblxuICBpZiAoaXNDb21taXR0aW5nICYmIGxhYmVsc0luQ3VycmVudENvbW1pdC5oYXMobGFiZWwpKSB7XG4gICAgLy8gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIHdlIGRvbid0IHNob3cgZHVwbGljYXRlIGxhYmVscyBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgYSBmaXhlZCBvdmVyaGVhZCBmb3IgZXZlcnkgbWVhc3VyZW1lbnQsIGFuZCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIGJleW9uZCBuZWNlc3NhcnkuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxhYmVsc0luQ3VycmVudENvbW1pdC5hZGQobGFiZWwpO1xuXG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBiZWdpbk1hcmsobWFya05hbWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBjbGVhckZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGNsZWFyTWFyayhtYXJrTmFtZSk7XG59O1xuXG52YXIgZW5kRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSwgd2FybmluZykge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmcpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTW9kZTpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgY2xlYXJGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSk7XG4gIH1cbiAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICBjdXJyZW50UGhhc2UgPSBudWxsO1xuICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IGZhbHNlO1xufTtcblxudmFyIHBhdXNlVGltZXJzID0gZnVuY3Rpb24gKCkge1xuICAvLyBTdG9wcyBhbGwgY3VycmVudGx5IGFjdGl2ZSBtZWFzdXJlbWVudHMgc28gdGhhdCB0aGV5IGNhbiBiZSByZXN1bWVkXG4gIC8vIGlmIHdlIGNvbnRpbnVlIGluIGEgbGF0ZXIgZGVmZXJyZWQgbG9vcCBmcm9tIHRoZSBzYW1lIHVuaXQgb2Ygd29yay5cbiAgdmFyIGZpYmVyID0gY3VycmVudEZpYmVyO1xuICB3aGlsZSAoZmliZXIpIHtcbiAgICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICB9XG59O1xuXG52YXIgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnJldHVybiAhPT0gbnVsbCkge1xuICAgIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5KGZpYmVyLnJldHVybik7XG4gIH1cbiAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59O1xuXG52YXIgcmVzdW1lVGltZXJzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZXN1bWVzIGFsbCBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGFjdGl2ZSBkdXJpbmcgdGhlIGxhc3QgZGVmZXJyZWQgbG9vcC5cbiAgaWYgKGN1cnJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5KGN1cnJlbnRGaWJlcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlY29yZEVmZmVjdCgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCsrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFNjaGVkdWxlVXBkYXRlKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbE1vdW50JyAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcgJiYgIWlzV2FpdGluZ0ZvckNhbGxiYWNrKSB7XG4gICAgICBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IHRydWU7XG4gICAgICBiZWdpbk1hcmsoJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuICAgICAgdmFyIHdhcm5pbmcgPSBkaWRFeHBpcmUgPyAnUmVhY3Qgd2FzIGJsb2NrZWQgYnkgbWFpbiB0aHJlYWQnIDogbnVsbDtcbiAgICAgIGVuZE1hcmsoJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiB3aWxsIGZvcmNlIGZsdXNoIGluICcgKyBleHBpcmF0aW9uVGltZSArICcgbXMpJywgJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCB3YXJuaW5nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtZW1iZXIgd2Ugc2hvdWxkbid0IGNvbXBsZXRlIG1lYXN1cmVtZW50IGZvciB0aGlzIGZpYmVyLlxuICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY2xlYXJGaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wRmFpbGVkV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHZhciB3YXJuaW5nID0gJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnknO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCBwaGFzZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBwaGFzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBmaWJlcjtcbiAgICBjdXJyZW50UGhhc2UgPSBwaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUGhhc2VUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmluZyA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgLy8gUmVzdW1lIGFueSBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGluIHByb2dyZXNzIGR1cmluZyB0aGUgbGFzdCBsb29wLlxuICAgIHJlc3VtZVRpbWVycygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB3YXJuaW5nID0gbnVsbDtcbiAgICBpZiAoaW50ZXJydXB0ZWRCeSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGludGVycnVwdGVkQnkudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB3YXJuaW5nID0gJ0EgdG9wLWxldmVsIHVwZGF0ZSBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShpbnRlcnJ1cHRlZEJ5LnR5cGUpIHx8ICdVbmtub3duJztcbiAgICAgICAgd2FybmluZyA9ICdBbiB1cGRhdGUgdG8gJyArIGNvbXBvbmVudE5hbWUgKyAnIGludGVycnVwdGVkIHRoZSBwcmV2aW91cyByZW5kZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA+IDEpIHtcbiAgICAgIHdhcm5pbmcgPSAnVGhlcmUgd2VyZSBjYXNjYWRpbmcgdXBkYXRlcyc7XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIHZhciBsYWJlbCA9IGRpZENvbXBsZXRlUm9vdCA/ICcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbjogQ29tcGxldGVkIFJvb3QpJyA6ICcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbjogWWllbGRlZCknO1xuICAgIC8vIFBhdXNlIGFueSBtZWFzdXJlbWVudHMgdW50aWwgdGhlIG5leHQgbG9vcC5cbiAgICBwYXVzZVRpbWVycygpO1xuICAgIGVuZE1hcmsobGFiZWwsICcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknLCB3YXJuaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nID0gbnVsbDtcbiAgICBpZiAoaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0KSB7XG4gICAgICB3YXJuaW5nID0gJ0xpZmVjeWNsZSBob29rIHNjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA+IDApIHtcbiAgICAgIHdhcm5pbmcgPSAnQ2F1c2VkIGJ5IGEgY2FzY2FkaW5nIHVwZGF0ZSBpbiBlYXJsaWVyIGNvbW1pdCc7XG4gICAgfVxuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3ArKztcbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcblxuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJywgJyhDb21taXR0aW5nIENoYW5nZXMpJywgd2FybmluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgU25hcHNob3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgU25hcHNob3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gIH1cbn1cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcblxudmFyIGZpYmVyU3RhY2sgPSB2b2lkIDA7XG5cbntcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja1RoYXRTdGFja0lzRW1wdHkoKSB7XG4gIHtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdFeHBlY3RlZCBhbiBlbXB0eSBzdGFjay4gU29tZXRoaW5nIHdhcyBub3QgcmVzZXQgcHJvcGVybHkuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldigpIHtcbiAge1xuICAgIGluZGV4ID0gLTE7XG4gICAgdmFsdWVTdGFjay5sZW5ndGggPSAwO1xuICAgIGZpYmVyU3RhY2subGVuZ3RoID0gMDtcbiAgfVxufVxuXG52YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuXG57XG4gIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn1cblxuLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlDb250ZXh0T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG5mdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyKSB7XG4gIGlmIChkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIgJiYgaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAvLyB3ZSBtYXkgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgLy8gQXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgdW5tYXNrZWQgY29udGV4dCBoYXMgY2hhbmdlZC5cbiAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4gIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICB9XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYpO1xuICB9XG5cbiAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYmVmb3JlIHRoZSBjbGFzcyBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkIHNvIGNoZWNrIGZvciBpbnN0YW5jZS5cbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGhhc0NvbnRleHRDaGFuZ2VkKCkge1xuICByZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcih0eXBlKSB7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IHR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG4gIHJldHVybiBjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyKSB7XG4gIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHVzaFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlciwgY29udGV4dCwgZGlkQ2hhbmdlKSB7XG4gICEoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGVtcHR5Q29udGV4dE9iamVjdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgdHlwZSwgcGFyZW50Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IHR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgc2V0Q3VycmVudFBoYXNlKCdnZXRDaGlsZENvbnRleHQnKTtcbiAgfVxuICBzdGFydFBoYXNlVGltZXIoZmliZXIsICdnZXRDaGlsZENvbnRleHQnKTtcbiAgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gIHN0b3BQaGFzZVRpbWVyKCk7XG4gIHtcbiAgICBzZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAhKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bicsIGNvbnRleHRLZXkpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYpO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5Q29udGV4dE9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHR5cGUsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAhKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50TGF6eSkpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgc3VidHJlZSBwYXJlbnQgdG8gYmUgYSBtb3VudGVkIGNsYXNzIGNvbXBvbmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICB2YXIgbm9kZSA9IGZpYmVyO1xuICBkbyB7XG4gICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIENvbXBvbmVudCA9IG5vZGUudHlwZTtcbiAgICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX0NvbXBvbmVudCA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKG5vZGUudHlwZSk7XG4gICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfSB3aGlsZSAobm9kZSAhPT0gbnVsbCk7XG4gIGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbnZhciBvbkNvbW1pdEZpYmVyUm9vdCA9IG51bGw7XG52YXIgb25Db21taXRGaWJlclVubW91bnQgPSBudWxsO1xudmFyIGhhc0xvZ2dlZEVycm9yID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNhdGNoRXJyb3JzKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhcmcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRydWUgJiYgIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBpc0RldlRvb2xzUHJlc2VudCA9IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxuLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXG4vLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4vLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxudmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMztcblxudmFyIE5vV29yayA9IDA7XG52YXIgU3luYyA9IDE7XG52YXIgTmV2ZXIgPSBtYXhTaWduZWQzMUJpdEludDtcblxudmFyIFVOSVRfU0laRSA9IDEwO1xudmFyIE1BR0lDX05VTUJFUl9PRkZTRVQgPSAyO1xuXG4vLyAxIHVuaXQgb2YgZXhwaXJhdGlvbiB0aW1lIHJlcHJlc2VudHMgMTBtcy5cbmZ1bmN0aW9uIG1zVG9FeHBpcmF0aW9uVGltZShtcykge1xuICAvLyBBbHdheXMgYWRkIGFuIG9mZnNldCBzbyB0aGF0IHdlIGRvbid0IGNsYXNoIHdpdGggdGhlIG1hZ2ljIG51bWJlciBmb3IgTm9Xb3JrLlxuICByZXR1cm4gKG1zIC8gVU5JVF9TSVpFIHwgMCkgKyBNQUdJQ19OVU1CRVJfT0ZGU0VUO1xufVxuXG5mdW5jdGlvbiBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpIHtcbiAgcmV0dXJuIChleHBpcmF0aW9uVGltZSAtIE1BR0lDX05VTUJFUl9PRkZTRVQpICogVU5JVF9TSVpFO1xufVxuXG5mdW5jdGlvbiBjZWlsaW5nKG51bSwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiAoKG51bSAvIHByZWNpc2lvbiB8IDApICsgMSkgKiBwcmVjaXNpb247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uSW5NcywgYnVja2V0U2l6ZU1zKSB7XG4gIHJldHVybiBNQUdJQ19OVU1CRVJfT0ZGU0VUICsgY2VpbGluZyhjdXJyZW50VGltZSAtIE1BR0lDX05VTUJFUl9PRkZTRVQgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIExPV19QUklPUklUWV9FWFBJUkFUSU9OID0gNTAwMDtcbnZhciBMT1dfUFJJT1JJVFlfQkFUQ0hfU0laRSA9IDI1MDtcblxuZnVuY3Rpb24gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbihjdXJyZW50VGltZSkge1xuICByZXR1cm4gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIExPV19QUklPUklUWV9FWFBJUkFUSU9OLCBMT1dfUFJJT1JJVFlfQkFUQ0hfU0laRSk7XG59XG5cbi8vIFdlIGludGVudGlvbmFsbHkgc2V0IGEgaGlnaGVyIGV4cGlyYXRpb24gdGltZSBmb3IgaW50ZXJhY3RpdmUgdXBkYXRlcyBpblxuLy8gZGV2IHRoYW4gaW4gcHJvZHVjdGlvbi5cbi8vXG4vLyBJZiB0aGUgbWFpbiB0aHJlYWQgaXMgYmVpbmcgYmxvY2tlZCBzbyBsb25nIHRoYXQgeW91IGhpdCB0aGUgZXhwaXJhdGlvbixcbi8vIGl0J3MgYSBwcm9ibGVtIHRoYXQgY291bGQgYmUgc29sdmVkIHdpdGggYmV0dGVyIHNjaGVkdWxpbmcuXG4vL1xuLy8gUGVvcGxlIHdpbGwgYmUgbW9yZSBsaWtlbHkgdG8gbm90aWNlIHRoaXMgYW5kIGZpeCBpdCB3aXRoIHRoZSBsb25nXG4vLyBleHBpcmF0aW9uIHRpbWUgaW4gZGV2ZWxvcG1lbnQuXG4vL1xuLy8gSW4gcHJvZHVjdGlvbiB3ZSBvcHQgZm9yIGJldHRlciBVWCBhdCB0aGUgcmlzayBvZiBtYXNraW5nIHNjaGVkdWxpbmdcbi8vIHByb2JsZW1zLCBieSBleHBpcmluZyBmYXN0LlxudmFyIEhJR0hfUFJJT1JJVFlfRVhQSVJBVElPTiA9IDUwMDtcbnZhciBISUdIX1BSSU9SSVRZX0JBVENIX1NJWkUgPSAxMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcmFjdGl2ZUV4cGlyYXRpb24oY3VycmVudFRpbWUpIHtcbiAgcmV0dXJuIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBISUdIX1BSSU9SSVRZX0VYUElSQVRJT04sIEhJR0hfUFJJT1JJVFlfQkFUQ0hfU0laRSk7XG59XG5cbnZhciBOb0NvbnRleHQgPSAwO1xudmFyIEFzeW5jTW9kZSA9IDE7XG52YXIgU3RyaWN0TW9kZSA9IDI7XG52YXIgUHJvZmlsZU1vZGUgPSA0O1xuXG52YXIgaGFzQmFkTWFwUG9seWZpbGwgPSB2b2lkIDA7XG5cbntcbiAgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgdmFyIHRlc3RNYXAgPSBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcbiAgICB2YXIgdGVzdFNldCA9IG5ldyBTZXQoW25vbkV4dGVuc2libGVPYmplY3RdKTtcbiAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgUm9sbHVwIHRvIG5vdCBjb25zaWRlciB0aGVzZSB1bnVzZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE3NzFcbiAgICAvLyBUT0RPOiB3ZSBjYW4gcmVtb3ZlIHRoZXNlIGlmIFJvbGx1cCBmaXhlcyB0aGUgYnVnLlxuICAgIHRlc3RNYXAuc2V0KDAsIDApO1xuICAgIHRlc3RTZXQuYWRkKDApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbi8vIEEgRmliZXIgaXMgd29yayBvbiBhIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgb3Igd2FzIGRvbmUuIFRoZXJlIGNhblxuLy8gYmUgbW9yZSB0aGFuIG9uZSBwZXIgY29tcG9uZW50LlxuXG5cbnZhciBkZWJ1Z0NvdW50ZXIgPSB2b2lkIDA7XG5cbntcbiAgZGVidWdDb3VudGVyID0gMTtcbn1cblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgLy8gRmliZXJcbiAgdGhpcy5yZXR1cm4gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG5cbiAgdGhpcy5yZWYgPSBudWxsO1xuXG4gIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgdGhpcy5maXJzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcblxuICB0aGlzLm1vZGUgPSBtb2RlO1xuXG4gIC8vIEVmZmVjdHNcbiAgdGhpcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgdGhpcy5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB0aGlzLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuIHR5cGVvZiBwcm90b3R5cGUgPT09ICdvYmplY3QnICYmIHByb3RvdHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPT09ICdvYmplY3QnICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhmaWJlciwgQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpID8gQ2xhc3NDb21wb25lbnRMYXp5IDogRnVuY3Rpb25hbENvbXBvbmVudExhenk7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsICYmIENvbXBvbmVudC4kJHR5cGVvZikge1xuICAgIHJldHVybiBGb3J3YXJkUmVmTGF6eTtcbiAgfVxuICByZXR1cm4gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIHBlbmRpbmdQcm9wcywgY3VycmVudC5rZXksIGN1cnJlbnQubW9kZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IHJlc2V0LCByYXRoZXIgdGhhbiBjb3B5LCBhY3R1YWxEdXJhdGlvbiAmIGFjdHVhbFN0YXJ0VGltZS5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgdGltZSBmcm9tIGVuZGxlc3NseSBhY2N1bXVsYXRpbmcgaW4gbmV3IGNvbW1pdHMuXG4gICAgICAvLyBUaGlzIGhhcyB0aGUgZG93bnNpZGUgb2YgcmVzZXR0aW5nIHZhbHVlcyBmb3IgZGlmZmVyZW50IHByaW9yaXR5IHJlbmRlcnMsXG4gICAgICAvLyBCdXQgd29ya3MgZm9yIHlpZWxkaW5nICh0aGUgY29tbW9uIGNhc2UpIGFuZCBzaG91bGQgc3VwcG9ydCByZXN1bWluZy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8vIERvbid0IHRvdWNoaW5nIHRoZSBzdWJ0cmVlJ3MgZXhwaXJhdGlvbiB0aW1lLCB3aGljaCBoYXMgbm90IGNoYW5nZWQuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBjdXJyZW50LmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gIGlmIChwZW5kaW5nUHJvcHMgIT09IGN1cnJlbnQucGVuZGluZ1Byb3BzKSB7XG4gICAgLy8gVGhpcyBmaWJlciBoYXMgbmV3IHByb3BzLlxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBmaWJlcidzIHByb3BzIGhhdmUgbm90IGNoYW5nZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBjdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gIHdvcmtJblByb2dyZXNzLmZpcnN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50LmZpcnN0Q29udGV4dERlcGVuZGVuY3k7XG5cbiAgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcihpc0FzeW5jKSB7XG4gIHZhciBtb2RlID0gaXNBc3luYyA/IEFzeW5jTW9kZSB8IFN0cmljdE1vZGUgOiBOb0NvbnRleHQ7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXG4gIHZhciBmaWJlclRhZyA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXJUYWcgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBDbGFzc0NvbXBvbmVudCA6IEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXJUYWcgPSBIb3N0Q29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIGdldFRhZzogc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChwZW5kaW5nUHJvcHMuY2hpbGRyZW4sIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBBc3luY01vZGUgfCBTdHJpY3RNb2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IFN0cmljdE1vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgIGNhc2UgUkVBQ1RfUExBQ0VIT0xERVJfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBQbGFjZWhvbGRlckNvbXBvbmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNvbnN1bWVyXG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBGb3J3YXJkUmVmO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLnR5cGUgPSB0eXBlO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwZW5kaW5nUHJvcHMub25SZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgc3RyaW5nIGFuZCBcIm9uUmVuZGVyXCIgZnVuY3Rpb24gYXMgcHJvcHMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihQcm9maWxlciwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUgfCBQcm9maWxlTW9kZSk7XG4gIGZpYmVyLnR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiAhPT0gbnVsbCA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwZW5kaW5nUHJvcHMsIHBvcnRhbC5rZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLCAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG4vLyBVc2VkIGZvciBzdGFzaGluZyBXSVAgcHJvcGVydGllcyB0byByZXBsYXkgZmFpbGVkIHdvcmsgaW4gREVWLlxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vQ29udGV4dCk7XG4gIH1cblxuICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiBhcyBhIGxpc3Qgb2YgYWxsIHByb3BlcnRpZXMuXG4gIC8vIFdlIHRyaWVkIHRvIHVzZSBPYmplY3QuYXNzaWduKCkgaW5zdGVhZCBidXQgdGhpcyBpcyBjYWxsZWQgaW5cbiAgLy8gdGhlIGhvdHRlc3QgcGF0aCwgYW5kIE9iamVjdC5hc3NpZ24oKSB3YXMgdG9vIHNsb3c6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDJcbiAgLy8gVGhpcyBjb2RlIGlzIERFVi1vbmx5IHNvIHNpemUgaXMgbm90IGEgY29uY2Vybi5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC50eXBlID0gc291cmNlLnR5cGU7XG4gIHRhcmdldC5zdGF0ZU5vZGUgPSBzb3VyY2Uuc3RhdGVOb2RlO1xuICB0YXJnZXQucmV0dXJuID0gc291cmNlLnJldHVybjtcbiAgdGFyZ2V0LmNoaWxkID0gc291cmNlLmNoaWxkO1xuICB0YXJnZXQuc2libGluZyA9IHNvdXJjZS5zaWJsaW5nO1xuICB0YXJnZXQuaW5kZXggPSBzb3VyY2UuaW5kZXg7XG4gIHRhcmdldC5yZWYgPSBzb3VyY2UucmVmO1xuICB0YXJnZXQucGVuZGluZ1Byb3BzID0gc291cmNlLnBlbmRpbmdQcm9wcztcbiAgdGFyZ2V0Lm1lbW9pemVkUHJvcHMgPSBzb3VyY2UubWVtb2l6ZWRQcm9wcztcbiAgdGFyZ2V0LnVwZGF0ZVF1ZXVlID0gc291cmNlLnVwZGF0ZVF1ZXVlO1xuICB0YXJnZXQubWVtb2l6ZWRTdGF0ZSA9IHNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICB0YXJnZXQuZmlyc3RDb250ZXh0RGVwZW5kZW5jeSA9IHNvdXJjZS5maXJzdENvbnRleHREZXBlbmRlbmN5O1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZWZmZWN0VGFnID0gc291cmNlLmVmZmVjdFRhZztcbiAgdGFyZ2V0Lm5leHRFZmZlY3QgPSBzb3VyY2UubmV4dEVmZmVjdDtcbiAgdGFyZ2V0LmZpcnN0RWZmZWN0ID0gc291cmNlLmZpcnN0RWZmZWN0O1xuICB0YXJnZXQubGFzdEVmZmVjdCA9IHNvdXJjZS5sYXN0RWZmZWN0O1xuICB0YXJnZXQuZXhwaXJhdGlvblRpbWUgPSBzb3VyY2UuZXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5jaGlsZEV4cGlyYXRpb25UaW1lID0gc291cmNlLmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5hbHRlcm5hdGUgPSBzb3VyY2UuYWx0ZXJuYXRlO1xuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHRhcmdldC5hY3R1YWxEdXJhdGlvbiA9IHNvdXJjZS5hY3R1YWxEdXJhdGlvbjtcbiAgICB0YXJnZXQuYWN0dWFsU3RhcnRUaW1lID0gc291cmNlLmFjdHVhbFN0YXJ0VGltZTtcbiAgICB0YXJnZXQuc2VsZkJhc2VEdXJhdGlvbiA9IHNvdXJjZS5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHRhcmdldC50cmVlQmFzZUR1cmF0aW9uID0gc291cmNlLnRyZWVCYXNlRHVyYXRpb247XG4gIH1cbiAgdGFyZ2V0Ll9kZWJ1Z0lEID0gc291cmNlLl9kZWJ1Z0lEO1xuICB0YXJnZXQuX2RlYnVnU291cmNlID0gc291cmNlLl9kZWJ1Z1NvdXJjZTtcbiAgdGFyZ2V0Ll9kZWJ1Z093bmVyID0gc291cmNlLl9kZWJ1Z093bmVyO1xuICB0YXJnZXQuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBzb3VyY2UuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmc7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIGxpZnRlZCBpbnRvIHRoZSByZW5kZXJlci5cblxuXG4vLyBUaGUgZm9sbG93aW5nIGF0dHJpYnV0ZXMgYXJlIG9ubHkgdXNlZCBieSBpbnRlcmFjdGlvbiB0cmFja2luZyBidWlsZHMuXG4vLyBUaGV5IGVuYWJsZSBpbnRlcmFjdGlvbnMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIGFzeW5jIHdvcmssXG4vLyBBbmQgZXhwb3NlIGludGVyYWN0aW9uIG1ldGFkYXRhIHRvIHRoZSBSZWFjdCBEZXZUb29scyBQcm9maWxlciBwbHVnaW4uXG4vLyBOb3RlIHRoYXQgdGhlc2UgYXR0cmlidXRlcyBhcmUgb25seSBkZWZpbmVkIHdoZW4gdGhlIGVuYWJsZVNjaGVkdWxlclRyYWNraW5nIGZsYWcgaXMgZW5hYmxlZC5cblxuXG4vLyBFeHBvcnRlZCBGaWJlclJvb3QgdHlwZSBpbmNsdWRlcyBhbGwgcHJvcGVydGllcyxcbi8vIFRvIGF2b2lkIHJlcXVpcmluZyBwb3RlbnRpYWxseSBlcnJvci1wcm9uZSA6YW55IGNhc3RzIHRocm91Z2hvdXQgdGhlIHByb2plY3QuXG4vLyBQcm9maWxpbmcgcHJvcGVydGllcyBhcmUgb25seSBzYWZlIHRvIGFjY2VzcyBpbiBwcm9maWxpbmcgYnVpbGRzICh3aGVuIGVuYWJsZVNjaGVkdWxlclRyYWNraW5nIGlzIHRydWUpLlxuLy8gVGhlIHR5cGVzIGFyZSBkZWZpbmVkIHNlcGFyYXRlbHkgd2l0aGluIHRoaXMgZmlsZSB0byBlbnN1cmUgdGhleSBzdGF5IGluIHN5bmMuXG4vLyAoV2UgZG9uJ3QgaGF2ZSB0byB1c2UgYW4gaW5saW5lIDphbnkgY2FzdCB3aGVuIGVuYWJsZVNjaGVkdWxlclRyYWNraW5nIGlzIGRpc2FibGVkLilcblxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaXNBc3luYywgaHlkcmF0ZSkge1xuICAvLyBDeWNsaWMgY29uc3RydWN0aW9uLiBUaGlzIGNoZWF0cyB0aGUgdHlwZSBzeXN0ZW0gcmlnaHQgbm93IGJlY2F1c2VcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIoaXNBc3luYyk7XG5cbiAgdmFyIHJvb3QgPSB2b2lkIDA7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFja2luZykge1xuICAgIHJvb3QgPSB7XG4gICAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuXG4gICAgICBlYXJsaWVzdFBlbmRpbmdUaW1lOiBOb1dvcmssXG4gICAgICBsYXRlc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgICAgZWFybGllc3RTdXNwZW5kZWRUaW1lOiBOb1dvcmssXG4gICAgICBsYXRlc3RTdXNwZW5kZWRUaW1lOiBOb1dvcmssXG4gICAgICBsYXRlc3RQaW5nZWRUaW1lOiBOb1dvcmssXG5cbiAgICAgIGRpZEVycm9yOiBmYWxzZSxcblxuICAgICAgcGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBub1RpbWVvdXQsXG4gICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgcGVuZGluZ0NvbnRleHQ6IG51bGwsXG4gICAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgICAgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT246IE5vV29yayxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgICBmaXJzdEJhdGNoOiBudWxsLFxuICAgICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGwsXG5cbiAgICAgIGludGVyYWN0aW9uVGhyZWFkSUQ6IHRyYWNraW5nLnVuc3RhYmxlX2dldFRocmVhZElEKCksXG4gICAgICBtZW1vaXplZEludGVyYWN0aW9uczogbmV3IFNldCgpLFxuICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwOiBuZXcgTWFwKClcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJvb3QgPSB7XG4gICAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuXG4gICAgICBlYXJsaWVzdFBlbmRpbmdUaW1lOiBOb1dvcmssXG4gICAgICBsYXRlc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgICAgZWFybGllc3RTdXNwZW5kZWRUaW1lOiBOb1dvcmssXG4gICAgICBsYXRlc3RTdXNwZW5kZWRUaW1lOiBOb1dvcmssXG4gICAgICBsYXRlc3RQaW5nZWRUaW1lOiBOb1dvcmssXG5cbiAgICAgIGRpZEVycm9yOiBmYWxzZSxcblxuICAgICAgcGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBub1RpbWVvdXQsXG4gICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgcGVuZGluZ0NvbnRleHQ6IG51bGwsXG4gICAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgICAgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT246IE5vV29yayxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgICBmaXJzdEJhdGNoOiBudWxsLFxuICAgICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG5cbiAgLy8gVGhlIHJlYXNvbiBmb3IgdGhlIHdheSB0aGUgRmxvdyB0eXBlcyBhcmUgc3RydWN0dXJlZCBpbiB0aGlzIGZpbGUsXG4gIC8vIElzIHRvIGF2b2lkIG5lZWRpbmcgOmFueSBjYXN0cyBldmVyeXdoZXJlIGludGVyYWN0aW9uIHRyYWNraW5nIGZpZWxkcyBhcmUgdXNlZC5cbiAgLy8gVW5mb3J0dW5hdGVseSB0aGF0IHJlcXVpcmVzIGFuIDphbnkgY2FzdCBmb3Igbm9uLWludGVyYWN0aW9uIHRyYWNraW5nIGNhcGFibGUgYnVpbGRzLlxuICAvLyAkRmxvd0ZpeE1lIFJlbW92ZSB0aGlzIDphbnkgY2FzdCBhbmQgcmVwbGFjZSBpdCB3aXRoIHNvbWV0aGluZyBiZXR0ZXIuXG4gIHJldHVybiByb290O1xufVxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bsb3dQcmlvcml0eVdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyA9IHtcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIGZsdXNoUGVuZGluZ0RlcHJlY2F0aW9uV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICBmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIHJlY29yZERlcHJlY2F0aW9uV2FybmluZ3M6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIHJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIExJRkVDWUNMRV9TVUdHRVNUSU9OUyA9IHtcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcycsXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU6ICdjb21wb25lbnREaWRVcGRhdGUnXG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG4gIHZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuXG4gIHZhciBzZXRUb1NvcnRlZFN0cmluZyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlV2FybmluZ3NNYXAsIHN0cmljdFJvb3QpIHtcbiAgICAgIHZhciBsaWZlY3ljbGVzV2FybmluZ01lc2FnZXMgPSBbXTtcblxuICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlV2FybmluZ3NNYXApLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZSkge1xuICAgICAgICB2YXIgbGlmZWN5Y2xlV2FybmluZ3MgPSBsaWZlY3ljbGVXYXJuaW5nc01hcFtsaWZlY3ljbGVdO1xuICAgICAgICBpZiAobGlmZWN5Y2xlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBsaWZlY3ljbGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gbGlmZWN5Y2xlLnJlcGxhY2UoJ1VOU0FGRV8nLCAnJyk7XG4gICAgICAgICAgdmFyIHN1Z2dlc3Rpb24gPSBMSUZFQ1lDTEVfU1VHR0VTVElPTlNbbGlmZWN5Y2xlXTtcbiAgICAgICAgICB2YXIgc29ydGVkQ29tcG9uZW50TmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnROYW1lcyk7XG5cbiAgICAgICAgICBsaWZlY3ljbGVzV2FybmluZ01lc2FnZXMucHVzaChmb3JtYXR0ZWQgKyAnOiBQbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50cyB0byB1c2UgJyArIChzdWdnZXN0aW9uICsgJyBpbnN0ZWFkOiAnICsgc29ydGVkQ29tcG9uZW50TmFtZXMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChsaWZlY3ljbGVzV2FybmluZ01lc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgc3RyaWN0Um9vdENvbXBvbmVudFN0YWNrID0gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHN0cmljdFJvb3QpO1xuXG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1Vuc2FmZSBsaWZlY3ljbGUgbWV0aG9kcyB3ZXJlIGZvdW5kIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWU6JXMnICsgJ1xcblxcbiVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS13YXJuaW5ncycsIHN0cmljdFJvb3RDb21wb25lbnRTdGFjaywgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmpvaW4oJ1xcblxcbicpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICB2YXIgZmluZFN0cmljdFJvb3QgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgbWF5YmVTdHJpY3RSb290ID0gbnVsbDtcblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIG1heWJlU3RyaWN0Um9vdCA9IG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdEZXByZWNhdGlvbldhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcblxuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdjb21wb25lbnRXaWxsTW91bnQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIGNvbXBvbmVudERpZE1vdW50IGluc3RlYWQuIEFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmQsICcgKyAneW91IGNhbiByZW5hbWUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudC4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIHNvcnRlZE5hbWVzKTtcblxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIF91bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgX3VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhfdW5pcXVlTmFtZXMpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgaW5zdGVhZC4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIF9zb3J0ZWROYW1lcyk7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX3VuaXF1ZU5hbWVzMiA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgX3VuaXF1ZU5hbWVzMi5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMiA9IHNldFRvU29ydGVkU3RyaW5nKF91bmlxdWVOYW1lczIpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIGNvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLiBBcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kLCAnICsgJ3lvdSBjYW4gcmVuYW1lIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlLicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX3NvcnRlZE5hbWVzMik7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIC8vIFRoaXMgaXMgZGlmZmljdWx0IHRvIHRyYWNrIGFueSBvdGhlciB3YXkgc2luY2UgY29tcG9uZW50IG5hbWVzXG4gICAgLy8gYXJlIG9mdGVuIHZhZ3VlIGFuZCBhcmUgbGlrZWx5IHRvIGNvbGxpZGUgYmV0d2VlbiAzcmQgcGFydHkgbGlicmFyaWVzLlxuICAgIC8vIEFuIGV4cGFuZCBwcm9wZXJ0eSBpcyBwcm9iYWJseSBva2F5IHRvIHVzZSBoZXJlIHNpbmNlIGl0J3MgREVWLW9ubHksXG4gICAgLy8gYW5kIHdpbGwgb25seSBiZSBzZXQgaW4gdGhlIGV2ZW50IG9mIHNlcmlvdXMgd2FybmluZ3MuXG4gICAgaWYgKGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzRm9yUm9vdCA9IHZvaWQgMDtcbiAgICBpZiAoIXBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5oYXMoc3RyaWN0Um9vdCkpIHtcbiAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudDogW10sXG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBbXSxcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU6IFtdXG4gICAgICB9O1xuXG4gICAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Muc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5nZXQoc3RyaWN0Um9vdCk7XG4gICAgfVxuXG4gICAgdmFyIHVuc2FmZUxpZmVjeWNsZXMgPSBbXTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSB8fCB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUgfHwgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1bnNhZmVMaWZlY3ljbGVzLnB1c2goJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUgfHwgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1bnNhZmVMaWZlY3ljbGVzLnB1c2goJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgfVxuXG4gICAgaWYgKHVuc2FmZUxpZmVjeWNsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGUpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290W2xpZmVjeWNsZV0ucHVzaChmaWJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgdmFyIHN0cmljdFJvb3QgPSBmaW5kU3RyaWN0Um9vdChmaWJlcik7XG4gICAgaWYgKHN0cmljdFJvb3QgPT09IG51bGwpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCk7XG5cbiAgICBpZiAoZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGwgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHdhcm5pbmdzRm9yUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IFtdO1xuICAgICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXksIHN0cmljdFJvb3QpIHtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG4gICAgICB2YXIgc3RyaWN0Um9vdENvbXBvbmVudFN0YWNrID0gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHN0cmljdFJvb3QpO1xuXG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZTogJXMnICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3Qtc3RyaWN0LW1vZGUtd2FybmluZ3MnLCBzdHJpY3RSb290Q29tcG9uZW50U3RhY2ssIHNvcnRlZE5hbWVzKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbi8vIFRPRE86IE9mZnNjcmVlbiB1cGRhdGVzIHNob3VsZCBuZXZlciBzdXNwZW5kLiBIb3dldmVyLCBhIHByb21pc2UgdGhhdFxuLy8gc3VzcGVuZGVkIGluc2lkZSBhbiBvZmZzY3JlZW4gc3VidHJlZSBzaG91bGQgYmUgYWJsZSB0byBwaW5nIGF0IHRoZSBwcmlvcml0eVxuLy8gb2YgdGhlIG91dGVyIHJlbmRlci5cblxuZnVuY3Rpb24gbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIElmIHRoZXJlJ3MgYSBnYXAgYmV0d2VlbiBjb21wbGV0aW5nIGEgZmFpbGVkIHJvb3QgYW5kIHJldHJ5aW5nIGl0LFxuICAvLyBhZGRpdGlvbmFsIHVwZGF0ZXMgbWF5IGJlIHNjaGVkdWxlZC4gQ2xlYXIgYGRpZEVycm9yYCwgaW4gY2FzZSB0aGUgdXBkYXRlXG4gIC8vIGlzIHN1ZmZpY2llbnQgdG8gZml4IHRoZSBlcnJvci5cbiAgcm9vdC5kaWRFcnJvciA9IGZhbHNlO1xuXG4gIC8vIFVwZGF0ZSB0aGUgbGF0ZXN0IGFuZCBlYXJsaWVzdCBwZW5kaW5nIHRpbWVzXG4gIHZhciBlYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lO1xuICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gTm8gb3RoZXIgcGVuZGluZyB1cGRhdGVzLlxuICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBlYXJsaWVzdCBwZW5kaW5nIHVwZGF0ZS5cbiAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgICAgaWYgKGxhdGVzdFBlbmRpbmdUaW1lIDwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGF0ZXN0IHBlbmRpbmcgdXBkYXRlXG4gICAgICAgIHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKGV4cGlyYXRpb25UaW1lLCByb290KTtcbn1cblxuZnVuY3Rpb24gbWFya0NvbW1pdHRlZFByaW9yaXR5TGV2ZWxzKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSkge1xuICByb290LmRpZEVycm9yID0gZmFsc2U7XG5cbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gRmFzdCBwYXRoLiBUaGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLiBDbGVhciBldmVyeXRoaW5nLlxuICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFBpbmdlZFRpbWUgPSBOb1dvcms7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTGV0J3Mgc2VlIGlmIHRoZSBwcmV2aW91cyBsYXRlc3Qga25vd24gcGVuZGluZyBsZXZlbCB3YXMganVzdCBmbHVzaGVkLlxuICB2YXIgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgIT09IE5vV29yaykge1xuICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSA8IGVhcmxpZXN0UmVtYWluaW5nVGltZSkge1xuICAgICAgLy8gV2UndmUgZmx1c2hlZCBhbGwgdGhlIGtub3duIHBlbmRpbmcgbGV2ZWxzLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gICAgICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA8IGVhcmxpZXN0UmVtYWluaW5nVGltZSkge1xuICAgICAgICAvLyBXZSd2ZSBmbHVzaGVkIHRoZSBlYXJsaWVzdCBrbm93biBwZW5kaW5nIGxldmVsLiBTZXQgdGhpcyB0byB0aGVcbiAgICAgICAgLy8gbGF0ZXN0IHBlbmRpbmcgdGltZS5cbiAgICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgbGV0J3MgaGFuZGxlIHRoZSBlYXJsaWVzdCByZW1haW5pbmcgbGV2ZWwgaW4gdGhlIHdob2xlIHRyZWUuIFdlIG5lZWQgdG9cbiAgLy8gZGVjaWRlIHdoZXRoZXIgdG8gdHJlYXQgaXQgYXMgYSBwZW5kaW5nIGxldmVsIG9yIGFzIHN1c3BlbmRlZC4gQ2hlY2tcbiAgLy8gaXQgZmFsbHMgd2l0aGluIHRoZSByYW5nZSBvZiBrbm93biBzdXNwZW5kZWQgbGV2ZWxzLlxuXG4gIHZhciBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gVGhlcmUncyBubyBzdXNwZW5kZWQgd29yay4gVHJlYXQgdGhlIGVhcmxpZXN0IHJlbWFpbmluZyBsZXZlbCBhcyBhXG4gICAgLy8gcGVuZGluZyBsZXZlbC5cbiAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lKTtcbiAgICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oTm9Xb3JrLCByb290KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZSA+IGxhdGVzdFN1c3BlbmRlZFRpbWUpIHtcbiAgICAvLyBUaGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGlzIGxhdGVyIHRoYW4gYWxsIHRoZSBzdXNwZW5kZWQgd29yay4gVGhhdFxuICAgIC8vIG1lYW5zIHdlJ3ZlIGZsdXNoZWQgYWxsIHRoZSBzdXNwZW5kZWQgd29yay5cbiAgICByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFN1c3BlbmRlZFRpbWUgPSBOb1dvcms7XG4gICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuXG4gICAgLy8gVGhlcmUncyBubyBzdXNwZW5kZWQgd29yay4gVHJlYXQgdGhlIGVhcmxpZXN0IHJlbWFpbmluZyBsZXZlbCBhcyBhXG4gICAgLy8gcGVuZGluZyBsZXZlbC5cbiAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lKTtcbiAgICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oTm9Xb3JrLCByb290KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWFybGllc3RSZW1haW5pbmdUaW1lIDwgZWFybGllc3RTdXNwZW5kZWRUaW1lKSB7XG4gICAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyB0aW1lIGlzIGVhcmxpZXIgdGhhbiBhbGwgdGhlIHN1c3BlbmRlZCB3b3JrLlxuICAgIC8vIFRyZWF0IGl0IGFzIGEgcGVuZGluZyB1cGRhdGUuXG4gICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSk7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyB0aW1lIGZhbGxzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Yga25vd24gc3VzcGVuZGVkXG4gIC8vIGxldmVscy4gV2Ugc2hvdWxkIHRyZWF0IHRoaXMgYXMgc3VzcGVuZGVkIHdvcmsuXG4gIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihOb1dvcmssIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBoYXNMb3dlclByaW9yaXR5V29yayhyb290LCBlcnJvcmVkRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGxhdGVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZTtcbiAgdmFyIGxhdGVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gIHZhciBsYXRlc3RQaW5nZWRUaW1lID0gcm9vdC5sYXRlc3RQaW5nZWRUaW1lO1xuICByZXR1cm4gbGF0ZXN0UGVuZGluZ1RpbWUgIT09IE5vV29yayAmJiBsYXRlc3RQZW5kaW5nVGltZSA+IGVycm9yZWRFeHBpcmF0aW9uVGltZSB8fCBsYXRlc3RTdXNwZW5kZWRUaW1lICE9PSBOb1dvcmsgJiYgbGF0ZXN0U3VzcGVuZGVkVGltZSA+IGVycm9yZWRFeHBpcmF0aW9uVGltZSB8fCBsYXRlc3RQaW5nZWRUaW1lICE9PSBOb1dvcmsgJiYgbGF0ZXN0UGluZ2VkVGltZSA+IGVycm9yZWRFeHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gaXNQcmlvcml0eUxldmVsU3VzcGVuZGVkKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgdmFyIGxhdGVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gIHJldHVybiBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgIT09IE5vV29yayAmJiBleHBpcmF0aW9uVGltZSA+PSBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgJiYgZXhwaXJhdGlvblRpbWUgPD0gbGF0ZXN0U3VzcGVuZGVkVGltZTtcbn1cblxuZnVuY3Rpb24gbWFya1N1c3BlbmRlZFByaW9yaXR5TGV2ZWwocm9vdCwgc3VzcGVuZGVkVGltZSkge1xuICByb290LmRpZEVycm9yID0gZmFsc2U7XG4gIGNsZWFyUGluZyhyb290LCBzdXNwZW5kZWRUaW1lKTtcblxuICAvLyBGaXJzdCwgY2hlY2sgdGhlIGtub3duIHBlbmRpbmcgbGV2ZWxzIGFuZCB1cGRhdGUgdGhlbSBpZiBuZWVkZWQuXG4gIHZhciBlYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lO1xuICB2YXIgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA9PT0gc3VzcGVuZGVkVGltZSkge1xuICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSA9PT0gc3VzcGVuZGVkVGltZSkge1xuICAgICAgLy8gQm90aCBrbm93biBwZW5kaW5nIGxldmVscyB3ZXJlIHN1c3BlbmRlZC4gQ2xlYXIgdGhlbS5cbiAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBOb1dvcms7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBlYXJsaWVzdCBwZW5kaW5nIGxldmVsIHdhcyBzdXNwZW5kZWQuIENsZWFyIGJ5IHNldHRpbmcgaXQgdG8gdGhlXG4gICAgICAvLyBsYXRlc3QgcGVuZGluZyBsZXZlbC5cbiAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IGxhdGVzdFBlbmRpbmdUaW1lO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsYXRlc3RQZW5kaW5nVGltZSA9PT0gc3VzcGVuZGVkVGltZSkge1xuICAgIC8vIFRoZSBsYXRlc3QgcGVuZGluZyBsZXZlbCB3YXMgc3VzcGVuZGVkLiBDbGVhciBieSBzZXR0aW5nIGl0IHRvIHRoZVxuICAgIC8vIGxhdGVzdCBwZW5kaW5nIGxldmVsLlxuICAgIHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBlYXJsaWVzdFBlbmRpbmdUaW1lO1xuICB9XG5cbiAgLy8gRmluYWxseSwgdXBkYXRlIHRoZSBrbm93biBzdXNwZW5kZWQgbGV2ZWxzLlxuICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIHZhciBsYXRlc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lO1xuICBpZiAoZWFybGllc3RTdXNwZW5kZWRUaW1lID09PSBOb1dvcmspIHtcbiAgICAvLyBObyBvdGhlciBzdXNwZW5kZWQgbGV2ZWxzLlxuICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWFybGllc3RTdXNwZW5kZWRUaW1lID4gc3VzcGVuZGVkVGltZSkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZWFybGllc3Qgc3VzcGVuZGVkIGxldmVsLlxuICAgICAgcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSBzdXNwZW5kZWRUaW1lO1xuICAgIH0gZWxzZSBpZiAobGF0ZXN0U3VzcGVuZGVkVGltZSA8IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGxhdGVzdCBzdXNwZW5kZWQgbGV2ZWxcbiAgICAgIHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZSA9IHN1c3BlbmRlZFRpbWU7XG4gICAgfVxuICB9XG5cbiAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKHN1c3BlbmRlZFRpbWUsIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBtYXJrUGluZ2VkUHJpb3JpdHlMZXZlbChyb290LCBwaW5nZWRUaW1lKSB7XG4gIHJvb3QuZGlkRXJyb3IgPSBmYWxzZTtcblxuICAvLyBUT0RPOiBXaGVuIHdlIGFkZCBiYWNrIHJlc3VtaW5nLCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgcHJvZ3Jlc3NlZCB3b3JrXG4gIC8vIGlzIHRocm93biBvdXQgYW5kIG5vdCByZXVzZWQgZHVyaW5nIHRoZSByZXN0YXJ0ZWQgcmVuZGVyLiBPbmUgd2F5IHRvXG4gIC8vIGludmFsaWRhdGUgdGhlIHByb2dyZXNzZWQgd29yayBpcyB0byByZXN0YXJ0IGF0IGV4cGlyYXRpb25UaW1lICsgMS5cbiAgdmFyIGxhdGVzdFBpbmdlZFRpbWUgPSByb290LmxhdGVzdFBpbmdlZFRpbWU7XG4gIGlmIChsYXRlc3RQaW5nZWRUaW1lID09PSBOb1dvcmsgfHwgbGF0ZXN0UGluZ2VkVGltZSA8IHBpbmdlZFRpbWUpIHtcbiAgICByb290LmxhdGVzdFBpbmdlZFRpbWUgPSBwaW5nZWRUaW1lO1xuICB9XG4gIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihwaW5nZWRUaW1lLCByb290KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJQaW5nKHJvb3QsIGNvbXBsZXRlZFRpbWUpIHtcbiAgLy8gVE9ETzogVHJhY2sgd2hldGhlciB0aGUgcm9vdCB3YXMgcGluZ2VkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiBzbyxcbiAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgbG9zZSB0cmFjayBvZiBpdC5cbiAgdmFyIGxhdGVzdFBpbmdlZFRpbWUgPSByb290LmxhdGVzdFBpbmdlZFRpbWU7XG4gIGlmIChsYXRlc3RQaW5nZWRUaW1lICE9PSBOb1dvcmsgJiYgbGF0ZXN0UGluZ2VkVGltZSA8PSBjb21wbGV0ZWRUaW1lKSB7XG4gICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRFYXJsaWVzdE91dHN0YW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgZWFybGllc3RFeHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuXG4gIHZhciBlYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lO1xuICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIGlmIChlYXJsaWVzdEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZWFybGllc3RQZW5kaW5nVGltZSAhPT0gTm9Xb3JrICYmIGVhcmxpZXN0UGVuZGluZ1RpbWUgPCBlYXJsaWVzdEV4cGlyYXRpb25UaW1lKSB7XG4gICAgZWFybGllc3RFeHBpcmF0aW9uVGltZSA9IGVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIH1cbiAgaWYgKGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgIT09IE5vV29yayAmJiBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPCBlYXJsaWVzdEV4cGlyYXRpb25UaW1lKSB7XG4gICAgZWFybGllc3RFeHBpcmF0aW9uVGltZSA9IGVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgfVxuICByZXR1cm4gZWFybGllc3RFeHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZGlkRXhwaXJlQXRFeHBpcmF0aW9uVGltZShyb290LCBjdXJyZW50VGltZSkge1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICBpZiAoZXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiBjdXJyZW50VGltZSA+PSBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZSByb290IGhhcyBleHBpcmVkLiBGbHVzaCBhbGwgd29yayB1cCB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgIHJvb3QubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPSBjdXJyZW50VGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oY29tcGxldGVkRXhwaXJhdGlvblRpbWUsIHJvb3QpIHtcbiAgdmFyIGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIHZhciBsYXRlc3RQaW5nZWRUaW1lID0gcm9vdC5sYXRlc3RQaW5nZWRUaW1lO1xuXG4gIC8vIFdvcmsgb24gdGhlIGVhcmxpZXN0IHBlbmRpbmcgdGltZS4gRmFpbGluZyB0aGF0LCB3b3JrIG9uIHRoZSBsYXRlc3RcbiAgLy8gcGluZ2VkIHRpbWUuXG4gIHZhciBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9IGVhcmxpZXN0UGVuZGluZ1RpbWUgIT09IE5vV29yayA/IGVhcmxpZXN0UGVuZGluZ1RpbWUgOiBsYXRlc3RQaW5nZWRUaW1lO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vIHBlbmRpbmcgb3IgcGluZ2VkIHdvcmssIGNoZWNrIGlmIHRoZXJlJ3Mgc3VzcGVuZGVkIHdvcmtcbiAgLy8gdGhhdCdzIGxvd2VyIHByaW9yaXR5IHRoYW4gd2hhdCB3ZSBqdXN0IGNvbXBsZXRlZC5cbiAgaWYgKG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID09PSBOb1dvcmsgJiYgKGNvbXBsZXRlZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbGF0ZXN0U3VzcGVuZGVkVGltZSA+IGNvbXBsZXRlZEV4cGlyYXRpb25UaW1lKSkge1xuICAgIC8vIFRoZSBsb3dlc3QgcHJpb3JpdHkgc3VzcGVuZGVkIHdvcmsgaXMgdGhlIHdvcmsgbW9zdCBsaWtlbHkgdG8gYmVcbiAgICAvLyBjb21taXR0ZWQgbmV4dC4gTGV0J3Mgc3RhcnQgcmVuZGVyaW5nIGl0IGFnYWluLCBzbyB0aGF0IGlmIGl0IHRpbWVzIG91dCxcbiAgICAvLyBpdCdzIHJlYWR5IHRvIGNvbW1pdC5cbiAgICBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9IGxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gIH1cblxuICB2YXIgZXhwaXJhdGlvblRpbWUgPSBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjtcbiAgaWYgKGV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgZWFybGllc3RTdXNwZW5kZWRUaW1lICE9PSBOb1dvcmsgJiYgZWFybGllc3RTdXNwZW5kZWRUaW1lIDwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBFeHBpcmUgdXNpbmcgdGhlIGVhcmxpZXN0IGtub3duIGV4cGlyYXRpb24gdGltZS5cbiAgICBleHBpcmF0aW9uVGltZSA9IGVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgfVxuXG4gIHJvb3QubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPSBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjtcbiAgcm9vdC5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xufVxuXG4vLyBVcGRhdGVRdWV1ZSBpcyBhIGxpbmtlZCBsaXN0IG9mIHByaW9yaXRpemVkIHVwZGF0ZXMuXG4vL1xuLy8gTGlrZSBmaWJlcnMsIHVwZGF0ZSBxdWV1ZXMgY29tZSBpbiBwYWlyczogYSBjdXJyZW50IHF1ZXVlLCB3aGljaCByZXByZXNlbnRzXG4vLyB0aGUgdmlzaWJsZSBzdGF0ZSBvZiB0aGUgc2NyZWVuLCBhbmQgYSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCB3aGljaCBpc1xuLy8gY2FuIGJlIG11dGF0ZWQgYW5kIHByb2Nlc3NlZCBhc3luY2hyb25vdXNseSBiZWZvcmUgaXQgaXMgY29tbWl0dGVkIOKAlCBhIGZvcm1cbi8vIG9mIGRvdWJsZSBidWZmZXJpbmcuIElmIGEgd29yay1pbi1wcm9ncmVzcyByZW5kZXIgaXMgZGlzY2FyZGVkIGJlZm9yZVxuLy8gZmluaXNoaW5nLCB3ZSBjcmVhdGUgYSBuZXcgd29yay1pbi1wcm9ncmVzcyBieSBjbG9uaW5nIHRoZSBjdXJyZW50IHF1ZXVlLlxuLy9cbi8vIEJvdGggcXVldWVzIHNoYXJlIGEgcGVyc2lzdGVudCwgc2luZ2x5LWxpbmtlZCBsaXN0IHN0cnVjdHVyZS4gVG8gc2NoZWR1bGUgYW5cbi8vIHVwZGF0ZSwgd2UgYXBwZW5kIGl0IHRvIHRoZSBlbmQgb2YgYm90aCBxdWV1ZXMuIEVhY2ggcXVldWUgbWFpbnRhaW5zIGFcbi8vIHBvaW50ZXIgdG8gZmlyc3QgdXBkYXRlIGluIHRoZSBwZXJzaXN0ZW50IGxpc3QgdGhhdCBoYXNuJ3QgYmVlbiBwcm9jZXNzZWQuXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBwb2ludGVyIGFsd2F5cyBoYXMgYSBwb3NpdGlvbiBlcXVhbCB0byBvciBncmVhdGVyIHRoYW5cbi8vIHRoZSBjdXJyZW50IHF1ZXVlLCBzaW5jZSB3ZSBhbHdheXMgd29yayBvbiB0aGF0IG9uZS4gVGhlIGN1cnJlbnQgcXVldWUnc1xuLy8gcG9pbnRlciBpcyBvbmx5IHVwZGF0ZWQgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIHdoZW4gd2Ugc3dhcCBpbiB0aGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MuXG4vL1xuLy8gRm9yIGV4YW1wbGU6XG4vL1xuLy8gICBDdXJyZW50IHBvaW50ZXI6ICAgICAgICAgICBBIC0gQiAtIEMgLSBEIC0gRSAtIEZcbi8vICAgV29yay1pbi1wcm9ncmVzcyBwb2ludGVyOiAgICAgICAgICAgICAgRCAtIEUgLSBGXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaGFzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZCBtb3JlIHVwZGF0ZXMgdGhhbiBjdXJyZW50LlxuLy9cbi8vIFRoZSByZWFzb24gd2UgYXBwZW5kIHRvIGJvdGggcXVldWVzIGlzIGJlY2F1c2Ugb3RoZXJ3aXNlIHdlIG1pZ2h0IGRyb3Bcbi8vIHVwZGF0ZXMgd2l0aG91dCBldmVyIHByb2Nlc3NpbmcgdGhlbS4gRm9yIGV4YW1wbGUsIGlmIHdlIG9ubHkgYWRkIHVwZGF0ZXMgdG9cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBzb21lIHVwZGF0ZXMgY291bGQgYmUgbG9zdCB3aGVuZXZlciBhIHdvcmstaW5cbi8vIC1wcm9ncmVzcyByZW5kZXIgcmVzdGFydHMgYnkgY2xvbmluZyBmcm9tIGN1cnJlbnQuIFNpbWlsYXJseSwgaWYgd2Ugb25seSBhZGRcbi8vIHVwZGF0ZXMgdG8gdGhlIGN1cnJlbnQgcXVldWUsIHRoZSB1cGRhdGVzIHdpbGwgYmUgbG9zdCB3aGVuZXZlciBhbiBhbHJlYWR5XG4vLyBpbi1wcm9ncmVzcyBxdWV1ZSBjb21taXRzIGFuZCBzd2FwcyB3aXRoIHRoZSBjdXJyZW50IHF1ZXVlLiBIb3dldmVyLCBieVxuLy8gYWRkaW5nIHRvIGJvdGggcXVldWVzLCB3ZSBndWFyYW50ZWUgdGhhdCB0aGUgdXBkYXRlIHdpbGwgYmUgcGFydCBvZiB0aGUgbmV4dFxuLy8gd29yay1pbi1wcm9ncmVzcy4gKEFuZCBiZWNhdXNlIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGJlY29tZXMgdGhlXG4vLyBjdXJyZW50IHF1ZXVlIG9uY2UgaXQgY29tbWl0cywgdGhlcmUncyBubyBkYW5nZXIgb2YgYXBwbHlpbmcgdGhlIHNhbWVcbi8vIHVwZGF0ZSB0d2ljZS4pXG4vL1xuLy8gUHJpb3JpdGl6YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gVXBkYXRlcyBhcmUgbm90IHNvcnRlZCBieSBwcmlvcml0eSwgYnV0IGJ5IGluc2VydGlvbjsgbmV3IHVwZGF0ZXMgYXJlIGFsd2F5c1xuLy8gYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbi8vXG4vLyBUaGUgcHJpb3JpdHkgaXMgc3RpbGwgaW1wb3J0YW50LCB0aG91Z2guIFdoZW4gcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlXG4vLyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgb25seSB0aGUgdXBkYXRlcyB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkgYXJlXG4vLyBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0LiBJZiB3ZSBza2lwIGFuIHVwZGF0ZSBiZWNhdXNlIGl0IGhhcyBpbnN1ZmZpY2llbnRcbi8vIHByaW9yaXR5LCBpdCByZW1haW5zIGluIHRoZSBxdWV1ZSB0byBiZSBwcm9jZXNzZWQgbGF0ZXIsIGR1cmluZyBhIGxvd2VyXG4vLyBwcmlvcml0eSByZW5kZXIuIENydWNpYWxseSwgYWxsIHVwZGF0ZXMgc3Vic2VxdWVudCB0byBhIHNraXBwZWQgdXBkYXRlIGFsc29cbi8vIHJlbWFpbiBpbiB0aGUgcXVldWUgKnJlZ2FyZGxlc3Mgb2YgdGhlaXIgcHJpb3JpdHkqLiBUaGF0IG1lYW5zIGhpZ2ggcHJpb3JpdHlcbi8vIHVwZGF0ZXMgYXJlIHNvbWV0aW1lcyBwcm9jZXNzZWQgdHdpY2UsIGF0IHR3byBzZXBhcmF0ZSBwcmlvcml0aWVzLiBXZSBhbHNvXG4vLyBrZWVwIHRyYWNrIG9mIGEgYmFzZSBzdGF0ZSwgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBiZWZvcmUgdGhlIGZpcnN0XG4vLyB1cGRhdGUgaW4gdGhlIHF1ZXVlIGlzIGFwcGxpZWQuXG4vL1xuLy8gRm9yIGV4YW1wbGU6XG4vL1xuLy8gICBHaXZlbiBhIGJhc2Ugc3RhdGUgb2YgJycsIGFuZCB0aGUgZm9sbG93aW5nIHF1ZXVlIG9mIHVwZGF0ZXNcbi8vXG4vLyAgICAgQTEgLSBCMiAtIEMxIC0gRDJcbi8vXG4vLyAgIHdoZXJlIHRoZSBudW1iZXIgaW5kaWNhdGVzIHRoZSBwcmlvcml0eSwgYW5kIHRoZSB1cGRhdGUgaXMgYXBwbGllZCB0byB0aGVcbi8vICAgcHJldmlvdXMgc3RhdGUgYnkgYXBwZW5kaW5nIGEgbGV0dGVyLCBSZWFjdCB3aWxsIHByb2Nlc3MgdGhlc2UgdXBkYXRlcyBhc1xuLy8gICB0d28gc2VwYXJhdGUgcmVuZGVycywgb25lIHBlciBkaXN0aW5jdCBwcmlvcml0eSBsZXZlbDpcbi8vXG4vLyAgIEZpcnN0IHJlbmRlciwgYXQgcHJpb3JpdHkgMTpcbi8vICAgICBCYXNlIHN0YXRlOiAnJ1xuLy8gICAgIFVwZGF0ZXM6IFtBMSwgQzFdXG4vLyAgICAgUmVzdWx0IHN0YXRlOiAnQUMnXG4vL1xuLy8gICBTZWNvbmQgcmVuZGVyLCBhdCBwcmlvcml0eSAyOlxuLy8gICAgIEJhc2Ugc3RhdGU6ICdBJyAgICAgICAgICAgIDwtICBUaGUgYmFzZSBzdGF0ZSBkb2VzIG5vdCBpbmNsdWRlIEMxLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWNhdXNlIEIyIHdhcyBza2lwcGVkLlxuLy8gICAgIFVwZGF0ZXM6IFtCMiwgQzEsIEQyXSAgICAgIDwtICBDMSB3YXMgcmViYXNlZCBvbiB0b3Agb2YgQjJcbi8vICAgICBSZXN1bHQgc3RhdGU6ICdBQkNEJ1xuLy9cbi8vIEJlY2F1c2Ugd2UgcHJvY2VzcyB1cGRhdGVzIGluIGluc2VydGlvbiBvcmRlciwgYW5kIHJlYmFzZSBoaWdoIHByaW9yaXR5XG4vLyB1cGRhdGVzIHdoZW4gcHJlY2VkaW5nIHVwZGF0ZXMgYXJlIHNraXBwZWQsIHRoZSBmaW5hbCByZXN1bHQgaXMgZGV0ZXJtaW5pc3RpY1xuLy8gcmVnYXJkbGVzcyBvZiBwcmlvcml0eS4gSW50ZXJtZWRpYXRlIHN0YXRlIG1heSB2YXJ5IGFjY29yZGluZyB0byBzeXN0ZW1cbi8vIHJlc291cmNlcywgYnV0IHRoZSBmaW5hbCBzdGF0ZSBpcyBhbHdheXMgdGhlIHNhbWUuXG5cbnZhciBVcGRhdGVTdGF0ZSA9IDA7XG52YXIgUmVwbGFjZVN0YXRlID0gMTtcbnZhciBGb3JjZVVwZGF0ZSA9IDI7XG52YXIgQ2FwdHVyZVVwZGF0ZSA9IDM7XG5cbi8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG52YXIgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxudmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB2b2lkIDA7XG52YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gdm9pZCAwO1xudmFyIHJlc2V0Q3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gdm9pZCAwO1xue1xuICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG4gIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIHJlc2V0Q3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZVF1ZXVlKGJhc2VTdGF0ZSkge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBiYXNlU3RhdGUsXG4gICAgZmlyc3RVcGRhdGU6IG51bGwsXG4gICAgbGFzdFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdENhcHR1cmVkVXBkYXRlOiBudWxsLFxuICAgIGxhc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuICAgIGZpcnN0Q2FwdHVyZWRFZmZlY3Q6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkRWZmZWN0OiBudWxsXG4gIH07XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50UXVldWUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICBmaXJzdFVwZGF0ZTogY3VycmVudFF1ZXVlLmZpcnN0VXBkYXRlLFxuICAgIGxhc3RVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0VXBkYXRlLFxuXG4gICAgLy8gVE9ETzogV2l0aCByZXN1bWluZywgaWYgd2UgYmFpbCBvdXQgYW5kIHJlc3VzZSB0aGUgY2hpbGQgdHJlZSwgd2Ugc2hvdWxkXG4gICAgLy8ga2VlcCB0aGVzZSBlZmZlY3RzLlxuICAgIGZpcnN0Q2FwdHVyZWRVcGRhdGU6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkVXBkYXRlOiBudWxsLFxuXG4gICAgZmlyc3RFZmZlY3Q6IG51bGwsXG4gICAgbGFzdEVmZmVjdDogbnVsbCxcblxuICAgIGZpcnN0Q2FwdHVyZWRFZmZlY3Q6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkRWZmZWN0OiBudWxsXG4gIH07XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiB7XG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuXG4gICAgdGFnOiBVcGRhdGVTdGF0ZSxcbiAgICBwYXlsb2FkOiBudWxsLFxuICAgIGNhbGxiYWNrOiBudWxsLFxuXG4gICAgbmV4dDogbnVsbCxcbiAgICBuZXh0RWZmZWN0OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3RVcGRhdGUgPSBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3RVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSkge1xuICAvLyBVcGRhdGUgcXVldWVzIGFyZSBjcmVhdGVkIGxhemlseS5cbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IHZvaWQgMDtcbiAgdmFyIHF1ZXVlMiA9IHZvaWQgMDtcbiAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgb25seSBvbmUgZmliZXIuXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKGZpYmVyLm1lbW9pemVkU3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBhcmUgdHdvIG93bmVycy5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICBxdWV1ZTIgPSBhbHRlcm5hdGUudXBkYXRlUXVldWU7XG4gICAgaWYgKHF1ZXVlMSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBOZWl0aGVyIGZpYmVyIGhhcyBhbiB1cGRhdGUgcXVldWUuIENyZWF0ZSBuZXcgb25lcy5cbiAgICAgICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShmaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgcXVldWUyID0gYWx0ZXJuYXRlLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT25seSBvbmUgZmliZXIgaGFzIGFuIHVwZGF0ZSBxdWV1ZS4gQ2xvbmUgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjbG9uZVVwZGF0ZVF1ZXVlKHF1ZXVlMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gT25seSBvbmUgZmliZXIgaGFzIGFuIHVwZGF0ZSBxdWV1ZS4gQ2xvbmUgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgcXVldWUyID0gYWx0ZXJuYXRlLnVwZGF0ZVF1ZXVlID0gY2xvbmVVcGRhdGVRdWV1ZShxdWV1ZTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQm90aCBvd25lcnMgaGF2ZSBhbiB1cGRhdGUgcXVldWUuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChxdWV1ZTIgPT09IG51bGwgfHwgcXVldWUxID09PSBxdWV1ZTIpIHtcbiAgICAvLyBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgcXVldWUuXG4gICAgYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUgYXJlIHR3byBxdWV1ZXMuIFdlIG5lZWQgdG8gYXBwZW5kIHRoZSB1cGRhdGUgdG8gYm90aCBxdWV1ZXMsXG4gICAgLy8gd2hpbGUgYWNjb3VudGluZyBmb3IgdGhlIHBlcnNpc3RlbnQgc3RydWN0dXJlIG9mIHRoZSBsaXN0IOKAlCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdGhlIHNhbWUgdXBkYXRlIHRvIGJlIGFkZGVkIG11bHRpcGxlIHRpbWVzLlxuICAgIGlmIChxdWV1ZTEubGFzdFVwZGF0ZSA9PT0gbnVsbCB8fCBxdWV1ZTIubGFzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gT25lIG9mIHRoZSBxdWV1ZXMgaXMgbm90IGVtcHR5LiBXZSBtdXN0IGFkZCB0aGUgdXBkYXRlIHRvIGJvdGggcXVldWVzLlxuICAgICAgYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgICBhcHBlbmRVcGRhdGVUb1F1ZXVlKHF1ZXVlMiwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBxdWV1ZXMgYXJlIG5vbi1lbXB0eS4gVGhlIGxhc3QgdXBkYXRlIGlzIHRoZSBzYW1lIGluIGJvdGggbGlzdHMsXG4gICAgICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIG9ubHkgYXBwZW5kIHRvIG9uZSBvZiB0aGUgbGlzdHMuXG4gICAgICBhcHBlbmRVcGRhdGVUb1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICAgIC8vIEJ1dCB3ZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSB0aGUgYGxhc3RVcGRhdGVgIHBvaW50ZXIgb2YgcXVldWUyLlxuICAgICAgcXVldWUyLmxhc3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmICgoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50TGF6eSkgJiYgKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gcXVldWUxIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHF1ZXVlMikgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSkge1xuICAvLyBDYXB0dXJlZCB1cGRhdGVzIGdvIGludG8gYSBzZXBhcmF0ZSBsaXN0LCBhbmQgb25seSBvbiB0aGUgd29yay1pbi1cbiAgLy8gcHJvZ3Jlc3MgcXVldWUuXG4gIHZhciB3b3JrSW5Qcm9ncmVzc1F1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1F1ZXVlID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETzogSSBwdXQgdGhpcyBoZXJlIHJhdGhlciB0aGFuIGNyZWF0ZVdvcmtJblByb2dyZXNzIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBjbG9uZSB0aGUgcXVldWUgdW5uZWNlc3NhcmlseS4gVGhlcmUncyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG9cbiAgICAvLyBzdHJ1Y3R1cmUgdGhpcy5cbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlID0gZW5zdXJlV29ya0luUHJvZ3Jlc3NRdWV1ZUlzQUNsb25lKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzc1F1ZXVlKTtcbiAgfVxuXG4gIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1F1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBwaGFzZSB1cGRhdGVcbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGUgPSB3b3JrSW5Qcm9ncmVzc1F1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIHdvcmtJblByb2dyZXNzUXVldWUubGFzdENhcHR1cmVkVXBkYXRlID0gdXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVdvcmtJblByb2dyZXNzUXVldWVJc0FDbG9uZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUpIHtcbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gSWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgcXVldWUsXG4gICAgLy8gd2UgbmVlZCB0byBjbG9uZSBpdCBmaXJzdC5cbiAgICBpZiAocXVldWUgPT09IGN1cnJlbnQudXBkYXRlUXVldWUpIHtcbiAgICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjbG9uZVVwZGF0ZVF1ZXVlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG4gICAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGF0ZSBvYmplY3RcbiAgICAgICAgcmV0dXJuIF9wYXlsb2FkO1xuICAgICAgfVxuICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBVcGRhdGVTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkMiA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkMiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgICAgX3BheWxvYWQyLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQyLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQYXJ0aWFsIHN0YXRlIG9iamVjdFxuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAgICAgIHJldHVybiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBwcmV2U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICBxdWV1ZSA9IGVuc3VyZVdvcmtJblByb2dyZXNzUXVldWVJc0FDbG9uZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUpO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZTtcbiAgfVxuXG4gIC8vIFRoZXNlIHZhbHVlcyBtYXkgY2hhbmdlIGFzIHdlIHByb2Nlc3MgdGhlIHF1ZXVlLlxuICB2YXIgbmV3QmFzZVN0YXRlID0gcXVldWUuYmFzZVN0YXRlO1xuICB2YXIgbmV3Rmlyc3RVcGRhdGUgPSBudWxsO1xuICB2YXIgbmV3RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIHVwZGF0ZXMgdG8gY29tcHV0ZSB0aGUgcmVzdWx0LlxuICB2YXIgdXBkYXRlID0gcXVldWUuZmlyc3RVcGRhdGU7XG4gIHZhciByZXN1bHRTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAodXBkYXRlRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBub3QgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBTa2lwIGl0LlxuICAgICAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHNraXBwZWQgdXBkYXRlLiBJdCB3aWxsIGJlIHRoZSBmaXJzdCB1cGRhdGUgaW5cbiAgICAgICAgLy8gdGhlIG5ldyBsaXN0LlxuICAgICAgICBuZXdGaXJzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgLy8gU2luY2UgdGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHRoYXQgd2FzIHNraXBwZWQsIHRoZSBjdXJyZW50IHJlc3VsdFxuICAgICAgICAvLyBpcyB0aGUgbmV3IGJhc2Ugc3RhdGUuXG4gICAgICAgIG5ld0Jhc2VTdGF0ZSA9IHJlc3VsdFN0YXRlO1xuICAgICAgfVxuICAgICAgLy8gU2luY2UgdGhpcyB1cGRhdGUgd2lsbCByZW1haW4gaW4gdGhlIGxpc3QsIHVwZGF0ZSB0aGUgcmVtYWluaW5nXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobmV3RXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXdFeHBpcmF0aW9uVGltZSA+IHVwZGF0ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBQcm9jZXNzIGl0IGFuZCBjb21wdXRlXG4gICAgICAvLyBhIG5ldyByZXN1bHQuXG4gICAgICByZXN1bHRTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcmVzdWx0U3RhdGUsIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgICB2YXIgX2NhbGxiYWNrID0gdXBkYXRlLmNhbGxiYWNrO1xuICAgICAgaWYgKF9jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ2FsbGJhY2s7XG4gICAgICAgIC8vIFNldCB0aGlzIHRvIG51bGwsIGluIGNhc2UgaXQgd2FzIG11dGF0ZWQgZHVyaW5nIGFuIGFib3J0ZWQgcmVuZGVyLlxuICAgICAgICB1cGRhdGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgIGlmIChxdWV1ZS5sYXN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcXVldWUuZmlyc3RFZmZlY3QgPSBxdWV1ZS5sYXN0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXVlLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHVwZGF0ZTtcbiAgICAgICAgICBxdWV1ZS5sYXN0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENvbnRpbnVlIHRvIHRoZSBuZXh0IHVwZGF0ZS5cbiAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgfVxuXG4gIC8vIFNlcGFyYXRlbHksIGl0ZXJhdGUgdGhvdWdoIHRoZSBsaXN0IG9mIGNhcHR1cmVkIHVwZGF0ZXMuXG4gIHZhciBuZXdGaXJzdENhcHR1cmVkVXBkYXRlID0gbnVsbDtcbiAgdXBkYXRlID0gcXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZTtcbiAgd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIHZhciBfdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKF91cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICBpZiAobmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBza2lwcGVkIGNhcHR1cmVkIHVwZGF0ZS4gSXQgd2lsbCBiZSB0aGUgZmlyc3RcbiAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBuZXcgbGlzdC5cbiAgICAgICAgbmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHRoYXQgd2FzIHNraXBwZWQsIHRoZSBjdXJyZW50IHJlc3VsdCBpc1xuICAgICAgICAvLyB0aGUgbmV3IGJhc2Ugc3RhdGUuXG4gICAgICAgIGlmIChuZXdGaXJzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IHJlc3VsdFN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSB0aGlzIHVwZGF0ZSB3aWxsIHJlbWFpbiBpbiB0aGUgbGlzdCwgdXBkYXRlIHRoZSByZW1haW5pbmdcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gX3VwZGF0ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gX3VwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gUHJvY2VzcyBpdCBhbmQgY29tcHV0ZVxuICAgICAgLy8gYSBuZXcgcmVzdWx0LlxuICAgICAgcmVzdWx0U3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHJlc3VsdFN0YXRlLCBwcm9wcywgaW5zdGFuY2UpO1xuICAgICAgdmFyIF9jYWxsYmFjazIgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgICBpZiAoX2NhbGxiYWNrMiAhPT0gbnVsbCkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ2FsbGJhY2s7XG4gICAgICAgIC8vIFNldCB0aGlzIHRvIG51bGwsIGluIGNhc2UgaXQgd2FzIG11dGF0ZWQgZHVyaW5nIGFuIGFib3J0ZWQgcmVuZGVyLlxuICAgICAgICB1cGRhdGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgIGlmIChxdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBxdWV1ZS5maXJzdENhcHR1cmVkRWZmZWN0ID0gcXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdC5uZXh0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdCA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgfVxuXG4gIGlmIChuZXdGaXJzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIHF1ZXVlLmxhc3RVcGRhdGUgPSBudWxsO1xuICB9XG4gIGlmIChuZXdGaXJzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUubGFzdENhcHR1cmVkVXBkYXRlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ2FsbGJhY2s7XG4gIH1cbiAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsICYmIG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPT09IG51bGwpIHtcbiAgICAvLyBXZSBwcm9jZXNzZWQgZXZlcnkgdXBkYXRlLCB3aXRob3V0IHNraXBwaW5nLiBUaGF0IG1lYW5zIHRoZSBuZXcgYmFzZVxuICAgIC8vIHN0YXRlIGlzIHRoZSBzYW1lIGFzIHRoZSByZXN1bHQgc3RhdGUuXG4gICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gIH1cblxuICBxdWV1ZS5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gIHF1ZXVlLmZpcnN0VXBkYXRlID0gbmV3Rmlyc3RVcGRhdGU7XG4gIHF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBuZXdGaXJzdENhcHR1cmVkVXBkYXRlO1xuXG4gIC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAvLyBUaGlzIHNob3VsZCBiZSBmaW5lIGJlY2F1c2UgdGhlIG9ubHkgdHdvIG90aGVyIHRoaW5ncyB0aGF0IGNvbnRyaWJ1dGUgdG9cbiAgLy8gZXhwaXJhdGlvbiB0aW1lIGFyZSBwcm9wcyBhbmQgY29udGV4dC4gV2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIHRoZVxuICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAvLyBkZWFsdCB3aXRoIHRoZSBwcm9wcy4gQ29udGV4dCBpbiBjb21wb25lbnRzIHRoYXQgc3BlY2lmeVxuICAvLyBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdHJpY2t5OyBidXQgd2UnbGwgaGF2ZSB0byBhY2NvdW50IGZvclxuICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSByZXN1bHRTdGF0ZTtcblxuICB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsbGJhY2spIDogdm9pZCAwO1xuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHtcbiAgcmV0dXJuIGhhc0ZvcmNlVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIGZpbmlzaGVkUXVldWUsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAvLyBJZiB0aGUgZmluaXNoZWQgcmVuZGVyIGluY2x1ZGVkIGNhcHR1cmVkIHVwZGF0ZXMsIGFuZCB0aGVyZSBhcmUgc3RpbGxcbiAgLy8gbG93ZXIgcHJpb3JpdHkgdXBkYXRlcyBsZWZ0IG92ZXIsIHdlIG5lZWQgdG8ga2VlcCB0aGUgY2FwdHVyZWQgdXBkYXRlc1xuICAvLyBpbiB0aGUgcXVldWUgc28gdGhhdCB0aGV5IGFyZSByZWJhc2VkIGFuZCBub3QgZHJvcHBlZCBvbmNlIHdlIHByb2Nlc3MgdGhlXG4gIC8vIHF1ZXVlIGFnYWluIGF0IHRoZSBsb3dlciBwcmlvcml0eS5cbiAgaWYgKGZpbmlzaGVkUXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEpvaW4gdGhlIGNhcHR1cmVkIHVwZGF0ZSBsaXN0IHRvIHRoZSBlbmQgb2YgdGhlIG5vcm1hbCBsaXN0LlxuICAgIGlmIChmaW5pc2hlZFF1ZXVlLmxhc3RVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaGVkUXVldWUubGFzdFVwZGF0ZS5uZXh0ID0gZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlO1xuICAgICAgZmluaXNoZWRRdWV1ZS5sYXN0VXBkYXRlID0gZmluaXNoZWRRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGU7XG4gICAgfVxuICAgIC8vIENsZWFyIHRoZSBsaXN0IG9mIGNhcHR1cmVkIHVwZGF0ZXMuXG4gICAgZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlID0gZmluaXNoZWRRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB9XG5cbiAgLy8gQ29tbWl0IHRoZSBlZmZlY3RzXG4gIGNvbW1pdFVwZGF0ZUVmZmVjdHMoZmluaXNoZWRRdWV1ZS5maXJzdEVmZmVjdCwgaW5zdGFuY2UpO1xuICBmaW5pc2hlZFF1ZXVlLmZpcnN0RWZmZWN0ID0gZmluaXNoZWRRdWV1ZS5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICBjb21taXRVcGRhdGVFZmZlY3RzKGZpbmlzaGVkUXVldWUuZmlyc3RDYXB0dXJlZEVmZmVjdCwgaW5zdGFuY2UpO1xuICBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRFZmZlY3QgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZUVmZmVjdHMoZWZmZWN0LCBpbnN0YW5jZSkge1xuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9jYWxsYmFjazMgPSBlZmZlY3QuY2FsbGJhY2s7XG4gICAgaWYgKF9jYWxsYmFjazMgIT09IG51bGwpIHtcbiAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjYWxsQ2FsbGJhY2soX2NhbGxiYWNrMywgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2UpIHtcbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4gIC8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gIH07XG59XG5cbnZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcblxudmFyIHJlbmRlcmVyU2lnaWwgPSB2b2lkIDA7XG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG52YXIgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbnZhciBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNlcygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBuZXh0VmFsdWUpIHtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG5cbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB7XG4gICAgICAhKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9PT0gdW5kZWZpbmVkIHx8IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9PT0gbnVsbCB8fCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IHJlbmRlcmVyU2lnaWwpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsIHByb3ZpZGVyRmliZXIpO1xuXG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5leHRWYWx1ZTtcbiAgICB7XG4gICAgICAhKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IHVuZGVmaW5lZCB8fCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID09PSBudWxsIHx8IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IHJlbmRlcmVyU2lnaWwpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BQcm92aWRlcihwcm92aWRlckZpYmVyKSB7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuXG4gIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG5cbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG4gIGlmIChpc1ByaW1hcnlSZW5kZXJlcikge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKGNvbnRleHQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAvLyBVc2UgT2JqZWN0LmlzIHRvIGNvbXBhcmUgdGhlIG5ldyBjb250ZXh0IHZhbHVlIHRvIHRoZSBvbGQgdmFsdWUuIElubGluZWRcbiAgLy8gT2JqZWN0LmlzIHBvbHlmaWxsLlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgaWYgKG9sZFZhbHVlID09PSBuZXdWYWx1ZSAmJiAob2xkVmFsdWUgIT09IDAgfHwgMSAvIG9sZFZhbHVlID09PSAxIC8gbmV3VmFsdWUpIHx8IG9sZFZhbHVlICE9PSBvbGRWYWx1ZSAmJiBuZXdWYWx1ZSAhPT0gbmV3VmFsdWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgKSB7XG4gICAgICAvLyBObyBjaGFuZ2VcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgdmFyIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IG1heFNpZ25lZDMxQml0SW50O1xuXG4gICAge1xuICAgICAgISgoY2hhbmdlZEJpdHMgJiBtYXhTaWduZWQzMUJpdEludCkgPT09IGNoYW5nZWRCaXRzKSA/IHdhcm5pbmckMShmYWxzZSwgJ2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBFeHBlY3RlZCB0aGUgcmV0dXJuIHZhbHVlIHRvIGJlIGEgJyArICczMS1iaXQgaW50ZWdlci4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkQml0cyB8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dEZpYmVyID0gdm9pZCAwO1xuXG4gICAgLy8gVmlzaXQgdGhpcyBmaWJlci5cbiAgICB2YXIgZGVwZW5kZW5jeSA9IGZpYmVyLmZpcnN0Q29udGV4dERlcGVuZGVuY3k7XG4gICAgaWYgKGRlcGVuZGVuY3kgIT09IG51bGwpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRleHQgbWF0Y2hlcy5cbiAgICAgICAgaWYgKGRlcGVuZGVuY3kuY29udGV4dCA9PT0gY29udGV4dCAmJiAoZGVwZW5kZW5jeS5vYnNlcnZlZEJpdHMgJiBjaGFuZ2VkQml0cykgIT09IDApIHtcbiAgICAgICAgICAvLyBNYXRjaCEgU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoaXMgZmliZXIuXG5cbiAgICAgICAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50TGF6eSkge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBmb3JjZSB1cGRhdGUgb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MuXG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcbiAgICAgICAgICAgIC8vIFRPRE86IEJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHdvcmstaW4tcHJvZ3Jlc3MsIHRoaXMgd2lsbCBhZGQgdGhlXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgZmliZXIsIHRvbywgd2hpY2ggbWVhbnMgaXQgd2lsbCBwZXJzaXN0IGV2ZW4gaWZcbiAgICAgICAgICAgIC8vIHRoaXMgcmVuZGVyIGlzIHRocm93biBhd2F5LiBTaW5jZSBpdCdzIGEgcmFjZSBjb25kaXRpb24sIG5vdCBzdXJlIGl0J3NcbiAgICAgICAgICAgIC8vIHdvcnRoIGZpeGluZy5cbiAgICAgICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZpYmVyLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZmliZXIuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIChhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZSBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nXG4gICAgICAgICAgLy8gdGhlIGFsdGVybmF0ZXMuXG4gICAgICAgICAgdmFyIG5vZGUgPSBmaWJlci5yZXR1cm47XG4gICAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICAgIG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIChhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgKGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5laXRoZXIgYWx0ZXJuYXRlIHdhcyB1cGRhdGVkLCB3aGljaCBtZWFucyB0aGUgcmVzdCBvZiB0aGVcbiAgICAgICAgICAgICAgLy8gYW5jZXN0b3IgcGF0aCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9IHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKTtcbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAvLyBEb24ndCBzY2FuIGRlZXBlciBpZiB0aGlzIGlzIGEgbWF0Y2hpbmcgcHJvdmlkZXJcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnR5cGUgPT09IHdvcmtJblByb2dyZXNzLnR5cGUgPyBudWxsIDogZmliZXIuY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIC8vIFdlJ3JlIGJhY2sgdG8gdGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlLiBFeGl0LlxuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXh0RmliZXIuc2libGluZztcbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgbGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID0gbnVsbDtcblxuICAvLyBSZXNldCB0aGUgd29yay1pbi1wcm9ncmVzcyBsaXN0XG4gIHdvcmtJblByb2dyZXNzLmZpcnN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgaWYgKGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9PT0gY29udGV4dCkge1xuICAgIC8vIE5vdGhpbmcgdG8gZG8uIFdlIGFscmVhZHkgb2JzZXJ2ZSBldmVyeXRoaW5nIGluIHRoaXMgY29udGV4dC5cbiAgfSBlbHNlIGlmIChvYnNlcnZlZEJpdHMgPT09IGZhbHNlIHx8IG9ic2VydmVkQml0cyA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBvYnNlcnZlIGFueSB1cGRhdGVzLlxuICB9IGVsc2Uge1xuICAgIHZhciByZXNvbHZlZE9ic2VydmVkQml0cyA9IHZvaWQgMDsgLy8gQXZvaWQgZGVvcHRpbmcgb24gb2JzZXJ2YWJsZSBhcmd1bWVudHMgb3IgaGV0ZXJvZ2VuZW91cyB0eXBlcy5cbiAgICBpZiAodHlwZW9mIG9ic2VydmVkQml0cyAhPT0gJ251bWJlcicgfHwgb2JzZXJ2ZWRCaXRzID09PSBtYXhTaWduZWQzMUJpdEludCkge1xuICAgICAgLy8gT2JzZXJ2ZSBhbGwgdXBkYXRlcy5cbiAgICAgIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IGNvbnRleHQ7XG4gICAgICByZXNvbHZlZE9ic2VydmVkQml0cyA9IG1heFNpZ25lZDMxQml0SW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlZE9ic2VydmVkQml0cyA9IG9ic2VydmVkQml0cztcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dEl0ZW0gPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgb2JzZXJ2ZWRCaXRzOiByZXNvbHZlZE9ic2VydmVkQml0cyxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9PT0gbnVsbCkge1xuICAgICAgIShjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDb250ZXh0LnVuc3RhYmxlX3JlYWQoKTogQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZywgZS5nLiBpbnNpZGUgdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLicpIDogdm9pZCAwO1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBpbiB0aGUgbGlzdFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZmlyc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHRJdGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgYSBuZXcgY29udGV4dCBpdGVtLlxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0SXRlbTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzUHJpbWFyeVJlbmRlcmVyID8gY29udGV4dC5fY3VycmVudFZhbHVlIDogY29udGV4dC5fY3VycmVudFZhbHVlMjtcbn1cblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIGNvbnRleHRTdGFja0N1cnNvciQxID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG5mdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAhKGMgIT09IE5PX0NPTlRFWFQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG4gIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuXG4gIC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcbiAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHZhciBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSwgcm9vdEluc3RhbmNlKTtcblxuICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxudmFyIGNvbW1pdFRpbWUgPSAwO1xudmFyIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG5cbmZ1bmN0aW9uIGdldENvbW1pdFRpbWUoKSB7XG4gIHJldHVybiBjb21taXRUaW1lO1xufVxuXG5mdW5jdGlvbiByZWNvcmRDb21taXRUaW1lKCkge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tbWl0VGltZSA9IHNjaGVkdWxlLnVuc3RhYmxlX25vdygpO1xufVxuXG5mdW5jdGlvbiBzdGFydFByb2ZpbGVyVGltZXIoZmliZXIpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBzY2hlZHVsZS51bnN0YWJsZV9ub3coKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IHNjaGVkdWxlLnVuc3RhYmxlX25vdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKGZpYmVyKSB7XG4gIGlmICghZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGZpYmVyLCBvdmVycmlkZUJhc2VUaW1lKSB7XG4gIGlmICghZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcm9maWxlclN0YXJ0VGltZSA+PSAwKSB7XG4gICAgdmFyIGVsYXBzZWRUaW1lID0gc2NoZWR1bGUudW5zdGFibGVfbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICBpZiAob3ZlcnJpZGVCYXNlVGltZSkge1xuICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgIH1cbiAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vLyBSZWFjdC5Db21wb25lbnQgdXNlcyBhIHNoYXJlZCBmcm96ZW4gb2JqZWN0IGJ5IGRlZmF1bHQuXG4vLyBXZSdsbCB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UgbmVlZCB0byBpbml0aWFsaXplIGxlZ2FjeSByZWZzLlxudmFyIGVtcHR5UmVmc09iamVjdCA9IG5ldyBSZWFjdC5Db21wb25lbnQoKS5yZWZzO1xuXG52YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSB2b2lkIDA7XG52YXIgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gdm9pZCAwO1xudmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayQxID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gdm9pZCAwO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG5cbiAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGtleSA9IGNhbGxlck5hbWUgKyAnXycgKyBjYWxsYmFjaztcbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gZnVuY3Rpb24gKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0IGEgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc25cXCd0IHN1cHBvcnRlZC4gVHJ5IHRvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoIHRvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICB7XG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcblxuICB7XG4gICAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IsIHBhcnRpYWxTdGF0ZSk7XG4gIH1cbiAgLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuXG4gIC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcik7XG5cbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBjdXJyZW50VGltZSA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGZpYmVyKTtcblxuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAgIHVwZGF0ZS50YWcgPSBSZXBsYWNlU3RhdGU7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH0sXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBjdXJyZW50VGltZSA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGZpYmVyKTtcblxuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dExlZ2FjeUNvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIHtcbiAgICAgICEoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPSAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0YW5jZS5zdGF0ZTtcbiAgICAhbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICFub0dldERlZmF1bHRQcm9wc09uRVM2ID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VQcm9wVHlwZXMgPSAhaW5zdGFuY2UucHJvcFR5cGVzO1xuICAgICFub0luc3RhbmNlUHJvcFR5cGVzID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgICFub0luc3RhbmNlQ29udGV4dFR5cGVzID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG4gICAgdmFyIG5vQ29tcG9uZW50RGlkVW5tb3VudCA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nO1xuICAgICFub0NvbXBvbmVudERpZFVubW91bnQgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICFub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBub1Vuc2FmZUNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vVW5zYWZlQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IG5ld1Byb3BzO1xuICAgICEoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZURlZmF1bHRQcm9wcyA9ICFpbnN0YW5jZS5kZWZhdWx0UHJvcHM7XG4gICAgIW5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKSA6IHZvaWQgMDtcblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSk7XG4gICAgfVxuXG4gICAgdmFyIG5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICFub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPSB0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nO1xuICAgICFub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXM6IGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCgpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vU3RhdGljR2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPSB0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGlmIChfc3RhdGUgJiYgKHR5cGVvZiBfc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoX3N0YXRlKSkpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgISh0eXBlb2YgY3Rvci5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcbiAge1xuICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gIHZhciBjb250ZXh0VHlwZXMgPSBjdG9yLmNvbnRleHRUeXBlcztcbiAgdmFyIGlzQ29udGV4dENvbnN1bWVyID0gY29udGV4dFR5cGVzICE9PSBudWxsICYmIGNvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkO1xuICB2YXIgY29udGV4dCA9IGlzQ29udGV4dENvbnN1bWVyID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5Q29udGV4dE9iamVjdDtcblxuICAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gIHtcbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7XG4gIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gbnVsbCAmJiBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBuZXcgY29tcG9uZW50IEFQSXMgYXJlIGRlZmluZWQsIFwidW5zYWZlXCIgbGlmZWN5Y2xlcyB3b24ndCBiZSBjYWxsZWQuXG4gICAgLy8gV2FybiBhYm91dCB0aGVzZSBsaWZlY3ljbGVzIGlmIHRoZXkgYXJlIHByZXNlbnQuXG4gICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIG1ldGhvZHMgdGhvdWdoLlxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfVxuICAgICAgaWYgKGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX2NvbXBvbmVudE5hbWUsIG5ld0FwaU5hbWUsIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cbiAgaWYgKGlzQ29udGV4dENvbnN1bWVyKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgfVxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dExlZ2FjeUNvbnRleHQpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dExlZ2FjeUNvbnRleHQpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dExlZ2FjeUNvbnRleHQpO1xuICB9XG4gIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnQ29tcG9uZW50JztcbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbi8vIEludm9rZXMgdGhlIG1vdW50IGxpZmUtY3ljbGVzIG9uIGEgcHJldmlvdXNseSBuZXZlciByZW5kZXJlZCBpbnN0YW5jZS5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAod2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZERlcHJlY2F0aW9uV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuICAgIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcblxuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgdmFyIG5leHRMZWdhY3lDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCk7XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuXG4gIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0TGVnYWN5Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dExlZ2FjeUNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7XG5cbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dExlZ2FjeUNvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cblxuICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBzdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dExlZ2FjeUNvbnRleHQ7XG5cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcblxuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgdmFyIG5leHRMZWdhY3lDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCk7XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuXG4gIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0TGVnYWN5Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dExlZ2FjeUNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7XG5cbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dExlZ2FjeUNvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dExlZ2FjeUNvbnRleHQpO1xuICAgICAgfVxuICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRMZWdhY3lDb250ZXh0O1xuXG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0gdm9pZCAwO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHZvaWQgMDtcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB2b2lkIDA7XG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGUgPSB7fTtcblxuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG4gIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yICcgKyAnbW9yZSBpbmZvcm1hdGlvbi4nICsgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpO1xuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAgIHdhcm5pbmckMShmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLicpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50JCQxLCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnO1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZkluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0Egc3RyaW5nIHJlZiwgXCIlc1wiLCBoYXMgYmVlbiBmb3VuZCB3aXRoaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1N0cmluZyByZWZzIGFyZSBhIHNvdXJjZSBvZiBwb3RlbnRpYWwgYnVncyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuICcgKyAnV2UgcmVjb21tZW5kIHVzaW5nIGNyZWF0ZVJlZigpIGluc3RlYWQuJyArICdcXG4lcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgbWl4ZWRSZWYsIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChyZXR1cm5GaWJlcikpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZkluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgb3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50TGF6eSkgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogdm9pZCAwO1xuICAgICAgICBpbnN0ID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgICAhaW5zdCA/IGludmFyaWFudChmYWxzZSwgJ01pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgJXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7XG4gICAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbiAgICAgIGlmIChjdXJyZW50JCQxICE9PSBudWxsICYmIGN1cnJlbnQkJDEucmVmICE9PSBudWxsICYmIHR5cGVvZiBjdXJyZW50JCQxLnJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBjdXJyZW50JCQxLnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQkJDEucmVmO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcztcbiAgICAgICAgaWYgKHJlZnMgPT09IGVtcHR5UmVmc09iamVjdCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXp5IHBvb2xlZCBmcm96ZW4gb2JqZWN0LCBzbyB3ZSBuZWVkIHRvIGluaXRpYWxpemUuXG4gICAgICAgICAgcmVmcyA9IGluc3QucmVmcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSByZWZzW3N0cmluZ1JlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmc1tzdHJpbmdSZWZdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgICEodHlwZW9mIG1peGVkUmVmID09PSAnc3RyaW5nJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYSBzdHJpbmcsIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgbnVsbC4nKSA6IHZvaWQgMDtcbiAgICAgICFlbGVtZW50Ll9vd25lciA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKCVzKSBidXQgbm8gb3duZXIgd2FzIHNldC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxcbjIuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgcmVuZGVyIG1ldGhvZFxcbjMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG5TZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAocmV0dXJuRmliZXIudHlwZSAhPT0gJ3RleHRhcmVhJykge1xuICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgIHtcbiAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IG5ld0NoaWxkLCBhZGRlbmR1bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKCkge1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICsgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpO1xuXG4gIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICB3YXJuaW5nJDEoZmFsc2UsICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcbn1cblxuLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZWxldGlvbnMgYXJlIGFkZGVkIGluIHJldmVyc2VkIG9yZGVyIHNvIHdlIGFkZCBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJldHVybiBmaWJlcidzIGVmZmVjdCBsaXN0IGlzIGVtcHR5IGV4Y2VwdCBmb3JcbiAgICAvLyBkZWxldGlvbnMsIHNvIHdlIGNhbiBqdXN0IGFwcGVuZCB0aGUgZGVsZXRpb24gdG8gdGhlIGxpc3QuIFRoZSByZW1haW5pbmdcbiAgICAvLyBlZmZlY3RzIGFyZW4ndCBhZGRlZCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UuIE9uY2Ugd2UgaW1wbGVtZW50XG4gICAgLy8gcmVzdW1pbmcsIHRoaXMgbWF5IG5vdCBiZSB0cnVlLlxuICAgIHZhciBsYXN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdDtcbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgICBjaGlsZFRvRGVsZXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTtcblxuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGV4aXN0aW5nQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChleGlzdGluZ0NoaWxkLmtleSAhPT0gbnVsbCkge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuICAgIC8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG4gICAgdmFyIGNsb25lID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgICB2YXIgY3VycmVudCQkMSA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudCQkMS5pbmRleDtcbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIGNhbiBzdGF5IGluIHBsYWNlLlxuICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCQkMSwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwgfHwgY3VycmVudCQkMS50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQkJDEsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50JCQxLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50JCQxICE9PSBudWxsICYmIGN1cnJlbnQkJDEudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50JCQxLCBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQkJDEsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQkJDEsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCQkMSwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50JCQxID09PSBudWxsIHx8IGN1cnJlbnQkJDEudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQkJDEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQkJDEuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCQkMSwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCQkMSwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCB8fCBjdXJyZW50JCQxLnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmcmFnbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCQkMSwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgX2NyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkMi5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJywga2V5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG4gICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCB0b1N0cmluZ1RhZ1xuICAgICAgbmV3Q2hpbGRyZW5JdGVyYWJsZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnR2VuZXJhdG9yJykge1xuICAgICAgICAhZGlkV2FybkFib3V0R2VuZXJhdG9ycyA/IHdhcm5pbmckMShmYWxzZSwgJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgaWYgKG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAhZGlkV2FybkFib3V0TWFwcyA/IHdhcm5pbmckMShmYWxzZSwgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgICB2YXIgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgIShuZXdDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci4nKSA6IHZvaWQgMDtcblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIHZhciBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKCFvbGRGaWJlcikge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICB2YXIgX25ld0ZpYmVyMyA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGNoaWxkLCBlbGVtZW50KTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgdmFyIGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuICAgIGlmIChpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KSB7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsO1xuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICd1bmRlZmluZWQnICYmICFpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGNoaWxkIGlzIHVuZGVmaW5lZCwgYW5kIHRoZSByZXR1cm4gZmliZXIgaXMgYSBjb21wb3NpdGVcbiAgICAgIC8vIGNvbXBvbmVudCwgdGhyb3cgYW4gZXJyb3IuIElmIEZpYmVyIHJldHVybiB0eXBlcyBhcmUgZGlzYWJsZWQsXG4gICAgICAvLyB3ZSBhbHJlYWR5IHRocmV3IGFib3ZlLlxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG4gICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gIH1cblxuICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnM7XG59XG5cbnZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcih0cnVlKTtcbnZhciBtb3VudENoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKGZhbHNlKTtcblxuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcykge1xuICAhKGN1cnJlbnQkJDEgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IGN1cnJlbnQkJDEuY2hpbGQpID8gaW52YXJpYW50KGZhbHNlLCAnUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuXG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gICAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59XG5cbi8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuLy8gVGhpcyBtYXkgaGF2ZSBiZWVuIGFuIGluc2VydGlvbiBvciBhIGh5ZHJhdGlvbi5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG52YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IHJldHVybkZpYmVyO1xuICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuXG4gIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgLy8gRXZlbiBpZiB3ZSBhYm9ydCBhbmQgcmVyZWNvbmNpbGUgdGhlIGNoaWxkcmVuLCB0aGF0IHdpbGwgdHJ5IHRvIGh5ZHJhdGVcbiAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gIC8vIHJlY3JlYXRlZC5cbiAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3R5cGUsIF9wcm9wcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZTtcbiAgaWYgKCF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgIC8vIG1pZ2h0IGJlIGZsYXdlZCBvciB1bm5lY2Vzc2FyeS5cbiAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gICAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgLy8gd2UnbGwgaGF2ZSB0byBzY2hlZHVsZSBhIGRlbGV0aW9uLiBUbyBkbyB0aGF0LCB0aGlzIG5vZGUgbmVlZHMgYSBkdW1teVxuICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICB9XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuXG4gIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICB2YXIgc2hvdWxkVXBkYXRlID0gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCBmaWJlcik7XG4gIHtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBwYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAvLyB0cmVlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgIC8vIHNpYmxpbmdzLlxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4gIC8vIHNpZGUgb2YgdGhlbS5cbiAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCB0eXBlICE9PSAnaGVhZCcgJiYgdHlwZSAhPT0gJ2JvZHknICYmICFzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkge1xuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZExhenlDb21wb25lbnRUeXBlKHRoZW5hYmxlKSB7XG4gIHZhciBzdGF0dXMgPSB0aGVuYWJsZS5fcmVhY3RTdGF0dXM7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSBSZXNvbHZlZDpcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGVuYWJsZS5fcmVhY3RSZXN1bHQ7XG4gICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIGNhc2UgUmVqZWN0ZWQ6XG4gICAgICB0aHJvdyB0aGVuYWJsZS5fcmVhY3RSZXN1bHQ7XG4gICAgY2FzZSBQZW5kaW5nOlxuICAgICAgdGhyb3cgdGhlbmFibGU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhlbmFibGUuX3JlYWN0U3RhdHVzID0gUGVuZGluZztcbiAgICAgICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAocmVzb2x2ZWRWYWx1ZSkge1xuICAgICAgICAgIGlmICh0aGVuYWJsZS5fcmVhY3RTdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoZW5hYmxlLl9yZWFjdFN0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlZFZhbHVlID09PSAnb2JqZWN0JyAmJiByZXNvbHZlZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBgZGVmYXVsdGAgcHJvcGVydHkgaXMgbm90IGVtcHR5LCBhc3N1bWUgaXQncyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgIC8vIG9mIGFuIGFzeW5jIGltcG9ydCgpIGFuZCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCB1c2UgdGhlXG4gICAgICAgICAgICAgIC8vIHJlc29sdmVkIHZhbHVlIGl0c2VsZi5cbiAgICAgICAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSByZXNvbHZlZFZhbHVlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgIHJlc29sdmVkVmFsdWUgPSBkZWZhdWx0RXhwb3J0ICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdEV4cG9ydCAhPT0gbnVsbCA/IGRlZmF1bHRFeHBvcnQgOiByZXNvbHZlZFZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZSA9IHJlc29sdmVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGVuYWJsZS5fcmVhY3RSZXN1bHQgPSByZXNvbHZlZFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHRoZW5hYmxlLl9yZWFjdFN0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAgICAgdGhlbmFibGUuX3JlYWN0U3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgICAgICB0aGVuYWJsZS5fcmVhY3RSZXN1bHQgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyB0aGVuYWJsZTtcbiAgICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbmFsQ29tcG9uZW50ID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFN0YXRlbGVzc1JlZnMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbiAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbmFsQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dFN0YXRlbGVzc1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgIC8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4gICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgLy8gbGV0J3MgdGhyb3cgaXQgb3V0LlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQkJDEuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5leHRQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHJlbmRlciA9IHR5cGUucmVuZGVyO1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgdmFyIGN1cnJlbnRSZWYgPSBjdXJyZW50JCQxICE9PSBudWxsID8gY3VycmVudCQkMS5yZWYgOiBudWxsO1xuICAgIGlmIChyZWYgPT09IGN1cnJlbnRSZWYpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDMuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyKG5leHRQcm9wcywgcmVmKTtcbiAgICBzZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZmlsZXIoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIGlmIChjdXJyZW50JCQxID09PSBudWxsICYmIHJlZiAhPT0gbnVsbCB8fCBjdXJyZW50JCQxICE9PSBudWxsICYmIGN1cnJlbnQkJDEucmVmICE9PSByZWYpIHtcbiAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICB2YXIgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDMuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgbmV4dENoaWxkcmVuID0gQ29tcG9uZW50KG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG5cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgdmFyIGhhc0NvbnRleHQgPSB2b2lkIDA7XG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IHZvaWQgMDtcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgbWFya1JlZihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgdmFyIGRpZENhcHR1cmVFcnJvciA9ICh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSAhPT0gTm9FZmZlY3Q7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIC8vIFJlcmVuZGVyXG4gIFJlYWN0Q3VycmVudE93bmVyJDMuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICBpZiAoZGlkQ2FwdHVyZUVycm9yICYmICghZW5hYmxlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIHx8IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoICE9PSAnZnVuY3Rpb24nKSkge1xuICAgIC8vIElmIHdlIGNhcHR1cmVkIGFuIGVycm9yLCBidXQgZ2V0RGVyaXZlZFN0YXRlRnJvbSBjYXRjaCBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHwgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJiB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIHNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCAmJiBkaWRDYXB0dXJlRXJyb3IpIHtcbiAgICAvLyBJZiB3ZSdyZSByZWNvdmVyaW5nIGZyb20gYW4gZXJyb3IsIHJlY29uY2lsZSB0d2ljZTogZmlyc3QgdG8gZGVsZXRlXG4gICAgLy8gYWxsIHRoZSBleGlzdGluZyBjaGlsZHJlbi5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICAvLyBOb3cgd2UgY2FuIGNvbnRpbnVlIHJlY29uY2lsaW5nIGxpa2Ugbm9ybWFsLiBUaGlzIGhhcyB0aGUgZWZmZWN0IG9mXG4gICAgLy8gcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyIHRoZWlyXG4gICAgLy8gaWRlbnRpdHkgbWF0Y2hlcy5cbiAgfVxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIC8vIE1lbW9pemUgcHJvcHMgYW5kIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2Uuc3RhdGUpO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnByb3BzKTtcblxuICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpZiAocm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgLy8gU2hvdWxkIGFsd2F5cyBiZSBzZXRcbiAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LmNvbnRleHQsIGZhbHNlKTtcbiAgfVxuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgISh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB0aGUgcm9vdCBkb2VzIG5vdCBoYXZlIGFuIHVwZGF0ZVF1ZXVlLCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGJhaWxlZCBvdXQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgcHJldkNoaWxkcmVuID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmVsZW1lbnQgOiBudWxsO1xuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gIGlmIChuZXh0Q2hpbGRyZW4gPT09IHByZXZDaGlsZHJlbikge1xuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAvLyBubyB3b3JrIHRoYXQgZXhwaXJlcyBhdCB0aGlzIHRpbWUuXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmICgoY3VycmVudCQkMSA9PT0gbnVsbCB8fCBjdXJyZW50JCQxLmNoaWxkID09PSBudWxsKSAmJiByb290Lmh5ZHJhdGUgJiYgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAvLyBiZSBhbnkgY2hpbGRyZW4gdG8gaHlkcmF0ZSB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZyBhc1xuICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgIC8vIGtub3cgdGhhdCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBtb3VudGluZyBzdGF0ZS4gVGhhdCB3YXkgaXNNb3VudGVkXG4gICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgIC8vIG5vZGVzIHRoYXQgd2lsbCBiZSBoeWRyYXRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAvLyByb290LlxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50JCQxID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlByb3BzID0gY3VycmVudCQkMSAhPT0gbnVsbCA/IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAvLyBhdm9pZHMgYWxsb2NhdGluZyBhbm90aGVyIEhvc3RUZXh0IGZpYmVyIGFuZCB0cmF2ZXJzaW5nIGl0LlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAocHJldlByb3BzICE9PSBudWxsICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBhIGRpcmVjdCB0ZXh0IGNoaWxkIHRvIGEgbm9ybWFsIGNoaWxkLCBvciB0b1xuICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIG1hcmtSZWYoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICBpZiAocmVuZGVyRXhwaXJhdGlvblRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBBc3luY01vZGUgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpKSB7XG4gICAgLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgb2Zmc2NyZWVuIHByaW9yaXR5LiBUaGVuIGJhaWxvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbiAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSBDb21wb25lbnQuZGVmYXVsdFByb3BzO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuICByZXR1cm4gYmFzZVByb3BzO1xufVxuXG5mdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgIShjdXJyZW50JCQxID09PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBuZXZlciBoYXZlIG1vdW50ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIENvbXBvbmVudCA9IHJlYWRMYXp5Q29tcG9uZW50VHlwZShDb21wb25lbnQpO1xuICAgIHZhciByZXNvbHZlZFRhZyA9IHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgICBzd2l0Y2ggKHJlc29sdmVkVGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnRMYXp5OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgRm9yd2FyZFJlZkxhenk6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUaGlzIG1lc3NhZ2UgaW50ZW50aW9uYWxseSBkb2Vzbid0IG1ldGlvbiBGb3J3YXJkUmVmIGJlY2F1c2UgdGhlXG4gICAgICAgICAgLy8gZmFjdCB0aGF0IGl0J3MgYSBzZXBhcmF0ZSB0eXBlIG9mIHdvcmsgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogJXMuIFByb21pc2UgZWxlbWVudHMgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uJywgQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuICB2YXIgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICB2YXIgdmFsdWUgPSB2b2lkIDA7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB2YWx1ZSA9IENvbXBvbmVudChwcm9wcywgY29udGV4dCk7XG4gIH1cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuXG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgcHJvcHMpO1xuICAgIH1cblxuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlLCBoYXNDb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAge1xuICAgICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgICAhIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG4gICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCB8fCAnJztcbiAgICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMnLCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25hbENvbXBvbmVudFtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogU3RhdGVsZXNzIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25hbENvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgcHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVQbGFjZWhvbGRlckNvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGVuYWJsZVN1c3BlbnNlKSB7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHJlbmRlciB0aGUgbm9ybWFsIHN0YXRlLiBJZiB3ZSBkaWQsXG4gICAgLy8gYW5kIHdlIHRpbWVkIG91dCwgcmVuZGVyIHRoZSBwbGFjZWhvbGRlciBzdGF0ZS5cbiAgICB2YXIgYWxyZWFkeUNhcHR1cmVkID0gKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdDtcblxuICAgIHZhciBuZXh0RGlkVGltZW91dCA9IHZvaWQgMDtcbiAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgb3V0c2lkZSBzdHJpY3QgbW9kZS4gU29tZXRoaW5nIGluc2lkZSB0aGlzIFBsYWNlaG9sZGVyIGJvdW5kYXJ5XG4gICAgICAvLyBzdXNwZW5kZWQgZHVyaW5nIHRoZSBsYXN0IGNvbW1pdC4gU3dpdGNoIHRvIHRoZSBwbGFjaG9sZGVyLlxuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgbmV4dERpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgLy8gSWYgd2UncmUgcmVjb3ZlcmluZyBmcm9tIGFuIGVycm9yLCByZWNvbmNpbGUgdHdpY2U6IGZpcnN0IHRvIGRlbGV0ZVxuICAgICAgLy8gYWxsIHRoZSBleGlzdGluZyBjaGlsZHJlbi5cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBudWxsLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjdXJyZW50JCQxLmNoaWxkID0gbnVsbDtcbiAgICAgIC8vIE5vdyB3ZSBjYW4gY29udGludWUgcmVjb25jaWxpbmcgbGlrZSBub3JtYWwuIFRoaXMgaGFzIHRoZSBlZmZlY3Qgb2ZcbiAgICAgIC8vIHJlbW91bnRpbmcgYWxsIGNoaWxkcmVuIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVpciB0aGVpclxuICAgICAgLy8gaWRlbnRpdHkgbWF0Y2hlcy5cbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dERpZFRpbWVvdXQgPSAhYWxyZWFkeUNhcHR1cmVkO1xuICAgIH1cblxuICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpICE9PSBOb0VmZmVjdCkge1xuICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgIC8vIElmIHRoZSB0aW1lZC1vdXQgdmlldyBjb21taXRzLCBzY2hlZHVsZSBhbiB1cGRhdGUgZWZmZWN0IHRvIHJlY29yZFxuICAgICAgICAvLyB0aGUgY29tbWl0dGVkIHRpbWUuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgc3RhdGUgbm9kZSBwb2ludHMgdG8gdGhlIHRpbWUgYXQgd2hpY2ggcGxhY2Vob2xkZXIgdGltZWQgb3V0LlxuICAgICAgICAvLyBXZSBjYW4gY2xlYXIgaXQgb25jZSB3ZSBzd2l0Y2ggYmFjayB0byB0aGUgbm9ybWFsIGNoaWxkcmVuLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBgY2hpbGRyZW5gIHByb3AgaXMgYSBmdW5jdGlvbiwgdHJlYXQgaXQgbGlrZSBhIHJlbmRlciBwcm9wLlxuICAgIC8vIFRPRE86IFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIGZpbmFsaXplIGEgbG93ZXIgbGV2ZWwgQVBJLlxuICAgIHZhciBjaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGNoaWxkcmVuKG5leHREaWRUaW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENoaWxkcmVuID0gbmV4dERpZFRpbWVvdXQgPyBuZXh0UHJvcHMuZmFsbGJhY2sgOiBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0RGlkVGltZW91dDtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICB9XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgcHJvdmlkZXJUeXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlclR5cGUuX2NvbnRleHQ7XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG5cbiAge1xuICAgIHZhciBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKHByb3ZpZGVyUHJvcFR5cGVzKSB7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm92aWRlclByb3BUeXBlcywgbmV3UHJvcHMsICdwcm9wJywgJ0NvbnRleHQuUHJvdmlkZXInLCBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgICB9XG4gIH1cblxuICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5ld1ZhbHVlKTtcblxuICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSBjYWxjdWxhdGVDaGFuZ2VkQml0cyhjb250ZXh0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgIGlmIChjaGFuZ2VkQml0cyA9PT0gMCkge1xuICAgICAgLy8gTm8gY2hhbmdlLiBCYWlsb3V0IGVhcmx5IGlmIGNoaWxkcmVuIGFyZSB0aGUgc2FtZS5cbiAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGNvbnRleHQgdmFsdWUgY2hhbmdlZC4gU2VhcmNoIGZvciBtYXRjaGluZyBjb25zdW1lcnMgYW5kIHNjaGVkdWxlXG4gICAgICAvLyB0aGVtIHRvIHVwZGF0ZS5cbiAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIGNoYW5nZWRCaXRzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuID0gbmV3UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZW5kZXIgPSBuZXdQcm9wcy5jaGlsZHJlbjtcblxuICB7XG4gICAgISh0eXBlb2YgcmVuZGVyID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnICsgXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiICsgJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnICsgJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJykgOiB2b2lkIDA7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0LCBuZXdQcm9wcy51bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgICBzZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cblxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbi8qXG4gIGZ1bmN0aW9uIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHJldHVybkZpYmVyIDogRmliZXIsIGZpcnN0Q2hpbGQgOiBGaWJlcikge1xuICAgIGxldCBjaGlsZCA9IGZpcnN0Q2hpbGQ7XG4gICAgZG8ge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZpcnN0IGFuZCBsYXN0IGVmZmVjdCBvZiB0aGUgcGFyZW50IGNvcnJlc3BvbmRzXG4gICAgICAvLyB0byB0aGUgY2hpbGRyZW4ncyBmaXJzdCBhbmQgbGFzdCBlZmZlY3QuXG4gICAgICBpZiAoIXJldHVybkZpYmVyLmZpcnN0RWZmZWN0KSB7XG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQubGFzdEVmZmVjdCkge1xuICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZC5sYXN0RWZmZWN0O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gIH1cbiAgKi9cblxuZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGNvbnRleHQgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50JCQxLmZpcnN0Q29udGV4dERlcGVuZGVuY3k7XG4gIH1cblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIGFueSBwZW5kaW5nIHdvcmsuXG4gIHZhciBjaGlsZEV4cGlyYXRpb25UaW1lID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgaWYgKGNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBjaGlsZEV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gZG9uJ3QgaGF2ZSBhbnkgd29yayBlaXRoZXIuIFdlIGNhbiBza2lwIHRoZW0uXG4gICAgLy8gVE9ETzogT25jZSB3ZSBhZGQgYmFjayByZXN1bWluZywgd2Ugc2hvdWxkIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBhcmVcbiAgICAvLyBhIHdvcmstaW4tcHJvZ3Jlc3Mgc2V0LiBJZiBzbywgd2UgbmVlZCB0byB0cmFuc2ZlciB0aGVpciBlZmZlY3RzLlxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgZmliZXIgZG9lc24ndCBoYXZlIHdvcmssIGJ1dCBpdHMgc3VidHJlZSBkb2VzLiBDbG9uZSB0aGUgY2hpbGRcbiAgICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuICAgIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxufVxuXG4vLyBUT0RPOiBEZWxldGUgbWVtb2l6ZVByb3BzL1N0YXRlIGFuZCBtb3ZlIHRvIHJlY29uY2lsZS9iYWlsb3V0IGluc3RlYWRcbmZ1bmN0aW9uIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSB7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gIC8vIERvbid0IHJlc2V0IHRoZSB1cGRhdGVRdWV1ZSwgaW4gY2FzZSB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBSZXNldHRpbmdcbiAgLy8gaXMgaGFuZGxlZCBieSBwcm9jZXNzVXBkYXRlUXVldWUuXG59XG5cbmZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWU7XG4gIGlmICghaGFzQ29udGV4dENoYW5nZWQoKSAmJiAodXBkYXRlRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB1cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSkge1xuICAgIC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgICAvLyB0aGUgYmVnaW4gcGhhc2UuIFRoZXJlJ3Mgc3RpbGwgc29tZSBib29ra2VlcGluZyB3ZSB0aGF0IG5lZWRzIHRvIGJlIGRvbmVcbiAgICAvLyBpbiB0aGlzIG9wdGltaXplZCBwYXRoLCBtb3N0bHkgcHVzaGluZyBzdHVmZiBvbnRvIHRoZSBzdGFjay5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICB2YXIgX0NvbXBvbmVudCA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKHRoZW5hYmxlKTtcbiAgICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5ld1ZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgLy8gQmVmb3JlIGVudGVyaW5nIHRoZSBiZWdpbiBwaGFzZSwgY2xlYXIgdGhlIGV4cGlyYXRpb24gdGltZS5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50MyA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHJldHVybiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudDQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQ0LCBfdW5yZXNvbHZlZFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50TGF6eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90aGVuYWJsZTIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX0NvbXBvbmVudDUgPSBnZXRSZXN1bHRGcm9tUmVzb2x2ZWRUaGVuYWJsZShfdGhlbmFibGUyKTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgX2NoaWxkID0gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDUsIHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDUsIF91bnJlc29sdmVkUHJvcHMyKSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gX3VucmVzb2x2ZWRQcm9wczI7XG4gICAgICAgIHJldHVybiBfY2hpbGQ7XG4gICAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQ2ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQ2LCBfdW5yZXNvbHZlZFByb3BzMywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OlxuICAgICAge1xuICAgICAgICB2YXIgX3RoZW5hYmxlMyA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfQ29tcG9uZW50NyA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKF90aGVuYWJsZTMpO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciBfY2hpbGQyID0gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQ3LCByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQ3LCBfdW5yZXNvbHZlZFByb3BzNCksIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IF91bnJlc29sdmVkUHJvcHM0O1xuICAgICAgICByZXR1cm4gX2NoaWxkMjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKTtcbiAgICBjYXNlIFBsYWNlaG9sZGVyQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZVBsYWNlaG9sZGVyQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgY2FzZSBGb3J3YXJkUmVmTGF6eTpcbiAgICAgIHZhciBfdGhlbmFibGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgdmFyIF9Db21wb25lbnQyID0gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUoX3RoZW5hYmxlKTtcbiAgICAgIHZhciB1bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICB2YXIgY2hpbGQgPSB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50MiwgcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50MiwgdW5yZXNvbHZlZFByb3BzKSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IHVucmVzb2x2ZWRQcm9wcztcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1Vua25vd24gdW5pdCBvZiB3b3JrIHRhZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbiAgLy8gYSBQbGFjZW1lbnRBbmRVcGRhdGUuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcykge1xuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxudmFyIHVwZGF0ZUhvc3RDb250YWluZXIgPSB2b2lkIDA7XG52YXIgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gdm9pZCAwO1xudmFyIHVwZGF0ZUhvc3RUZXh0JDEgPSB2b2lkIDA7XG5pZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAvLyBNdXRhdGlvbiBtb2RlXG5cbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIE5vb3BcbiAgfTtcbiAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSB7XG4gICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG4gIHVwZGF0ZUhvc3RUZXh0JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xufSBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gIC8vIFBlcnNpc3RlbnQgaG9zdCB0cmVlIG1vZGVcblxuICAvLyBBbiB1bmZvcnR1bmF0ZSBmb3JrIG9mIGFwcGVuZEFsbENoaWxkcmVuIGJlY2F1c2Ugd2UgaGF2ZSB0d28gZGlmZmVyZW50IHBhcmVudCB0eXBlcy5cbiAgdmFyIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyQ2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9O1xuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHBvcnRhbE9yUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICB2YXIgbmV3Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXIpO1xuICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbiA9IG5ld0NoaWxkU2V0O1xuICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjb250YWluZXIgdG8gc3dhcCBvdXQgdGhlIGNvbnRhaW5lci5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KTtcbiAgICB9XG4gIH07XG4gIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIHRoZW4gbm9uZSBvZiBvdXIgY2hpbGRyZW4gaGFkIGFueSB1cGRhdGVzLlxuICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICB2YXIgY3VycmVudEluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVjeWNsYWJsZUluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlJ3JlIG5vdCBnb2luZyB0byB1c2UgaXQgZm9yIGFueXRoaW5nLlxuICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIC8vIElmIHRoZSB0ZXh0IGNvbnRlbnQgZGlmZmVycywgd2UnbGwgY3JlYXRlIGEgbmV3IHRleHQgaW5zdGFuY2UgZm9yIGl0LlxuICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIFRoaXMgbGV0cyB0aGUgcGFyZW50cyBrbm93IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIGNoaWxkcmVuIGhhcyBjaGFuZ2VkLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gTm8gaG9zdCBvcGVyYXRpb25zXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBOb29wXG4gIH07XG4gIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkge1xuICAgIC8vIE5vb3BcbiAgfTtcbiAgdXBkYXRlSG9zdFRleHQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIC8vIE5vb3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50TGF6eTpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKHdvcmtJblByb2dyZXNzLnR5cGUpO1xuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgIC8vIFRPRE86IERlbGV0ZSB0aGlzIHdoZW4gd2UgZGVsZXRlIGlzTW91bnRlZCBhbmQgZmluZERPTU5vZGUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkIHRvXG4gICAgICAgICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IHVwZGF0ZWQgYmVjYXVzZSBvbmUgb2Ygb3VyIGNoaWxkcmVuIHVwZGF0ZWQsIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAgICAgICAgIC8vIFRPRE86IFNwbGl0IHRoZSB1cGRhdGUgQVBJIGFzIHNlcGFyYXRlIGZvciB0aGUgcHJvcHMgdnMuIGNoaWxkcmVuLlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgICAgICAgICAvLyBjb21wb25lbnQgaXMgaGl0dGluZyB0aGUgcmVzdW1lIHBhdGguIEZpZ3VyZSBvdXQgd2h5LiBQb3NzaWJseVxuICAgICAgICAgICAgLy8gcmVsYXRlZCB0byBgaGlkZGVuYC5cbiAgICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gcHJlcGFyZVVwZGF0ZShpbnN0YW5jZSwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuICAgICAgICAgIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG4gICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIGNoYW5nZXMgdG8gdGhlIGh5ZHJhdGVkIG5vZGUgbmVlZHMgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oX2luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihfaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgISh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dDIgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQyLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZvcndhcmRSZWZMYXp5OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBQbGFjZWhvbGRlckNvbXBvbmVudDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICBicmVhaztcbiAgICBjYXNlIE1vZGU6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIGJyZWFrO1xuICAgIC8vIEVycm9yIGNhc2VzXG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIGhhdmUgYmVjb21lIGRldGVybWluYXRlIGJlZm9yZSBjb21wbGV0aW5nLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVGhpcyBtb2R1bGUgaXMgZm9ya2VkIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudHMuXG4vLyBCeSBkZWZhdWx0LCByZXR1cm4gYHRydWVgIHRvIGxvZyBlcnJvcnMgdG8gdGhlIGNvbnNvbGUuXG4vLyBGb3JrcyBjYW4gcmV0dXJuIGBmYWxzZWAgaWYgdGhpcyBpc24ndCBkZXNpcmFibGUuXG5mdW5jdGlvbiBzaG93RXJyb3JEaWFsb2coY2FwdHVyZWRFcnJvcikge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dFcnJvckRpYWxvZyhjYXB0dXJlZEVycm9yKTtcblxuICAvLyBBbGxvdyBpbmplY3RlZCBzaG93RXJyb3JEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuICAvLyBUaGlzIGVuYWJsZXMgcmVuZGVyZXJzIGxpa2UgUmVhY3ROYXRpdmUgdG8gYmV0dGVyIG1hbmFnZSByZWRib3ggYmVoYXZpb3IuXG4gIGlmIChsb2dFcnJvciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgd2lsbFJldHJ5ID0gY2FwdHVyZWRFcnJvci53aWxsUmV0cnk7XG5cbiAgICAvLyBCcm93c2VycyBzdXBwb3J0IHNpbGVuY2luZyB1bmNhdWdodCBlcnJvcnMgYnkgY2FsbGluZ1xuICAgIC8vIGBwcmV2ZW50RGVmYXVsdCgpYCBpbiB3aW5kb3cgYGVycm9yYCBoYW5kbGVyLlxuICAgIC8vIFdlIHJlY29yZCB0aGlzIGluZm9ybWF0aW9uIGFzIGFuIGV4cGFuZG8gb24gdGhlIGVycm9yLlxuXG4gICAgaWYgKGVycm9yICE9IG51bGwgJiYgZXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiB3aWxsUmV0cnkpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIGlzIHJlY292ZXJhYmxlIGFuZCB3YXMgc2lsZW5jZWQuXG4gICAgICAgIC8vIElnbm9yZSBpdCBhbmQgZG9uJ3QgcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuICAgICAgICAvLyBUaGlzIGlzIGhhbmR5IGZvciB0ZXN0aW5nIGVycm9yIGJvdW5kYXJpZXMgd2l0aG91dCBub2lzZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGVycm9yIGlzIGZhdGFsLiBTaW5jZSB0aGUgc2lsZW5jaW5nIG1pZ2h0IGhhdmVcbiAgICAgIC8vIGJlZW4gYWNjaWRlbnRhbCwgd2UnbGwgc3VyZmFjZSBpdCBhbnl3YXkuXG4gICAgICAvLyBIb3dldmVyLCB0aGUgYnJvd3NlciB3b3VsZCBoYXZlIHNpbGVuY2VkIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgLy8gc28gd2UnbGwgcHJpbnQgaXQgZmlyc3QsIGFuZCB0aGVuIHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgLy8gRm9yIGEgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGlzIGJsb2NrLCBzZWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzM4NFxuICAgIH1cblxuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBjb21wb25lbnQ6JyA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuXG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gdm9pZCAwO1xuICAgIC8vIGVycm9yQm91bmRhcnlGb3VuZCBjaGVjayBpcyBzdWZmaWNpZW50OyBlcnJvckJvdW5kYXJ5TmFtZSBjaGVjayBpcyB0byBzYXRpc2Z5IEZsb3cuXG4gICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiBlcnJvckJvdW5kYXJ5TmFtZSkge1xuICAgICAgaWYgKHdpbGxSZXRyeSkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCAnICsgKCd1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnVGhpcyBlcnJvciB3YXMgaW5pdGlhbGx5IGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJ5ICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuXFxuJyArICdSZWNyZWF0aW5nIHRoZSB0cmVlIGZyb20gc2NyYXRjaCBmYWlsZWQgc28gUmVhY3Qgd2lsbCB1bm1vdW50IHRoZSB0cmVlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgIH1cbiAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gJycgKyBjb21wb25lbnROYW1lTWVzc2FnZSArIGNvbXBvbmVudFN0YWNrICsgJ1xcblxcbicgKyAoJycgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7XG5cbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cbiAgICBjb25zb2xlLmVycm9yKGNvbWJpbmVkTWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG57XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvcihib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHZhciBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gIGlmIChzdGFjayA9PT0gbnVsbCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICBzdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGNhcHR1cmVkRXJyb3IgPSB7XG4gICAgY29tcG9uZW50TmFtZTogc291cmNlICE9PSBudWxsID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UudHlwZSkgOiBudWxsLFxuICAgIGNvbXBvbmVudFN0YWNrOiBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJycsXG4gICAgZXJyb3I6IGVycm9ySW5mby52YWx1ZSxcbiAgICBlcnJvckJvdW5kYXJ5OiBudWxsLFxuICAgIGVycm9yQm91bmRhcnlOYW1lOiBudWxsLFxuICAgIGVycm9yQm91bmRhcnlGb3VuZDogZmFsc2UsXG4gICAgd2lsbFJldHJ5OiBmYWxzZVxuICB9O1xuXG4gIGlmIChib3VuZGFyeSAhPT0gbnVsbCAmJiBib3VuZGFyeS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5ID0gYm91bmRhcnkuc3RhdGVOb2RlO1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lKGJvdW5kYXJ5LnR5cGUpO1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeUZvdW5kID0gdHJ1ZTtcbiAgICBjYXB0dXJlZEVycm9yLndpbGxSZXRyeSA9IHRydWU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuICAgIC8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQkJDEsIGluc3RhbmNlKSB7XG4gIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50JCQxLCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gY3VycmVudCQkMS5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xufTtcblxuLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50JCQxLCBpbnN0YW5jZSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCQkMSwgaW5zdGFuY2UpO1xuICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCQkMSwgdW5tb3VudEVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQkJDEpIHtcbiAgdmFyIHJlZiA9IGN1cnJlbnQkJDEucmVmO1xuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIHJlZiwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQkJDEsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50JCQxLCBmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50JCQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCQkMS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQkJDEubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZScpO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZGlkV2FyblNldCA9IGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlO1xuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuICAgICAgICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjdXJyZW50JCQxLCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50JCQxLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OlxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG4gICAgICAgIGlmIChjdXJyZW50JCQxID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICAgIHZhciBvblJlbmRlciA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLm9uUmVuZGVyO1xuXG4gICAgICAgICAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNraW5nKSB7XG4gICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgY3VycmVudCQkMSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJywgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgZ2V0Q29tbWl0VGltZSgpLCBmaW5pc2hlZFJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgY3VycmVudCQkMSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJywgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgZ2V0Q29tbWl0VGltZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgUGxhY2Vob2xkZXJDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgICAgICAgIGlmICgoZmluaXNoZWRXb3JrLm1vZGUgJiBTdHJpY3RNb2RlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAgIC8vIEluIGxvb3NlIG1vZGUsIGEgcGxhY2Vob2xkZXIgdGltZXMgb3V0IGJ5IHNjaGVkdWxpbmcgYSBzeW5jaHJvbm91c1xuICAgICAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBjb21taXQgcGhhc2UuIFVzZSBgdXBkYXRlUXVldWVgIGZpZWxkIHRvIHNpZ25hbCB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgVGltZW91dCBuZWVkcyB0byBzd2l0Y2ggdG8gdGhlIHBsYWNlaG9sZGVyLiBXZSBkb24ndCBuZWVkIGFuXG4gICAgICAgICAgICAvLyBlbnRpcmUgcXVldWUuIEFueSBub24tbnVsbCB2YWx1ZSB3b3Jrcy5cbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBJbnRlbnRpb25hbGx5IHVzaW5nIGEgdmFsdWUgb3RoZXIgdGhhbiBhbiBVcGRhdGVRdWV1ZS5cbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IGVtcHR5T2JqZWN0O1xuICAgICAgICAgICAgc2NoZWR1bGVXb3JrKGZpbmlzaGVkV29yaywgU3luYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIHN0cmljdCBtb2RlLCB0aGUgVXBkYXRlIGVmZmVjdCBpcyB1c2VkIHRvIHJlY29yZCB0aGUgdGltZSBhdFxuICAgICAgICAgICAgLy8gd2hpY2ggdGhlIHBsYWNlaG9sZGVyIHRpbWVkIG91dC5cbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IHsgdGltZWRPdXRBdDogY3VycmVudFRpbWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHZhciBpbnN0YW5jZVRvVXNlID0gdm9pZCAwO1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gJyArICdVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS4lcycsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpLCBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCQkMSkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQkJDEucmVmO1xuICBpZiAoY3VycmVudFJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgY3VycmVudFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFJlZihudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4vLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuLy8gaW50ZXJydXB0IGRlbGV0aW9uLCBzbyBpdCdzIG9rYXlcbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCQkMSkge1xuICBvbkNvbW1pdFVubW91bnQoY3VycmVudCQkMSk7XG5cbiAgc3dpdGNoIChjdXJyZW50JCQxLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICB7XG4gICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50JCQxKTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudCQkMS5zdGF0ZU5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCQkMSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50JCQxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50JCQxKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgZW1wdHlQb3J0YWxDb250YWluZXIoY3VycmVudCQkMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKHJvb3QpIHtcbiAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgdmFyIG5vZGUgPSByb290O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbW1pdFVubW91bnQobm9kZSk7XG4gICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgLy8gU2tpcCBwb3J0YWxzIGJlY2F1c2UgY29tbWl0VW5tb3VudCgpIGN1cnJlbnRseSB2aXNpdHMgdGhlbSByZWN1cnNpdmVseS5cbiAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoXG4gICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgLy8gSWYgd2UgZG9uJ3QgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIGhlcmUgaW5zdGVhZC5cbiAgICAhc3VwcG9ydHNNdXRhdGlvbiB8fCBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyKGN1cnJlbnQkJDEpIHtcbiAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXJzIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS4gSWRlYWxseSwgd2VcbiAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gIC8vIGdldCBHQzplZCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmb3Igc3VyZSB3aGljaCBwYXJlbnQgaXMgdGhlIGN1cnJlbnRcbiAgLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuIFRoaXMgY2hpbGRcbiAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgY3VycmVudCQkMS5yZXR1cm4gPSBudWxsO1xuICBjdXJyZW50JCQxLmNoaWxkID0gbnVsbDtcbiAgaWYgKGN1cnJlbnQkJDEuYWx0ZXJuYXRlKSB7XG4gICAgY3VycmVudCQkMS5hbHRlcm5hdGUuY2hpbGQgPSBudWxsO1xuICAgIGN1cnJlbnQkJDEuYWx0ZXJuYXRlLnJldHVybiA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1wdHlQb3J0YWxDb250YWluZXIoY3VycmVudCQkMSkge1xuICBpZiAoIXN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcG9ydGFsID0gY3VycmVudCQkMS5zdGF0ZU5vZGU7XG4gIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvLFxuICAgICAgICAgICAgX3BlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW47XG5cbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIF9wZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cbiAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RSb290IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFBvcnRhbDtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgLy8gV2UncmUgZ29pbmcgdG8gc2VhcmNoIGZvcndhcmQgaW50byB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyBob3N0XG4gIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZS5yZXR1cm4pKSB7XG4gICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgLy8gbGFzdCBzaWJsaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgaWYgKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgLy8gV2UgYWxzbyBza2lwIHBvcnRhbHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgcGFydCBvZiB0aGlzIGhvc3QgdHJlZS5cbiAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICBpZiAoIShub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkpIHtcbiAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG4gIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG4gIC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuICB2YXIgcGFyZW50ID0gdm9pZCAwO1xuICB2YXIgaXNDb250YWluZXIgPSB2b2lkIDA7XG5cbiAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICBpc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTtcbiAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgIHBhcmVudEZpYmVyLmVmZmVjdFRhZyAmPSB+Q29udGVudFJlc2V0O1xuICB9XG5cbiAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50JCQxKSB7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICB2YXIgbm9kZSA9IGN1cnJlbnQkJDE7XG5cbiAgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG5cbiAgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG4gIHZhciBjdXJyZW50UGFyZW50ID0gdm9pZCAwO1xuICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShwYXJlbnQgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgLy8gQWZ0ZXIgYWxsIHRoZSBjaGlsZHJlbiBoYXZlIHVubW91bnRlZCwgaXQgaXMgbm93IHNhZmUgdG8gcmVtb3ZlIHRoZVxuICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgbWF5IGZpbmQgbW9yZSBob3N0IGNvbXBvbmVudHMgYmVsb3cuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnQkJDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50JCQxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBXaGVuIHdlIGdvIG91dCBvZiB0aGUgcG9ydGFsLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHBhcmVudC5cbiAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oY3VycmVudCQkMSkge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCQkMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50JCQxKTtcbiAgfVxuICBkZXRhY2hGaWJlcihjdXJyZW50JCQxKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50JCQxLCBmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQkJDEgIT09IG51bGwgPyBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgIC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cbiAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgICEoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQkJDEgIT09IG51bGwgPyBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgUGxhY2Vob2xkZXJDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQkJDEpIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc2V0VGV4dENvbnRlbnQoY3VycmVudCQkMS5zdGF0ZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBOb29wQ29tcG9uZW50KCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIHVwZGF0ZS5wYXlsb2FkID0geyBlbGVtZW50OiBudWxsIH07XG4gIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvcik7XG4gICAgbG9nRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gIH07XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2g7XG4gIGlmIChlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggJiYgdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2goZXJyb3IpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgaWYgKGluc3QgIT09IG51bGwgJiYgdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIGlmICghZW5hYmxlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIHx8IGdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbiAgICAgICAgLy8gd2Uga2VlcCB0cmFjayBvZiB3aGljaCBvbmVzIGFscmVhZHkgZmFpbGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuICAgICAgICAvLyBUaGlzIGdldHMgcmVzZXQgYmVmb3JlIHdlIHlpZWxkIGJhY2sgdG8gdGhlIGJyb3dzZXIuXG4gICAgICAgIC8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIGlzXG4gICAgICAgIC8vIG5vdCBkZWZpbmVkLlxuICAgICAgICBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKHRoaXMpO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgbG9nRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9yLCB7XG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJydcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB2YWx1ZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuICBzb3VyY2VGaWJlci5lZmZlY3RUYWcgfD0gSW5jb21wbGV0ZTtcbiAgLy8gSXRzIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgc291cmNlRmliZXIuZmlyc3RFZmZlY3QgPSBzb3VyY2VGaWJlci5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICBpZiAoZW5hYmxlU3VzcGVuc2UgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYSB0aGVuYWJsZS5cbiAgICB2YXIgdGhlbmFibGUgPSB2YWx1ZTtcblxuICAgIC8vIEZpbmQgdGhlIGVhcmxpZXN0IHRpbWVvdXQgdGhyZXNob2xkIG9mIGFsbCB0aGUgcGxhY2Vob2xkZXJzIGluIHRoZVxuICAgIC8vIGFuY2VzdG9yIHBhdGguIFdlIGNvdWxkIGF2b2lkIHRoaXMgdHJhdmVyc2FsIGJ5IHN0b3JpbmcgdGhlIHRocmVzaG9sZHMgb25cbiAgICAvLyB0aGUgc3RhY2ssIGJ1dCB3ZSBjaG9vc2Ugbm90IHRvIGJlY2F1c2Ugd2Ugb25seSBoaXQgdGhpcyBwYXRoIGlmIHdlJ3JlXG4gICAgLy8gSU8tYm91bmQgKGkuZS4gaWYgc29tZXRoaW5nIHN1c3BlbmRzKS4gV2hlcmVhcyB0aGUgc3RhY2sgaXMgdXNlZCBldmVuIGluXG4gICAgLy8gdGhlIG5vbi1JTy0gYm91bmQgY2FzZS5cbiAgICB2YXIgX3dvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgdmFyIGVhcmxpZXN0VGltZW91dE1zID0gLTE7XG4gICAgdmFyIHN0YXJ0VGltZU1zID0gLTE7XG4gICAgZG8ge1xuICAgICAgaWYgKF93b3JrSW5Qcm9ncmVzcy50YWcgPT09IFBsYWNlaG9sZGVyQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gX3dvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlID09PSB0cnVlICYmIGN1cnJlbnQuc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVhY2hlZCBhIHBsYWNlaG9sZGVyIHRoYXQgYWxyZWFkeSB0aW1lZCBvdXQuIEVhY2ggdGltZWQgb3V0XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYWN0cyBhcyB0aGUgcm9vdCBvZiBhIG5ldyBzdXNwZW5zZSBib3VuZGFyeS5cblxuICAgICAgICAgIC8vIFVzZSB0aGUgdGltZSBhdCB3aGljaCB0aGUgcGxhY2Vob2xkZXIgdGltZWQgb3V0IGFzIHRoZSBzdGFydCB0aW1lXG4gICAgICAgICAgLy8gZm9yIHRoZSBjdXJyZW50IHJlbmRlci5cbiAgICAgICAgICB2YXIgdGltZWRPdXRBdCA9IGN1cnJlbnQuc3RhdGVOb2RlLnRpbWVkT3V0QXQ7XG4gICAgICAgICAgc3RhcnRUaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXModGltZWRPdXRBdCk7XG5cbiAgICAgICAgICAvLyBEbyBub3Qgc2VhcmNoIGFueSBmdXJ0aGVyLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lb3V0UHJvcE1zID0gX3dvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5kZWxheU1zO1xuICAgICAgICBpZiAodHlwZW9mIHRpbWVvdXRQcm9wTXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaWYgKHRpbWVvdXRQcm9wTXMgPD0gMCkge1xuICAgICAgICAgICAgZWFybGllc3RUaW1lb3V0TXMgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWFybGllc3RUaW1lb3V0TXMgPT09IC0xIHx8IHRpbWVvdXRQcm9wTXMgPCBlYXJsaWVzdFRpbWVvdXRNcykge1xuICAgICAgICAgICAgZWFybGllc3RUaW1lb3V0TXMgPSB0aW1lb3V0UHJvcE1zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuXG4gICAgLy8gU2NoZWR1bGUgdGhlIG5lYXJlc3QgUGxhY2Vob2xkZXIgdG8gcmUtcmVuZGVyIHRoZSB0aW1lZCBvdXQgdmlldy5cbiAgICBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICBkbyB7XG4gICAgICBpZiAoX3dvcmtJblByb2dyZXNzLnRhZyA9PT0gUGxhY2Vob2xkZXJDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGRpZFRpbWVvdXQgPSBfd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgaWYgKCFkaWRUaW1lb3V0KSB7XG4gICAgICAgICAgLy8gRm91bmQgdGhlIG5lYXJlc3QgYm91bmRhcnkuXG5cbiAgICAgICAgICAvLyBJZiB0aGUgYm91bmRhcnkgaXMgbm90IGluIGFzeW5jIG1vZGUsIHdlIHNob3VsZCBub3Qgc3VzcGVuZCwgYW5kXG4gICAgICAgICAgLy8gbGlrZXdpc2UsIHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMsIHdlIHNob3VsZCBwaW5nIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgdmFyIHBpbmdUaW1lID0gKF93b3JrSW5Qcm9ncmVzcy5tb2RlICYgQXN5bmNNb2RlKSA9PT0gTm9FZmZlY3QgPyBTeW5jIDogcmVuZGVyRXhwaXJhdGlvblRpbWU7XG5cbiAgICAgICAgICAvLyBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgcHJvbWlzZSB0byBcInBpbmdcIiB0aGUgcm9vdCBhbmQgcmV0cnkuXG4gICAgICAgICAgdmFyIG9uUmVzb2x2ZU9yUmVqZWN0ID0gcmV0cnlTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgX3dvcmtJblByb2dyZXNzLCBwaW5nVGltZSk7XG4gICAgICAgICAgdGhlbmFibGUudGhlbihvblJlc29sdmVPclJlamVjdCwgb25SZXNvbHZlT3JSZWplY3QpO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIGJvdW5kYXJ5IGlzIG91dHNpZGUgb2Ygc3RyaWN0IG1vZGUsIHdlIHNob3VsZCAqbm90KiBzdXNwZW5kXG4gICAgICAgICAgLy8gdGhlIGNvbW1pdC4gUHJldGVuZCBhcyBpZiB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCByZW5kZXJlZCBudWxsIGFuZFxuICAgICAgICAgIC8vIGtlZXAgcmVuZGVyaW5nLiBJbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSdsbCBzY2hlZHVsZSBhIHN1YnNlcXVlbnRcbiAgICAgICAgICAvLyBzeW5jaHJvbm91cyB1cGRhdGUgdG8gcmUtcmVuZGVyIHRoZSBQbGFjZWhvbGRlci5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIE5vdGU6IEl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgdGhlIGNvbXBvbmVudCB0aGF0IHN1c3BlbmRlZCB3YXNcbiAgICAgICAgICAvLyBpbnNpZGUgYSBzdHJpY3QgbW9kZSB0cmVlLiBJZiB0aGUgUGxhY2Vob2xkZXIgaXMgb3V0c2lkZSBvZiBpdCwgd2VcbiAgICAgICAgICAvLyBzaG91bGQgKm5vdCogc3VzcGVuZCB0aGUgY29tbWl0LlxuICAgICAgICAgIGlmICgoX3dvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAgIF93b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuXG4gICAgICAgICAgICAvLyBVbm1vdW50IHRoZSBzb3VyY2UgZmliZXIncyBjaGlsZHJlblxuICAgICAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihzb3VyY2VGaWJlci5hbHRlcm5hdGUsIHNvdXJjZUZpYmVyLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIHNvdXJjZUZpYmVyLmVmZmVjdFRhZyAmPSB+SW5jb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VGaWJlci50YWcgPT09IEluZGV0ZXJtaW5hdGVDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgLy8gTGV0J3MganVzdCBhc3N1bWUgaXQncyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LiBUaGlzIGZpYmVyIHdpbGxcbiAgICAgICAgICAgICAgLy8gYmUgdW5tb3VudGVkIGluIHRoZSBpbW1lZGlhdGUgbmV4dCBjb21taXQsIGFueXdheS5cbiAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgc291cmNlRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpIHtcbiAgICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gY29tbWl0IHRoaXMgZmliZXIgZXZlbiB0aG91Z2ggaXQgZGlkbid0XG4gICAgICAgICAgICAgIC8vIGNvbXBsZXRlLiBCdXQgd2Ugc2hvdWxkbid0IGNhbGwgYW55IGxpZmVjeWNsZSBtZXRob2RzIG9yXG4gICAgICAgICAgICAgIC8vIGNhbGxiYWNrcy4gUmVtb3ZlIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLmVmZmVjdFRhZyAmPSB+TGlmZWN5Y2xlRWZmZWN0TWFzaztcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZUZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGFib3V0IHRvIG1vdW50IGEgY2xhc3MgY29tcG9uZW50IHRoYXQgZG9lc24ndCBoYXZlIGFuXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UuIFR1cm4gdGhpcyBpbnRvIGEgZHVtbXkgZnVuY3Rpb25hbCBjb21wb25lbnQgaW5zdGVhZCxcbiAgICAgICAgICAgICAgICAvLyB0byBwcmV2ZW50IHR5cGUgZXJyb3JzLiBUaGlzIGlzIGEgYml0IHdlaXJkIGJ1dCBpdCdzIGFuIGVkZ2VcbiAgICAgICAgICAgICAgICAvLyBjYXNlIGFuZCB3ZSdyZSBhYm91dCB0byBzeW5jaHJvbm91c2x5IGRlbGV0ZSB0aGlzXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50LCBhbnl3YXkuXG4gICAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWJlci50eXBlID0gTm9vcENvbXBvbmVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeGl0IHdpdGhvdXQgc3VzcGVuZGluZy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb25maXJtZWQgdGhhdCB0aGUgYm91bmRhcnkgaXMgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiBDb250aW51ZSB3aXRoXG4gICAgICAgICAgLy8gdGhlIG5vcm1hbCBzdXNwZW5kIHBhdGguXG5cbiAgICAgICAgICB2YXIgYWJzb2x1dGVUaW1lb3V0TXMgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKGVhcmxpZXN0VGltZW91dE1zID09PSAtMSkge1xuICAgICAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgdGhyZXNob2xkIGlzIGdpdmVuLCBkZWZhdWx0IHRvIGFuIGFiaXRyYXJpbHkgbGFyZ2VcbiAgICAgICAgICAgIC8vIHZhbHVlLiBUaGUgYWN0dWFsIHNpemUgZG9lc24ndCBtYXR0ZXIgYmVjYXVzZSB0aGUgdGhyZXNob2xkIGZvciB0aGVcbiAgICAgICAgICAgIC8vIHdob2xlIHRyZWUgd2lsbCBiZSBjbGFtcGVkIHRvIHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgICAgICBhYnNvbHV0ZVRpbWVvdXRNcyA9IG1heFNpZ25lZDMxQml0SW50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lTXMgPT09IC0xKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgc3VzcGVuZCBoYXBwZW5lZCBvdXRzaWRlIG9mIGFueSBhbHJlYWR5IHRpbWVkLW91dFxuICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlcnMuIFdlIGRvbid0IGtub3cgZXhhY3RseSB3aGVuIHRoZSB1cGRhdGUgd2FzIHNjaGVkdWxlZCxcbiAgICAgICAgICAgICAgLy8gYnV0IHdlIGNhbiBpbmZlciBhbiBhcHByb3hpbWF0ZSBzdGFydCB0aW1lIGZyb20gdGhlIGV4cGlyYXRpb25cbiAgICAgICAgICAgICAgLy8gdGltZS4gRmlyc3QsIGZpbmQgdGhlIGVhcmxpZXN0IHVuY29tbWl0dGVkIGV4cGlyYXRpb24gdGltZSBpbiB0aGVcbiAgICAgICAgICAgICAgLy8gdHJlZSwgaW5jbHVkaW5nIHdvcmsgdGhhdCBpcyBzdXNwZW5kZWQuIFRoZW4gc3VidHJhY3QgdGhlIG9mZnNldFxuICAgICAgICAgICAgICAvLyB1c2VkIHRvIGNvbXB1dGUgYW4gYXN5bmMgdXBkYXRlJ3MgZXhwaXJhdGlvbiB0aW1lLiBUaGlzIHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgLy8gaGlnaCBwcmlvcml0eSAoaW50ZXJhY3RpdmUpIHdvcmsgdG8gZXhwaXJlIGVhcmxpZXIgdGhhbiBuZWNlc3NhcnksXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBjYW4gYWNjb3VudCBmb3IgdGhpcyBieSBhZGp1c3RpbmcgZm9yIHRoZSBKdXN0IE5vdGljZWFibGVcbiAgICAgICAgICAgICAgLy8gRGlmZmVyZW5jZS5cbiAgICAgICAgICAgICAgdmFyIGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPSBmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICB2YXIgZWFybGllc3RFeHBpcmF0aW9uVGltZU1zID0gZXhwaXJhdGlvblRpbWVUb01zKGVhcmxpZXN0RXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBzdGFydFRpbWVNcyA9IGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyAtIExPV19QUklPUklUWV9FWFBJUkFUSU9OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWJzb2x1dGVUaW1lb3V0TXMgPSBzdGFydFRpbWVNcyArIGVhcmxpZXN0VGltZW91dE1zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1hcmsgdGhlIGVhcmxpZXN0IHRpbWVvdXQgaW4gdGhlIHN1c3BlbmRlZCBmaWJlcidzIGFuY2VzdG9yIHBhdGguXG4gICAgICAgICAgLy8gQWZ0ZXIgY29tcGxldGluZyB0aGUgcm9vdCwgd2UnbGwgdGFrZSB0aGUgbGFyZ2VzdCBvZiBhbGwgdGhlXG4gICAgICAgICAgLy8gc3VzcGVuZGVkIGZpYmVyJ3MgdGltZW91dHMgYW5kIHVzZSBpdCB0byBjb21wdXRlIGEgdGltZW91dCBmb3IgdGhlXG4gICAgICAgICAgLy8gd2hvbGUgdHJlZS5cbiAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kKHJvb3QsIGFic29sdXRlVGltZW91dE1zLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgX3dvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuIENvbnRpbnVlIHRvIHRoZVxuICAgICAgICAvLyBuZXh0IGJvdW5kYXJ5LlxuICAgICAgfVxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuICAgIC8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gRmFsbHRocm91Z2ggdG8gZXJyb3IgbW9kZS5cbiAgICB2YWx1ZSA9IG5ldyBFcnJvcignQW4gdXBkYXRlIHdhcyBzdXNwZW5kZWQsIGJ1dCBubyBwbGFjZWhvbGRlciBVSSB3YXMgcHJvdmlkZWQuJyk7XG4gIH1cblxuICAvLyBXZSBkaWRuJ3QgZmluZCBhIGJvdW5kYXJ5IHRoYXQgY291bGQgaGFuZGxlIHRoaXMgdHlwZSBvZiBleGNlcHRpb24uIFN0YXJ0XG4gIC8vIG92ZXIgYW5kIHRyYXZlcnNlIHBhcmVudCBwYXRoIGFnYWluLCB0aGlzIHRpbWUgdHJlYXRpbmcgdGhlIGV4Y2VwdGlvblxuICAvLyBhcyBhbiBlcnJvci5cbiAgcmVuZGVyRGlkRXJyb3IoKTtcbiAgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICBkbyB7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2Vycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX2Vycm9ySW5mbywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgICAgLy8gQ2FwdHVyZSBhbmQgcmV0cnlcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSA9PT0gTm9FZmZlY3QgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiBlbmFibGVHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuICAgICAgICAgIHZhciBfdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgZXJyb3JJbmZvLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcbn1cblxuZnVuY3Rpb24gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICBpZiAoZWZmZWN0VGFnICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fcmVhY3RSZXN1bHQ7XG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICBpZiAoX2VmZmVjdFRhZyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIF9lZmZlY3RUYWcyID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAhKChfZWZmZWN0VGFnMiAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgcm9vdCBmYWlsZWQgdG8gdW5tb3VudCBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnMiAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICBjYXNlIFBsYWNlaG9sZGVyQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX2VmZmVjdFRhZzMgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIGlmIChfZWZmZWN0VGFnMyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnMyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGludGVycnVwdGVkV29yay50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuICAgICAgICBpZiAoY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvcENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jaGlsZENvbnRleHRUeXBlcyA9IGludGVycnVwdGVkV29yay50eXBlLl9yZWFjdFJlc3VsdC5jaGlsZENvbnRleHRUeXBlcztcbiAgICAgICAgaWYgKF9jaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBfY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvcENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufVxuXG52YXIgRGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0XG59O1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXG5cbnZhciBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSB2b2lkIDA7XG52YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdm9pZCAwO1xudmFyIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkID0gdm9pZCAwO1xudmFyIHdhcm5BYm91dEludmFsaWRVcGRhdGVzID0gdm9pZCAwO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSBmYWxzZTtcbiAgdmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG4gIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgLy8gV2Ugc2hvdyB0aGUgd2hvbGUgc3RhY2sgYnV0IGRlZHVwZSBvbiB0aGUgdG9wIGNvbXBvbmVudCdzIG5hbWUgYmVjYXVzZVxuICAgIC8vIHRoZSBwcm9ibGVtYXRpYyBjb2RlIGFsbW9zdCBhbHdheXMgbGllcyBpbnNpZGUgdGhhdCBjb21wb25lbnQuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJDYW4ndCBjYWxsIHNldFN0YXRlIChvciBmb3JjZVVwZGF0ZSkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBcIiArICdpcyBhIG5vLW9wLCBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gJyArICdmaXgsIGNhbmNlbCBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluIHRoZSAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IG1ldGhvZC4lcycsIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChmaWJlcikpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgICBjYXNlICdnZXRDaGlsZENvbnRleHQnOlxuICAgICAgICBpZiAoZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJyk7XG4gICAgICAgIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVuZGVyJzpcbiAgICAgICAgaWYgKGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgJ2ByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gVXNlZCB0byBlbnN1cmUgY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbiBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG52YXIgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiA9IDA7XG5cbi8vIFJlcHJlc2VudHMgdGhlIGV4cGlyYXRpb24gdGltZSB0aGF0IGluY29taW5nIHVwZGF0ZXMgc2hvdWxkIHVzZS4gKElmIHRoaXNcbi8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbi8vIHVwZGF0ZXMgaW4gc3luYyBtb2RlLilcbnZhciBleHBpcmF0aW9uQ29udGV4dCA9IE5vV29yaztcblxudmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4vLyBUaGUgbmV4dCB3b3JrIGluIHByb2dyZXNzIGZpYmVyIHRoYXQgd2UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG52YXIgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xudmFyIG5leHRSb290ID0gbnVsbDtcbi8vIFRoZSB0aW1lIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgd29yay5cbnZhciBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gLTE7XG52YXIgbmV4dFJlbmRlckRpZEVycm9yID0gZmFsc2U7XG5cbi8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG52YXIgbmV4dEVmZmVjdCA9IG51bGw7XG5cbnZhciBpc0NvbW1pdHRpbmckMSA9IGZhbHNlO1xuXG52YXIgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuXG4vLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbnZhciBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxuLy8gRG8gbm90IGRlY3JlbWVudCBpbnRlcmFjdGlvbiBjb3VudHMgaW4gdGhlIGV2ZW50IG9mIHN1c3BlbnNlIHRpbWVvdXRzLlxuLy8gVGhpcyB3b3VsZCBsZWFkIHRvIHByZW1hdHVyZWx5IGNhbGxpbmcgdGhlIGludGVyYWN0aW9uLWNvbXBsZXRlIGhvb2suXG52YXIgc3VzcGVuc2VEaWRUaW1lb3V0ID0gZmFsc2U7XG5cbnZhciBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gdm9pZCAwO1xudmFyIHJlcGxheVVuaXRPZldvcmsgPSB2b2lkIDA7XG52YXIgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gdm9pZCAwO1xudmFyIG9yaWdpbmFsUmVwbGF5RXJyb3IgPSB2b2lkIDA7XG52YXIgcmV0aHJvd09yaWdpbmFsRXJyb3IgPSB2b2lkIDA7XG5pZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gbnVsbDtcbiAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gZmFsc2U7XG4gIG9yaWdpbmFsUmVwbGF5RXJyb3IgPSBudWxsO1xuICByZXBsYXlVbml0T2ZXb3JrID0gZnVuY3Rpb24gKGZhaWxlZFVuaXRPZldvcmssIHRocm93blZhbHVlLCBpc1lpZWxkeSkge1xuICAgIGlmICh0aHJvd25WYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBEb24ndCByZXBsYXkgcHJvbWlzZXMuIFRyZWF0IGV2ZXJ5dGhpbmcgZWxzZSBsaWtlIGFuIGVycm9yLlxuICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGEgZGlmZmVyZW50IHN0cmF0ZWd5IGlmL3doZW4gd2UgYWRkXG4gICAgICAvLyBzdXBwb3J0IGZvciBjYXRjaGluZyBvdGhlciB0eXBlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgd29yay1pbi1wcm9ncmVzc1xuICAgIGlmIChzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIERvbid0IHRocm93IGJlY2F1c2UgdGhpcyBjb2RlIGlzIERFVi1vbmx5LlxuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnQ291bGQgbm90IHJlcGxheSByZW5kZXJpbmcgYWZ0ZXIgYW4gZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihmYWlsZWRVbml0T2ZXb3JrLCBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzKTtcblxuICAgIHN3aXRjaCAoZmFpbGVkVW5pdE9mV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gZmFpbGVkVW5pdE9mV29yay50eXBlO1xuICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICBwb3BDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX0NvbXBvbmVudCA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKGZhaWxlZFVuaXRPZldvcmsudHlwZSk7XG4gICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgICBwb3BDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgICBwb3BQcm92aWRlcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlcGxheSB0aGUgYmVnaW4gcGhhc2UuXG4gICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gdHJ1ZTtcbiAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gdGhyb3duVmFsdWU7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIHdvcmtMb29wLCBudWxsLCBpc1lpZWxkeSk7XG4gICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gZmFsc2U7XG4gICAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IG51bGw7XG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciByZXBsYXlFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmIChyZXBsYXlFcnJvciAhPSBudWxsICYmIHRocm93blZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBSZWFkaW5nIHRoZSBleHBhbmRvIHByb3BlcnR5IGlzIGludGVudGlvbmFsbHlcbiAgICAgICAgICAvLyBpbnNpZGUgYHRyeWAgYmVjYXVzZSBpdCBtaWdodCBiZSBhIGdldHRlciBvciBQcm94eS5cbiAgICAgICAgICBpZiAocmVwbGF5RXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgICAgICAgLy8gQWxzbyBzdXBwcmVzcyBsb2dnaW5nIGZvciB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gICAgICAgICAgICB0aHJvd25WYWx1ZS5fc3VwcHJlc3NMb2dnaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGlubmVyKSB7XG4gICAgICAgICAgLy8gSWdub3JlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBiZWdpbiBwaGFzZSBkaWQgbm90IGZhaWwgdGhlIHNlY29uZCB0aW1lLCBzZXQgdGhpcyBwb2ludGVyXG4gICAgICAvLyBiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgIG5leHRVbml0T2ZXb3JrID0gZmFpbGVkVW5pdE9mV29yaztcbiAgICB9XG4gIH07XG4gIHJldGhyb3dPcmlnaW5hbEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG9yaWdpbmFsUmVwbGF5RXJyb3I7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RhY2soKSB7XG4gIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSBuZXh0VW5pdE9mV29yay5yZXR1cm47XG4gICAgd2hpbGUgKGludGVycnVwdGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGludGVycnVwdGVkV29yayk7XG4gICAgICBpbnRlcnJ1cHRlZFdvcmsgPSBpbnRlcnJ1cHRlZFdvcmsucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gICAgY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCk7XG4gIH1cblxuICBuZXh0Um9vdCA9IG51bGw7XG4gIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gLTE7XG4gIG5leHRSZW5kZXJEaWRFcnJvciA9IGZhbHNlO1xuICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEFsbEhvc3RFZmZlY3RzKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB9XG4gICAgcmVjb3JkRWZmZWN0KCk7XG5cbiAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgIHZhciBjdXJyZW50JCQxID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCQkMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgLy8gcG9zc2libGUgYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlXG4gICAgLy8gZWZmZWN0IHRhZyBhbmQgc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG4gICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiAoUGxhY2VtZW50IHwgVXBkYXRlIHwgRGVsZXRpb24pO1xuICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAvLyB0byBraWxsIHRoaXMuXG4gICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBQbGFjZW1lbnRcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICB2YXIgX2N1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnQyID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcygpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgIGlmIChlZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICB2YXIgY3VycmVudCQkMSA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQkJDEsIG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIC8vIERvbid0IGNsZWFudXAgZWZmZWN0cyB5ZXQ7XG4gICAgLy8gVGhpcyB3aWxsIGJlIGRvbmUgYnkgY29tbWl0QWxsTGlmZUN5Y2xlcygpXG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcblxuICAgIGlmICh3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcykge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncygpO1xuICAgIH1cblxuICAgIGlmICh3YXJuQWJvdXRMZWdhY3lDb250ZXh0QVBJKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgdmFyIGN1cnJlbnQkJDEgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjdXJyZW50JCQxLCBuZXh0RWZmZWN0LCBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICBjb21taXRBdHRhY2hSZWYobmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgY2xlYW4gdGhlc2UgdXAgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHkga2VlcCB0aGVtLlxuICAgIC8vIEknbSBub3QgYWN0dWFsbHkgc3VyZSB0aGlzIG1hdHRlcnMgYmVjYXVzZSB3ZSBjYW4ndCByZXNldCBmaXJzdEVmZmVjdFxuICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgIC8vIG9uZXMuIFNvIHdlIGhhdmUgdG8gY2xlYW4gZXZlcnl0aGluZyBhcyB3ZSByZXVzZSBub2RlcyBhbnl3YXkuXG4gICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAvLyB0YWdzIHRvIHJlYXNvbiBhYm91dCB0aGUgY3VycmVudCBsaWZlLWN5Y2xlLlxuICAgIG5leHRFZmZlY3QgPSBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcbiAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFtpbnN0YW5jZV0pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290LCBmaW5pc2hlZFdvcmspIHtcbiAgaXNXb3JraW5nID0gdHJ1ZTtcbiAgaXNDb21taXR0aW5nJDEgPSB0cnVlO1xuICBzdGFydENvbW1pdFRpbWVyKCk7XG5cbiAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lID0gcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU7XG4gICEoY29tbWl0dGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVXBkYXRlIHRoZSBwZW5kaW5nIHByaW9yaXR5IGxldmVscyB0byBhY2NvdW50IGZvciB0aGUgd29yayB0aGF0IHdlIGFyZVxuICAvLyBhYm91dCB0byBjb21taXQuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSBjYWxsaW5nIHRoZSBsaWZlY3ljbGVzLCBzaW5jZVxuICAvLyB0aGV5IG1heSBzY2hlZHVsZSBhZGRpdGlvbmFsIHVwZGF0ZXMuXG4gIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA9IGZpbmlzaGVkV29yay5leHBpcmF0aW9uVGltZTtcbiAgdmFyIGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgPSBmaW5pc2hlZFdvcmsuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgdmFyIGVhcmxpZXN0UmVtYWluaW5nVGltZUJlZm9yZUNvbW1pdCA9IHVwZGF0ZUV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0ID09PSBOb1dvcmsgfHwgY2hpbGRFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCAhPT0gTm9Xb3JrICYmIGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgPCB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA/IGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgOiB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdDtcbiAgbWFya0NvbW1pdHRlZFByaW9yaXR5TGV2ZWxzKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZUJlZm9yZUNvbW1pdCk7XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBudWxsO1xuICB2YXIgY29tbWl0dGVkSW50ZXJhY3Rpb25zID0gZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcgPyBbXSA6IG51bGw7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFja2luZykge1xuICAgIC8vIFJlc3RvcmUgYW55IHBlbmRpbmcgaW50ZXJhY3Rpb25zIGF0IHRoaXMgcG9pbnQsXG4gICAgLy8gU28gdGhhdCBjYXNjYWRpbmcgd29yayB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugd2lsbCBiZSBhY2NvdW50ZWQgZm9yLlxuICAgIHByZXZJbnRlcmFjdGlvbnMgPSB0cmFja2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICAgIHRyYWNraW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zO1xuXG4gICAgLy8gV2UgYXJlIHBvdGVudGlhbGx5IGZpbmlzaGVkIHdpdGggdGhlIGN1cnJlbnQgYmF0Y2ggb2YgaW50ZXJhY3Rpb25zLlxuICAgIC8vIFNvIHdlIHNob3VsZCBjbGVhciB0aGVtIG91dCBvZiB0aGUgcGVuZGluZyBpbnRlcmFjdGlvbiBtYXAuXG4gICAgLy8gV2UgZG8gdGhpcyBhdCB0aGUgc3RhcnQgb2YgY29tbWl0IGluIGNhc2UgY2FzY2FkaW5nIHdvcmsgaXMgc2NoZWR1bGVkIGJ5IGNvbW1pdCBwaGFzZSBsaWZlY3ljbGVzLlxuICAgIC8vIEluIHRoYXQgZXZlbnQsIGludGVyYWN0aW9uIGRhdGEgbWF5IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcGVuZGluZyBtYXAgZm9yIGEgZnV0dXJlIGNvbW1pdC5cbiAgICAvLyBXZSBhbHNvIHN0b3JlIHRoZSBpbnRlcmFjdGlvbnMgd2UgYXJlIGFib3V0IHRvIGNvbW1pdCBzbyB0aGF0IHdlIGNhbiBub3RpZnkgc3Vic2NyaWJlcnMgYWZ0ZXIgd2UncmUgZG9uZS5cbiAgICAvLyBUaGVzZSBhcmUgc3RvcmVkIGFzIGFuIEFycmF5IHJhdGhlciB0aGFuIGEgU2V0LFxuICAgIC8vIEJlY2F1c2UgdGhlIHNhbWUgaW50ZXJhY3Rpb24gbWF5IGJlIHBlbmRpbmcgZm9yIG11bHRpcGxlIGV4cGlyYXRpb24gdGltZXMsXG4gICAgLy8gSW4gd2hpY2ggY2FzZSBpdCdzIGltcG9ydGFudCB0aGF0IHdlIGRlY3JlbWVudCB0aGUgY291bnQgdGhlIHJpZ2h0IG51bWJlciBvZiB0aW1lcyBhZnRlciBmaW5pc2hpbmcuXG4gICAgcm9vdC5wZW5kaW5nSW50ZXJhY3Rpb25NYXAuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGVkSW50ZXJhY3Rpb25zLCBzY2hlZHVsZWRFeHBpcmF0aW9uVGltZSkge1xuICAgICAgaWYgKHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lIDw9IGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIGNvbW1pdHRlZEludGVyYWN0aW9ucy5wdXNoLmFwcGx5KGNvbW1pdHRlZEludGVyYWN0aW9ucywgQXJyYXkuZnJvbShzY2hlZHVsZWRJbnRlcmFjdGlvbnMpKTtcbiAgICAgICAgcm9vdC5wZW5kaW5nSW50ZXJhY3Rpb25NYXAuZGVsZXRlKHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7XG5cbiAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAvLyBBIGZpYmVyJ3MgZWZmZWN0IGxpc3QgY29uc2lzdHMgb25seSBvZiBpdHMgY2hpbGRyZW4sIG5vdCBpdHNlbGYuIFNvIGlmXG4gICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgLy8gcmVzdWx0aW5nIGxpc3QgaXMgdGhlIHNldCB0aGF0IHdvdWxkIGJlbG9uZyB0byB0aGUgcm9vdCdzIHBhcmVudCwgaWZcbiAgICAvLyBpdCBoYWQgb25lOyB0aGF0IGlzLCBhbGwgdGhlIGVmZmVjdHMgaW4gdGhlIHRyZWUgaW5jbHVkaW5nIHRoZSByb290LlxuICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gZWZmZWN0IG9uIHRoZSByb290LlxuICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICB9XG5cbiAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXG4gIC8vIEludm9rZSBpbnN0YW5jZXMgb2YgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgYmVmb3JlIG11dGF0aW9uLlxuICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gIHN0YXJ0Q29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcywgbnVsbCk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIGVycm9yKTtcbiAgICAgIC8vIENsZWFuLXVwXG4gICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpcyBiYXRjaC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgIHJlY29yZENvbW1pdFRpbWUoKTtcbiAgfVxuXG4gIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gIC8vIHJlZiB1bm1vdW50cy5cbiAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9lcnJvciA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QWxsSG9zdEVmZmVjdHMsIG51bGwpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2Vycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IpO1xuICAgICAgLy8gQ2xlYW4tdXBcbiAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG5cbiAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXG4gIC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUgaXMgbm93IHRoZSBjdXJyZW50IHRyZWUuIFRoaXMgbXVzdCBjb21lIGFmdGVyXG4gIC8vIHRoZSBmaXJzdCBwYXNzIG9mIHRoZSBjb21taXQgcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGxcbiAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gIC8vIHRoZSBmaW5pc2hlZCB3b3JrIGlzIGN1cnJlbnQgZHVyaW5nIGNvbXBvbmVudERpZE1vdW50L1VwZGF0ZS5cbiAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuXG4gIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgLy8gTGlmZS1jeWNsZXMgaGFwcGVuIGFzIGEgc2VwYXJhdGUgcGFzcyBzbyB0aGF0IGFsbCBwbGFjZW1lbnRzLCB1cGRhdGVzLFxuICAvLyBhbmQgZGVsZXRpb25zIGluIHRoZSBlbnRpcmUgdHJlZSBoYXZlIGFscmVhZHkgYmVlbiBpbnZva2VkLlxuICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9kaWRFcnJvcjIgPSBmYWxzZTtcbiAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCwgcm9vdCwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgX2RpZEVycm9yMiA9IHRydWU7XG4gICAgICAgIF9lcnJvcjIgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfZGlkRXJyb3IyKSB7XG4gICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IyKTtcbiAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNDb21taXR0aW5nJDEgPSBmYWxzZTtcbiAgaXNXb3JraW5nID0gZmFsc2U7XG4gIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgc3RvcENvbW1pdFRpbWVyKCk7XG4gIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21taXRXb3JrKGZpbmlzaGVkV29yayk7XG4gIH1cblxuICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdCA9IGZpbmlzaGVkV29yay5leHBpcmF0aW9uVGltZTtcbiAgdmFyIGNoaWxkRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdCA9IGZpbmlzaGVkV29yay5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICB2YXIgZWFybGllc3RSZW1haW5pbmdUaW1lQWZ0ZXJDb21taXQgPSB1cGRhdGVFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0ID09PSBOb1dvcmsgfHwgY2hpbGRFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0ICE9PSBOb1dvcmsgJiYgY2hpbGRFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0IDwgdXBkYXRlRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdCA/IGNoaWxkRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdCA6IHVwZGF0ZUV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQ7XG4gIGlmIChlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuICBvbkNvbW1pdChyb290LCBlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCk7XG5cbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNraW5nKSB7XG4gICAgdHJhY2tpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICB2YXIgc3Vic2NyaWJlciA9IHZvaWQgMDtcblxuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyID0gdHJhY2tpbmcuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChjb21taXR0ZWRFeHBpcmF0aW9uVGltZSwgcm9vdC5pbnRlcmFjdGlvblRocmVhZElEKTtcbiAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSXQncyBub3Qgc2FmZSBmb3IgY29tbWl0Um9vdCgpIHRvIHRocm93LlxuICAgICAgLy8gU3RvcmUgdGhlIGVycm9yIGZvciBub3cgYW5kIHdlJ2xsIHJlLXRocm93IGluIGZpbmlzaFJlbmRlcmluZygpLlxuICAgICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIERvbid0IHVwZGF0ZSBpbnRlcmFjdGlvbiBjb3VudHMgaWYgd2UncmUgZnJvemVuIGR1ZSB0byBzdXNwZW5zZS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgY2FuIHNraXAgdGhlIGNvbXBsZXRlZC13b3JrIGNoZWNrIGVudGlyZWx5LlxuICAgICAgaWYgKCFzdXNwZW5zZURpZFRpbWVvdXQpIHtcbiAgICAgICAgLy8gTm93IHRoYXQgd2UncmUgZG9uZSwgY2hlY2sgdGhlIGNvbXBsZXRlZCBiYXRjaCBvZiBpbnRlcmFjdGlvbnMuXG4gICAgICAgIC8vIElmIG5vIG1vcmUgd29yayBpcyBvdXRzdGFuZGluZyBmb3IgYSBnaXZlbiBpbnRlcmFjdGlvbixcbiAgICAgICAgLy8gV2UgbmVlZCB0byBub3RpZnkgdGhlIHN1YnNjcmliZXJzIHRoYXQgaXQncyBmaW5pc2hlZC5cbiAgICAgICAgY29tbWl0dGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSXQncyBub3Qgc2FmZSBmb3IgY29tbWl0Um9vdCgpIHRvIHRocm93LlxuICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgZXJyb3IgZm9yIG5vdyBhbmQgd2UnbGwgcmUtdGhyb3cgaW4gZmluaXNoUmVuZGVyaW5nKCkuXG4gICAgICAgICAgICAgIGlmICghaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyVGltZSkge1xuICBpZiAocmVuZGVyVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MuY2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTmV2ZXIpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgLy8gV2UncmUgaW4gcHJvZmlsaW5nIG1vZGUuXG4gICAgLy8gTGV0J3MgdXNlIHRoaXMgc2FtZSB0cmF2ZXJzYWwgdG8gdXBkYXRlIHRoZSByZW5kZXIgZHVyYXRpb25zLlxuICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uO1xuICAgIHZhciB0cmVlQmFzZUR1cmF0aW9uID0gd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbjtcblxuICAgIC8vIFdoZW4gYSBmaWJlciBpcyBjbG9uZWQsIGl0cyBhY3R1YWxEdXJhdGlvbiBpcyByZXNldCB0byAwLlxuICAgIC8vIFRoaXMgdmFsdWUgd2lsbCBvbmx5IGJlIHVwZGF0ZWQgaWYgd29yayBpcyBkb25lIG9uIHRoZSBmaWJlciAoaS5lLiBpdCBkb2Vzbid0IGJhaWxvdXQpLlxuICAgIC8vIFdoZW4gd29yayBpcyBkb25lLCBpdCBzaG91bGQgYnViYmxlIHRvIHRoZSBwYXJlbnQncyBhY3R1YWxEdXJhdGlvbi5cbiAgICAvLyBJZiB0aGUgZmliZXIgaGFzIG5vdCBiZWVuIGNsb25lZCB0aG91Z2gsIChtZWFuaW5nIG5vIHdvcmsgd2FzIGRvbmUpLFxuICAgIC8vIFRoZW4gdGhpcyB2YWx1ZSB3aWxsIHJlZmxlY3QgdGhlIGFtb3VudCBvZiB0aW1lIHNwZW50IHdvcmtpbmcgb24gYSBwcmV2aW91cyByZW5kZXIuXG4gICAgLy8gSW4gdGhhdCBjYXNlIGl0IHNob3VsZCBub3QgYnViYmxlLlxuICAgIC8vIFdlIGRldGVybWluZSB3aGV0aGVyIGl0IHdhcyBjbG9uZWQgYnkgY29tcGFyaW5nIHRoZSBjaGlsZCBwb2ludGVyLlxuICAgIHZhciBzaG91bGRCdWJibGVBY3R1YWxEdXJhdGlvbnMgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZS5jaGlsZDtcblxuICAgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGNoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIHZhciBjaGlsZENoaWxkRXhwaXJhdGlvblRpbWUgPSBjaGlsZC5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBjaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSA8IG5ld0NoaWxkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9IGNoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSA8IG5ld0NoaWxkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9IGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRCdWJibGVBY3R1YWxEdXJhdGlvbnMpIHtcbiAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICB9XG4gICAgICB0cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9jaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChfY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSA9IF9jaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIHZhciBfY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lID0gX2NoaWxkLmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAobmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IF9jaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgX2NoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgPCBuZXdDaGlsZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPSBfY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdDaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgX2NoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIF9jaGlsZENoaWxkRXhwaXJhdGlvblRpbWUgPCBuZXdDaGlsZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPSBfY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGRFeHBpcmF0aW9uVGltZSA9IG5ld0NoaWxkRXhwaXJhdGlvblRpbWU7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZVxuICAvLyBuZXh0IHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlXG4gIC8vIHBhcmVudCBmaWJlci5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCQkMSA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB2YXIgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgSW5jb21wbGV0ZSkgPT09IE5vRWZmZWN0KSB7XG4gICAgICAvLyBUaGlzIGZpYmVyIGNvbXBsZXRlZC5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBjb21wbGV0ZVdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBjb21wbGV0ZVdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dCA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXNldENoaWxkRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCAmJlxuICAgICAgLy8gRG8gbm90IGFwcGVuZCBlZmZlY3RzIHRvIHBhcmVudHMgaWYgYSBzaWJsaW5nIGZhaWxlZCB0byBjb21wbGV0ZVxuICAgICAgKHJldHVybkZpYmVyLmVmZmVjdFRhZyAmIEluY29tcGxldGUpID09PSBOb0VmZmVjdCkge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFdlIGNhbiBwZXJmb3JtIGNlcnRhaW4gc2lkZS1lZmZlY3RzIGVhcmxpZXIgaWZcbiAgICAgICAgLy8gbmVlZGVkLCBieSBkb2luZyBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZWZmZWN0IGxpc3QuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgLy8gcmV1c2luZyBjaGlsZHJlbiB3ZSdsbCBzY2hlZHVsZSB0aGlzIGVmZmVjdCBvbnRvIGl0c2VsZiBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBhdCB0aGUgZW5kLlxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgICByZXR1cm4gc2libGluZ0ZpYmVyO1xuICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1vcmUgd29yayBpbiB0aGlzIHJldHVybkZpYmVyLiBDb21wbGV0ZSB0aGUgcmV0dXJuRmliZXIuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSByZW5kZXIgZHVyYXRpb24gZm9yIHRoZSBmaWJlciB0aGF0IGVycm9yZWQuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgIHZhciBfbmV4dCA9IHVud2luZFdvcmsod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAvLyBCZWNhdXNlIHRoaXMgZmliZXIgZGlkIG5vdCBjb21wbGV0ZSwgZG9uJ3QgcmVzZXQgaXRzIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSB7XG4gICAgICAgIC8vIFJlc3RhcnRpbmcgYW4gZXJyb3IgYm91bmRhcnlcbiAgICAgICAgc3RvcEZhaWxlZFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgICAgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICBpZiAoX25leHQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBfbmV4dC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9uZXh0LmNoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbmV4dC5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJlc3RhcnRpbmcsIHJlbW92ZSBhbnl0aGluZyB0aGF0IGlzIG5vdCBhIGhvc3QgZWZmZWN0XG4gICAgICAgIC8vIGZyb20gdGhlIGVmZmVjdCB0YWcuXG4gICAgICAgIF9uZXh0LmVmZmVjdFRhZyAmPSBIb3N0RWZmZWN0TWFzaztcbiAgICAgICAgcmV0dXJuIF9uZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBlZmZlY3QgbGlzdC5cbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuRmliZXIuZWZmZWN0VGFnIHw9IEluY29tcGxldGU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHdvcmsgaW4gdGhpcyByZXR1cm5GaWJlci4gQ29tcGxldGUgdGhlIHJldHVybkZpYmVyLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBleHBsaWNpdCBudWxsIHJldHVybiBGbG93IGNvbXBsYWlucyBvZiBpbnZhbGlkIHJldHVybiB0eXBlXG4gIC8vIFRPRE8gUmVtb3ZlIHRoZSBhYm92ZSB3aGlsZSh0cnVlKSBsb29wXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgLy8gcHJvZ3Jlc3MuXG4gIHZhciBjdXJyZW50JCQxID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gIHN0YXJ0V29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAge1xuICAgIHNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICBzdGFydFByb2ZpbGVyVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBhc3N1bWluZyB3ZSBkaWRuJ3QgYmFpbG91dCAob3IgZXJyb3IpLlxuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICBpZiAoaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBDdXJyZW50bHkgcmVwbGF5aW5nIGEgZmFpbGVkIHVuaXQgb2Ygd29yay4gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGUsXG4gICAgICAvLyBiZWNhdXNlIHRoZSByZW5kZXIgcGhhc2UgaXMgbWVhbnQgdG8gYmUgaWRlbXBvdGVudCwgYW5kIGl0IHNob3VsZFxuICAgICAgLy8gaGF2ZSB0aHJvd24gYWdhaW4uIFNpbmNlIGl0IGRpZG4ndCwgcmV0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IsIHNvXG4gICAgICAvLyBSZWFjdCdzIGludGVybmFsIHN0YWNrIGlzIG5vdCBtaXNhbGlnbmVkLlxuICAgICAgcmV0aHJvd09yaWdpbmFsRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xuXG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChpc1lpZWxkeSkge1xuICBpZiAoIWlzWWllbGR5KSB7XG4gICAgLy8gRmx1c2ggd29yayB3aXRob3V0IHlpZWxkaW5nXG4gICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUm9vdChyb290LCBpc1lpZWxkeSwgaXNFeHBpcmVkKSB7XG4gICEhaXNXb3JraW5nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICBpc1dvcmtpbmcgPSB0cnVlO1xuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnREaXNwYXRjaGVyID0gRGlzcGF0Y2hlcjtcblxuICB2YXIgZXhwaXJhdGlvblRpbWUgPSByb290Lm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uO1xuXG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gbnVsbDtcbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNraW5nKSB7XG4gICAgLy8gV2UncmUgYWJvdXQgdG8gc3RhcnQgbmV3IHRyYWNrZWQgd29yay5cbiAgICAvLyBSZXN0b3JlIHBlbmRpbmcgaW50ZXJhY3Rpb25zIHNvIGNhc2NhZGluZyB3b3JrIHRyaWdnZXJlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSB3aWxsIGJlIGFjY291bnRlZCBmb3IuXG4gICAgcHJldkludGVyYWN0aW9ucyA9IHRyYWNraW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgdHJhY2tpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnM7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgLy8gcHJldmlvdXNseSB5aWVsZGVkIHdvcmsuXG4gIGlmIChleHBpcmF0aW9uVGltZSAhPT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIHx8IHJvb3QgIT09IG5leHRSb290IHx8IG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgcmVzZXRTdGFjaygpO1xuICAgIG5leHRSb290ID0gcm9vdDtcbiAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcpIHtcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpbnRlcmFjdGlvbnMgdGhpcyBiYXRjaCBvZiB3b3JrIGN1cnJlbnRseSBpbmNsdWRlcyxcbiAgICAgIC8vIFNvIHRoYXQgd2UgY2FuIGFjY3VyYXRlbHkgYXR0cmlidXRlIHRpbWUgc3BlbnQgd29ya2luZyBvbiBpdCxcbiAgICAgIHZhciBpbnRlcmFjdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIGlmIChzY2hlZHVsZWRFeHBpcmF0aW9uVGltZSA8PSBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyYWN0aW9ucy5hZGQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgc2V0IG9mIGludGVyYWN0aW9ucyBvbiB0aGUgRmliZXJSb290IGZvciBhIGZldyByZWFzb25zOlxuICAgICAgLy8gV2UgY2FuIHJlLXVzZSBpdCBpbiBob3QgZnVuY3Rpb25zIGxpa2UgcmVuZGVyUm9vdCgpIHdpdGhvdXQgaGF2aW5nIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgICAgLy8gV2Ugd2lsbCBhbHNvIHVzZSBpdCBpbiBjb21taXRXb3JrKCkgdG8gcGFzcyB0byBhbnkgUHJvZmlsZXIgb25SZW5kZXIoKSBob29rcy5cbiAgICAgIC8vIFRoaXMgYWxzbyBwcm92aWRlcyBEZXZUb29scyB3aXRoIGEgd2F5IHRvIGFjY2VzcyBpdCB3aGVuIHRoZSBvbkNvbW1pdFJvb3QoKSBob29rIGlzIGNhbGxlZC5cbiAgICAgIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbnM7XG5cbiAgICAgIGlmIChpbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSB0cmFja2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgdGhyZWFkSUQgPSBjb21wdXRlVGhyZWFkSUQoZXhwaXJhdGlvblRpbWUsIHJvb3QuaW50ZXJhY3Rpb25UaHJlYWRJRCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gV29yayB0aHJvd24gYnkgYW4gaW50ZXJhY3Rpb24gdHJhY2tpbmcgc3Vic2NyaWJlciBzaG91bGQgYmUgcmV0aHJvd24sXG4gICAgICAgICAgICAvLyBCdXQgb25seSBvbmNlIGl0J3Mgc2FmZSAodG8gYXZvaWQgbGVhdmVpbmcgdGhlIHNjaGVkdWxlciBpbiBhbiBpbnZhbGlkIHN0YXRlKS5cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBlcnJvciBmb3Igbm93IGFuZCB3ZSdsbCByZS10aHJvdyBpbiBmaW5pc2hSZW5kZXJpbmcoKS5cbiAgICAgICAgICAgIGlmICghaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkaWRGYXRhbCA9IGZhbHNlO1xuXG4gIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcChpc1lpZWxkeSk7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZmF0YWwgZXJyb3IuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBSZXNldCBnbG9iYWwgZGVidWcgc3RhdGVcbiAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhpcyBpcyBkZWZpbmVkIGluIERFVlxuICAgICAgICAgIHJlc2V0Q3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFpbGVkVW5pdE9mV29yayA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgICAgIHJlcGxheVVuaXRPZldvcmsoZmFpbGVkVW5pdE9mV29yaywgdGhyb3duVmFsdWUsIGlzWWllbGR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHdlIGFscmVhZHkga25vdyB0aGlzIGlzbid0IHRydWUgaW4gc29tZSBjYXNlcy5cbiAgICAgICAgLy8gQXQgbGVhc3QgdGhpcyBzaG93cyBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgdW50aWwgd2UgZmlndXJlIG91dCB0aGUgY2F1c2UuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI0NDkjaXNzdWVjb21tZW50LTM4NjcyNzQzMVxuICAgICAgICAhKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0ZhaWxlZCB0byByZXBsYXkgcmVuZGVyaW5nIGFmdGVyIGFuIGVycm9yLiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIHdpdGggYSByZXByb2R1Y2luZyBjYXNlIHRvIGhlbHAgdXMgZmluZCBpdC4nKSA6IHZvaWQgMDtcblxuICAgICAgICB2YXIgc291cmNlRmliZXIgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gc291cmNlRmliZXIucmV0dXJuO1xuICAgICAgICBpZiAocmV0dXJuRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByb290LiBUaGUgcm9vdCBjb3VsZCBjYXB0dXJlIGl0cyBvd24gZXJyb3JzLiBIb3dldmVyLFxuICAgICAgICAgIC8vIHdlIGRvbid0IGtub3cgaWYgaXQgZXJyb3JzIGJlZm9yZSBvciBhZnRlciB3ZSBwdXNoZWQgdGhlIGhvc3RcbiAgICAgICAgICAvLyBjb250ZXh0LiBUaGlzIGluZm9ybWF0aW9uIGlzIG5lZWRlZCB0byBhdm9pZCBhIHN0YWNrIG1pc21hdGNoLlxuICAgICAgICAgIC8vIEJlY2F1c2Ugd2UncmUgbm90IHN1cmUsIHRyZWF0IHRoaXMgYXMgYSBmYXRhbCBlcnJvci4gV2UgY291bGQgdHJhY2tcbiAgICAgICAgICAvLyB3aGljaCBwaGFzZSBpdCBmYWlscyBpbiwgYnV0IGRvZXNuJ3Qgc2VlbSB3b3J0aCBpdC4gQXQgbGVhc3RcbiAgICAgICAgICAvLyBmb3Igbm93LlxuICAgICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICBvblVuY2F1Z2h0RXJyb3IodGhyb3duVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXhjZXB0aW9uKHJvb3QsIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgdGhyb3duVmFsdWUsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBjb21wbGV0ZVVuaXRPZldvcmsoc291cmNlRmliZXIpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICB9IHdoaWxlICh0cnVlKTtcblxuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcpIHtcbiAgICAvLyBUcmFja2VkIHdvcmsgaXMgZG9uZSBmb3Igbm93OyByZXN0b3JlIHRoZSBwcmV2aW91cyBpbnRlcmFjdGlvbnMuXG4gICAgdHJhY2tpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG4gIH1cblxuICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgaXNXb3JraW5nID0gZmFsc2U7XG4gIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudERpc3BhdGNoZXIgPSBudWxsO1xuICByZXNldENvbnRleHREZXBlbmRlbmNlcygpO1xuXG4gIC8vIFlpZWxkIGJhY2sgdG8gbWFpbiB0aHJlYWQuXG4gIGlmIChkaWRGYXRhbCkge1xuICAgIHZhciBfZGlkQ29tcGxldGVSb290ID0gZmFsc2U7XG4gICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgX2RpZENvbXBsZXRlUm9vdCk7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgLy8gVGhlcmUgd2FzIGEgZmF0YWwgZXJyb3IuXG4gICAge1xuICAgICAgcmVzZXRTdGFja0FmdGVyRmF0YWxFcnJvckluRGV2KCk7XG4gICAgfVxuICAgIC8vIGBuZXh0Um9vdGAgcG9pbnRzIHRvIHRoZSBpbi1wcm9ncmVzcyByb290LiBBIG5vbi1udWxsIHZhbHVlIGluZGljYXRlc1xuICAgIC8vIHRoYXQgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhbiBhc3luYyByZW5kZXIuIFNldCBpdCB0byBudWxsIHRvIGluZGljYXRlXG4gICAgLy8gdGhlcmUncyBubyBtb3JlIHdvcmsgdG8gYmUgZG9uZSBpbiB0aGUgY3VycmVudCBiYXRjaC5cbiAgICBuZXh0Um9vdCA9IG51bGw7XG4gICAgb25GYXRhbChyb290KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSdzIHN0aWxsIHJlbWFpbmluZyBhc3luYyB3b3JrIGluIHRoaXMgdHJlZSwgYnV0IHdlIHJhbiBvdXQgb2YgdGltZVxuICAgIC8vIGluIHRoZSBjdXJyZW50IGZyYW1lLiBZaWVsZCBiYWNrIHRvIHRoZSByZW5kZXJlci4gVW5sZXNzIHdlJ3JlXG4gICAgLy8gaW50ZXJydXB0ZWQgYnkgYSBoaWdoZXIgcHJpb3JpdHkgdXBkYXRlLCB3ZSdsbCBjb250aW51ZSBsYXRlciBmcm9tIHdoZXJlXG4gICAgLy8gd2UgbGVmdCBvZmYuXG4gICAgdmFyIF9kaWRDb21wbGV0ZVJvb3QyID0gZmFsc2U7XG4gICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgX2RpZENvbXBsZXRlUm9vdDIpO1xuICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgIG9uWWllbGQocm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2UgY29tcGxldGVkIHRoZSB3aG9sZSB0cmVlLlxuICB2YXIgZGlkQ29tcGxldGVSb290ID0gdHJ1ZTtcbiAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgZGlkQ29tcGxldGVSb290KTtcbiAgdmFyIHJvb3RXb3JrSW5Qcm9ncmVzcyA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gICEocm9vdFdvcmtJblByb2dyZXNzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0ZpbmlzaGVkIHJvb3Qgc2hvdWxkIGhhdmUgYSB3b3JrLWluLXByb2dyZXNzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIC8vIGBuZXh0Um9vdGAgcG9pbnRzIHRvIHRoZSBpbi1wcm9ncmVzcyByb290LiBBIG5vbi1udWxsIHZhbHVlIGluZGljYXRlc1xuICAvLyB0aGF0IHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYW4gYXN5bmMgcmVuZGVyLiBTZXQgaXQgdG8gbnVsbCB0byBpbmRpY2F0ZVxuICAvLyB0aGVyZSdzIG5vIG1vcmUgd29yayB0byBiZSBkb25lIGluIHRoZSBjdXJyZW50IGJhdGNoLlxuICBuZXh0Um9vdCA9IG51bGw7XG4gIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIGlmIChuZXh0UmVuZGVyRGlkRXJyb3IpIHtcbiAgICAvLyBUaGVyZSB3YXMgYW4gZXJyb3JcbiAgICBpZiAoaGFzTG93ZXJQcmlvcml0eVdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAvLyBUaGVyZSdzIGxvd2VyIHByaW9yaXR5IHdvcmsuIElmIHNvLCBpdCBtYXkgaGF2ZSB0aGUgZWZmZWN0IG9mIGZpeGluZ1xuICAgICAgLy8gdGhlIGV4Y2VwdGlvbiB0aGF0IHdhcyBqdXN0IHRocm93bi4gRXhpdCB3aXRob3V0IGNvbW1pdHRpbmcuIFRoaXMgaXNcbiAgICAgIC8vIHNpbWlsYXIgdG8gYSBzdXNwZW5kLCBidXQgd2l0aG91dCBhIHRpbWVvdXQgYmVjYXVzZSB3ZSdyZSBub3Qgd2FpdGluZ1xuICAgICAgLy8gZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlLiBSZWFjdCB3aWxsIHJlc3RhcnQgYXQgdGhlIGxvd2VyXG4gICAgICAvLyBwcmlvcml0eSBsZXZlbC5cbiAgICAgIG1hcmtTdXNwZW5kZWRQcmlvcml0eUxldmVsKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHZhciBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgdmFyIHJvb3RFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgICBvblN1c3BlbmQocm9vdCwgcm9vdFdvcmtJblByb2dyZXNzLCBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSwgcm9vdEV4cGlyYXRpb25UaW1lLCAtMSAvLyBJbmRpY2F0ZXMgbm8gdGltZW91dFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKFxuICAgIC8vIFRoZXJlJ3Mgbm8gbG93ZXIgcHJpb3JpdHkgd29yaywgYnV0IHdlJ3JlIHJlbmRlcmluZyBhc3luY2hyb25vdXNseS5cbiAgICAvLyBTeW5jaHJvbnNvdWx5IGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBzYW1lIGxldmVsIG9uZSBtb3JlIHRpbWUuIFRoaXMgaXNcbiAgICAvLyBzaW1pbGFyIHRvIGEgc3VzcGVuZCwgYnV0IHdpdGhvdXQgYSB0aW1lb3V0IGJlY2F1c2Ugd2UncmUgbm90IHdhaXRpbmdcbiAgICAvLyBmb3IgYSBwcm9taXNlIHRvIHJlc29sdmUuXG4gICAgIXJvb3QuZGlkRXJyb3IgJiYgIWlzRXhwaXJlZCkge1xuICAgICAgcm9vdC5kaWRFcnJvciA9IHRydWU7XG4gICAgICB2YXIgX3N1c3BlbmRlZEV4cGlyYXRpb25UaW1lID0gcm9vdC5uZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgdmFyIF9yb290RXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIG9uU3VzcGVuZChyb290LCByb290V29ya0luUHJvZ3Jlc3MsIF9zdXNwZW5kZWRFeHBpcmF0aW9uVGltZSwgX3Jvb3RFeHBpcmF0aW9uVGltZSwgLTEgLy8gSW5kaWNhdGVzIG5vIHRpbWVvdXRcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuYWJsZVN1c3BlbnNlICYmICFpc0V4cGlyZWQgJiYgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zICE9PSAtMSkge1xuICAgIC8vIFRoZSB0cmVlIHdhcyBzdXNwZW5kZWQuXG4gICAgdmFyIF9zdXNwZW5kZWRFeHBpcmF0aW9uVGltZTIgPSBleHBpcmF0aW9uVGltZTtcbiAgICBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUyKTtcblxuICAgIC8vIEZpbmQgdGhlIGVhcmxpZXN0IHVuY29tbWl0dGVkIGV4cGlyYXRpb24gdGltZSBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nXG4gICAgLy8gd29yayB0aGF0IGlzIHN1c3BlbmRlZC4gVGhlIHRpbWVvdXQgdGhyZXNob2xkIGNhbm5vdCBiZSBsb25nZXIgdGhhblxuICAgIC8vIHRoZSBvdmVyYWxsIGV4cGlyYXRpb24uXG4gICAgdmFyIGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPSBmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciBlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZWFybGllc3RFeHBpcmF0aW9uVGltZSk7XG4gICAgaWYgKGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyA8IG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNcykge1xuICAgICAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gZWFybGllc3RFeHBpcmF0aW9uVGltZU1zO1xuICAgIH1cblxuICAgIC8vIFN1YnRyYWN0IHRoZSBjdXJyZW50IHRpbWUgZnJvbSB0aGUgYWJzb2x1dGUgdGltZW91dCB0byBnZXQgdGhlIG51bWJlclxuICAgIC8vIG9mIG1pbGxpc2Vjb25kcyB1bnRpbCB0aGUgdGltZW91dC4gSW4gb3RoZXIgd29yZHMsIGNvbnZlcnQgYW4gYWJzb2x1dGVcbiAgICAvLyB0aW1lc3RhbXAgdG8gYSByZWxhdGl2ZSB0aW1lLiBUaGlzIGlzIHRoZSB2YWx1ZSB0aGF0IGlzIHBhc3NlZFxuICAgIC8vIHRvIGBzZXRUaW1lb3V0YC5cbiAgICB2YXIgY3VycmVudFRpbWVNcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhyZXF1ZXN0Q3VycmVudFRpbWUoKSk7XG4gICAgdmFyIG1zVW50aWxUaW1lb3V0ID0gbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zIC0gY3VycmVudFRpbWVNcztcbiAgICBtc1VudGlsVGltZW91dCA9IG1zVW50aWxUaW1lb3V0IDwgMCA/IDAgOiBtc1VudGlsVGltZW91dDtcblxuICAgIC8vIFRPRE86IEFjY291bnQgZm9yIHRoZSBKdXN0IE5vdGljZWFibGUgRGlmZmVyZW5jZVxuXG4gICAgdmFyIF9yb290RXhwaXJhdGlvblRpbWUyID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICBvblN1c3BlbmQocm9vdCwgcm9vdFdvcmtJblByb2dyZXNzLCBfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUyLCBfcm9vdEV4cGlyYXRpb25UaW1lMiwgbXNVbnRpbFRpbWVvdXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlYWR5IHRvIGNvbW1pdC5cbiAgb25Db21wbGV0ZShyb290LCByb290V29ya0luUHJvZ3Jlc3MsIGV4cGlyYXRpb25UaW1lKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2goc291cmNlRmliZXIsIHZhbHVlLCBleHBpcmF0aW9uVGltZSkge1xuICAhKCFpc1dvcmtpbmcgfHwgaXNDb21taXR0aW5nJDEpID8gaW52YXJpYW50KGZhbHNlLCAnZGlzcGF0Y2g6IENhbm5vdCBkaXNwYXRjaCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4nKSA6IHZvaWQgMDtcblxuICB2YXIgZmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICAgIHZhciBjdG9yID0gZmliZXIudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2Vycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICB2YXIgX3VwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlciwgX2Vycm9ySW5mbywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIF91cGRhdGUpO1xuICAgICAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxuXG4gIGlmIChzb3VyY2VGaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuICAgIC8vIGl0c2VsZiBzaG91bGQgY2FwdHVyZSBpdC5cbiAgICB2YXIgcm9vdEZpYmVyID0gc291cmNlRmliZXI7XG4gICAgdmFyIF9lcnJvckluZm8yID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgcm9vdEZpYmVyKTtcbiAgICB2YXIgX3VwZGF0ZTIgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLCBfZXJyb3JJbmZvMiwgZXhwaXJhdGlvblRpbWUpO1xuICAgIGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBfdXBkYXRlMik7XG4gICAgc2NoZWR1bGVXb3JrKHJvb3RGaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBlcnJvcikge1xuICByZXR1cm4gZGlzcGF0Y2goZmliZXIsIGVycm9yLCBTeW5jKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRocmVhZElEKGV4cGlyYXRpb25UaW1lLCBpbnRlcmFjdGlvblRocmVhZElEKSB7XG4gIC8vIEludGVyYWN0aW9uIHRocmVhZHMgYXJlIHVuaXF1ZSBwZXIgcm9vdCBhbmQgZXhwaXJhdGlvbiB0aW1lLlxuICByZXR1cm4gZXhwaXJhdGlvblRpbWUgKiAxMDAwICsgaW50ZXJhY3Rpb25UaHJlYWRJRDtcbn1cblxuLy8gQ3JlYXRlcyBhIHVuaXF1ZSBhc3luYyBleHBpcmF0aW9uIHRpbWUuXG5mdW5jdGlvbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uKCkge1xuICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgdmFyIHJlc3VsdCA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oY3VycmVudFRpbWUpO1xuICBpZiAocmVzdWx0IDw9IGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24pIHtcbiAgICAvLyBTaW5jZSB3ZSBhc3N1bWUgdGhlIGN1cnJlbnQgdGltZSBtb25vdG9uaWNhbGx5IGluY3JlYXNlcywgd2Ugb25seSBoaXRcbiAgICAvLyB0aGlzIGJyYW5jaCB3aGVuIGNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24gaXMgZmlyZWQgbXVsdGlwbGUgdGltZXNcbiAgICAvLyB3aXRoaW4gYSAyMDBtcyB3aW5kb3cgKG9yIHdoYXRldmVyIHRoZSBhc3luYyBidWNrZXQgc2l6ZSBpcykuXG4gICAgcmVzdWx0ID0gbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiArIDE7XG4gIH1cbiAgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiA9IHJlc3VsdDtcbiAgcmV0dXJuIGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGZpYmVyKSB7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgaWYgKGV4cGlyYXRpb25Db250ZXh0ICE9PSBOb1dvcmspIHtcbiAgICAvLyBBbiBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldDtcbiAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25Db250ZXh0O1xuICB9IGVsc2UgaWYgKGlzV29ya2luZykge1xuICAgIGlmIChpc0NvbW1pdHRpbmckMSkge1xuICAgICAgLy8gVXBkYXRlcyB0aGF0IG9jY3VyIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHNob3VsZCBoYXZlIHN5bmMgcHJpb3JpdHlcbiAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZXMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugc2hvdWxkIGV4cGlyZSBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gICAgICAvLyB0aGUgd29yayB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgZXhwaXJhdGlvblRpbWUgPSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE5vIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0LCBhbmQgd2UncmUgbm90IGN1cnJlbnRseVxuICAgIC8vIHBlcmZvcm1pbmcgd29yay4gQ2FsY3VsYXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAoZmliZXIubW9kZSAmIEFzeW5jTW9kZSkge1xuICAgICAgaWYgKGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcmFjdGl2ZSB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlSW50ZXJhY3RpdmVFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZyBhIHRyZWUsIGRvIG5vdCB1cGRhdGUgYXQgdGhlIHNhbWVcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZSB0aGF0IGlzIGFscmVhZHkgcmVuZGVyaW5nLlxuICAgICAgaWYgKG5leHRSb290ICE9PSBudWxsICYmIGV4cGlyYXRpb25UaW1lID09PSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgKz0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgfVxuICB9XG4gIGlmIChpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBpbnRlcmFjdGl2ZSB1cGRhdGUuIEtlZXAgdHJhY2sgb2YgdGhlIGxvd2VzdCBwZW5kaW5nXG4gICAgLy8gaW50ZXJhY3RpdmUgZXhwaXJhdGlvbiB0aW1lLiBUaGlzIGFsbG93cyB1cyB0byBzeW5jaHJvbm91c2x5IGZsdXNoXG4gICAgLy8gYWxsIGludGVyYWN0aXZlIHVwZGF0ZXMgd2hlbiBuZWVkZWQuXG4gICAgaWYgKGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA+IGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kKHJvb3QsIGFic29sdXRlVGltZW91dE1zLCBzdXNwZW5kZWRUaW1lKSB7XG4gIC8vIFNjaGVkdWxlIHRoZSB0aW1lb3V0LlxuICBpZiAoYWJzb2x1dGVUaW1lb3V0TXMgPj0gMCAmJiBuZXh0TGF0ZXN0QWJzb2x1dGVUaW1lb3V0TXMgPCBhYnNvbHV0ZVRpbWVvdXRNcykge1xuICAgIG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNcyA9IGFic29sdXRlVGltZW91dE1zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckRpZEVycm9yKCkge1xuICBuZXh0UmVuZGVyRGlkRXJyb3IgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXRyeVN1c3BlbmRlZFJvb3Qocm9vdCwgZmliZXIsIHN1c3BlbmRlZFRpbWUpIHtcbiAgaWYgKGVuYWJsZVN1c3BlbnNlKSB7XG4gICAgdmFyIHJldHJ5VGltZSA9IHZvaWQgMDtcblxuICAgIGlmIChpc1ByaW9yaXR5TGV2ZWxTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkVGltZSkpIHtcbiAgICAgIC8vIFBpbmcgYXQgdGhlIG9yaWdpbmFsIGxldmVsXG4gICAgICByZXRyeVRpbWUgPSBzdXNwZW5kZWRUaW1lO1xuICAgICAgbWFya1BpbmdlZFByaW9yaXR5TGV2ZWwocm9vdCwgcmV0cnlUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUGxhY2Vob2xkZXIgYWxyZWFkeSB0aW1lZCBvdXQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgICAgIHJldHJ5VGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGZpYmVyKTtcbiAgICAgIG1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCByZXRyeVRpbWUpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlV29ya1RvUm9vdChmaWJlciwgcmV0cnlUaW1lKTtcbiAgICB2YXIgcm9vdEV4cGlyYXRpb25UaW1lID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAocm9vdEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgIGlmIChlbmFibGVTY2hlZHVsZXJUcmFja2luZykge1xuICAgICAgICAvLyBSZXN0b3JlIHByZXZpb3VzIGludGVyYWN0aW9ucyBzbyB0aGF0IG5ldyB3b3JrIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGVtLlxuICAgICAgICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHRyYWNraW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgICAgIHRyYWNraW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zO1xuICAgICAgICAvLyBCZWNhdXNlIHN1c3BlbnNlIHRpbWVvdXRzIGRvIG5vdCBkZWNyZW1lbnQgdGhlIGludGVyYWN0aW9uIGNvdW50LFxuICAgICAgICAvLyBDb250aW51ZWQgc3VzcGVuc2Ugd29yayBzaG91bGQgYWxzbyBub3QgaW5jcmVtZW50IHRoZSBjb3VudC5cbiAgICAgICAgc3RvcmVJbnRlcmFjdGlvbnNGb3JFeHBpcmF0aW9uVGltZShyb290LCByb290RXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgICAgICAgcmVxdWVzdFdvcmsocm9vdCwgcm9vdEV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgdHJhY2tpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0V29yayhyb290LCByb290RXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVdvcmtUb1Jvb3QoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgZXhwaXJhdGlvbiB0aW1lXG4gIGlmIChmaWJlci5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGZpYmVyLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB9XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgKGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSkge1xuICAgIGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB9XG4gIC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZS5cbiAgdmFyIG5vZGUgPSBmaWJlci5yZXR1cm47XG4gIGlmIChub2RlID09PSBudWxsICYmIGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gZmliZXIuc3RhdGVOb2RlO1xuICB9XG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgaWYgKG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBub2RlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgKGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAoYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICB9XG4gICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsICYmIG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHN0b3JlSW50ZXJhY3Rpb25zRm9yRXhwaXJhdGlvblRpbWUocm9vdCwgZXhwaXJhdGlvblRpbWUsIHVwZGF0ZUludGVyYWN0aW9uQ291bnRzKSB7XG4gIGlmICghZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW50ZXJhY3Rpb25zID0gdHJhY2tpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgaWYgKGludGVyYWN0aW9ucy5zaXplID4gMCkge1xuICAgIHZhciBwZW5kaW5nSW50ZXJhY3Rpb25zID0gcm9vdC5wZW5kaW5nSW50ZXJhY3Rpb25NYXAuZ2V0KGV4cGlyYXRpb25UaW1lKTtcbiAgICBpZiAocGVuZGluZ0ludGVyYWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaWYgKHVwZGF0ZUludGVyYWN0aW9uQ291bnRzICYmICFwZW5kaW5nSW50ZXJhY3Rpb25zLmhhcyhpbnRlcmFjdGlvbikpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgcHJldmlvdXNseSB1bnNjaGVkdWxlZCBpbnRlcmFjdGlvbi5cbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5wZW5kaW5nSW50ZXJhY3Rpb25NYXAuc2V0KGV4cGlyYXRpb25UaW1lLCBuZXcgU2V0KGludGVyYWN0aW9ucykpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb25zLlxuICAgICAgaWYgKHVwZGF0ZUludGVyYWN0aW9uQ291bnRzKSB7XG4gICAgICAgIGludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQrKztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN1YnNjcmliZXIgPSB0cmFja2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKGV4cGlyYXRpb25UaW1lLCByb290LmludGVyYWN0aW9uVGhyZWFkSUQpO1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpIHtcbiAgcmVjb3JkU2NoZWR1bGVVcGRhdGUoKTtcblxuICB7XG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IHNjaGVkdWxlV29ya1RvUm9vdChmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIGlmICh0cnVlICYmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5KSkge1xuICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcpIHtcbiAgICBzdG9yZUludGVyYWN0aW9uc0ZvckV4cGlyYXRpb25UaW1lKHJvb3QsIGV4cGlyYXRpb25UaW1lLCB0cnVlKTtcbiAgfVxuXG4gIGlmICghaXNXb3JraW5nICYmIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBpbnRlcnJ1cHRpb24uIChVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy4pXG4gICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgIHJlc2V0U3RhY2soKTtcbiAgfVxuICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAoXG4gIC8vIElmIHdlJ3JlIGluIHRoZSByZW5kZXIgcGhhc2UsIHdlIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgdGhpcyByb290XG4gIC8vIGZvciBhbiB1cGRhdGUsIGJlY2F1c2Ugd2UnbGwgZG8gaXQgYmVmb3JlIHdlIGV4aXQuLi5cbiAgIWlzV29ya2luZyB8fCBpc0NvbW1pdHRpbmckMSB8fFxuICAvLyAuLi51bmxlc3MgdGhpcyBpcyBhIGRpZmZlcmVudCByb290IHRoYW4gdGhlIG9uZSB3ZSdyZSByZW5kZXJpbmcuXG4gIG5leHRSb290ICE9PSByb290KSB7XG4gICAgdmFyIHJvb3RFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgcmVxdWVzdFdvcmsocm9vdCwgcm9vdEV4cGlyYXRpb25UaW1lKTtcbiAgfVxuICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgLy8gUmVzZXQgdGhpcyBiYWNrIHRvIHplcm8gc28gc3Vic2VxdWVudCB1cGRhdGVzIGRvbid0IHRocm93LlxuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4sIGEsIGIsIGMsIGQpIHtcbiAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgZXhwaXJhdGlvbkNvbnRleHQgPSBTeW5jO1xuICB0cnkge1xuICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gIH1cbn1cblxuLy8gVE9ETzogRXZlcnl0aGluZyBiZWxvdyB0aGlzIGlzIHdyaXR0ZW4gYXMgaWYgaXQgaGFzIGJlZW4gbGlmdGVkIHRvIHRoZVxuLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbi8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG52YXIgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbnZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbnZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xudmFyIGNhbGxiYWNrSUQgPSB2b2lkIDA7XG52YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbnZhciBuZXh0Rmx1c2hlZFJvb3QgPSBudWxsO1xudmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbnZhciBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xudmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG52YXIgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xudmFyIGRlYWRsaW5lID0gbnVsbDtcblxudmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG52YXIgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xudmFyIGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMgPSBmYWxzZTtcblxudmFyIGNvbXBsZXRlZEJhdGNoZXMgPSBudWxsO1xuXG52YXIgb3JpZ2luYWxTdGFydFRpbWVNcyA9IHNjaGVkdWxlLnVuc3RhYmxlX25vdygpO1xudmFyIGN1cnJlbnRSZW5kZXJlclRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUob3JpZ2luYWxTdGFydFRpbWVNcyk7XG52YXIgY3VycmVudFNjaGVkdWxlclRpbWUgPSBjdXJyZW50UmVuZGVyZXJUaW1lO1xuXG4vLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG52YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbnZhciBsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCA9IG51bGw7XG5cbnZhciB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yayA9IDE7XG5cbmZ1bmN0aW9uIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKSB7XG4gIHZhciBjdXJyZW50VGltZU1zID0gc2NoZWR1bGUudW5zdGFibGVfbm93KCkgLSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuICBjdXJyZW50UmVuZGVyZXJUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKGN1cnJlbnRUaW1lTXMpO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb25UaW1lKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPiBjYWxsYmFja0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2FsbGJhY2tJRCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBzY2hlZHVsZS51bnN0YWJsZV9jYW5jZWxTY2hlZHVsZWRXb3JrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgcmVxdWVzdCBjYWxsYmFjayB0aW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcuIERvbid0IHN0YXJ0IGEgbmV3IG9uZS5cbiAgfSBlbHNlIHtcbiAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gIH1cblxuICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHZhciBjdXJyZW50TXMgPSBzY2hlZHVsZS51bnN0YWJsZV9ub3coKSAtIG9yaWdpbmFsU3RhcnRUaW1lTXM7XG4gIHZhciBleHBpcmF0aW9uVGltZU1zID0gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKTtcbiAgdmFyIHRpbWVvdXQgPSBleHBpcmF0aW9uVGltZU1zIC0gY3VycmVudE1zO1xuICBjYWxsYmFja0lEID0gc2NoZWR1bGUudW5zdGFibGVfc2NoZWR1bGVXb3JrKHBlcmZvcm1Bc3luY1dvcmssIHsgdGltZW91dDogdGltZW91dCB9KTtcbn1cblxuLy8gRm9yIGV2ZXJ5IGNhbGwgdG8gcmVuZGVyUm9vdCwgb25lIG9mIG9uRmF0YWwsIG9uQ29tcGxldGUsIG9uU3VzcGVuZCwgYW5kXG4vLyBvbllpZWxkIGlzIGNhbGxlZCB1cG9uIGV4aXRpbmcuIFdlIHVzZSB0aGVzZSBpbiBsaWV1IG9mIHJldHVybmluZyBhIHR1cGxlLlxuLy8gSSd2ZSBhbHNvIGNob3NlbiBub3QgdG8gaW5saW5lIHRoZW0gaW50byByZW5kZXJSb290IGJlY2F1c2UgdGhlc2Ugd2lsbFxuLy8gZXZlbnR1YWxseSBiZSBsaWZ0ZWQgaW50byB0aGUgcmVuZGVyZXIuXG5mdW5jdGlvbiBvbkZhdGFsKHJvb3QpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBsZXRlKHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpIHtcbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG59XG5cbmZ1bmN0aW9uIG9uU3VzcGVuZChyb290LCBmaW5pc2hlZFdvcmssIHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lLCByb290RXhwaXJhdGlvblRpbWUsIG1zVW50aWxUaW1lb3V0KSB7XG4gIHJvb3QuZXhwaXJhdGlvblRpbWUgPSByb290RXhwaXJhdGlvblRpbWU7XG4gIGlmIChlbmFibGVTdXNwZW5zZSAmJiBtc1VudGlsVGltZW91dCA9PT0gMCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgIC8vIERvbid0IHdhaXQgYW4gYWRkaXRpb25hbCB0aWNrLiBDb21taXQgdGhlIHRyZWUgaW1tZWRpYXRlbHkuXG4gICAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZTtcbiAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgfSBlbHNlIGlmIChtc1VudGlsVGltZW91dCA+IDApIHtcbiAgICAvLyBXYWl0IGBtc1VudGlsVGltZW91dGAgbWlsbGlzZWNvbmRzIGJlZm9yZSBjb21taXR0aW5nLlxuICAgIHJvb3QudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChvblRpbWVvdXQuYmluZChudWxsLCByb290LCBmaW5pc2hlZFdvcmssIHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lKSwgbXNVbnRpbFRpbWVvdXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uWWllbGQocm9vdCkge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIG9uVGltZW91dChyb290LCBmaW5pc2hlZFdvcmssIHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIC8vIFRoZSByb290IHRpbWVkIG91dC4gQ29tbWl0IGl0LlxuICAgIHJvb3QucGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lID0gc3VzcGVuZGVkRXhwaXJhdGlvblRpbWU7XG4gICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgLy8gUmVhZCB0aGUgY3VycmVudCB0aW1lIGJlZm9yZSBlbnRlcmluZyB0aGUgY29tbWl0IHBoYXNlLiBXZSBjYW4gYmVcbiAgICAvLyBjZXJ0YWluIHRoaXMgd29uJ3QgY2F1c2UgdGVhcmluZyByZWxhdGVkIHRvIGJhdGNoaW5nIG9mIGV2ZW50IHVwZGF0ZXNcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIGF0IHRoZSB0b3Agb2YgYSB0aW1lciBldmVudC5cbiAgICByZWNvbXB1dGVDdXJyZW50UmVuZGVyZXJUaW1lKCk7XG4gICAgY3VycmVudFNjaGVkdWxlclRpbWUgPSBjdXJyZW50UmVuZGVyZXJUaW1lO1xuXG4gICAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNraW5nKSB7XG4gICAgICAvLyBEb24ndCB1cGRhdGUgcGVuZGluZyBpbnRlcmFjdGlvbiBjb3VudHMgZm9yIHN1c3BlbnNlIHRpbWVvdXRzLFxuICAgICAgLy8gQmVjYXVzZSB3ZSBrbm93IHdlIHN0aWxsIG5lZWQgdG8gZG8gbW9yZSB3b3JrIGluIHRoaXMgY2FzZS5cbiAgICAgIHN1c3BlbnNlRGlkVGltZW91dCA9IHRydWU7XG4gICAgICBmbHVzaFJvb3Qocm9vdCwgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgc3VzcGVuc2VEaWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoUm9vdChyb290LCBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRpbWUoKSB7XG4gIC8vIHJlcXVlc3RDdXJyZW50VGltZSBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBjb21wdXRlIGFuIGV4cGlyYXRpb25cbiAgLy8gdGltZS5cbiAgLy9cbiAgLy8gRXhwaXJhdGlvbiB0aW1lcyBhcmUgY29tcHV0ZWQgYnkgYWRkaW5nIHRvIHRoZSBjdXJyZW50IHRpbWUgKHRoZSBzdGFydFxuICAvLyB0aW1lKS4gSG93ZXZlciwgaWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlXG4gIC8vIHNob3VsZCB0cmVhdCB0aGVpciBzdGFydCB0aW1lcyBhcyBzaW11bHRhbmVvdXMsIGV2ZW4gaWYgdGhlIGFjdHVhbCBjbG9ja1xuICAvLyB0aW1lIGhhcyBhZHZhbmNlZCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNhbGwuXG5cbiAgLy8gSW4gb3RoZXIgd29yZHMsIGJlY2F1c2UgZXhwaXJhdGlvbiB0aW1lcyBkZXRlcm1pbmUgaG93IHVwZGF0ZXMgYXJlIGJhdGNoZWQsXG4gIC8vIHdlIHdhbnQgYWxsIHVwZGF0ZXMgb2YgbGlrZSBwcmlvcml0eSB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgc2FtZSBldmVudCB0b1xuICAvLyByZWNlaXZlIHRoZSBzYW1lIGV4cGlyYXRpb24gdGltZS4gT3RoZXJ3aXNlIHdlIGdldCB0ZWFyaW5nLlxuICAvL1xuICAvLyBXZSBrZWVwIHRyYWNrIG9mIHR3byBzZXBhcmF0ZSB0aW1lczogdGhlIGN1cnJlbnQgXCJyZW5kZXJlclwiIHRpbWUgYW5kIHRoZVxuICAvLyBjdXJyZW50IFwic2NoZWR1bGVyXCIgdGltZS4gVGhlIHJlbmRlcmVyIHRpbWUgY2FuIGJlIHVwZGF0ZWQgd2hlbmV2ZXI7IGl0XG4gIC8vIG9ubHkgZXhpc3RzIHRvIG1pbmltaXplIHRoZSBjYWxscyBwZXJmb3JtYW5jZS5ub3cuXG4gIC8vXG4gIC8vIEJ1dCB0aGUgc2NoZWR1bGVyIHRpbWUgY2FuIG9ubHkgYmUgdXBkYXRlZCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yaywgb3JcbiAgLy8gaWYgd2Uga25vdyBmb3IgY2VydGFpbiB0aGF0IHdlJ3JlIG5vdCBpbiB0aGUgbWlkZGxlIG9mIGFuIGV2ZW50LlxuXG4gIGlmIChpc1JlbmRlcmluZykge1xuICAgIC8vIFdlJ3JlIGFscmVhZHkgcmVuZGVyaW5nLiBSZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgcmVhZCB0aW1lLlxuICAgIHJldHVybiBjdXJyZW50U2NoZWR1bGVyVGltZTtcbiAgfVxuICAvLyBDaGVjayBpZiB0aGVyZSdzIHBlbmRpbmcgd29yay5cbiAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGVuZGluZyB3b3JrLCBvciBpZiB0aGUgcGVuZGluZyB3b3JrIGlzIG9mZnNjcmVlbiwgd2UgY2FuXG4gICAgLy8gcmVhZCB0aGUgY3VycmVudCB0aW1lIHdpdGhvdXQgcmlzayBvZiB0ZWFyaW5nLlxuICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG4gICAgcmV0dXJuIGN1cnJlbnRTY2hlZHVsZXJUaW1lO1xuICB9XG4gIC8vIFRoZXJlJ3MgYWxyZWFkeSBwZW5kaW5nIHdvcmsuIFdlIG1pZ2h0IGJlIGluIHRoZSBtaWRkbGUgb2YgYSBicm93c2VyXG4gIC8vIGV2ZW50LiBJZiB3ZSB3ZXJlIHRvIHJlYWQgdGhlIGN1cnJlbnQgdGltZSwgaXQgY291bGQgY2F1c2UgbXVsdGlwbGUgdXBkYXRlc1xuICAvLyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgdG8gcmVjZWl2ZSBkaWZmZXJlbnQgZXhwaXJhdGlvbiB0aW1lcywgbGVhZGluZyB0b1xuICAvLyB0ZWFyaW5nLiBSZXR1cm4gdGhlIGxhc3QgcmVhZCB0aW1lLiBEdXJpbmcgdGhlIG5leHQgaWRsZSBjYWxsYmFjaywgdGhlXG4gIC8vIHRpbWUgd2lsbCBiZSB1cGRhdGVkLlxuICByZXR1cm4gY3VycmVudFNjaGVkdWxlclRpbWU7XG59XG5cbi8vIHJlcXVlc3RXb3JrIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHdoZW5ldmVyIGEgcm9vdCByZWNlaXZlcyBhbiB1cGRhdGUuXG4vLyBJdCdzIHVwIHRvIHRoZSByZW5kZXJlciB0byBjYWxsIHJlbmRlclJvb3QgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgYWRkUm9vdFRvU2NoZWR1bGUocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgY3VycmVudGx5IHJlbmRlcmluZyBiYXRjaC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyAuLi51bmxlc3Mgd2UncmUgaW5zaWRlIHVuYmF0Y2hlZFVwZGF0ZXMsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkXG4gICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChyb290LCBTeW5jLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogR2V0IHJpZCBvZiBTeW5jIGFuZCB1c2UgY3VycmVudCB0aW1lP1xuICBpZiAoZXhwaXJhdGlvblRpbWUgPT09IFN5bmMpIHtcbiAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb25UaW1lKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb290VG9TY2hlZHVsZShyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgaWYgKHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgcm9vdC5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBzY2hlZHVsZWQsIGJ1dCBpdHMgcHJpb3JpdHkgbWF5IGhhdmUgaW5jcmVhc2VkLlxuICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eS5cbiAgICAgIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKSB7XG4gIHZhciBoaWdoZXN0UHJpb3JpdHlXb3JrID0gTm9Xb3JrO1xuICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG4gIGlmIChsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAgIC8vIFRoaXMgcm9vdCBubyBsb25nZXIgaGFzIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZXIuXG5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAvLyBiZWxvdyB3aGVyZSB3ZSBzZXQgbGFzdFNjaGVkdWxlZFJvb3QgdG8gbnVsbCwgZXZlbiB0aG91Z2ggd2UgYnJlYWtcbiAgICAgICAgLy8gZnJvbSB0aGUgbG9vcCByaWdodCBhZnRlci5cbiAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBpZiAocm9vdCA9PT0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LCBpZiBpdCdzIGhpZ2hlclxuICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlnaGVzdFByaW9yaXR5V29yayA9PT0gU3luYykge1xuICAgICAgICAgIC8vIFN5bmMgaXMgaGlnaGVzdCBwcmlvcml0eSBieSBkZWZpbml0aW9uIHNvXG4gICAgICAgICAgLy8gd2UgY2FuIHN0b3Agc2VhcmNoaW5nLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5leHRGbHVzaGVkUm9vdCA9IGhpZ2hlc3RQcmlvcml0eVJvb3Q7XG4gIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBoaWdoZXN0UHJpb3JpdHlXb3JrO1xufVxuXG5mdW5jdGlvbiBwZXJmb3JtQXN5bmNXb3JrKGRsKSB7XG4gIGlmIChkbC5kaWRUaW1lb3V0KSB7XG4gICAgLy8gVGhlIGNhbGxiYWNrIHRpbWVkIG91dC4gVGhhdCBtZWFucyBhdCBsZWFzdCBvbmUgdXBkYXRlIGhhcyBleHBpcmVkLlxuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm9vdCBzY2hlZHVsZS4gSWYgdGhleSBjb250YWluIGV4cGlyZWQgd29yaywgc2V0XG4gICAgLy8gdGhlIG5leHQgcmVuZGVyIGV4cGlyYXRpb24gdGltZSB0byB0aGUgY3VycmVudCB0aW1lLiBUaGlzIGhhcyB0aGUgZWZmZWN0XG4gICAgLy8gb2YgZmx1c2hpbmcgYWxsIGV4cGlyZWQgd29yayBpbiBhIHNpbmdsZSBiYXRjaCwgaW5zdGVhZCBvZiBmbHVzaGluZyBlYWNoXG4gICAgLy8gbGV2ZWwgb25lIGF0IGEgdGltZS5cbiAgICBpZiAoZmlyc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSB7XG4gICAgICByZWNvbXB1dGVDdXJyZW50UmVuZGVyZXJUaW1lKCk7XG4gICAgICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIGRvIHtcbiAgICAgICAgZGlkRXhwaXJlQXRFeHBpcmF0aW9uVGltZShyb290LCBjdXJyZW50UmVuZGVyZXJUaW1lKTtcbiAgICAgICAgLy8gVGhlIHJvb3Qgc2NoZWR1bGUgaXMgY2lyY3VsYXIsIHNvIHRoaXMgaXMgbmV2ZXIgbnVsbC5cbiAgICAgICAgcm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9IHdoaWxlIChyb290ICE9PSBmaXJzdFNjaGVkdWxlZFJvb3QpO1xuICAgIH1cbiAgfVxuICBwZXJmb3JtV29yayhOb1dvcmssIGRsKTtcbn1cblxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrKCkge1xuICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gcGVyZm9ybVdvcmsobWluRXhwaXJhdGlvblRpbWUsIGRsKSB7XG4gIGRlYWRsaW5lID0gZGw7XG5cbiAgLy8gS2VlcCB3b3JraW5nIG9uIHJvb3RzIHVudGlsIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrLCBvciB1bnRpbCB3ZSByZWFjaFxuICAvLyB0aGUgZGVhZGxpbmUuXG4gIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG5cbiAgaWYgKGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgcmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSgpO1xuICAgIGN1cnJlbnRTY2hlZHVsZXJUaW1lID0gY3VycmVudFJlbmRlcmVyVGltZTtcblxuICAgIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgICB2YXIgZGlkRXhwaXJlID0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8IGN1cnJlbnRSZW5kZXJlclRpbWU7XG4gICAgICB2YXIgdGltZW91dCA9IGV4cGlyYXRpb25UaW1lVG9NcyhuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUsIHRpbWVvdXQpO1xuICAgIH1cblxuICAgIHdoaWxlIChuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwgJiYgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChtaW5FeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG1pbkV4cGlyYXRpb25UaW1lID49IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpICYmICghZGVhZGxpbmVEaWRFeHBpcmUgfHwgY3VycmVudFJlbmRlcmVyVGltZSA+PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lLCBjdXJyZW50UmVuZGVyZXJUaW1lID49IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICAgIGN1cnJlbnRTY2hlZHVsZXJUaW1lID0gY3VycmVudFJlbmRlcmVyVGltZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbWluRXhwaXJhdGlvblRpbWUgPj0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSwgdHJ1ZSk7XG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAvLyBvciB0aGVyZSdzIG5vIG1vcmUgd29yayBsZWZ0IHdpdGggc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBjYWxsYmFjaywgc2V0IHRoaXMgdG8gZmFsc2Ugc2luY2Ugd2UganVzdCBjb21wbGV0ZWQgaXQuXG4gIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgY2FsbGJhY2tJRCA9IG51bGw7XG4gIH1cbiAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gIGlmIChuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb25UaW1lKG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICAvLyBDbGVhbi11cC5cbiAgZGVhZGxpbmUgPSBudWxsO1xuICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuXG4gIGZpbmlzaFJlbmRlcmluZygpO1xufVxuXG5mdW5jdGlvbiBmbHVzaFJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3dvcmsuY29tbWl0KCk6IENhbm5vdCBjb21taXQgd2hpbGUgYWxyZWFkeSByZW5kZXJpbmcuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBhdHRlbXB0ZWQgdG8gY29tbWl0IGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4nKSA6IHZvaWQgMDtcbiAgLy8gUGVyZm9ybSB3b3JrIG9uIHJvb3QgYXMgaWYgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZSBpcyB0aGUgY3VycmVudCB0aW1lLlxuICAvLyBUaGlzIGhhcyB0aGUgZWZmZWN0IG9mIHN5bmNocm9ub3VzbHkgZmx1c2hpbmcgYWxsIHdvcmsgdXAgdG8gYW5kXG4gIC8vIGluY2x1ZGluZyB0aGUgZ2l2ZW4gdGltZS5cbiAgbmV4dEZsdXNoZWRSb290ID0gcm9vdDtcbiAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBwZXJmb3JtV29ya09uUm9vdChyb290LCBleHBpcmF0aW9uVGltZSwgdHJ1ZSk7XG4gIC8vIEZsdXNoIGFueSBzeW5jIHdvcmsgdGhhdCB3YXMgc2NoZWR1bGVkIGJ5IGxpZmVjeWNsZXNcbiAgcGVyZm9ybVN5bmNXb3JrKCk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFJlbmRlcmluZygpIHtcbiAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICBsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCA9IG51bGw7XG5cbiAgaWYgKGNvbXBsZXRlZEJhdGNoZXMgIT09IG51bGwpIHtcbiAgICB2YXIgYmF0Y2hlcyA9IGNvbXBsZXRlZEJhdGNoZXM7XG4gICAgY29tcGxldGVkQmF0Y2hlcyA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYmF0Y2ggPSBiYXRjaGVzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYmF0Y2guX29uQ29tcGxldGUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICghaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgIHZhciBlcnJvciA9IHVuaGFuZGxlZEVycm9yO1xuICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lLCBpc0V4cGlyZWQpIHtcbiAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgaXNSZW5kZXJpbmcgPSB0cnVlO1xuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYXN5bmMgd29yayBvciBzeW5jL2V4cGlyZWQgd29yay5cbiAgaWYgKGRlYWRsaW5lID09PSBudWxsIHx8IGlzRXhwaXJlZCkge1xuICAgIC8vIEZsdXNoIHdvcmsgd2l0aG91dCB5aWVsZGluZy5cbiAgICAvLyBUT0RPOiBOb24teWllbGR5IHdvcmsgZG9lcyBub3QgbmVjZXNzYXJpbHkgaW1wbHkgZXhwaXJlZCB3b3JrLiBBIHJlbmRlcmVyXG4gICAgLy8gbWF5IHdhbnQgdG8gcGVyZm9ybSBzb21lIHdvcmsgd2l0aG91dCB5aWVsZGluZywgYnV0IGFsc28gd2l0aG91dFxuICAgIC8vIHJlcXVpcmluZyB0aGUgcm9vdCB0byBjb21wbGV0ZSAoYnkgdHJpZ2dlcmluZyBwbGFjZWhvbGRlcnMpLlxuXG4gICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IGNvbXBsZXRlLiBXZSBjYW4gY29tbWl0IGl0LlxuICAgICAgY29tcGxldGVSb290KHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAvLyBJZiB0aGlzIHJvb3QgcHJldmlvdXNseSBzdXNwZW5kZWQsIGNsZWFyIGl0cyBleGlzdGluZyB0aW1lb3V0LCBzaW5jZVxuICAgICAgLy8gd2UncmUgYWJvdXQgdG8gdHJ5IHJlbmRlcmluZyBhZ2Fpbi5cbiAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlICYmIHRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dCkge1xuICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7XG4gICAgICAgIC8vICRGbG93Rml4TWUgQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG4gICAgICAgIGNhbmNlbFRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXNZaWVsZHkgPSBmYWxzZTtcbiAgICAgIHJlbmRlclJvb3Qocm9vdCwgaXNZaWVsZHksIGlzRXhwaXJlZCk7XG4gICAgICBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDb21taXQgaXQuXG4gICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmx1c2ggYXN5bmMgd29yay5cbiAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgIGlmIChfZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgIGNvbXBsZXRlUm9vdChyb290LCBfZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgIC8vIElmIHRoaXMgcm9vdCBwcmV2aW91c2x5IHN1c3BlbmRlZCwgY2xlYXIgaXRzIGV4aXN0aW5nIHRpbWVvdXQsIHNpbmNlXG4gICAgICAvLyB3ZSdyZSBhYm91dCB0byB0cnkgcmVuZGVyaW5nIGFnYWluLlxuICAgICAgdmFyIF90aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlICYmIF90aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICBjYW5jZWxUaW1lb3V0KF90aW1lb3V0SGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIHZhciBfaXNZaWVsZHkgPSB0cnVlO1xuICAgICAgcmVuZGVyUm9vdChyb290LCBfaXNZaWVsZHksIGlzRXhwaXJlZCk7XG4gICAgICBfZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgIC8vIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICBpZiAoIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgX2ZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICByb290LmZpbmlzaGVkV29yayA9IF9maW5pc2hlZFdvcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1JlbmRlcmluZyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgYmF0Y2ggdGhhdCBtYXRjaGVzIHRoaXMgZXhwaXJhdGlvbiB0aW1lLlxuICB2YXIgZmlyc3RCYXRjaCA9IHJvb3QuZmlyc3RCYXRjaDtcbiAgaWYgKGZpcnN0QmF0Y2ggIT09IG51bGwgJiYgZmlyc3RCYXRjaC5fZXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY29tcGxldGVkQmF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgY29tcGxldGVkQmF0Y2hlcyA9IFtmaXJzdEJhdGNoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGVkQmF0Y2hlcy5wdXNoKGZpcnN0QmF0Y2gpO1xuICAgIH1cbiAgICBpZiAoZmlyc3RCYXRjaC5fZGVmZXIpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBibG9ja2VkIGZyb20gY29tbWl0dGluZyBieSBhIGJhdGNoLiBVbnNjaGVkdWxlIGl0IHVudGlsXG4gICAgICAvLyB3ZSByZWNlaXZlIGFub3RoZXIgdXBkYXRlLlxuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgICByb290LmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbW1pdCB0aGUgcm9vdC5cbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBuZXN0ZWQgdXBkYXRlIChhIHN5bmMgdXBkYXRlIHNjaGVkdWxlZCBkdXJpbmcgdGhlXG4gIC8vIGNvbW1pdCBwaGFzZSkuXG4gIGlmIChyb290ID09PSBsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCkge1xuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgd2hlbmV2ZXIgd2Ugc3dpdGNoIHJvb3RzLlxuICAgIGxhc3RDb21taXR0ZWRSb290RHVyaW5nVGhpc0JhdGNoID0gcm9vdDtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIH1cbiAgY29tbWl0Um9vdChyb290LCBmaW5pc2hlZFdvcmspO1xufVxuXG4vLyBXaGVuIHdvcmtpbmcgb24gYXN5bmMgd29yaywgdGhlIHJlY29uY2lsZXIgYXNrcyB0aGUgcmVuZGVyZXIgaWYgaXQgc2hvdWxkXG4vLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbmZ1bmN0aW9uIHNob3VsZFlpZWxkKCkge1xuICBpZiAoZGVhZGxpbmVEaWRFeHBpcmUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZGVhZGxpbmUgPT09IG51bGwgfHwgZGVhZGxpbmUudGltZVJlbWFpbmluZygpID4gdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmspIHtcbiAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uVW5jYXVnaHRFcnJvcihlcnJvcikge1xuICAhKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgd29ya2luZyBvbiBhIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAvLyBhbm90aGVyIHVwZGF0ZS5cbiAgbmV4dEZsdXNoZWRSb290LmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgaGFzVW5oYW5kbGVkRXJyb3IgPSB0cnVlO1xuICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyQxKGZuLCBhKSB7XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiB1bmJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZuKGEpO1xufVxuXG4vLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4vLyB0aGUgcmVjb25jaWxlci5cbmZ1bmN0aW9uIGZsdXNoU3luYyhmbiwgYSkge1xuICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAnZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBJdCBjYW5ub3QgYmUgY2FsbGVkIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuJykgOiB2b2lkIDA7XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc3luY1VwZGF0ZXMoZm4sIGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMShmbiwgYSwgYikge1xuICBpZiAoaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcykge1xuICAgIHJldHVybiBmbihhLCBiKTtcbiAgfVxuICAvLyBJZiB0aGVyZSBhcmUgYW55IHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcywgc3luY2hyb25vdXNseSBmbHVzaCB0aGVtLlxuICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgd2UgcmVhZCBhbnkgaGFuZGxlcnMsIGJlY2F1c2UgdGhlIGVmZmVjdCBvZlxuICAvLyB0aGUgcHJldmlvdXMgZXZlbnQgbWF5IGluZmx1ZW5jZSB3aGljaCBoYW5kbGVycyBhcmUgY2FsbGVkIGR1cmluZ1xuICAvLyB0aGlzIGV2ZW50LlxuICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZyAmJiBsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcy5cbiAgICBwZXJmb3JtV29yayhsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICBsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB9XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMgPSBpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzO1xuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICBpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzID0gdHJ1ZTtcbiAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmbihhLCBiKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzJDEoKSB7XG4gIGlmICghaXNSZW5kZXJpbmcgJiYgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMuXG4gICAgcGVyZm9ybVdvcmsobG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENvbnRyb2xsZWQoZm4pIHtcbiAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICB0cnkge1xuICAgIHN5bmNVcGRhdGVzKGZuKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAwIGlzIFBST0QsIDEgaXMgREVWLlxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBDb21wb25lbnQsIHBhcmVudENvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50TGF6eSkge1xuICAgIHZhciBfQ29tcG9uZW50ID0gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUoZmliZXIudHlwZSk7XG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgX0NvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUm9vdFVwZGF0ZShjdXJyZW50JCQxLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSwgY2FsbGJhY2spIHtcbiAge1xuICAgIGlmIChwaGFzZSA9PT0gJ3JlbmRlcicgJiYgY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcykge1xuICAgICAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IHRydWU7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgJyArICd0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gJyArICdJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbicgKyAnQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgZ2V0Q29tcG9uZW50TmFtZShjdXJyZW50LnR5cGUpIHx8ICdVbmtub3duJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gIC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuICB1cGRhdGUucGF5bG9hZCA9IHsgZWxlbWVudDogZWxlbWVudCB9O1xuXG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjaykgOiB2b2lkIDA7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50JCQxLCB1cGRhdGUpO1xuXG4gIHNjaGVkdWxlV29yayhjdXJyZW50JCQxLCBleHBpcmF0aW9uVGltZSk7XG4gIHJldHVybiBleHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKSB7XG4gIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICB2YXIgY3VycmVudCQkMSA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgaWYgKGN1cnJlbnQkJDEuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIHJldHVybiBzY2hlZHVsZVJvb3RVcGRhdGUoY3VycmVudCQkMSwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnQpIHtcbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0FyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6ICVzJywgT2JqZWN0LmtleXMoY29tcG9uZW50KSk7XG4gICAgfVxuICB9XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lckluZm8sIGlzQXN5bmMsIGh5ZHJhdGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBpc0FzeW5jLCBoeWRyYXRlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudCQkMSA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgY3VycmVudCQkMSk7XG4gIHJldHVybiB1cGRhdGVDb250YWluZXJBdEV4cGlyYXRpb25UaW1lKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBleHBpcmF0aW9uVGltZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRvRGV2VG9vbHMoZGV2VG9vbHNDb25maWcpIHtcbiAgdmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7XG5cbiAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG4gICAgfSxcbiAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICBpZiAoIWZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKSB7XG4gICAgICAgIC8vIE1pZ2h0IG5vdCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgcmVuZGVyZXIuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9XG4gIH0pKTtcbn1cblxuLy8gVGhpcyBmaWxlIGludGVudGlvbmFsbHkgZG9lcyAqbm90KiBoYXZlIHRoZSBGbG93IGFubm90YXRpb24uXG4vLyBEb24ndCBhZGQgaXQuIFNlZSBgLi9pbmxpbmUtdHlwZWQuanNgIGZvciBhbiBleHBsYW5hdGlvbi5cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sXG4vLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuNS4wJztcblxuLy8gVE9ETzogVGhpcyB0eXBlIGlzIHNoYXJlZCBiZXR3ZWVuIHRoZSByZWNvbmNpbGVyIGFuZCBSZWFjdERPTSwgYnV0IHdpbGxcbi8vIGV2ZW50dWFsbHkgYmUgbGlmdGVkIG91dCB0byB0aGUgcmVuZGVyZXIuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcblxudmFyIHRvcExldmVsVXBkYXRlV2FybmluZ3MgPSB2b2lkIDA7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gZmFsc2U7XG5cbntcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHxcbiAgLy8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBNYXAgaGFzIG5vIHByb3RvdHlwZVxuICBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8XG4gIC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgU2V0IGhhcyBubyBwcm90b3R5cGVcbiAgU2V0LnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cblxuICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLl9pbnRlcm5hbFJvb3QuY3VycmVudCk7XG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgICEoaG9zdEluc3RhbmNlLnBhcmVudE5vZGUgPT09IGNvbnRhaW5lcikgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCkpO1xuXG4gICAgISghaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCkgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpIDogdm9pZCAwO1xuXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJykgOiB2b2lkIDA7XG4gIH07XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgIShjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMSk7XG5cbmZ1bmN0aW9uIFJlYWN0QmF0Y2gocm9vdCkge1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uKCk7XG4gIHRoaXMuX2V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fZGlkQ29tcGxldGUgPSBmYWxzZTtcbiAgdGhpcy5faGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgdGhpcy5fY2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLl9kZWZlciA9IHRydWU7XG59XG5SZWFjdEJhdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgIXRoaXMuX2RlZmVyID8gaW52YXJpYW50KGZhbHNlLCAnYmF0Y2gucmVuZGVyOiBDYW5ub3QgcmVuZGVyIGEgYmF0Y2ggdGhhdCBhbHJlYWR5IGNvbW1pdHRlZC4nKSA6IHZvaWQgMDtcbiAgdGhpcy5faGFzQ2hpbGRyZW4gPSB0cnVlO1xuICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5fcm9vdC5faW50ZXJuYWxSb290O1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSB0aGlzLl9leHBpcmF0aW9uVGltZTtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIHVwZGF0ZUNvbnRhaW5lckF0RXhwaXJhdGlvblRpbWUoY2hpbGRyZW4sIGludGVybmFsUm9vdCwgbnVsbCwgZXhwaXJhdGlvblRpbWUsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RCYXRjaC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gIGlmICh0aGlzLl9kaWRDb21wbGV0ZSkge1xuICAgIG9uQ29tcGxldGUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICB9XG4gIGNhbGxiYWNrcy5wdXNoKG9uQ29tcGxldGUpO1xufTtcblJlYWN0QmF0Y2gucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGludGVybmFsUm9vdCA9IHRoaXMuX3Jvb3QuX2ludGVybmFsUm9vdDtcbiAgdmFyIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaDtcbiAgISh0aGlzLl9kZWZlciAmJiBmaXJzdEJhdGNoICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2JhdGNoLmNvbW1pdDogQ2Fubm90IGNvbW1pdCBhIGJhdGNoIG11bHRpcGxlIHRpbWVzLicpIDogdm9pZCAwO1xuXG4gIGlmICghdGhpcy5faGFzQ2hpbGRyZW4pIHtcbiAgICAvLyBUaGlzIGJhdGNoIGlzIGVtcHR5LiBSZXR1cm4uXG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgdGhpcy5fZGVmZXIgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXhwaXJhdGlvblRpbWUgPSB0aGlzLl9leHBpcmF0aW9uVGltZTtcblxuICAvLyBFbnN1cmUgdGhpcyBpcyB0aGUgZmlyc3QgYmF0Y2ggaW4gdGhlIGxpc3QuXG4gIGlmIChmaXJzdEJhdGNoICE9PSB0aGlzKSB7XG4gICAgLy8gVGhpcyBiYXRjaCBpcyBub3QgdGhlIGVhcmxpZXN0IGJhdGNoLiBXZSBuZWVkIHRvIG1vdmUgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIFVwZGF0ZSBpdHMgZXhwaXJhdGlvbiB0aW1lIHRvIGJlIHRoZSBleHBpcmF0aW9uIHRpbWUgb2YgdGhlIGVhcmxpZXN0XG4gICAgLy8gYmF0Y2gsIHNvIHRoYXQgd2UgY2FuIGZsdXNoIGl0IHdpdGhvdXQgZmx1c2hpbmcgdGhlIG90aGVyIGJhdGNoZXMuXG4gICAgaWYgKHRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IHRoaXMuX2V4cGlyYXRpb25UaW1lID0gZmlyc3RCYXRjaC5fZXhwaXJhdGlvblRpbWU7XG4gICAgICAvLyBSZW5kZXJpbmcgdGhpcyBiYXRjaCBhZ2FpbiBlbnN1cmVzIGl0cyBjaGlsZHJlbiB3aWxsIGJlIHRoZSBmaW5hbCBzdGF0ZVxuICAgICAgLy8gd2hlbiB3ZSBmbHVzaCAodXBkYXRlcyBhcmUgcHJvY2Vzc2VkIGluIGluc2VydGlvbiBvcmRlcjogbGFzdFxuICAgICAgLy8gdXBkYXRlIHdpbnMpLlxuICAgICAgLy8gVE9ETzogVGhpcyBmb3JjZXMgYSByZXN0YXJ0LiBTaG91bGQgd2UgcHJpbnQgYSB3YXJuaW5nP1xuICAgICAgdGhpcy5yZW5kZXIodGhpcy5fY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgYmF0Y2ggZnJvbSB0aGUgbGlzdC5cbiAgICB2YXIgcHJldmlvdXMgPSBudWxsO1xuICAgIHZhciBiYXRjaCA9IGZpcnN0QmF0Y2g7XG4gICAgd2hpbGUgKGJhdGNoICE9PSB0aGlzKSB7XG4gICAgICBwcmV2aW91cyA9IGJhdGNoO1xuICAgICAgYmF0Y2ggPSBiYXRjaC5fbmV4dDtcbiAgICB9XG4gICAgIShwcmV2aW91cyAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdiYXRjaC5jb21taXQ6IENhbm5vdCBjb21taXQgYSBiYXRjaCBtdWx0aXBsZSB0aW1lcy4nKSA6IHZvaWQgMDtcbiAgICBwcmV2aW91cy5fbmV4dCA9IGJhdGNoLl9uZXh0O1xuXG4gICAgLy8gQWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICB0aGlzLl9uZXh0ID0gZmlyc3RCYXRjaDtcbiAgICBmaXJzdEJhdGNoID0gaW50ZXJuYWxSb290LmZpcnN0QmF0Y2ggPSB0aGlzO1xuICB9XG5cbiAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBhbGwgdGhlIHdvcmsgdXAgdG8gdGhpcyBiYXRjaCdzIGV4cGlyYXRpb24gdGltZS5cbiAgdGhpcy5fZGVmZXIgPSBmYWxzZTtcbiAgZmx1c2hSb290KGludGVybmFsUm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuXG4gIC8vIFBvcCB0aGUgYmF0Y2ggZnJvbSB0aGUgbGlzdC5cbiAgdmFyIG5leHQgPSB0aGlzLl9uZXh0O1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoID0gbmV4dDtcblxuICAvLyBBcHBlbmQgdGhlIG5leHQgZWFybGllc3QgYmF0Y2gncyBjaGlsZHJlbiB0byB0aGUgdXBkYXRlIHF1ZXVlLlxuICBpZiAoZmlyc3RCYXRjaCAhPT0gbnVsbCAmJiBmaXJzdEJhdGNoLl9oYXNDaGlsZHJlbikge1xuICAgIGZpcnN0QmF0Y2gucmVuZGVyKGZpcnN0QmF0Y2guX2NoaWxkcmVuKTtcbiAgfVxufTtcblJlYWN0QmF0Y2gucHJvdG90eXBlLl9vbkNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlkQ29tcGxldGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZGlkQ29tcGxldGUgPSB0cnVlO1xuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRPRE86IEVycm9yIGhhbmRsaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG4gICAgX2NhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFJlYWN0V29yaygpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fZGlkQ29tbWl0ID0gZmFsc2U7XG4gIC8vIFRPRE86IEF2b2lkIG5lZWQgdG8gYmluZCBieSByZXBsYWNpbmcgY2FsbGJhY2tzIGluIHRoZSB1cGRhdGUgcXVldWUgd2l0aFxuICAvLyBsaXN0IG9mIFdvcmsgb2JqZWN0cy5cbiAgdGhpcy5fb25Db21taXQgPSB0aGlzLl9vbkNvbW1pdC5iaW5kKHRoaXMpO1xufVxuUmVhY3RXb3JrLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uQ29tbWl0KSB7XG4gIGlmICh0aGlzLl9kaWRDb21taXQpIHtcbiAgICBvbkNvbW1pdCgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzID0gW107XG4gIH1cbiAgY2FsbGJhY2tzLnB1c2gob25Db21taXQpO1xufTtcblJlYWN0V29yay5wcm90b3R5cGUuX29uQ29tbWl0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlkQ29tbWl0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2RpZENvbW1pdCA9IHRydWU7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gVE9ETzogRXJyb3IgaGFuZGxpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jYWxsYmFjazIgPSBjYWxsYmFja3NbaV07XG4gICAgISh0eXBlb2YgX2NhbGxiYWNrMiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBfY2FsbGJhY2syKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2syKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGlzQXN5bmMsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBjcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBpc0FzeW5jLCBoeWRyYXRlKTtcbiAgdGhpcy5faW50ZXJuYWxSb290ID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAge1xuICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdvcmsudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCB3b3JrLl9vbkNvbW1pdCk7XG4gIHJldHVybiB3b3JrO1xufTtcblJlYWN0Um9vdC5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAge1xuICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdvcmsudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyKG51bGwsIHJvb3QsIG51bGwsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS5sZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9pbnRlcm5hbFJvb3Q7XG4gIHZhciB3b3JrID0gbmV3IFJlYWN0V29yaygpO1xuICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gIHtcbiAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZW5kZXInKTtcbiAgfVxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB3b3JrLnRoZW4oY2FsbGJhY2spO1xuICB9XG4gIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCB3b3JrLl9vbkNvbW1pdCk7XG4gIHJldHVybiB3b3JrO1xufTtcblJlYWN0Um9vdC5wcm90b3R5cGUuY3JlYXRlQmF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBiYXRjaCA9IG5ldyBSZWFjdEJhdGNoKHRoaXMpO1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSBiYXRjaC5fZXhwaXJhdGlvblRpbWU7XG5cbiAgdmFyIGludGVybmFsUm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaDtcbiAgaWYgKGZpcnN0QmF0Y2ggPT09IG51bGwpIHtcbiAgICBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaCA9IGJhdGNoO1xuICAgIGJhdGNoLl9uZXh0ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbnNlcnQgc29ydGVkIGJ5IGV4cGlyYXRpb24gdGltZSB0aGVuIGluc2VydGlvbiBvcmRlclxuICAgIHZhciBpbnNlcnRBZnRlciA9IG51bGw7XG4gICAgdmFyIGluc2VydEJlZm9yZSA9IGZpcnN0QmF0Y2g7XG4gICAgd2hpbGUgKGluc2VydEJlZm9yZSAhPT0gbnVsbCAmJiBpbnNlcnRCZWZvcmUuX2V4cGlyYXRpb25UaW1lIDw9IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBpbnNlcnRBZnRlciA9IGluc2VydEJlZm9yZTtcbiAgICAgIGluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZS5fbmV4dDtcbiAgICB9XG4gICAgYmF0Y2guX25leHQgPSBpbnNlcnRCZWZvcmU7XG4gICAgaWYgKGluc2VydEFmdGVyICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRBZnRlci5fbmV4dCA9IGJhdGNoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiYXRjaDtcbn07XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKTtcbn1cblxuc2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbihiYXRjaGVkVXBkYXRlcyQxLCBpbnRlcmFjdGl2ZVVwZGF0ZXMkMSwgZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMkMSk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUpIHtcbiAgdmFyIHNob3VsZEh5ZHJhdGUgPSBmb3JjZUh5ZHJhdGUgfHwgc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcik7XG4gIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICBpZiAoIXNob3VsZEh5ZHJhdGUpIHtcbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHJvb3RTaWJsaW5nKTtcbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChzaG91bGRIeWRyYXRlICYmICFmb3JjZUh5ZHJhdGUgJiYgIXdhcm5lZEFib3V0SHlkcmF0ZUFQSSkge1xuICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAncmVuZGVyKCk6IENhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgdG8gaHlkcmF0ZSBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwICcgKyAnd2lsbCBzdG9wIHdvcmtpbmcgaW4gUmVhY3QgdjE3LiBSZXBsYWNlIHRoZSBSZWFjdERPTS5yZW5kZXIoKSBjYWxsICcgKyAnd2l0aCBSZWFjdERPTS5oeWRyYXRlKCkgaWYgeW91IHdhbnQgUmVhY3QgdG8gYXR0YWNoIHRvIHRoZSBzZXJ2ZXIgSFRNTC4nKTtcbiAgICB9XG4gIH1cbiAgLy8gTGVnYWN5IHJvb3RzIGFyZSBub3QgYXN5bmMgYnkgZGVmYXVsdC5cbiAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgcmV0dXJuIG5ldyBSZWFjdFJvb3QoY29udGFpbmVyLCBpc0FzeW5jLCBzaG91bGRIeWRyYXRlKTtcbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gIC8vIFRPRE86IEVuc3VyZSBhbGwgZW50cnkgcG9pbnRzIGNvbnRhaW4gdGhpcyBjaGVja1xuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcblxuICB7XG4gICAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyhjb250YWluZXIpO1xuICB9XG5cbiAgLy8gVE9ETzogV2l0aG91dCBgYW55YCB0eXBlLCBGbG93IHNheXMgXCJQcm9wZXJ0eSBjYW5ub3QgYmUgYWNjZXNzZWQgb24gYW55XG4gIC8vIG1lbWJlciBvZiBpbnRlcnNlY3Rpb24gdHlwZS5cIiBXaHl5eXl5eS5cbiAgdmFyIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgaWYgKCFyb290KSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudFxuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IGxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlKTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290Ll9pbnRlcm5hbFJvb3QpO1xuICAgICAgICBvcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgdW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGFyZW50Q29tcG9uZW50ICE9IG51bGwpIHtcbiAgICAgICAgcm9vdC5sZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5yZW5kZXIoY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX29yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdC5faW50ZXJuYWxSb290KTtcbiAgICAgICAgX29yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBVcGRhdGVcbiAgICBpZiAocGFyZW50Q29tcG9uZW50ICE9IG51bGwpIHtcbiAgICAgIHJvb3QubGVnYWN5X3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5yZW5kZXIoY2hpbGRyZW4sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290Ll9pbnRlcm5hbFJvb3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuICAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn1cblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIuc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB3YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI7XG4gICAgICAgICF3YXJuZWRBYm91dFJlZnNJblJlbmRlciA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnRPckVsZW1lbnQpO1xuICB9LFxuICBoeWRyYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbiAgICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKTtcbiAgICAgICAgISFyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsIFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFVubW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgICAgdW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG51bGwsIGNvbnRhaW5lciwgZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyBJZiB5b3UgY2FsbCB1bm1vdW50Q29tcG9uZW50QXROb2RlIHR3aWNlIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHlvdSdsbFxuICAgICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShfcm9vdEVsKSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICAhIWhhc05vblJvb3RSZWFjdENoaWxkID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gVGVtcG9yYXJ5IGFsaWFzIHNpbmNlIHdlIGFscmVhZHkgc2hpcHBlZCBSZWFjdCAxNiBSQyB3aXRoIGl0LlxuICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuXG4gIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RET00uY3JlYXRlUG9ydGFsKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSSwgJyArICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9LFxuXG5cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzJDEsXG5cbiAgdW5zdGFibGVfaW50ZXJhY3RpdmVVcGRhdGVzOiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMSxcblxuICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICB1bnN0YWJsZV9mbHVzaENvbnRyb2xsZWQ6IGZsdXNoQ29udHJvbGxlZCxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEtlZXAgaW4gc3luYyB3aXRoIFJlYWN0RE9NVW5zdGFibGVOYXRpdmVEZXBlbmRlbmNpZXMuanNcbiAgICAvLyBhbmQgUmVhY3RUZXN0VXRpbHMuanMuIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG4gICAgRXZlbnRzOiBbZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLCBnZXROb2RlRnJvbUluc3RhbmNlJDEsIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSwgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcywgZW5xdWV1ZVN0YXRlUmVzdG9yZSwgcmVzdG9yZVN0YXRlSWZOZWVkZWQsIGRpc3BhdGNoRXZlbnQsIHJ1bkV2ZW50c0luQmF0Y2hdXG4gIH1cbn07XG5cblJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVJvb3QgPSBmdW5jdGlvbiBjcmVhdGVSb290KGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5zdGFibGVfY3JlYXRlUm9vdCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuICB2YXIgaHlkcmF0ZSA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGUgPT09IHRydWU7XG4gIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgdHJ1ZSwgaHlkcmF0ZSk7XG59O1xuXG52YXIgZm91bmREZXZUb29scyA9IGluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogMSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuICByZW5kZXJlclBhY2thZ2VOYW1lOiAncmVhY3QtZG9tJ1xufSk7XG5cbntcbiAgaWYgKCFmb3VuZERldlRvb2xzICYmIGNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgIC8vIERvbid0IHdhcm4gaW4gZXhvdGljIGNhc2VzIGxpa2UgY2hyb21lLWV4dGVuc2lvbjovLy5cbiAgICAgIGlmICgvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCclY0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnICsgKHByb3RvY29sID09PSAnZmlsZTonID8gJ1xcbllvdSBtaWdodCBuZWVkIHRvIHVzZSBhIGxvY2FsIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGZpbGU6Ly8pOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMtZmFxJyA6ICcnKSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbnZhciBSZWFjdERPTSQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0RE9NXG59KTtcblxudmFyIFJlYWN0RE9NJDMgPSAoIFJlYWN0RE9NJDIgJiYgUmVhY3RET00gKSB8fCBSZWFjdERPTSQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdERvbSA9IFJlYWN0RE9NJDMuZGVmYXVsdCB8fCBSZWFjdERPTSQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0RG9tO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gIC8vIENhbGwgdGhpcy5jb25zdHJ1Y3Rvci5nRFNGUCB0byBzdXBwb3J0IHN1Yi1jbGFzc2VzLlxuICB2YXIgc3RhdGUgPSB0aGlzLmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyh0aGlzLnByb3BzLCB0aGlzLnN0YXRlKTtcbiAgaWYgKHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAvLyBDYWxsIHRoaXMuY29uc3RydWN0b3IuZ0RTRlAgdG8gc3VwcG9ydCBzdWItY2xhc3Nlcy5cbiAgLy8gVXNlIHRoZSBzZXRTdGF0ZSgpIHVwZGF0ZXIgdG8gZW5zdXJlIHN0YXRlIGlzbid0IHN0YWxlIGluIGNlcnRhaW4gZWRnZSBjYXNlcy5cbiAgZnVuY3Rpb24gdXBkYXRlcihwcmV2U3RhdGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQgPyBzdGF0ZSA6IG51bGw7XG4gIH1cbiAgLy8gQmluZGluZyBcInRoaXNcIiBpcyBpbXBvcnRhbnQgZm9yIHNoYWxsb3cgcmVuZGVyZXIgc3VwcG9ydC5cbiAgdGhpcy5zZXRTdGF0ZSh1cGRhdGVyLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIHRyeSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3RGbGFnID0gdHJ1ZTtcbiAgICB0aGlzLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90ID0gdGhpcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZVxuICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgdGhpcy5wcm9wcyA9IHByZXZQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gcHJldlN0YXRlO1xuICB9XG59XG5cbi8vIFJlYWN0IG1heSB3YXJuIGFib3V0IGNXTS9jV1JQL2NXVSBtZXRob2RzIGJlaW5nIGRlcHJlY2F0ZWQuXG4vLyBBZGQgYSBmbGFnIHRvIHN1cHByZXNzIHRoZXNlIHdhcm5pbmdzIGZvciB0aGlzIHNwZWNpYWwgY2FzZS5cbmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nID0gdHJ1ZTtcbmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgPSB0cnVlO1xuXG5mdW5jdGlvbiBwb2x5ZmlsbChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cbiAgaWYgKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBwb2x5ZmlsbCBjbGFzcyBjb21wb25lbnRzJyk7XG4gIH1cblxuICBpZiAoXG4gICAgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcHJvdG90eXBlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybiBDb21wb25lbnQ7XG4gIH1cblxuICAvLyBJZiBuZXcgY29tcG9uZW50IEFQSXMgYXJlIGRlZmluZWQsIFwidW5zYWZlXCIgbGlmZWN5Y2xlcyB3b24ndCBiZSBjYWxsZWQuXG4gIC8vIEVycm9yIGlmIGFueSBvZiB0aGVzZSBsaWZlY3ljbGVzIGFyZSBwcmVzZW50LFxuICAvLyBCZWNhdXNlIHRoZXkgd291bGQgd29yayBkaWZmZXJlbnRseSBiZXR3ZWVuIG9sZGVyIGFuZCBuZXdlciAoMTYuMyspIHZlcnNpb25zIG9mIFJlYWN0LlxuICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG4gIGlmICh0eXBlb2YgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm90b3R5cGUuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgfVxuICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG90eXBlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICB9XG4gIGlmIChcbiAgICBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHxcbiAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8XG4gICAgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbFxuICApIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZTtcbiAgICB2YXIgbmV3QXBpTmFtZSA9XG4gICAgICB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSdcbiAgICAgICAgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICB0aHJvdyBFcnJvcihcbiAgICAgICdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICtcbiAgICAgICAgY29tcG9uZW50TmFtZSArXG4gICAgICAgICcgdXNlcyAnICtcbiAgICAgICAgbmV3QXBpTmFtZSArXG4gICAgICAgICcgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczonICtcbiAgICAgICAgKGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/ICdcXG4gICcgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJykgK1xuICAgICAgICAoZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbFxuICAgICAgICAgID8gJ1xcbiAgJyArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICA6ICcnKSArXG4gICAgICAgIChmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJykgK1xuICAgICAgICAnXFxuXFxuVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArXG4gICAgICAgICdodHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3MnXG4gICAgKTtcbiAgfVxuXG4gIC8vIFJlYWN0IDw9IDE2LjIgZG9lcyBub3Qgc3VwcG9ydCBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLlxuICAvLyBBcyBhIHdvcmthcm91bmQsIHVzZSBjV00gYW5kIGNXUlAgdG8gaW52b2tlIHRoZSBuZXcgc3RhdGljIGxpZmVjeWNsZS5cbiAgLy8gTmV3ZXIgdmVyc2lvbnMgb2YgUmVhY3Qgd2lsbCBpZ25vcmUgdGhlc2UgbGlmZWN5Y2xlcyBpZiBnRFNGUCBleGlzdHMuXG4gIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBjb21wb25lbnRXaWxsTW91bnQ7XG4gICAgcHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzO1xuICB9XG5cbiAgLy8gUmVhY3QgPD0gMTYuMiBkb2VzIG5vdCBzdXBwb3J0IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLlxuICAvLyBBcyBhIHdvcmthcm91bmQsIHVzZSBjV1UgdG8gaW52b2tlIHRoZSBuZXcgbGlmZWN5Y2xlLlxuICAvLyBOZXdlciB2ZXJzaW9ucyBvZiBSZWFjdCB3aWxsIGlnbm9yZSB0aGF0IGxpZmVjeWNsZSBpZiBnU0JVIGV4aXN0cy5cbiAgaWYgKHR5cGVvZiBwcm90b3R5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIHByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBwb2x5ZmlsbCBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGZvciBjb21wb25lbnRzIHRoYXQgZG8gbm90IGRlZmluZSBjb21wb25lbnREaWRVcGRhdGUoKSBvbiB0aGUgcHJvdG90eXBlJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBwcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGNvbXBvbmVudFdpbGxVcGRhdGU7XG5cbiAgICB2YXIgY29tcG9uZW50RGlkVXBkYXRlID0gcHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZTtcblxuICAgIHByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGVQb2x5ZmlsbChcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIHByZXZTdGF0ZSxcbiAgICAgIG1heWJlU25hcHNob3RcbiAgICApIHtcbiAgICAgIC8vIDE2LjMrIHdpbGwgbm90IGV4ZWN1dGUgb3VyIHdpbGwtdXBkYXRlIG1ldGhvZDtcbiAgICAgIC8vIEl0IHdpbGwgcGFzcyBhIHNuYXBzaG90IHZhbHVlIHRvIGRpZC11cGRhdGUgdGhvdWdoLlxuICAgICAgLy8gT2xkZXIgdmVyc2lvbnMgd2lsbCByZXF1aXJlIG91ciBwb2x5ZmlsbGVkIHdpbGwtdXBkYXRlIHZhbHVlLlxuICAgICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYm90aCBjYXNlcywgYnV0IGNhbid0IGp1c3QgY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBcIm1heWJlU25hcHNob3RcIixcbiAgICAgIC8vIEJlY2F1c2UgZm9yIDw9IDE1LnggdmVyc2lvbnMgdGhpcyBtaWdodCBiZSBhIFwicHJldkNvbnRleHRcIiBvYmplY3QuXG4gICAgICAvLyBXZSBhbHNvIGNhbid0IGp1c3QgY2hlY2sgXCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdFwiLFxuICAgICAgLy8gQmVjYXVzZSBnZXQtc25hcHNob3QgbWlnaHQgcmV0dXJuIGEgZmFsc3kgdmFsdWUuXG4gICAgICAvLyBTbyBjaGVjayBmb3IgdGhlIGV4cGxpY2l0IF9fcmVhY3RJbnRlcm5hbFNuYXBzaG90RmxhZyBmbGFnIHRvIGRldGVybWluZSBiZWhhdmlvci5cbiAgICAgIHZhciBzbmFwc2hvdCA9IHRoaXMuX19yZWFjdEludGVybmFsU25hcHNob3RGbGFnXG4gICAgICAgID8gdGhpcy5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdFxuICAgICAgICA6IG1heWJlU25hcHNob3Q7XG5cbiAgICAgIGNvbXBvbmVudERpZFVwZGF0ZS5jYWxsKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBDb21wb25lbnQ7XG59XG5cbmV4cG9ydCB7IHBvbHlmaWxsIH07XG4iLCJpbXBvcnQgeyBfX3Jlc3QsIF9fYXNzaWduLCBfX2V4dGVuZHMgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBjcmVhdGVDb250ZXh0LCBGcmFnbWVudCwgQ29tcG9uZW50LCBQdXJlQ29tcG9uZW50LCBDaGlsZHJlbiwgY2xvbmVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHBvc2VGYWN0b3J5IGZyb20gJ3BvcG1vdGlvbi1wb3NlJztcbmltcG9ydCBpc1ZhbGlkUHJvcCBmcm9tICdAZW1vdGlvbi9pcy1wcm9wLXZhbGlkJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ2hleS1saXN0ZW4nO1xuXG52YXIgaGFzQ2hhbmdlZCA9IGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XHJcbiAgICBpZiAocHJldiA9PT0gbmV4dClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgcHJldklzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByZXYpO1xyXG4gICAgdmFyIG5leHRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXh0KTtcclxuICAgIGlmIChwcmV2SXNBcnJheSAhPT0gbmV4dElzQXJyYXkgfHwgKCFwcmV2SXNBcnJheSAmJiAhbmV4dElzQXJyYXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcmV2SXNBcnJheSAmJiBuZXh0SXNBcnJheSkge1xyXG4gICAgICAgIHZhciBudW1QcmV2ID0gcHJldi5sZW5ndGg7XHJcbiAgICAgICAgdmFyIG51bU5leHQgPSBuZXh0Lmxlbmd0aDtcclxuICAgICAgICBpZiAobnVtUHJldiAhPT0gbnVtTmV4dClcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IG51bVByZXY7IGkgPCBudW1QcmV2OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHByZXZbaV0gIT09IG5leHRbaV0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XG5cbnZhciBwaWNrQXNzaWduID0gZnVuY3Rpb24gKHNob3VsZFBpY2ssIHNvdXJjZXMpIHtcclxuICAgIHJldHVybiBzb3VyY2VzLnJlZHVjZShmdW5jdGlvbiAocGlja2VkLCBzb3VyY2UpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRQaWNrKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHBpY2tlZFtrZXldID0gc291cmNlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBpY2tlZDtcclxuICAgIH0sIHt9KTtcclxufTtcblxudmFyIFBvc2VQYXJlbnRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XHJcbnZhciBjYWxjUG9wRnJvbUZsb3dTdHlsZSA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgdmFyIG9mZnNldFRvcCA9IGVsLm9mZnNldFRvcCwgb2Zmc2V0TGVmdCA9IGVsLm9mZnNldExlZnQsIG9mZnNldFdpZHRoID0gZWwub2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiBvZmZzZXRUb3AsXHJcbiAgICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcclxuICAgICAgICB3aWR0aDogb2Zmc2V0V2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBvZmZzZXRIZWlnaHRcclxuICAgIH07XHJcbn07XHJcbnZhciBoYXNQb3NlID0gZnVuY3Rpb24gKHBvc2UsIGtleSkge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocG9zZSkgPyBwb3NlLmluZGV4T2Yoa2V5KSAhPT0gLTEgOiBwb3NlID09PSBrZXk7XHJcbn07XHJcbnZhciBvYmplY3RUb01hcCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAobWFwLCBrZXkpIHtcclxuICAgICAgICBtYXAuc2V0KGtleSwgeyByYXc6IG9ialtrZXldIH0pO1xyXG4gICAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9LCBuZXcgTWFwKCkpO1xyXG59O1xyXG52YXIgdGVzdEFsd2F5c1RydWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xyXG52YXIgUG9zZUVsZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBvc2VFbGVtZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUG9zZUVsZW1lbnQocHJvcHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoKTtcclxuICAgICAgICBfdGhpcy5jaGlsZHJlbkhhbmRsZXJzID0ge1xyXG4gICAgICAgICAgICByZWdpc3RlckNoaWxkOiBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNoaWxkcmVuLmFkZChwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucG9zZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmx1c2hDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvblVubW91bnQ6IGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gX3RoaXMucG9zZXIucmVtb3ZlQ2hpbGQoY2hpbGQpOyB9LFxyXG4gICAgICAgICAgICBnZXRQYXJlbnRQb3NlQ29uZmlnOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcm9wcy5wb3NlQ29uZmlnOyB9LFxyXG4gICAgICAgICAgICBnZXRJbml0aWFsUG9zZUZyb21QYXJlbnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdldEluaXRpYWxQb3NlKCk7IH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLmdldFJlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZWZzID0ge307XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IF90aGlzLnByb3BzLmVsZW1lbnRUeXBlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmVmcy5yZWYgPSBfdGhpcy5zZXRSZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWZzLmlubmVyUmVmID0gX3RoaXMuc2V0UmVmO1xyXG4gICAgICAgICAgICAgICAgcmVmcy5ob3N0UmVmID0gX3RoaXMuc2V0UmVmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZWZzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuc2V0UmVmID0gZnVuY3Rpb24gKHJlZikge1xyXG4gICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgRWxlbWVudCB8fCAoX3RoaXMucmVmICYmIHJlZiA9PT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbm5lclJlZiA9IF90aGlzLnByb3BzLmlubmVyUmVmO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlubmVyUmVmKVxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyUmVmKHJlZik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWYgPSByZWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLnNob3VsZEZvcndhcmRQcm9wID1cclxuICAgICAgICAgICAgdHlwZW9mIF90aGlzLnByb3BzLmVsZW1lbnRUeXBlID09PSAnc3RyaW5nJyA/IGlzVmFsaWRQcm9wIDogdGVzdEFsd2F5c1RydWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgUG9zZUVsZW1lbnQucHJvdG90eXBlLmdldEluaXRpYWxQb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGdldEluaXRpYWxQb3NlRnJvbVBhcmVudCA9IF9hLmdldEluaXRpYWxQb3NlRnJvbVBhcmVudCwgcG9zZSA9IF9hLnBvc2UsIF9wb3NlID0gX2EuX3Bvc2UsIGluaXRpYWxQb3NlID0gX2EuaW5pdGlhbFBvc2U7XHJcbiAgICAgICAgaWYgKGluaXRpYWxQb3NlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsUG9zZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRQb3NlID0gZ2V0SW5pdGlhbFBvc2VGcm9tUGFyZW50ICYmIGdldEluaXRpYWxQb3NlRnJvbVBhcmVudCgpO1xyXG4gICAgICAgICAgICB2YXIgdGhpc1Bvc2UgPSBBcnJheS5pc0FycmF5KHBvc2UpID8gcG9zZSA6IFtwb3NlXTtcclxuICAgICAgICAgICAgdmFyIHRoaXNJbnRlcm5hbFBvc2UgPSBBcnJheS5pc0FycmF5KF9wb3NlKSA/IF9wb3NlIDogW19wb3NlXTtcclxuICAgICAgICAgICAgdmFyIGluaXRpYWxQb3NlcyA9IEFycmF5LmlzQXJyYXkocGFyZW50UG9zZSlcclxuICAgICAgICAgICAgICAgID8gcGFyZW50UG9zZS5jb25jYXQodGhpc1Bvc2UsIHRoaXNJbnRlcm5hbFBvc2UpIDogW3BhcmVudFBvc2VdLmNvbmNhdCh0aGlzUG9zZSwgdGhpc0ludGVybmFsUG9zZSk7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZEluaXRpYWxQb3NlcyA9IGluaXRpYWxQb3Nlcy5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEluaXRpYWxQb3Nlcy5sZW5ndGggPyBmaWx0ZXJlZEluaXRpYWxQb3NlcyA6IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUG9zZUVsZW1lbnQucHJvdG90eXBlLmdldEZpcnN0UG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBpbml0aWFsUG9zZSA9IF9hLmluaXRpYWxQb3NlLCBwb3NlID0gX2EucG9zZSwgX3Bvc2UgPSBfYS5fcG9zZTtcclxuICAgICAgICBpZiAoIWluaXRpYWxQb3NlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIHRoaXNQb3NlID0gQXJyYXkuaXNBcnJheShwb3NlKSA/IHBvc2UgOiBbcG9zZV07XHJcbiAgICAgICAgdmFyIHRoaXNJbnRlcm5hbFBvc2UgPSBBcnJheS5pc0FycmF5KF9wb3NlKSA/IF9wb3NlIDogW19wb3NlXTtcclxuICAgICAgICByZXR1cm4gdGhpc1Bvc2UuY29uY2F0KHRoaXNJbnRlcm5hbFBvc2UpO1xyXG4gICAgfTtcclxuICAgIFBvc2VFbGVtZW50LnByb3RvdHlwZS5nZXRTZXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBlbGVtZW50VHlwZSA9IF9hLmVsZW1lbnRUeXBlLCBwb3NlQ29uZmlnID0gX2EucG9zZUNvbmZpZywgb25WYWx1ZUNoYW5nZSA9IF9hLm9uVmFsdWVDaGFuZ2UsIGlubmVyUmVmID0gX2EuaW5uZXJSZWYsIF9wb3NlID0gX2EuX3Bvc2UsIHBvc2UgPSBfYS5wb3NlLCBpbml0aWFsUG9zZSA9IF9hLmluaXRpYWxQb3NlLCBwb3NlS2V5ID0gX2EucG9zZUtleSwgb25Qb3NlQ29tcGxldGUgPSBfYS5vblBvc2VDb21wbGV0ZSwgZ2V0UGFyZW50UG9zZUNvbmZpZyA9IF9hLmdldFBhcmVudFBvc2VDb25maWcsIHJlZ2lzdGVyQ2hpbGQgPSBfYS5yZWdpc3RlckNoaWxkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQsIGdldEluaXRpYWxQb3NlRnJvbVBhcmVudCA9IF9hLmdldEluaXRpYWxQb3NlRnJvbVBhcmVudCwgcG9wRnJvbUZsb3cgPSBfYS5wb3BGcm9tRmxvdywgdmFsdWVzID0gX2EudmFsdWVzLCBwYXJlbnRWYWx1ZXMgPSBfYS5wYXJlbnRWYWx1ZXMsIG9uRHJhZ1N0YXJ0ID0gX2Eub25EcmFnU3RhcnQsIG9uRHJhZ0VuZCA9IF9hLm9uRHJhZ0VuZCwgb25QcmVzc1N0YXJ0ID0gX2Eub25QcmVzc1N0YXJ0LCBvblByZXNzRW5kID0gX2Eub25QcmVzc0VuZCwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImVsZW1lbnRUeXBlXCIsIFwicG9zZUNvbmZpZ1wiLCBcIm9uVmFsdWVDaGFuZ2VcIiwgXCJpbm5lclJlZlwiLCBcIl9wb3NlXCIsIFwicG9zZVwiLCBcImluaXRpYWxQb3NlXCIsIFwicG9zZUtleVwiLCBcIm9uUG9zZUNvbXBsZXRlXCIsIFwiZ2V0UGFyZW50UG9zZUNvbmZpZ1wiLCBcInJlZ2lzdGVyQ2hpbGRcIiwgXCJvblVubW91bnRcIiwgXCJnZXRJbml0aWFsUG9zZUZyb21QYXJlbnRcIiwgXCJwb3BGcm9tRmxvd1wiLCBcInZhbHVlc1wiLCBcInBhcmVudFZhbHVlc1wiLCBcIm9uRHJhZ1N0YXJ0XCIsIFwib25EcmFnRW5kXCIsIFwib25QcmVzc1N0YXJ0XCIsIFwib25QcmVzc0VuZFwiXSk7XHJcbiAgICAgICAgaWYgKHBvcEZyb21GbG93ICYmIHRoaXMucmVmICYmIHRoaXMucmVmIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBvcFN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5zdHlsZSA9IF9fYXNzaWduKHt9LCBwcm9wcy5zdHlsZSwgY2FsY1BvcEZyb21GbG93U3R5bGUodGhpcy5yZWYpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9wU3R5bGUgPSBwcm9wcy5zdHlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLnN0eWxlID0gdGhpcy5wb3BTdHlsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH07XHJcbiAgICBQb3NlRWxlbWVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHRoaXMucmVmICE9PSAndW5kZWZpbmVkJywgXCJObyBET00gcmVmIGZvdW5kLiBJZiB5b3UncmUgY29udmVydGluZyBhbiBleGlzdGluZyBjb21wb25lbnQgdmlhIHBvc2VkKENvbXBvbmVudCksIHlvdSBtdXN0IGVuc3VyZSB5b3UncmUgcGFzc2luZyB0aGUgaG9zdFJlZiBwcm9wIHRvIHlvdXIgdW5kZXJseWluZyBET00gZWxlbWVudC5cIik7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgcG9zZUNvbmZpZyA9IF9hLnBvc2VDb25maWcsIG9uVmFsdWVDaGFuZ2UgPSBfYS5vblZhbHVlQ2hhbmdlLCByZWdpc3RlckNoaWxkID0gX2EucmVnaXN0ZXJDaGlsZCwgdmFsdWVzID0gX2EudmFsdWVzLCBwYXJlbnRWYWx1ZXMgPSBfYS5wYXJlbnRWYWx1ZXMsIG9uRHJhZ1N0YXJ0ID0gX2Eub25EcmFnU3RhcnQsIG9uRHJhZ0VuZCA9IF9hLm9uRHJhZ0VuZCwgb25QcmVzc1N0YXJ0ID0gX2Eub25QcmVzc1N0YXJ0LCBvblByZXNzRW5kID0gX2Eub25QcmVzc0VuZDtcclxuICAgICAgICB2YXIgY29uZmlnID0gX19hc3NpZ24oe30sIHBvc2VDb25maWcsIHsgaW5pdGlhbFBvc2U6IHRoaXMuZ2V0SW5pdGlhbFBvc2UoKSwgdmFsdWVzOiB2YWx1ZXMgfHwgcG9zZUNvbmZpZy52YWx1ZXMsIHBhcmVudFZhbHVlczogcGFyZW50VmFsdWVzID8gb2JqZWN0VG9NYXAocGFyZW50VmFsdWVzKSA6IHVuZGVmaW5lZCwgcHJvcHM6IHRoaXMuZ2V0U2V0UHJvcHMoKSwgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0LFxyXG4gICAgICAgICAgICBvbkRyYWdFbmQ6IG9uRHJhZ0VuZCxcclxuICAgICAgICAgICAgb25QcmVzc1N0YXJ0OiBvblByZXNzU3RhcnQsXHJcbiAgICAgICAgICAgIG9uUHJlc3NFbmQ6IG9uUHJlc3NFbmQsIG9uQ2hhbmdlOiBvblZhbHVlQ2hhbmdlIH0pO1xyXG4gICAgICAgIGlmICghcmVnaXN0ZXJDaGlsZCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRQb3Nlcihwb3NlRmFjdG9yeSh0aGlzLnJlZiwgY29uZmlnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWdpc3RlckNoaWxkKHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMucmVmLFxyXG4gICAgICAgICAgICAgICAgcG9zZUNvbmZpZzogY29uZmlnLFxyXG4gICAgICAgICAgICAgICAgb25SZWdpc3RlcmVkOiBmdW5jdGlvbiAocG9zZXIpIHsgcmV0dXJuIF90aGlzLmluaXRQb3Nlcihwb3Nlcik7IH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBvc2VFbGVtZW50LnByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBwb3NlID0gX2EucG9zZSwgX3Bvc2UgPSBfYS5fcG9zZTtcclxuICAgICAgICBpZiAoaGFzUG9zZShwb3NlLCAnZmxpcCcpIHx8IGhhc1Bvc2UoX3Bvc2UsICdmbGlwJykpXHJcbiAgICAgICAgICAgIHRoaXMucG9zZXIubWVhc3VyZSgpO1xyXG4gICAgfTtcclxuICAgIFBvc2VFbGVtZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgcG9zZSA9IF9hLnBvc2UsIF9wb3NlID0gX2EuX3Bvc2UsIHBvc2VLZXkgPSBfYS5wb3NlS2V5O1xyXG4gICAgICAgIHRoaXMucG9zZXIuc2V0UHJvcHModGhpcy5nZXRTZXRQcm9wcygpKTtcclxuICAgICAgICBpZiAocG9zZUtleSAhPT0gcHJldlByb3BzLnBvc2VLZXkgfHxcclxuICAgICAgICAgICAgaGFzQ2hhbmdlZChwcmV2UHJvcHMucG9zZSwgcG9zZSkgfHxcclxuICAgICAgICAgICAgcG9zZSA9PT0gJ2ZsaXAnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zZShwb3NlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9wb3NlICE9PSBwcmV2UHJvcHMuX3Bvc2UgfHwgX3Bvc2UgPT09ICdmbGlwJylcclxuICAgICAgICAgICAgdGhpcy5zZXRQb3NlKF9wb3NlKTtcclxuICAgIH07XHJcbiAgICBQb3NlRWxlbWVudC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBvc2VyKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIG9uVW5tb3VudCA9IHRoaXMucHJvcHMub25Vbm1vdW50O1xyXG4gICAgICAgIGlmIChvblVubW91bnQpXHJcbiAgICAgICAgICAgIG9uVW5tb3VudCh0aGlzLnBvc2VyKTtcclxuICAgICAgICB0aGlzLnBvc2VyLmRlc3Ryb3koKTtcclxuICAgIH07XHJcbiAgICBQb3NlRWxlbWVudC5wcm90b3R5cGUuaW5pdFBvc2VyID0gZnVuY3Rpb24gKHBvc2VyKSB7XHJcbiAgICAgICAgdGhpcy5wb3NlciA9IHBvc2VyO1xyXG4gICAgICAgIHRoaXMuZmx1c2hDaGlsZHJlbigpO1xyXG4gICAgICAgIHZhciBmaXJzdFBvc2UgPSB0aGlzLmdldEZpcnN0UG9zZSgpO1xyXG4gICAgICAgIGlmIChmaXJzdFBvc2UpXHJcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zZShmaXJzdFBvc2UpO1xyXG4gICAgfTtcclxuICAgIFBvc2VFbGVtZW50LnByb3RvdHlwZS5zZXRQb3NlID0gZnVuY3Rpb24gKHBvc2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvblBvc2VDb21wbGV0ZSA9IHRoaXMucHJvcHMub25Qb3NlQ29tcGxldGU7XHJcbiAgICAgICAgdmFyIHBvc2VMaXN0ID0gQXJyYXkuaXNBcnJheShwb3NlKSA/IHBvc2UgOiBbcG9zZV07XHJcbiAgICAgICAgUHJvbWlzZS5hbGwocG9zZUxpc3QubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSAmJiBfdGhpcy5wb3Nlci5zZXQoa2V5KTsgfSkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb25Qb3NlQ29tcGxldGUgJiYgb25Qb3NlQ29tcGxldGUoKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9zZUVsZW1lbnQucHJvdG90eXBlLmZsdXNoQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX2EuZWxlbWVudCwgcG9zZUNvbmZpZyA9IF9hLnBvc2VDb25maWcsIG9uUmVnaXN0ZXJlZCA9IF9hLm9uUmVnaXN0ZXJlZDtcclxuICAgICAgICAgICAgcmV0dXJuIG9uUmVnaXN0ZXJlZChfdGhpcy5wb3Nlci5hZGRDaGlsZChlbGVtZW50LCBwb3NlQ29uZmlnKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIFBvc2VFbGVtZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gdGhpcy5wcm9wcy5lbGVtZW50VHlwZTtcclxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUG9zZVBhcmVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuY2hpbGRyZW5IYW5kbGVycyB9LCBjcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlLCBwaWNrQXNzaWduKHRoaXMuc2hvdWxkRm9yd2FyZFByb3AsIFtcclxuICAgICAgICAgICAgdGhpcy5nZXRTZXRQcm9wcygpLFxyXG4gICAgICAgICAgICB0aGlzLmdldFJlZnMoKVxyXG4gICAgICAgIF0pKSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQb3NlRWxlbWVudDtcclxufShQdXJlQ29tcG9uZW50KSk7XG5cbnZhciBzdXBwb3J0ZWRFbGVtZW50cyA9IFtcclxuICAgICdhJyxcclxuICAgICdhcnRpY2xlJyxcclxuICAgICdhc2lkZScsXHJcbiAgICAnYXVkaW8nLFxyXG4gICAgJ2InLFxyXG4gICAgJ2Jsb2NrcXVvdGUnLFxyXG4gICAgJ2JvZHknLFxyXG4gICAgJ2JyJyxcclxuICAgICdidXR0b24nLFxyXG4gICAgJ2NhbnZhcycsXHJcbiAgICAnY2FwdGlvbicsXHJcbiAgICAnY2l0ZScsXHJcbiAgICAnY29kZScsXHJcbiAgICAnY29sJyxcclxuICAgICdjb2xncm91cCcsXHJcbiAgICAnZGF0YScsXHJcbiAgICAnZGF0YWxpc3QnLFxyXG4gICAgJ2RpYWxvZycsXHJcbiAgICAnZGl2JyxcclxuICAgICdlbScsXHJcbiAgICAnZW1iZWQnLFxyXG4gICAgJ2ZpZWxkc2V0JyxcclxuICAgICdmaWdjYXB0aW9uJyxcclxuICAgICdmaWd1cmUnLFxyXG4gICAgJ2Zvb3RlcicsXHJcbiAgICAnZm9ybScsXHJcbiAgICAnaDEnLFxyXG4gICAgJ2gyJyxcclxuICAgICdoMycsXHJcbiAgICAnaDQnLFxyXG4gICAgJ2g1JyxcclxuICAgICdoNicsXHJcbiAgICAnaGVhZCcsXHJcbiAgICAnaGVhZGVyJyxcclxuICAgICdoZ3JvdXAnLFxyXG4gICAgJ2hyJyxcclxuICAgICdpJyxcclxuICAgICdpZnJhbWUnLFxyXG4gICAgJ2ltZycsXHJcbiAgICAnaW5wdXQnLFxyXG4gICAgJ2xhYmVsJyxcclxuICAgICdsZWdlbmQnLFxyXG4gICAgJ2xpJyxcclxuICAgICduYXYnLFxyXG4gICAgJ29iamVjdCcsXHJcbiAgICAnb2wnLFxyXG4gICAgJ29wdGlvbicsXHJcbiAgICAncCcsXHJcbiAgICAncGFyYW0nLFxyXG4gICAgJ3BpY3R1cmUnLFxyXG4gICAgJ3ByZScsXHJcbiAgICAncHJvZ3Jlc3MnLFxyXG4gICAgJ3EnLFxyXG4gICAgJ3NlY3Rpb24nLFxyXG4gICAgJ3NlbGVjdCcsXHJcbiAgICAnc3BhbicsXHJcbiAgICAnc3Ryb25nJyxcclxuICAgICd0YWJsZScsXHJcbiAgICAndGJvZHknLFxyXG4gICAgJ3RkJyxcclxuICAgICd0ZXh0YXJlYScsXHJcbiAgICAndGZvb3QnLFxyXG4gICAgJ3RoJyxcclxuICAgICd0aGVhZCcsXHJcbiAgICAndGltZScsXHJcbiAgICAndGl0bGUnLFxyXG4gICAgJ3RyJyxcclxuICAgICd1bCcsXHJcbiAgICAndmlkZW8nLFxyXG4gICAgJ2NpcmNsZScsXHJcbiAgICAnY2xpcFBhdGgnLFxyXG4gICAgJ2RlZnMnLFxyXG4gICAgJ2VsbGlwc2UnLFxyXG4gICAgJ2cnLFxyXG4gICAgJ2ltYWdlJyxcclxuICAgICdsaW5lJyxcclxuICAgICdsaW5lYXJHcmFkaWVudCcsXHJcbiAgICAnbWFzaycsXHJcbiAgICAncGF0aCcsXHJcbiAgICAncGF0dGVybicsXHJcbiAgICAncG9seWdvbicsXHJcbiAgICAncG9seWxpbmUnLFxyXG4gICAgJ3JhZGlhbEdyYWRpZW50JyxcclxuICAgICdyZWN0JyxcclxuICAgICdzdG9wJyxcclxuICAgICdzdmcnLFxyXG4gICAgJ3RleHQnLFxyXG4gICAgJ3RzcGFuJ1xyXG5dO1xuXG52YXIgY29tcG9uZW50Q2FjaGUgPSBuZXcgTWFwKCk7XHJcbnZhciBjcmVhdGVDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgdmFyIGNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAocG9zZUNvbmZpZykge1xyXG4gICAgICAgIGlmIChwb3NlQ29uZmlnID09PSB2b2lkIDApIHsgcG9zZUNvbmZpZyA9IHt9OyB9XHJcbiAgICAgICAgdmFyIGNvbmZpZztcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBfYiA9IF9hLndpdGhQYXJlbnQsIHdpdGhQYXJlbnQgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wid2l0aFBhcmVudFwiXSk7XHJcbiAgICAgICAgICAgIGNvbmZpZyA9XHJcbiAgICAgICAgICAgICAgICBjb25maWcgfHxcclxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHBvc2VDb25maWcgPT09ICdmdW5jdGlvbicgPyBwb3NlQ29uZmlnKHByb3BzKSA6IHBvc2VDb25maWcpO1xyXG4gICAgICAgICAgICByZXR1cm4gIXdpdGhQYXJlbnQgfHwgcHJvcHMucGFyZW50VmFsdWVzID8gKGNyZWF0ZUVsZW1lbnQoUG9zZUVsZW1lbnQsIF9fYXNzaWduKHsgcG9zZUNvbmZpZzogY29uZmlnLCBlbGVtZW50VHlwZToga2V5IH0sIHByb3BzKSkpIDogKGNyZWF0ZUVsZW1lbnQoUG9zZVBhcmVudENvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChwYXJlbnRDdHgpIHsgcmV0dXJuIChjcmVhdGVFbGVtZW50KFBvc2VFbGVtZW50LCBfX2Fzc2lnbih7IHBvc2VDb25maWc6IGNvbmZpZywgZWxlbWVudFR5cGU6IGtleSB9LCBwcm9wcywgcGFyZW50Q3R4KSkpOyB9KSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBjb21wb25lbnRDYWNoZS5zZXQoa2V5LCBjb21wb25lbnRGYWN0b3J5KTtcclxuICAgIHJldHVybiBjb21wb25lbnRGYWN0b3J5O1xyXG59O1xyXG52YXIgZ2V0Q29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiBjb21wb25lbnRDYWNoZS5oYXMoa2V5KVxyXG4gICAgICAgID8gY29tcG9uZW50Q2FjaGUuZ2V0KGtleSlcclxuICAgICAgICA6IGNyZWF0ZUNvbXBvbmVudEZhY3Rvcnkoa2V5KTtcclxufTtcclxudmFyIHBvc2VkID0gKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgIHJldHVybiBnZXRDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudCk7XHJcbn0pO1xyXG5zdXBwb3J0ZWRFbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XHJcbiAgICBhY2Nba2V5XSA9IGdldENvbXBvbmVudEZhY3Rvcnkoa2V5KTtcclxuICAgIHJldHVybiBhY2M7XHJcbn0sIHBvc2VkKTtcblxudmFyIENoaWxkcmVuJDEgPSBDaGlsZHJlbiwgY2xvbmVFbGVtZW50JDEgPSBjbG9uZUVsZW1lbnQ7XHJcbnZhciBnZXRLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLmtleTsgfTtcclxudmFyIGFuaW1hdGVDaGlsZHJlbkxpc3QgPSBmdW5jdGlvbiAoaW5jb21pbmdDaGlsZHJlbiwgcG9zZSwgaW5pdGlhbFBvc2UpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgQ2hpbGRyZW4kMS5mb3JFYWNoKGluY29taW5nQ2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5wdXNoKGNsb25lRWxlbWVudCQxKGNoaWxkLCB7IHBvc2U6IHBvc2UsIGluaXRpYWxQb3NlOiBpbml0aWFsUG9zZSB9KSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufTtcclxudmFyIG1lcmdlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBpbmNvbWluZ0NoaWxkcmVuID0gX2EuaW5jb21pbmdDaGlsZHJlbiwgZGlzcGxheWVkQ2hpbGRyZW4gPSBfYS5kaXNwbGF5ZWRDaGlsZHJlbiwgaXNMZWF2aW5nID0gX2EuaXNMZWF2aW5nLCByZW1vdmVGcm9tVHJlZSA9IF9hLnJlbW92ZUZyb21UcmVlLCBwcmVFbnRlclBvc2UgPSBfYS5wcmVFbnRlclBvc2UsIGVudGVyUG9zZSA9IF9hLmVudGVyUG9zZSwgZXhpdFBvc2UgPSBfYS5leGl0UG9zZSwgZmxpcE1vdmUgPSBfYS5mbGlwTW92ZTtcclxuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xyXG4gICAgdmFyIHByZXZLZXlzID0gZGlzcGxheWVkQ2hpbGRyZW4ubWFwKGdldEtleSk7XHJcbiAgICB2YXIgbmV4dEtleXMgPSBpbmNvbWluZ0NoaWxkcmVuLm1hcChnZXRLZXkpO1xyXG4gICAgdmFyIGVudGVyaW5nID0gbmV3IFNldChuZXh0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gaXNMZWF2aW5nLmhhcyhrZXkpIHx8IHByZXZLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7IH0pKTtcclxuICAgIGVudGVyaW5nLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gaXNMZWF2aW5nLmRlbGV0ZShrZXkpOyB9KTtcclxuICAgIHZhciBsZWF2aW5nID0gcHJldktleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gIWVudGVyaW5nLmhhcyhrZXkpICYmIChpc0xlYXZpbmcuaGFzKGtleSkgfHwgbmV4dEtleXMuaW5kZXhPZihrZXkpID09PSAtMSk7XHJcbiAgICB9KTtcclxuICAgIGxlYXZpbmcuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBpc0xlYXZpbmcuYWRkKGtleSk7IH0pO1xyXG4gICAgdmFyIG1vdmluZyA9IG5ldyBTZXQocHJldktleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXksIGkpIHtcclxuICAgICAgICB2YXIgbmV4dEluZGV4ID0gbmV4dEtleXMuaW5kZXhPZihrZXkpO1xyXG4gICAgICAgIHJldHVybiAhZW50ZXJpbmcuaGFzKGtleSkgJiYgbmV4dEluZGV4ICE9PSAtMSAmJiBpICE9PSBuZXh0SW5kZXg7XHJcbiAgICB9KSk7XHJcbiAgICBpbmNvbWluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIG5ld0NoaWxkUHJvcHMgPSBlbnRlcmluZy5oYXMoY2hpbGQua2V5KVxyXG4gICAgICAgICAgICA/IHsgaW5pdGlhbFBvc2U6IHByZUVudGVyUG9zZSwgX3Bvc2U6IGVudGVyUG9zZSB9XHJcbiAgICAgICAgICAgIDogbW92aW5nLmhhcyhjaGlsZC5rZXkpICYmIGZsaXBNb3ZlXHJcbiAgICAgICAgICAgICAgICA/IHsgX3Bvc2U6IFtlbnRlclBvc2UsICdmbGlwJ10gfVxyXG4gICAgICAgICAgICAgICAgOiB7IF9wb3NlOiBlbnRlclBvc2UgfTtcclxuICAgICAgICBjaGlsZHJlbi5wdXNoKGNsb25lRWxlbWVudCQxKGNoaWxkLCBuZXdDaGlsZFByb3BzKSk7XHJcbiAgICB9KTtcclxuICAgIGxlYXZpbmcuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gZGlzcGxheWVkQ2hpbGRyZW4uZmluZChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5rZXkgPT09IGtleTsgfSk7XHJcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gY2xvbmVFbGVtZW50JDEoY2hpbGQsIHtcclxuICAgICAgICAgICAgX3Bvc2U6IGV4aXRQb3NlLFxyXG4gICAgICAgICAgICBvblBvc2VDb21wbGV0ZTogcmVtb3ZlRnJvbVRyZWUoa2V5KSxcclxuICAgICAgICAgICAgcG9wRnJvbUZsb3c6IGZsaXBNb3ZlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGluc2VydGlvbkluZGV4ID0gcHJldktleXMuaW5kZXhPZihrZXkpO1xyXG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgbmV3Q2hpbGQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY2hpbGRyZW47XHJcbn07XHJcbnZhciBoYW5kbGVJbmNvbWluZ0NoaWxkcmVuID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICB2YXIgZGlzcGxheWVkQ2hpbGRyZW4gPSBwcm9wcy5kaXNwbGF5ZWRDaGlsZHJlbiwgaW5jb21pbmdDaGlsZHJlbiA9IHByb3BzLmluY29taW5nQ2hpbGRyZW4sIGFuaW1hdGVPbk1vdW50ID0gcHJvcHMuYW5pbWF0ZU9uTW91bnQsIHByZUVudGVyUG9zZSA9IHByb3BzLnByZUVudGVyUG9zZSwgZW50ZXJQb3NlID0gcHJvcHMuZW50ZXJQb3NlO1xyXG4gICAgaWYgKCFkaXNwbGF5ZWRDaGlsZHJlbiAmJiBhbmltYXRlT25Nb3VudCkge1xyXG4gICAgICAgIHJldHVybiBhbmltYXRlQ2hpbGRyZW5MaXN0KGluY29taW5nQ2hpbGRyZW4sIGVudGVyUG9zZSwgcHJlRW50ZXJQb3NlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRpc3BsYXllZENoaWxkcmVuKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlQ2hpbGRyZW4ocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGFuaW1hdGVDaGlsZHJlbkxpc3QoaW5jb21pbmdDaGlsZHJlbiwgZW50ZXJQb3NlKTtcclxuICAgIH1cclxufTtcclxudmFyIG1ha2VDaGlsZExpc3QgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcclxuICAgIHZhciBsaXN0ID0gW107XHJcbiAgICBDaGlsZHJlbiQxLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQgJiYgbGlzdC5wdXNoKGNoaWxkKTsgfSk7XHJcbiAgICByZXR1cm4gbGlzdDtcclxufTtcclxudmFyIHJlbW92ZUZyb21DaGlsZHJlbiA9IGZ1bmN0aW9uIChjaGlsZHJlbiwga2V5KSB7IHJldHVybiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5rZXkgIT09IGtleTsgfSk7IH07XG5cbnZhciBQb3NlR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBvc2VHcm91cCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBvc2VHcm91cCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgaW5jb21pbmdDaGlsZHJlbjogW10sXHJcbiAgICAgICAgICAgIGlzTGVhdmluZzogbmV3IFNldCgpLFxyXG4gICAgICAgICAgICByZW1vdmVGcm9tVHJlZTogZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzTGVhdmluZyA9IF90aGlzLnN0YXRlLmlzTGVhdmluZztcclxuICAgICAgICAgICAgICAgIGlzTGVhdmluZy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUZyb21DaGlsZHJlbihrZXkpO1xyXG4gICAgICAgICAgICB9OyB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBQb3NlR3JvdXAucHJvdG90eXBlLnJlbW92ZUZyb21DaGlsZHJlbiA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnN0YXRlLmNoaWxkcmVuO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBjaGlsZHJlbjogcmVtb3ZlRnJvbUNoaWxkcmVuKGNoaWxkcmVuLCBrZXkpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9zZUdyb3VwLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSAhPT0gbmV4dFN0YXRlO1xyXG4gICAgfTtcclxuICAgIFBvc2VHcm91cC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCB0aGlzLnN0YXRlLmNoaWxkcmVuKTtcclxuICAgIH07XHJcbiAgICBQb3NlR3JvdXAuZGVmYXVsdFByb3BzID0ge1xyXG4gICAgICAgIGZsaXBNb3ZlOiB0cnVlLFxyXG4gICAgICAgIHByZUVudGVyUG9zZTogJ2V4aXQnLFxyXG4gICAgICAgIGVudGVyUG9zZTogJ2VudGVyJyxcclxuICAgICAgICBleGl0UG9zZTogJ2V4aXQnLFxyXG4gICAgICAgIHNpbmdsZUNoaWxkT25seTogZmFsc2VcclxuICAgIH07XHJcbiAgICBQb3NlR3JvdXAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gKHByb3BzLCBfYSkge1xyXG4gICAgICAgIHZhciBpc0xlYXZpbmcgPSBfYS5pc0xlYXZpbmcsIHJlbW92ZUZyb21UcmVlID0gX2EucmVtb3ZlRnJvbVRyZWUsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGluY29taW5nQ2hpbGRyZW4gPSBtYWtlQ2hpbGRMaXN0KHByb3BzLmNoaWxkcmVuKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbmNvbWluZ0NoaWxkcmVuOiBpbmNvbWluZ0NoaWxkcmVuLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogaGFuZGxlSW5jb21pbmdDaGlsZHJlbih7XHJcbiAgICAgICAgICAgICAgICBpbmNvbWluZ0NoaWxkcmVuOiBpbmNvbWluZ0NoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheWVkQ2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgaXNMZWF2aW5nOiBpc0xlYXZpbmcsXHJcbiAgICAgICAgICAgICAgICByZW1vdmVGcm9tVHJlZTogcmVtb3ZlRnJvbVRyZWUsXHJcbiAgICAgICAgICAgICAgICBlbnRlclBvc2U6IHByb3BzLmVudGVyUG9zZSxcclxuICAgICAgICAgICAgICAgIGV4aXRQb3NlOiBwcm9wcy5leGl0UG9zZSxcclxuICAgICAgICAgICAgICAgIGZsaXBNb3ZlOiBwcm9wcy5mbGlwTW92ZSxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGVPbk1vdW50OiBwcm9wcy5hbmltYXRlT25Nb3VudCxcclxuICAgICAgICAgICAgICAgIHByZUVudGVyUG9zZTogcHJvcHMucHJlRW50ZXJQb3NlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9zZUdyb3VwO1xyXG59KENvbXBvbmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBwb3NlZDtcbmV4cG9ydCB7IFBvc2VHcm91cCB9O1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi41LjBcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi41LjAnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfUExBQ0VIT0xERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBsYWNlaG9sZGVyJykgOiAweGVhZDE7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIFJlbHlpbmcgb24gdGhlIGBpbnZhcmlhbnQoKWAgaW1wbGVtZW50YXRpb24gbGV0cyB1c1xuLy8gcHJlc2VydmUgdGhlIGZvcm1hdCBhbmQgcGFyYW1zIGluIHRoZSB3d3cgYnVpbGRzLlxuXG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcblxuXG4vLyBFeHBlcmltZW50YWwgZXJyb3ItYm91bmRhcnkgQVBJIHRoYXQgY2FuIHJlY292ZXIgZnJvbSBlcnJvcnMgd2l0aGluIGEgc2luZ2xlXG4vLyByZW5kZXIgcGhhc2VcblxuLy8gU3VzcGVuc2VcbnZhciBlbmFibGVTdXNwZW5zZSA9IGZhbHNlO1xuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG5cblxuLy8gSW4gc29tZSBjYXNlcywgU3RyaWN0TW9kZSBzaG91bGQgYWxzbyBkb3VibGUtcmVuZGVyIGxpZmVjeWNsZXMuXG4vLyBUaGlzIGNhbiBiZSBjb25mdXNpbmcgZm9yIHRlc3RzIHRob3VnaCxcbi8vIEFuZCBpdCBjYW4gYmUgYmFkIGZvciBwZXJmb3JtYW5jZSBpbiBwcm9kdWN0aW9uLlxuLy8gVGhpcyBmZWF0dXJlIGZsYWcgY2FuIGJlIHVzZWQgdG8gY29udHJvbCB0aGUgYmVoYXZpb3I6XG5cblxuLy8gVG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgZGVidWdnZXIsIHdlXG4vLyByZXBsYXkgdGhlIGJlZ2luIHBoYXNlIG9mIGEgZmFpbGVkIGNvbXBvbmVudCBpbnNpZGUgaW52b2tlR3VhcmRlZENhbGxiYWNrLlxuXG5cbi8vIFdhcm4gYWJvdXQgZGVwcmVjYXRlZCwgYXN5bmMtdW5zYWZlIGxpZmVjeWNsZXM7IHJlbGF0ZXMgdG8gUkZDICM2OlxuXG5cbi8vIFdhcm4gYWJvdXQgbGVnYWN5IGNvbnRleHQgQVBJXG5cblxuLy8gR2F0aGVyIGFkdmFuY2VkIHRpbWluZyBtZXRyaWNzIGZvciBQcm9maWxlciBzdWJ0cmVlcy5cblxuXG4vLyBUcmFjayB3aGljaCBpbnRlcmFjdGlvbnMgdHJpZ2dlciBlYWNoIGNvbW1pdC5cblxuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93UHJpb3JpdHlXYXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZ1dpdGhvdXRTdGFjayhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICAgIHZhciBzdHJpbmdBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICAgIH0pO1xuICAgICAgKF9jb25zb2xlID0gY29uc29sZSkuZXJyb3IuYXBwbHkoX2NvbnNvbGUsIFsnV2FybmluZzogJyArIGZvcm1hdF0uY29uY2F0KHN0cmluZ0FyZ3MpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxudmFyIHdhcm5pbmdXaXRob3V0U3RhY2skMSA9IHdhcm5pbmdXaXRob3V0U3RhY2s7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuXG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsLFxuICBjdXJyZW50RGlzcGF0Y2hlcjogbnVsbFxufTtcblxudmFyIEJFRk9SRV9TTEFTSF9SRSA9IC9eKC4qKVtcXFxcXFwvXS87XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHZhciBzb3VyY2VJbmZvID0gJyc7XG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgcGF0aCA9IHNvdXJjZS5maWxlTmFtZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBwYXRoLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCAnJyk7XG4gICAge1xuICAgICAgLy8gSW4gREVWLCBpbmNsdWRlIGNvZGUgZm9yIGEgY29tbW9uIHNwZWNpYWwgY2FzZTpcbiAgICAgIC8vIHByZWZlciBcImZvbGRlci9pbmRleC5qc1wiIGluc3RlYWQgb2YganVzdCBcImluZGV4LmpzXCIuXG4gICAgICBpZiAoL15pbmRleFxcLi8udGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcGF0aC5tYXRjaChCRUZPUkVfU0xBU0hfUkUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YXIgcGF0aEJlZm9yZVNsYXNoID0gbWF0Y2hbMV07XG4gICAgICAgICAgaWYgKHBhdGhCZWZvcmVTbGFzaCkge1xuICAgICAgICAgICAgdmFyIGZvbGRlck5hbWUgPSBwYXRoQmVmb3JlU2xhc2gucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gZm9sZGVyTmFtZSArICcvJyArIGZpbGVOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VJbmZvID0gJyAoYXQgJyArIGZpbGVOYW1lICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKSc7XG4gIH0gZWxzZSBpZiAob3duZXJOYW1lKSB7XG4gICAgc291cmNlSW5mbyA9ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJztcbiAgfVxuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIHNvdXJjZUluZm87XG59O1xuXG52YXIgUmVzb2x2ZWQgPSAxO1xuXG5cblxuXG5mdW5jdGlvbiByZWZpbmVSZXNvbHZlZFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIHJldHVybiB0aGVuYWJsZS5fcmVhY3RTdGF0dXMgPT09IFJlc29sdmVkID8gdGhlbmFibGUuX3JlYWN0UmVzdWx0IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnQXN5bmNNb2RlJztcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgY2FzZSBSRUFDVF9QTEFDRUhPTERFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQbGFjZWhvbGRlcic7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Db25zdW1lcic7XG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Qcm92aWRlcic7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHZhciByZW5kZXJGbiA9IHR5cGUucmVuZGVyO1xuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gcmVuZGVyRm4uZGlzcGxheU5hbWUgfHwgcmVuZGVyRm4ubmFtZSB8fCAnJztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyAnRm9yd2FyZFJlZignICsgZnVuY3Rpb25OYW1lICsgJyknIDogJ0ZvcndhcmRSZWYnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHR5cGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRoZW5hYmxlID0gdHlwZTtcbiAgICAgIHZhciByZXNvbHZlZFRoZW5hYmxlID0gcmVmaW5lUmVzb2x2ZWRUaGVuYWJsZSh0aGVuYWJsZSk7XG4gICAgICBpZiAocmVzb2x2ZWRUaGVuYWJsZSkge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShyZXNvbHZlZFRoZW5hYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbnZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgfVxufVxuXG57XG4gIC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuXG4gICAgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50LnR5cGUpO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX293bmVyO1xuICAgICAgc3RhY2sgKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpKTtcbiAgICB9XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIF9hc3NpZ24oUmVhY3RTaGFyZWRJbnRlcm5hbHMsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IHdhcm5pbmdXaXRob3V0U3RhY2skMTtcblxue1xuICB3YXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3dhcm5pbmctYW5kLWludmFyaWFudC1hcmdzXG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMS5hcHBseSh1bmRlZmluZWQsIFtmYWxzZSwgZm9ybWF0ICsgJyVzJ10uY29uY2F0KGFyZ3MsIFtzdGFja10pKTtcbiAgfTtcbn1cblxudmFyIHdhcm5pbmckMSA9IHdhcm5pbmc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHZvaWQgMDtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHZvaWQgMDtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVmYWN0b3J5XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICAhIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCAlcy4nLCBlbGVtZW50KSA6IHZvaWQgMDtcblxuICB2YXIgcHJvcE5hbWUgPSB2b2lkIDA7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB2b2lkIDA7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG52YXIgUE9PTF9TSVpFID0gMTA7XG52YXIgdHJhdmVyc2VDb250ZXh0UG9vbCA9IFtdO1xuZnVuY3Rpb24gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gdHJhdmVyc2VDb250ZXh0UG9vbC5wb3AoKTtcbiAgICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbWFwUmVzdWx0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgICByZXR1cm4gdHJhdmVyc2VDb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IG1hcFJlc3VsdCxcbiAgICAgIGtleVByZWZpeDoga2V5UHJlZml4LFxuICAgICAgZnVuYzogbWFwRnVuY3Rpb24sXG4gICAgICBjb250ZXh0OiBtYXBDb250ZXh0LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KSB7XG4gIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQgPSB2b2lkIDA7XG4gIHZhciBuZXh0TmFtZSA9IHZvaWQgMDtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgICFkaWRXYXJuQWJvdXRNYXBzID8gd2FybmluZyQxKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50RGlzcGF0Y2hlcjtcbiAgIShkaXNwYXRjaGVyICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NvbnRleHQudW5zdGFibGVfcmVhZCgpOiBDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLCBlLmcuIGluc2lkZSB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJykgOiB2b2lkIDA7XG4gIHJldHVybiBkaXNwYXRjaGVyLnJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICAhKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSBudWxsIHx8IHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbCxcbiAgICB1bnN0YWJsZV9yZWFkOiBudWxsXG4gIH07XG5cbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICBjb250ZXh0LkNvbnN1bWVyID0gY29udGV4dDtcbiAgY29udGV4dC51bnN0YWJsZV9yZWFkID0gcmVhZENvbnRleHQuYmluZChudWxsLCBjb250ZXh0KTtcblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHRoZW5hYmxlID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAodGhlbmFibGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gTGF6aWx5IGNyZWF0ZSB0aGVuYWJsZSBieSB3cmFwcGluZyBpbiBhbiBleHRyYSB0aGVuYWJsZS5cbiAgICAgICAgdGhlbmFibGUgPSBjdG9yKCk7XG4gICAgICAgIGN0b3IgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoZW5hYmxlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LFxuXG4gICAgLy8gUmVhY3QgdXNlcyB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfcmVhY3RTdGF0dXM6IC0xLFxuICAgIF9yZWFjdFJlc3VsdDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIShyZW5kZXIubGVuZ3RoID09PSAyKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICcgKyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgIShyZW5kZXIuZGVmYXVsdFByb3BzID09IG51bGwgJiYgcmVuZGVyLnByb3BUeXBlcyA9PSBudWxsKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/JykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gIC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QTEFDRUhPTERFUl9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlb2YgdHlwZS50aGVuID09PSAnZnVuY3Rpb24nIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArICcuJztcbiAgfVxuXG4gIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcbiAgfVxuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcCA9IHZvaWQgMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIG5hbWUgPSB2b2lkIDAsXG4gICAgICBwcm9wVHlwZXMgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIENsYXNzIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgbmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAvLyBGb3J3YXJkUmVmXG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgbmFtZSA9IGZ1bmN0aW9uTmFtZSAhPT0gJycgPyAnRm9yd2FyZFJlZignICsgZnVuY3Rpb25OYW1lICsgJyknIDogJ0ZvcndhcmRSZWYnO1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvcFR5cGVzKSB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSk7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgbmFtZSB8fCAnVW5rbm93bicpO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG4gIH1cblxuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpO1xuXG4gIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHByb3BzKTtcbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nID0gdm9pZCAwO1xuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJzwnICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgJyAvPic7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcbiAgLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuICBDaGlsZHJlbjoge1xuICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgY3JlYXRlUmVmOiBjcmVhdGVSZWYsXG4gIENvbXBvbmVudDogQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXG4gIGZvcndhcmRSZWY6IGZvcndhcmRSZWYsXG5cbiAgRnJhZ21lbnQ6IFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG4gIFN0cmljdE1vZGU6IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUsXG4gIHVuc3RhYmxlX0FzeW5jTW9kZTogUkVBQ1RfQVNZTkNfTU9ERV9UWVBFLFxuICB1bnN0YWJsZV9Qcm9maWxlcjogUkVBQ1RfUFJPRklMRVJfVFlQRSxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbixcbiAgaXNWYWxpZEVsZW1lbnQ6IGlzVmFsaWRFbGVtZW50LFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDogUmVhY3RTaGFyZWRJbnRlcm5hbHNcbn07XG5cbmlmIChlbmFibGVTdXNwZW5zZSkge1xuICBSZWFjdC5QbGFjZWhvbGRlciA9IFJFQUNUX1BMQUNFSE9MREVSX1RZUEU7XG4gIFJlYWN0LmxhenkgPSBsYXp5O1xufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0ID0gUmVhY3QkMy5kZWZhdWx0IHx8IFJlYWN0JDM7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3Q7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuNS4wXG4gKiBzY2hlZHVsZS10cmFja2luZy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG57XG4gIFxufVxuXG4vLyBSZWx5aW5nIG9uIHRoZSBgaW52YXJpYW50KClgIGltcGxlbWVudGF0aW9uIGxldHMgdXNcbi8vIHByZXNlcnZlIHRoZSBmb3JtYXQgYW5kIHBhcmFtcyBpbiB0aGUgd3d3IGJ1aWxkcy5cblxuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG5cblxuLy8gRXhwZXJpbWVudGFsIGVycm9yLWJvdW5kYXJ5IEFQSSB0aGF0IGNhbiByZWNvdmVyIGZyb20gZXJyb3JzIHdpdGhpbiBhIHNpbmdsZVxuLy8gcmVuZGVyIHBoYXNlXG5cbi8vIFN1c3BlbnNlXG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxuXG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuXG5cbi8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cblxuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcblxuXG4vLyBXYXJuIGFib3V0IGxlZ2FjeSBjb250ZXh0IEFQSVxuXG5cbi8vIEdhdGhlciBhZHZhbmNlZCB0aW1pbmcgbWV0cmljcyBmb3IgUHJvZmlsZXIgc3VidHJlZXMuXG5cblxuLy8gVHJhY2sgd2hpY2ggaW50ZXJhY3Rpb25zIHRyaWdnZXIgZWFjaCBjb21taXQuXG52YXIgZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcgPSB0cnVlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxudmFyIERFRkFVTFRfVEhSRUFEX0lEID0gMDtcblxuLy8gQ291bnRlcnMgdXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLlxudmFyIGludGVyYWN0aW9uSURDb3VudGVyID0gMDtcbnZhciB0aHJlYWRJRENvdW50ZXIgPSAwO1xuXG4vLyBTZXQgb2YgY3VycmVudGx5IHRyYWNrZWQgaW50ZXJhY3Rpb25zLlxuLy8gSW50ZXJhY3Rpb25zIFwic3RhY2tcIuKAk1xuLy8gTWVhbmluZyB0aGF0IG5ld2x5IHRyYWNrZWQgaW50ZXJhY3Rpb25zIGFyZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXNseSBhY3RpdmUgc2V0LlxuLy8gV2hlbiBhbiBpbnRlcmFjdGlvbiBnb2VzIG91dCBvZiBzY29wZSwgdGhlIHByZXZpb3VzIHNldCAoaWYgYW55KSBpcyByZXN0b3JlZC5cbmV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYgPSBudWxsO1xuXG4vLyBMaXN0ZW5lcihzKSB0byBub3RpZnkgd2hlbiBpbnRlcmFjdGlvbnMgYmVnaW4gYW5kIGVuZC5cbmV4cG9ydHMuX19zdWJzY3JpYmVyUmVmID0gbnVsbDtcblxuaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNraW5nKSB7XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYgPSB7XG4gICAgY3VycmVudDogbmV3IFNldCgpXG4gIH07XG4gIGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY2xlYXIoY2FsbGJhY2spIHtcbiAgaWYgKCFlbmFibGVTY2hlZHVsZXJUcmFja2luZykge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IG5ldyBTZXQoKTtcblxuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudCgpIHtcbiAgaWYgKCFlbmFibGVTY2hlZHVsZXJUcmFja2luZykge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0VGhyZWFkSUQoKSB7XG4gIHJldHVybiArK3RocmVhZElEQ291bnRlcjtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfdHJhY2sobmFtZSwgdGltZXN0YW1wLCBjYWxsYmFjaykge1xuICB2YXIgdGhyZWFkSUQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IERFRkFVTFRfVEhSRUFEX0lEO1xuXG4gIGlmICghZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIHZhciBpbnRlcmFjdGlvbiA9IHtcbiAgICBfX2NvdW50OiAxLFxuICAgIGlkOiBpbnRlcmFjdGlvbklEQ291bnRlcisrLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgfTtcblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcblxuICAvLyBUcmFja2VkIGludGVyYWN0aW9ucyBzaG91bGQgc3RhY2svYWNjdW11bGF0ZS5cbiAgLy8gVG8gZG8gdGhhdCwgY2xvbmUgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb25zLlxuICAvLyBUaGUgcHJldmlvdXMgc2V0IHdpbGwgYmUgcmVzdG9yZWQgdXBvbiBjb21wbGV0aW9uLlxuICB2YXIgaW50ZXJhY3Rpb25zID0gbmV3IFNldChwcmV2SW50ZXJhY3Rpb25zKTtcbiAgaW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IGludGVyYWN0aW9ucztcblxuICB2YXIgc3Vic2NyaWJlciA9IGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG4gIHZhciByZXR1cm5WYWx1ZSA9IHZvaWQgMDtcblxuICB0cnkge1xuICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25UcmFja2VkKGludGVyYWN0aW9uKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICAgIC8vIElmIG5vIGFzeW5jIHdvcmsgd2FzIHNjaGVkdWxlZCBmb3IgdGhpcyBpbnRlcmFjdGlvbixcbiAgICAgICAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCBpdCdzIGNvbXBsZXRlZC5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXAoY2FsbGJhY2spIHtcbiAgdmFyIHRocmVhZElEID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX1RIUkVBRF9JRDtcblxuICBpZiAoIWVuYWJsZVNjaGVkdWxlclRyYWNraW5nKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHdyYXBwZWRJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG5cbiAgdmFyIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgIHN1YnNjcmliZXIub25Xb3JrU2NoZWR1bGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFVwZGF0ZSBhZnRlciBjYWxsaW5nIHN1YnNjcmliZXJzIGluIGNhc2Ugb2YgZXJyb3IuXG4gIHdyYXBwZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gIH0pO1xuXG4gIHZhciBoYXNSdW4gPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3cmFwcGVkKCkge1xuICAgIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHdyYXBwZWRJbnRlcmFjdGlvbnM7XG5cbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCFoYXNSdW4pIHtcbiAgICAgICAgLy8gV2Ugb25seSBleHBlY3QgYSB3cmFwcGVkIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UsXG4gICAgICAgIC8vIEJ1dCBpbiB0aGUgZXZlbnQgdGhhdCBpdCdzIGV4ZWN1dGVkIG1vcmUgdGhhbiBvbmNl4oCTXG4gICAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBvdXRzdGFuZGluZyBpbnRlcmFjdGlvbiBjb3VudHMgb25jZS5cbiAgICAgICAgaGFzUnVuID0gdHJ1ZTtcblxuICAgICAgICAvLyBVcGRhdGUgcGVuZGluZyBhc3luYyBjb3VudHMgZm9yIGFsbCB3cmFwcGVkIGludGVyYWN0aW9ucy5cbiAgICAgICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3Qgc2NoZWR1bGVkIGFzeW5jIHdvcmsgZm9yIGFueSBvZiB0aGVtLFxuICAgICAgICAvLyBNYXJrIHRoZW0gYXMgY29tcGxldGVkLlxuICAgICAgICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3cmFwcGVkLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya0NhbmNlbGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gVXBkYXRlIHBlbmRpbmcgYXN5bmMgY291bnRzIGZvciBhbGwgd3JhcHBlZCBpbnRlcmFjdGlvbnMuXG4gICAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBzY2hlZHVsZWQgYXN5bmMgd29yayBmb3IgYW55IG9mIHRoZW0sXG4gICAgICAvLyBNYXJrIHRoZW0gYXMgY29tcGxldGVkLlxuICAgICAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgaWYgKHN1YnNjcmliZXIgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbnZhciBzdWJzY3JpYmVycyA9IG51bGw7XG5pZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcpIHtcbiAgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3N1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFja2luZykge1xuICAgIHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcblxuICAgIGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG4gICAgICBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50ID0ge1xuICAgICAgICBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZDogb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQsXG4gICAgICAgIG9uSW50ZXJhY3Rpb25UcmFja2VkOiBvbkludGVyYWN0aW9uVHJhY2tlZCxcbiAgICAgICAgb25Xb3JrQ2FuY2VsZWQ6IG9uV29ya0NhbmNlbGVkLFxuICAgICAgICBvbldvcmtTY2hlZHVsZWQ6IG9uV29ya1NjaGVkdWxlZCxcbiAgICAgICAgb25Xb3JrU3RhcnRlZDogb25Xb3JrU3RhcnRlZCxcbiAgICAgICAgb25Xb3JrU3RvcHBlZDogb25Xb3JrU3RvcHBlZFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2tpbmcpIHtcbiAgICBzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSW50ZXJhY3Rpb25UcmFja2VkKGludGVyYWN0aW9uKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25UcmFja2VkKGludGVyYWN0aW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbikge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU2NoZWR1bGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU2NoZWR1bGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya0NhbmNlbGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrQ2FuY2VsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0cy51bnN0YWJsZV9jbGVhciA9IHVuc3RhYmxlX2NsZWFyO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50ID0gdW5zdGFibGVfZ2V0Q3VycmVudDtcbmV4cG9ydHMudW5zdGFibGVfZ2V0VGhyZWFkSUQgPSB1bnN0YWJsZV9nZXRUaHJlYWRJRDtcbmV4cG9ydHMudW5zdGFibGVfdHJhY2sgPSB1bnN0YWJsZV90cmFjaztcbmV4cG9ydHMudW5zdGFibGVfd3JhcCA9IHVuc3RhYmxlX3dyYXA7XG5leHBvcnRzLnVuc3RhYmxlX3N1YnNjcmliZSA9IHVuc3RhYmxlX3N1YnNjcmliZTtcbmV4cG9ydHMudW5zdGFibGVfdW5zdWJzY3JpYmUgPSB1bnN0YWJsZV91bnN1YnNjcmliZTtcbiAgfSkoKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuNS4wXG4gKiBzY2hlZHVsZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBBIHNjaGVkdWxpbmcgbGlicmFyeSB0byBhbGxvdyBzY2hlZHVsaW5nIHdvcmsgd2l0aCBtb3JlIGdyYW51bGFyIHByaW9yaXR5IGFuZFxuICogY29udHJvbCB0aGFuIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhbmQgcmVxdWVzdElkbGVDYWxsYmFjay5cbiAqIEN1cnJlbnQgVE9ETyBpdGVtczpcbiAqIFgtIFB1bGwgb3V0IHRoZSBzY2hlZHVsZVdvcmsgcG9seWZpbGwgYnVpbHQgaW50byBSZWFjdFxuICogWC0gSW5pdGlhbCB0ZXN0IGNvdmVyYWdlXG4gKiBYLSBTdXBwb3J0IGZvciBtdWx0aXBsZSBjYWxsYmFja3NcbiAqIC0gU3VwcG9ydCBmb3IgdHdvIHByaW9yaXRpZXM7IHNlcmlhbCBhbmQgZGVmZXJyZWRcbiAqIC0gQmV0dGVyIHRlc3QgY292ZXJhZ2VcbiAqIC0gQmV0dGVyIGRvY2Jsb2NrXG4gKiAtIFBvbGlzaCBkb2N1bWVudGF0aW9uLCBBUElcbiAqL1xuXG4vLyBUaGlzIGlzIGEgYnVpbHQtaW4gcG9seWZpbGwgZm9yIHJlcXVlc3RJZGxlQ2FsbGJhY2suIEl0IHdvcmtzIGJ5IHNjaGVkdWxpbmdcbi8vIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBzdG9yaW5nIHRoZSB0aW1lIGZvciB0aGUgc3RhcnQgb2YgdGhlIGZyYW1lLCB0aGVuXG4vLyBzY2hlZHVsaW5nIGEgcG9zdE1lc3NhZ2Ugd2hpY2ggZ2V0cyBzY2hlZHVsZWQgYWZ0ZXIgcGFpbnQuIFdpdGhpbiB0aGVcbi8vIHBvc3RNZXNzYWdlIGhhbmRsZXIgZG8gYXMgbXVjaCB3b3JrIGFzIHBvc3NpYmxlIHVudGlsIHRpbWUgKyBmcmFtZSByYXRlLlxuLy8gQnkgc2VwYXJhdGluZyB0aGUgaWRsZSBjYWxsIGludG8gYSBzZXBhcmF0ZSBldmVudCB0aWNrIHdlIGVuc3VyZSB0aGF0XG4vLyBsYXlvdXQsIHBhaW50IGFuZCBvdGhlciBicm93c2VyIHdvcmsgaXMgY291bnRlZCBhZ2FpbnN0IHRoZSBhdmFpbGFibGUgdGltZS5cbi8vIFRoZSBmcmFtZSByYXRlIGlzIGR5bmFtaWNhbGx5IGFkanVzdGVkLlxuXG4vLyBXZSBjYXB0dXJlIGEgbG9jYWwgcmVmZXJlbmNlIHRvIGFueSBnbG9iYWwsIGluIGNhc2UgaXQgZ2V0cyBwb2x5ZmlsbGVkIGFmdGVyXG4vLyB0aGlzIG1vZHVsZSBpcyBpbml0aWFsbHkgZXZhbHVhdGVkLlxuLy8gV2Ugd2FudCB0byBiZSB1c2luZyBhIGNvbnNpc3RlbnQgaW1wbGVtZW50YXRpb24uXG52YXIgbG9jYWxEYXRlID0gRGF0ZTtcblxuLy8gVGhpcyBpbml0aWFsaXphdGlvbiBjb2RlIG1heSBydW4gZXZlbiBvbiBzZXJ2ZXIgZW52aXJvbm1lbnRzXG4vLyBpZiBhIGNvbXBvbmVudCBqdXN0IGltcG9ydHMgUmVhY3RET00gKGUuZy4gZm9yIGZpbmRET01Ob2RlKS5cbi8vIFNvbWUgZW52aXJvbm1lbnRzIG1pZ2h0IG5vdCBoYXZlIHNldFRpbWVvdXQgb3IgY2xlYXJUaW1lb3V0LlxuLy8gSG93ZXZlciwgd2UgYWx3YXlzIGV4cGVjdCB0aGVtIHRvIGJlIGRlZmluZWQgb24gdGhlIGNsaWVudC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMDg4XG52YXIgbG9jYWxTZXRUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkO1xudmFyIGxvY2FsQ2xlYXJUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZDtcblxuLy8gV2UgZG9uJ3QgZXhwZWN0IGVpdGhlciBvZiB0aGVzZSB0byBuZWNlc3NhcmlseSBiZSBkZWZpbmVkLFxuLy8gYnV0IHdlIHdpbGwgZXJyb3IgbGF0ZXIgaWYgdGhleSBhcmUgbWlzc2luZyBvbiB0aGUgY2xpZW50LlxudmFyIGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHVuZGVmaW5lZDtcbnZhciBsb2NhbENhbmNlbEFuaW1hdGlvbkZyYW1lID0gdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nID8gY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiB1bmRlZmluZWQ7XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxuZXhwb3J0cy51bnN0YWJsZV9ub3cgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCk7XG4gIH07XG59XG5cbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVXb3JrID0gdm9pZCAwO1xuZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxTY2hlZHVsZWRXb3JrID0gdm9pZCAwO1xuXG5pZiAoIWNhblVzZURPTSkge1xuICB2YXIgdGltZW91dElkcyA9IG5ldyBNYXAoKTtcblxuICBleHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlV29yayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8vIGtlZXBpbmcgcmV0dXJuIHR5cGUgY29uc2lzdGVudFxuICAgIHZhciBjYWxsYmFja0NvbmZpZyA9IHtcbiAgICAgIHNjaGVkdWxlZENhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIHRpbWVvdXRUaW1lOiAwLFxuICAgICAgbmV4dDogbnVsbCxcbiAgICAgIHByZXY6IG51bGxcbiAgICB9O1xuICAgIHZhciB0aW1lb3V0SWQgPSBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aW1lb3V0SWRzLnNldChjYWxsYmFjaywgdGltZW91dElkKTtcbiAgICByZXR1cm4gY2FsbGJhY2tDb25maWc7XG4gIH07XG4gIGV4cG9ydHMudW5zdGFibGVfY2FuY2VsU2NoZWR1bGVkV29yayA9IGZ1bmN0aW9uIChjYWxsYmFja0lkKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tJZC5zY2hlZHVsZWRDYWxsYmFjaztcbiAgICB2YXIgdGltZW91dElkID0gdGltZW91dElkcy5nZXQoY2FsbGJhY2spO1xuICAgIHRpbWVvdXRJZHMuZGVsZXRlKGNhbGxiYWNrSWQpO1xuICAgIGxvY2FsQ2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH07XG59IGVsc2Uge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiBsb2NhbFJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFwiICsgJ01ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbG9jYWxDYW5jZWxBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxBbmltYXRpb25GcmFtZS4gXCIgKyAnTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9IG51bGw7XG4gIHZhciB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9IG51bGw7XG5cbiAgLy8gV2UgdHJhY2sgd2hhdCB0aGUgbmV4dCBzb29uZXN0IHRpbWVvdXRUaW1lIGlzLCB0byBiZSBhYmxlIHRvIHF1aWNrbHkgdGVsbFxuICAvLyBpZiBub25lIG9mIHRoZSBzY2hlZHVsZWQgY2FsbGJhY2tzIGhhdmUgdGltZWQgb3V0LlxuICB2YXIgbmV4dFNvb25lc3RUaW1lb3V0VGltZSA9IC0xO1xuXG4gIHZhciBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZG9lcyBub3QgcnVuIHdoZW4gdGhlIHRhYiBpcyBpbiB0aGUgYmFja2dyb3VuZC5cbiAgLy8gaWYgd2UncmUgYmFja2dyb3VuZGVkIHdlIHByZWZlciBmb3IgdGhhdCB3b3JrIHRvIGhhcHBlbiBzbyB0aGF0IHRoZSBwYWdlXG4gIC8vIGNvbnRpbnVlc1x0dG8gbG9hZCBpbiB0aGUgYmFja2dyb3VuZC5cbiAgLy8gc28gd2UgYWxzbyBzY2hlZHVsZSBhICdzZXRUaW1lb3V0JyBhcyBhIGZhbGxiYWNrLlxuICB2YXIgYW5pbWF0aW9uRnJhbWVUaW1lb3V0ID0gMTAwO1xuICB2YXIgcmFmSUQgPSB2b2lkIDA7XG4gIHZhciB0aW1lb3V0SUQgPSB2b2lkIDA7XG4gIHZhciBzY2hlZHVsZUFuaW1hdGlvbkZyYW1lV2l0aEZhbGxiYWNrU3VwcG9ydCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIHNjaGVkdWxlIHJBRiBhbmQgYWxzbyBhIHNldFRpbWVvdXRcbiAgICByYWZJRCA9IGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgIC8vIGNhbmNlbCB0aGUgc2V0VGltZW91dFxuICAgICAgbG9jYWxDbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gICAgfSk7XG4gICAgdGltZW91dElEID0gbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNhbmNlbCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICBsb2NhbENhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklEKTtcbiAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgIH0sIGFuaW1hdGlvbkZyYW1lVGltZW91dCk7XG4gIH07XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmUgPSAwO1xuICAvLyBXZSBzdGFydCBvdXQgYXNzdW1pbmcgdGhhdCB3ZSBydW4gYXQgMzBmcHMgYnV0IHRoZW4gdGhlIGhldXJpc3RpYyB0cmFja2luZ1xuICAvLyB3aWxsIGFkanVzdCB0aGlzIHZhbHVlIHRvIGEgZmFzdGVyIGZwcyBpZiB3ZSBnZXQgbW9yZSBmcmVxdWVudCBhbmltYXRpb25cbiAgLy8gZnJhbWVzLlxuICB2YXIgcHJldmlvdXNGcmFtZVRpbWUgPSAzMztcbiAgdmFyIGFjdGl2ZUZyYW1lVGltZSA9IDMzO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgIHJldHVybiByZW1haW5pbmcgPiAwID8gcmVtYWluaW5nIDogMDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSBjYWxsYmFjayBlcnJvcnM6XG4gICAqIC0gZG9uJ3QgY2F0Y2ggdGhlIGVycm9yLCBiZWNhdXNlIHRoaXMgY2hhbmdlcyBkZWJ1Z2dpbmcgYmVoYXZpb3JcbiAgICogLSBkbyBzdGFydCBhIG5ldyBwb3N0TWVzc2FnZSBjYWxsYmFjaywgdG8gY2FsbCBhbnkgcmVtYWluaW5nIGNhbGxiYWNrcyxcbiAgICogLSBidXQgb25seSBpZiB0aGVyZSBpcyBhbiBlcnJvciwgc28gdGhlcmUgaXMgbm90IGV4dHJhIG92ZXJoZWFkLlxuICAgKi9cbiAgdmFyIGNhbGxVbnNhZmVseSA9IGZ1bmN0aW9uIChjYWxsYmFja0NvbmZpZywgYXJnKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tDb25maWcuc2NoZWR1bGVkQ2FsbGJhY2s7XG4gICAgdmFyIGZpbmlzaGVkQ2FsbGluZyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjayhhcmcpO1xuICAgICAgZmluaXNoZWRDYWxsaW5nID0gdHJ1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gYWx3YXlzIHJlbW92ZSBpdCBmcm9tIGxpbmtlZCBsaXN0XG4gICAgICBleHBvcnRzLnVuc3RhYmxlX2NhbmNlbFNjaGVkdWxlZFdvcmsoY2FsbGJhY2tDb25maWcpO1xuXG4gICAgICBpZiAoIWZpbmlzaGVkQ2FsbGluZykge1xuICAgICAgICAvLyBhbiBlcnJvciBtdXN0IGhhdmUgYmVlbiB0aHJvd25cbiAgICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VLZXksICcqJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgZm9yIHRpbWVkIG91dCBjYWxsYmFja3MsIHJ1bnMgdGhlbSwgYW5kIHRoZW4gY2hlY2tzIGFnYWluIHRvIHNlZSBpZlxuICAgKiBhbnkgbW9yZSBoYXZlIHRpbWVkIG91dC5cbiAgICogS2VlcHMgZG9pbmcgdGhpcyB1bnRpbCB0aGVyZSBhcmUgbm9uZSB3aGljaCBoYXZlIGN1cnJlbnRseSB0aW1lZCBvdXQuXG4gICAqL1xuICB2YXIgY2FsbFRpbWVkT3V0Q2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgLy8gVE9ETzogdGhpcyB3b3VsZCBiZSBtb3JlIGVmZmljaWVudCBpZiBkZWZlcnJlZCBjYWxsYmFja3MgYXJlIHN0b3JlZCBpblxuICAgIC8vIG1pbiBoZWFwLlxuICAgIC8vIE9yIGluIGEgbGlua2VkIGxpc3Qgd2l0aCBsaW5rcyBmb3IgYm90aCB0aW1lb3V0VGltZSBvcmRlciBhbmQgaW5zZXJ0aW9uXG4gICAgLy8gb3JkZXIuXG4gICAgLy8gRm9yIG5vdyBhbiBlYXN5IGNvbXByb21pc2UgaXMgdGhlIGN1cnJlbnQgYXBwcm9hY2g6XG4gICAgLy8gS2VlcCBhIHBvaW50ZXIgdG8gdGhlIHNvb25lc3QgdGltZW91dFRpbWUsIGFuZCBjaGVjayB0aGF0IGZpcnN0LlxuICAgIC8vIElmIGl0IGhhcyBub3QgZXhwaXJlZCwgd2UgY2FuIHNraXAgdHJhdmVyc2luZyB0aGUgd2hvbGUgbGlzdC5cbiAgICAvLyBJZiBpdCBoYXMgZXhwaXJlZCwgdGhlbiB3ZSBzdGVwIHRocm91Z2ggYWxsIHRoZSBjYWxsYmFja3MuXG4gICAgaWYgKG5leHRTb29uZXN0VGltZW91dFRpbWUgPT09IC0xIHx8IG5leHRTb29uZXN0VGltZW91dFRpbWUgPiBjdXJyZW50VGltZSkge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IG5vbmUgb2YgdGhlbSBoYXZlIHRpbWVkIG91dCB5ZXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE5PVEU6IHdlIGludGVudGlvbmFsbHkgd2FpdCB0byB1cGRhdGUgdGhlIG5leHRTb29uZXN0VGltZW91dFRpbWUgdW50aWxcbiAgICAvLyBhZnRlciBzdWNjZXNzZnVsbHkgY2FsbGluZyBhbnkgdGltZWQgb3V0IGNhbGxiYWNrcy5cbiAgICAvLyBJZiBhIHRpbWVkIG91dCBjYWxsYmFjayB0aHJvd3MgYW4gZXJyb3IsIHdlIGNvdWxkIGdldCBzdHVjayBpbiBhIHN0YXRlXG4gICAgLy8gd2hlcmUgdGhlIG5leHRTb29uZXN0VGltZW91dFRpbWUgd2FzIHNldCB3cm9uZy5cbiAgICB2YXIgdXBkYXRlZE5leHRTb29uZXN0VGltZW91dFRpbWUgPSAtMTsgLy8gd2Ugd2lsbCB1cGRhdGUgbmV4dFNvb25lc3RUaW1lb3V0VGltZSBiZWxvd1xuICAgIHZhciB0aW1lZE91dENhbGxiYWNrcyA9IFtdO1xuXG4gICAgLy8gaXRlcmF0ZSBvbmNlIHRvIGZpbmQgdGltZWQgb3V0IGNhbGxiYWNrcyBhbmQgZmluZCBuZXh0U29vbmVzdFRpbWVvdXRUaW1lXG4gICAgdmFyIGN1cnJlbnRDYWxsYmFja0NvbmZpZyA9IGhlYWRPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0O1xuICAgIHdoaWxlIChjdXJyZW50Q2FsbGJhY2tDb25maWcgIT09IG51bGwpIHtcbiAgICAgIHZhciBfdGltZW91dFRpbWUgPSBjdXJyZW50Q2FsbGJhY2tDb25maWcudGltZW91dFRpbWU7XG4gICAgICBpZiAoX3RpbWVvdXRUaW1lICE9PSAtMSAmJiBfdGltZW91dFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgLy8gaXQgaGFzIHRpbWVkIG91dCFcbiAgICAgICAgdGltZWRPdXRDYWxsYmFja3MucHVzaChjdXJyZW50Q2FsbGJhY2tDb25maWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF90aW1lb3V0VGltZSAhPT0gLTEgJiYgKHVwZGF0ZWROZXh0U29vbmVzdFRpbWVvdXRUaW1lID09PSAtMSB8fCBfdGltZW91dFRpbWUgPCB1cGRhdGVkTmV4dFNvb25lc3RUaW1lb3V0VGltZSkpIHtcbiAgICAgICAgICB1cGRhdGVkTmV4dFNvb25lc3RUaW1lb3V0VGltZSA9IF90aW1lb3V0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VycmVudENhbGxiYWNrQ29uZmlnID0gY3VycmVudENhbGxiYWNrQ29uZmlnLm5leHQ7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVkT3V0Q2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGltZWRPdXRDYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2FsbFVuc2FmZWx5KHRpbWVkT3V0Q2FsbGJhY2tzW2ldLCBmcmFtZURlYWRsaW5lT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBpbnRlbnRpb25hbGx5IHdhaXQgdG8gdXBkYXRlIHRoZSBuZXh0U29vbmVzdFRpbWVvdXRUaW1lIHVudGlsXG4gICAgLy8gYWZ0ZXIgc3VjY2Vzc2Z1bGx5IGNhbGxpbmcgYW55IHRpbWVkIG91dCBjYWxsYmFja3MuXG4gICAgbmV4dFNvb25lc3RUaW1lb3V0VGltZSA9IHVwZGF0ZWROZXh0U29vbmVzdFRpbWVvdXRUaW1lO1xuICB9O1xuXG4gIC8vIFdlIHVzZSB0aGUgcG9zdE1lc3NhZ2UgdHJpY2sgdG8gZGVmZXIgaWRsZSB3b3JrIHVudGlsIGFmdGVyIHRoZSByZXBhaW50LlxuICB2YXIgbWVzc2FnZUtleSA9ICdfX3JlYWN0SWRsZUNhbGxiYWNrJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgdmFyIGlkbGVUaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSAhPT0gd2luZG93IHx8IGV2ZW50LmRhdGEgIT09IG1lc3NhZ2VLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICBpZiAoaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaXJzdCBjYWxsIGFueXRoaW5nIHdoaWNoIGhhcyB0aW1lZCBvdXQsIHVudGlsIHdlIGhhdmUgY2F1Z2h0IHVwLlxuICAgIGNhbGxUaW1lZE91dENhbGxiYWNrcygpO1xuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAvLyBOZXh0LCBhcyBsb25nIGFzIHdlIGhhdmUgaWRsZSB0aW1lLCB0cnkgY2FsbGluZyBtb3JlIGNhbGxiYWNrcy5cbiAgICB3aGlsZSAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lID4gMCAmJiBoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGxhdGVzdENhbGxiYWNrQ29uZmlnID0gaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3Q7XG4gICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSBmYWxzZTtcbiAgICAgIC8vIGNhbGxVbnNhZmVseSB3aWxsIHJlbW92ZSBpdCBmcm9tIHRoZSBoZWFkIG9mIHRoZSBsaW5rZWQgbGlzdFxuICAgICAgY2FsbFVuc2FmZWx5KGxhdGVzdENhbGxiYWNrQ29uZmlnLCBmcmFtZURlYWRsaW5lT2JqZWN0KTtcbiAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICB9XG4gICAgaWYgKGhlYWRPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICBzY2hlZHVsZUFuaW1hdGlvbkZyYW1lV2l0aEZhbGxiYWNrU3VwcG9ydChhbmltYXRpb25UaWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIEFzc3VtZXMgdGhhdCB3ZSBoYXZlIGFkZEV2ZW50TGlzdGVuZXIgaW4gdGhpcyBlbnZpcm9ubWVudC4gTWlnaHQgbmVlZFxuICAvLyBzb21ldGhpbmcgYmV0dGVyIGZvciBvbGQgSUUuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaWRsZVRpY2ssIGZhbHNlKTtcblxuICB2YXIgYW5pbWF0aW9uVGljayA9IGZ1bmN0aW9uIChyYWZUaW1lKSB7XG4gICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0RnJhbWVUaW1lID0gcmFmVGltZSAtIGZyYW1lRGVhZGxpbmUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKG5leHRGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUgJiYgcHJldmlvdXNGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUpIHtcbiAgICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgOCkge1xuICAgICAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBXZSBkb24ndCBzdXBwb3J0IGhpZ2hlciBmcmFtZSByYXRlcyB0aGFuIDEyMGh6LlxuICAgICAgICAvLyBJZiB3ZSBnZXQgbG93ZXIgdGhhbiB0aGF0LCBpdCBpcyBwcm9iYWJseSBhIGJ1Zy5cbiAgICAgICAgbmV4dEZyYW1lVGltZSA9IDg7XG4gICAgICB9XG4gICAgICAvLyBJZiBvbmUgZnJhbWUgZ29lcyBsb25nLCB0aGVuIHRoZSBuZXh0IG9uZSBjYW4gYmUgc2hvcnQgdG8gY2F0Y2ggdXAuXG4gICAgICAvLyBJZiB0d28gZnJhbWVzIGFyZSBzaG9ydCBpbiBhIHJvdywgdGhlbiB0aGF0J3MgYW4gaW5kaWNhdGlvbiB0aGF0IHdlXG4gICAgICAvLyBhY3R1YWxseSBoYXZlIGEgaGlnaGVyIGZyYW1lIHJhdGUgdGhhbiB3aGF0IHdlJ3JlIGN1cnJlbnRseSBvcHRpbWl6aW5nLlxuICAgICAgLy8gV2UgYWRqdXN0IG91ciBoZXVyaXN0aWMgZHluYW1pY2FsbHkgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiB3ZSdyZVxuICAgICAgLy8gcnVubmluZyBvbiAxMjBoeiBkaXNwbGF5IG9yIDkwaHogVlIgZGlzcGxheS5cbiAgICAgIC8vIFRha2UgdGhlIG1heCBvZiB0aGUgdHdvIGluIGNhc2Ugb25lIG9mIHRoZW0gd2FzIGFuIGFub21hbHkgZHVlIHRvXG4gICAgICAvLyBtaXNzZWQgZnJhbWUgZGVhZGxpbmVzLlxuICAgICAgYWN0aXZlRnJhbWVUaW1lID0gbmV4dEZyYW1lVGltZSA8IHByZXZpb3VzRnJhbWVUaW1lID8gcHJldmlvdXNGcmFtZVRpbWUgOiBuZXh0RnJhbWVUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0ZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWU7XG4gICAgfVxuICAgIGZyYW1lRGVhZGxpbmUgPSByYWZUaW1lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmICghaXNJZGxlU2NoZWR1bGVkKSB7XG4gICAgICBpc0lkbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VLZXksICcqJyk7XG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVXb3JrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRpb25zKSAvKiBDYWxsYmFja0NvbmZpZ1R5cGUgKi97XG4gICAgdmFyIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgdGltZW91dFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpICsgb3B0aW9ucy50aW1lb3V0O1xuICAgIH1cbiAgICBpZiAobmV4dFNvb25lc3RUaW1lb3V0VGltZSA9PT0gLTEgfHwgdGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDwgbmV4dFNvb25lc3RUaW1lb3V0VGltZSkge1xuICAgICAgbmV4dFNvb25lc3RUaW1lb3V0VGltZSA9IHRpbWVvdXRUaW1lO1xuICAgIH1cblxuICAgIHZhciBzY2hlZHVsZWRDYWxsYmFja0NvbmZpZyA9IHtcbiAgICAgIHNjaGVkdWxlZENhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIHRpbWVvdXRUaW1lOiB0aW1lb3V0VGltZSxcbiAgICAgIHByZXY6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAoaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPT09IG51bGwpIHtcbiAgICAgIC8vIE1ha2UgdGhpcyBjYWxsYmFjayB0aGUgaGVhZCBhbmQgdGFpbCBvZiBvdXIgbGlzdFxuICAgICAgaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBzY2hlZHVsZWRDYWxsYmFja0NvbmZpZztcbiAgICAgIHRhaWxPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0ID0gc2NoZWR1bGVkQ2FsbGJhY2tDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkZCBsYXRlc3QgY2FsbGJhY2sgYXMgdGhlIG5ldyB0YWlsIG9mIHRoZSBsaXN0XG4gICAgICBzY2hlZHVsZWRDYWxsYmFja0NvbmZpZy5wcmV2ID0gdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3Q7XG4gICAgICAvLyByZW5hbWluZyBmb3IgY2xhcml0eVxuICAgICAgdmFyIG9sZFRhaWxPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0ID0gdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3Q7XG4gICAgICBpZiAob2xkVGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgIT09IG51bGwpIHtcbiAgICAgICAgb2xkVGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QubmV4dCA9IHNjaGVkdWxlZENhbGxiYWNrQ29uZmlnO1xuICAgICAgfVxuICAgICAgdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBzY2hlZHVsZWRDYWxsYmFja0NvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgIC8vIElmIHJBRiBkaWRuJ3QgYWxyZWFkeSBzY2hlZHVsZSBvbmUsIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBmcmFtZS5cbiAgICAgIC8vIFRPRE86IElmIHRoaXMgckFGIGRvZXNuJ3QgbWF0ZXJpYWxpemUgYmVjYXVzZSB0aGUgYnJvd3NlciB0aHJvdHRsZXMsIHdlXG4gICAgICAvLyBtaWdodCB3YW50IHRvIHN0aWxsIGhhdmUgc2V0VGltZW91dCB0cmlnZ2VyIHNjaGVkdWxlV29yayBhcyBhIGJhY2t1cCB0byBlbnN1cmVcbiAgICAgIC8vIHRoYXQgd2Uga2VlcCBwZXJmb3JtaW5nIHdvcmsuXG4gICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlQW5pbWF0aW9uRnJhbWVXaXRoRmFsbGJhY2tTdXBwb3J0KGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZWR1bGVkQ2FsbGJhY2tDb25maWc7XG4gIH07XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxTY2hlZHVsZWRXb3JrID0gZnVuY3Rpb24gKGNhbGxiYWNrQ29uZmlnIC8qIENhbGxiYWNrQ29uZmlnVHlwZSAqL1xuICApIHtcbiAgICBpZiAoY2FsbGJhY2tDb25maWcucHJldiA9PT0gbnVsbCAmJiBoZWFkT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCAhPT0gY2FsbGJhY2tDb25maWcpIHtcbiAgICAgIC8vIHRoaXMgY2FsbGJhY2tDb25maWcgaGFzIGFscmVhZHkgYmVlbiBjYW5jZWxsZWQuXG4gICAgICAvLyBjYW5jZWxTY2hlZHVsZWRXb3JrIHNob3VsZCBiZSBpZGVtcG90ZW50LCBhIG5vLW9wIGFmdGVyIGZpcnN0IGNhbGwuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIGZvdXIgcG9zc2libGUgY2FzZXM6XG4gICAgICogLSBIZWFkL25vZGVUb1JlbW92ZS9UYWlsIC0+IG51bGxcbiAgICAgKiAgIEluIHRoaXMgY2FzZSB3ZSBzZXQgSGVhZCBhbmQgVGFpbCB0byBudWxsLlxuICAgICAqIC0gSGVhZCAtPiAuLi4gbWlkZGxlIG5vZGVzLi4uIC0+IFRhaWwvbm9kZVRvUmVtb3ZlXG4gICAgICogICBJbiB0aGlzIGNhc2Ugd2UgcG9pbnQgdGhlIG1pZGRsZS5uZXh0IHRvIG51bGwgYW5kIHB1dCBtaWRkbGUgYXMgdGhlIG5ld1xuICAgICAqICAgVGFpbC5cbiAgICAgKiAtIEhlYWQvbm9kZVRvUmVtb3ZlIC0+IC4uLm1pZGRsZSBub2Rlcy4uLiAtPiBUYWlsXG4gICAgICogICBJbiB0aGlzIGNhc2Ugd2UgcG9pbnQgdGhlIG1pZGRsZS5wcmV2IGF0IG51bGwgYW5kIG1vdmUgdGhlIEhlYWQgdG9cbiAgICAgKiAgIG1pZGRsZS5cbiAgICAgKiAtIEhlYWQgLT4gLi4uID9zb21lIG5vZGVzIC4uLiAtPiBub2RlVG9SZW1vdmUgLT4gLi4uID9zb21lIG5vZGVzIC4uLiAtPiBUYWlsXG4gICAgICogICBJbiB0aGlzIGNhc2Ugd2UgcG9pbnQgdGhlIEhlYWQubmV4dCB0byB0aGUgVGFpbCBhbmQgdGhlIFRhaWwucHJldiB0b1xuICAgICAqICAgdGhlIEhlYWQuXG4gICAgICovXG4gICAgdmFyIG5leHQgPSBjYWxsYmFja0NvbmZpZy5uZXh0O1xuICAgIHZhciBwcmV2ID0gY2FsbGJhY2tDb25maWcucHJldjtcbiAgICBjYWxsYmFja0NvbmZpZy5uZXh0ID0gbnVsbDtcbiAgICBjYWxsYmFja0NvbmZpZy5wcmV2ID0gbnVsbDtcbiAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgLy8gd2UgaGF2ZSBhIG5leHRcblxuICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHByZXZcblxuICAgICAgICAvLyBjYWxsYmFja0NvbmZpZyBpcyBzb21ld2hlcmUgaW4gdGhlIG1pZGRsZSBvZiBhIGxpc3Qgb2YgMyBvciBtb3JlIG5vZGVzLlxuICAgICAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSBpcyBhIG5leHQgYnV0IG5vdCBhIHByZXZpb3VzIG9uZTtcbiAgICAgICAgLy8gY2FsbGJhY2tDb25maWcgaXMgdGhlIGhlYWQgb2YgYSBsaXN0IG9mIDIgb3IgbW9yZSBvdGhlciBub2Rlcy5cbiAgICAgICAgbmV4dC5wcmV2ID0gbnVsbDtcbiAgICAgICAgaGVhZE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBuZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5leHQgY2FsbGJhY2sgY29uZmlnOyB0aGlzIG11c3QgdGhlIHRhaWwgb2YgdGhlIGxpc3RcblxuICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHByZXZcblxuICAgICAgICAvLyBjYWxsYmFja0NvbmZpZyBpcyB0aGUgdGFpbCBvZiBhIGxpc3Qgb2YgMiBvciBtb3JlIG90aGVyIG5vZGVzLlxuICAgICAgICBwcmV2Lm5leHQgPSBudWxsO1xuICAgICAgICB0YWlsT2ZQZW5kaW5nQ2FsbGJhY2tzTGlua2VkTGlzdCA9IHByZXY7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNhbGxiYWNrIGNvbmZpZztcbiAgICAgICAgLy8gY2FsbGJhY2tDb25maWcgaXMgdGhlIG9ubHkgdGhpbmcgaW4gdGhlIGxpbmtlZCBsaXN0LFxuICAgICAgICAvLyBzbyBib3RoIGhlYWQgYW5kIHRhaWwgcG9pbnQgdG8gaXQuXG4gICAgICAgIGhlYWRPZlBlbmRpbmdDYWxsYmFja3NMaW5rZWRMaXN0ID0gbnVsbDtcbiAgICAgICAgdGFpbE9mUGVuZGluZ0NhbGxiYWNrc0xpbmtlZExpc3QgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGUtdHJhY2tpbmcucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGUtdHJhY2tpbmcuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCl7XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBwYXJlbnQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEF0LmJlZm9yZSwgdGFyZ2V0KTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRpZihvcHRpb25zLmF0dHJzLm5vbmNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuXHRcdGlmIChub25jZSkge1xuXHRcdFx0b3B0aW9ucy5hdHRycy5ub25jZSA9IG5vbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcblxudmFyIGNsYW1wID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7IHJldHVybiBmdW5jdGlvbiAodikge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHYsIG1heCksIG1pbik7XHJcbn07IH07XHJcbnZhciBpc0ZpcnN0Q2hhcnMgPSBmdW5jdGlvbiAodGVybSkgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgdi5pbmRleE9mKHRlcm0pID09PSAwO1xyXG59OyB9O1xyXG52YXIgZ2V0VmFsdWVGcm9tRnVuY3Rpb25TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcodmFsdWUuaW5kZXhPZignKCcpICsgMSwgdmFsdWUubGFzdEluZGV4T2YoJyknKSk7XHJcbn07XHJcbnZhciBzcGxpdENvbW1hRGVsaW1pdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnNwbGl0KC8sXFxzKi8pIDogW3ZhbHVlXTtcclxufTtcclxudmFyIHNhbml0aXplID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ICUgMSA/IE51bWJlcih2LnRvRml4ZWQoNSkpIDogdik7IH07XG5cbnZhciBudW1iZXIgPSB7XHJcbiAgICB0ZXN0OiBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInOyB9LFxyXG4gICAgcGFyc2U6IHBhcnNlRmxvYXQsXHJcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2OyB9XHJcbn07XHJcbnZhciBhbHBoYSA9IF9fYXNzaWduKHt9LCBudW1iZXIsIHsgdHJhbnNmb3JtOiBjbGFtcCgwLCAxKSB9KTtcclxudmFyIHNjYWxlID0gX19hc3NpZ24oe30sIG51bWJlciwgeyBkZWZhdWx0OiAxIH0pO1xuXG52YXIgY3JlYXRlVW5pdFR5cGUgPSBmdW5jdGlvbiAodW5pdCkgeyByZXR1cm4gKHtcclxuICAgIHRlc3Q6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJyAmJiB2LmVuZHNXaXRoKHVuaXQpICYmIHYuc3BsaXQoJyAnKS5sZW5ndGggPT09IDE7XHJcbiAgICB9LFxyXG4gICAgcGFyc2U6IHBhcnNlRmxvYXQsXHJcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIlwiICsgdiArIHVuaXQ7IH1cclxufSk7IH07XHJcbnZhciBkZWdyZWVzID0gY3JlYXRlVW5pdFR5cGUoJ2RlZycpO1xyXG52YXIgcGVyY2VudCA9IGNyZWF0ZVVuaXRUeXBlKCclJyk7XHJcbnZhciBweCA9IGNyZWF0ZVVuaXRUeXBlKCdweCcpO1xyXG52YXIgdmggPSBjcmVhdGVVbml0VHlwZSgndmgnKTtcclxudmFyIHZ3ID0gY3JlYXRlVW5pdFR5cGUoJ3Z3Jyk7XG5cbnZhciBjbGFtcFJnYlVuaXQgPSBjbGFtcCgwLCAyNTUpO1xyXG52YXIgb25seUNvbG9yUmVnZXggPSAvXigjWzAtOWEtZl17M318Iyg/OlswLTlhLWZdezJ9KXsyLDR9fChyZ2J8aHNsKWE/XFwoKC0/XFxkKyU/WyxcXHNdKyl7MiwzfVxccypbXFxkXFwuXSslP1xcKSkkL2k7XHJcbnZhciBpc1JnYmEgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdi5yZWQgIT09IHVuZGVmaW5lZDsgfTtcclxudmFyIGlzSHNsYSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2Lmh1ZSAhPT0gdW5kZWZpbmVkOyB9O1xyXG52YXIgc3BsaXRDb2xvclZhbHVlcyA9IGZ1bmN0aW9uICh0ZXJtcykge1xyXG4gICAgdmFyIG51bVRlcm1zID0gdGVybXMubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHt9O1xyXG4gICAgICAgIHZhciB2YWx1ZXNBcnJheSA9IHNwbGl0Q29tbWFEZWxpbWl0ZWQoZ2V0VmFsdWVGcm9tRnVuY3Rpb25TdHJpbmcodikpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGVybXM7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZXNbdGVybXNbaV1dID1cclxuICAgICAgICAgICAgICAgIHZhbHVlc0FycmF5W2ldICE9PSB1bmRlZmluZWQgPyBwYXJzZUZsb2F0KHZhbHVlc0FycmF5W2ldKSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgcmdiYVRlbXBsYXRlID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcmVkID0gX2EucmVkLCBncmVlbiA9IF9hLmdyZWVuLCBibHVlID0gX2EuYmx1ZSwgX2IgPSBfYS5hbHBoYSwgYWxwaGEkJDEgPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iO1xyXG4gICAgcmV0dXJuIFwicmdiYShcIiArIHJlZCArIFwiLCBcIiArIGdyZWVuICsgXCIsIFwiICsgYmx1ZSArIFwiLCBcIiArIGFscGhhJCQxICsgXCIpXCI7XHJcbn07XHJcbnZhciBoc2xhVGVtcGxhdGUgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBodWUgPSBfYS5odWUsIHNhdHVyYXRpb24gPSBfYS5zYXR1cmF0aW9uLCBsaWdodG5lc3MgPSBfYS5saWdodG5lc3MsIF9iID0gX2EuYWxwaGEsIGFscGhhJCQxID0gX2IgPT09IHZvaWQgMCA/IDEgOiBfYjtcclxuICAgIHJldHVybiBcImhzbGEoXCIgKyBodWUgKyBcIiwgXCIgKyBzYXR1cmF0aW9uICsgXCIsIFwiICsgbGlnaHRuZXNzICsgXCIsIFwiICsgYWxwaGEkJDEgKyBcIilcIjtcclxufTtcclxudmFyIHJnYlVuaXQgPSBfX2Fzc2lnbih7fSwgbnVtYmVyLCB7IHRyYW5zZm9ybTogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE1hdGgucm91bmQoY2xhbXBSZ2JVbml0KHYpKTsgfSB9KTtcclxudmFyIHRlc3RSZ2JhU3RyaW5nID0gaXNGaXJzdENoYXJzKCdyZ2InKTtcclxudmFyIHJnYmEgPSB7XHJcbiAgICB0ZXN0OiBmdW5jdGlvbiAodikgeyByZXR1cm4gKHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHRlc3RSZ2JhU3RyaW5nKHYpIDogaXNSZ2JhKHYpKTsgfSxcclxuICAgIHBhcnNlOiBzcGxpdENvbG9yVmFsdWVzKFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnLCAnYWxwaGEnXSksXHJcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciByZWQgPSBfYS5yZWQsIGdyZWVuID0gX2EuZ3JlZW4sIGJsdWUgPSBfYS5ibHVlLCBhbHBoYSQkMSA9IF9hLmFscGhhO1xyXG4gICAgICAgIHJldHVybiByZ2JhVGVtcGxhdGUoe1xyXG4gICAgICAgICAgICByZWQ6IHJnYlVuaXQudHJhbnNmb3JtKHJlZCksXHJcbiAgICAgICAgICAgIGdyZWVuOiByZ2JVbml0LnRyYW5zZm9ybShncmVlbiksXHJcbiAgICAgICAgICAgIGJsdWU6IHJnYlVuaXQudHJhbnNmb3JtKGJsdWUpLFxyXG4gICAgICAgICAgICBhbHBoYTogc2FuaXRpemUoYWxwaGEkJDEpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn07XHJcbnZhciB0ZXN0SHNsYVN0cmluZyA9IGlzRmlyc3RDaGFycygnaHNsJyk7XHJcbnZhciBoc2xhID0ge1xyXG4gICAgdGVzdDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB0ZXN0SHNsYVN0cmluZyh2KSA6IGlzSHNsYSh2KSk7IH0sXHJcbiAgICBwYXJzZTogc3BsaXRDb2xvclZhbHVlcyhbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcycsICdhbHBoYSddKSxcclxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGh1ZSA9IF9hLmh1ZSwgc2F0dXJhdGlvbiA9IF9hLnNhdHVyYXRpb24sIGxpZ2h0bmVzcyA9IF9hLmxpZ2h0bmVzcywgYWxwaGEkJDEgPSBfYS5hbHBoYTtcclxuICAgICAgICByZXR1cm4gaHNsYVRlbXBsYXRlKHtcclxuICAgICAgICAgICAgaHVlOiBNYXRoLnJvdW5kKGh1ZSksXHJcbiAgICAgICAgICAgIHNhdHVyYXRpb246IHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKHNhdHVyYXRpb24pKSxcclxuICAgICAgICAgICAgbGlnaHRuZXNzOiBwZXJjZW50LnRyYW5zZm9ybShzYW5pdGl6ZShsaWdodG5lc3MpKSxcclxuICAgICAgICAgICAgYWxwaGE6IHNhbml0aXplKGFscGhhJCQxKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG52YXIgaGV4ID0gX19hc3NpZ24oe30sIHJnYmEsIHsgdGVzdDogaXNGaXJzdENoYXJzKCcjJyksIHBhcnNlOiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciByID0gJyc7XHJcbiAgICAgICAgdmFyIGcgPSAnJztcclxuICAgICAgICB2YXIgYiA9ICcnO1xyXG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDQpIHtcclxuICAgICAgICAgICAgciA9IHYuc3Vic3RyKDEsIDIpO1xyXG4gICAgICAgICAgICBnID0gdi5zdWJzdHIoMywgMik7XHJcbiAgICAgICAgICAgIGIgPSB2LnN1YnN0cig1LCAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHIgPSB2LnN1YnN0cigxLCAxKTtcclxuICAgICAgICAgICAgZyA9IHYuc3Vic3RyKDIsIDEpO1xyXG4gICAgICAgICAgICBiID0gdi5zdWJzdHIoMywgMSk7XHJcbiAgICAgICAgICAgIHIgKz0gcjtcclxuICAgICAgICAgICAgZyArPSBnO1xyXG4gICAgICAgICAgICBiICs9IGI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJlZDogcGFyc2VJbnQociwgMTYpLFxyXG4gICAgICAgICAgICBncmVlbjogcGFyc2VJbnQoZywgMTYpLFxyXG4gICAgICAgICAgICBibHVlOiBwYXJzZUludChiLCAxNiksXHJcbiAgICAgICAgICAgIGFscGhhOiAxXHJcbiAgICAgICAgfTtcclxuICAgIH0gfSk7XHJcbnZhciBjb2xvciA9IHtcclxuICAgIHRlc3Q6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgb25seUNvbG9yUmVnZXgudGVzdCh2KSkgfHxcclxuICAgICAgICAgICAgcmdiYS50ZXN0KHYpIHx8XHJcbiAgICAgICAgICAgIGhzbGEudGVzdCh2KSB8fFxyXG4gICAgICAgICAgICBoZXgudGVzdCh2KTtcclxuICAgIH0sXHJcbiAgICBwYXJzZTogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAocmdiYS50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JhLnBhcnNlKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoc2xhLnRlc3QodikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhzbGEucGFyc2Uodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhleC50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZXgucGFyc2Uodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfSxcclxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAoaXNSZ2JhKHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZ2JhLnRyYW5zZm9ybSh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNIc2xhKHYpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoc2xhLnRyYW5zZm9ybSh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9XHJcbn07XG5cbnZhciBmbG9hdFJlZ2V4ID0gLygtKT8oXFxkW1xcZFxcLl0qKS9nO1xyXG52YXIgY29sb3JSZWdleCA9IC8oI1swLTlhLWZdezZ9fCNbMC05YS1mXXszfXwjKD86WzAtOWEtZl17Mn0pezIsNH18KHJnYnxoc2wpYT9cXCgoLT9cXGQrJT9bLFxcc10rKXsyLDN9XFxzKltcXGRcXC5dKyU/XFwpKS9naTtcclxudmFyIENPTE9SX1RPS0VOID0gJyR7Y30nO1xyXG52YXIgTlVNQkVSX1RPS0VOID0gJyR7bn0nO1xyXG52YXIgY29tcGxleCA9IHtcclxuICAgIHRlc3Q6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ICE9PSAnc3RyaW5nJyB8fCAhaXNOYU4odikpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgbnVtVmFsdWVzID0gMDtcclxuICAgICAgICB2YXIgZm91bmROdW1iZXJzID0gdi5tYXRjaChmbG9hdFJlZ2V4KTtcclxuICAgICAgICB2YXIgZm91bmRDb2xvcnMgPSB2Lm1hdGNoKGNvbG9yUmVnZXgpO1xyXG4gICAgICAgIGlmIChmb3VuZE51bWJlcnMpXHJcbiAgICAgICAgICAgIG51bVZhbHVlcyArPSBmb3VuZE51bWJlcnMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChmb3VuZENvbG9ycylcclxuICAgICAgICAgICAgbnVtVmFsdWVzICs9IGZvdW5kQ29sb3JzLmxlbmd0aDtcclxuICAgICAgICByZXR1cm4gbnVtVmFsdWVzID4gMDtcclxuICAgIH0sXHJcbiAgICBwYXJzZTogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgaW5wdXQgPSB2O1xyXG4gICAgICAgIHZhciBwYXJzZWQgPSBbXTtcclxuICAgICAgICB2YXIgZm91bmRDb2xvcnMgPSBpbnB1dC5tYXRjaChjb2xvclJlZ2V4KTtcclxuICAgICAgICBpZiAoZm91bmRDb2xvcnMpIHtcclxuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKGNvbG9yUmVnZXgsIENPTE9SX1RPS0VOKTtcclxuICAgICAgICAgICAgcGFyc2VkLnB1c2guYXBwbHkocGFyc2VkLCBmb3VuZENvbG9ycy5tYXAoY29sb3IucGFyc2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZvdW5kTnVtYmVycyA9IGlucHV0Lm1hdGNoKGZsb2F0UmVnZXgpO1xyXG4gICAgICAgIGlmIChmb3VuZE51bWJlcnMpIHtcclxuICAgICAgICAgICAgcGFyc2VkLnB1c2guYXBwbHkocGFyc2VkLCBmb3VuZE51bWJlcnMubWFwKG51bWJlci5wYXJzZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VkO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZVRyYW5zZm9ybWVyOiBmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHByb3A7XHJcbiAgICAgICAgdmFyIHRva2VuID0gMDtcclxuICAgICAgICB2YXIgZm91bmRDb2xvcnMgPSBwcm9wLm1hdGNoKGNvbG9yUmVnZXgpO1xyXG4gICAgICAgIHZhciBudW1Db2xvcnMgPSBmb3VuZENvbG9ycyA/IGZvdW5kQ29sb3JzLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgaWYgKGZvdW5kQ29sb3JzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29sb3JzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZShmb3VuZENvbG9yc1tpXSwgQ09MT1JfVE9LRU4pO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZm91bmROdW1iZXJzID0gdGVtcGxhdGUubWF0Y2goZmxvYXRSZWdleCk7XHJcbiAgICAgICAgdmFyIG51bU51bWJlcnMgPSBmb3VuZE51bWJlcnMgPyBmb3VuZE51bWJlcnMubGVuZ3RoIDogMDtcclxuICAgICAgICBpZiAoZm91bmROdW1iZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTnVtYmVyczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoZm91bmROdW1iZXJzW2ldLCBOVU1CRVJfVE9LRU4pO1xyXG4gICAgICAgICAgICAgICAgdG9rZW4rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRlbXBsYXRlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKGkgPCBudW1Db2xvcnMgPyBDT0xPUl9UT0tFTiA6IE5VTUJFUl9UT0tFTiwgaSA8IG51bUNvbG9ycyA/IGNvbG9yLnRyYW5zZm9ybSh2W2ldKSA6IHNhbml0aXplKHZbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XG5cbmV4cG9ydCB7IG51bWJlciwgc2NhbGUsIGFscGhhLCBkZWdyZWVzLCBwZXJjZW50LCBweCwgdncsIHZoLCByZ2JhLCByZ2JVbml0LCBoZXgsIGhzbGEsIGNvbG9yLCBjb21wbGV4IH07XG4iLCJpbXBvcnQgeyBvbkZyYW1lUmVuZGVyIH0gZnJvbSAnZnJhbWVzeW5jJztcbmltcG9ydCB7IGFscGhhLCBjb2xvciwgZGVncmVlcywgc2NhbGUsIHB4LCBwZXJjZW50IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdoZXktbGlzdGVuJztcblxudmFyIGNyZWF0ZVN0eWxlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBvblJlYWQgPSBfYS5vblJlYWQsXG4gICAgICAgIG9uUmVuZGVyID0gX2Eub25SZW5kZXIsXG4gICAgICAgIF9iID0gX2EuYWxpYXNNYXAsXG4gICAgICAgIGFsaWFzTWFwID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2IsXG4gICAgICAgIF9jID0gX2EudXNlQ2FjaGUsXG4gICAgICAgIHVzZUNhY2hlID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYztcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuICAgICAgICB2YXIgY2hhbmdlZFZhbHVlcyA9IFtdO1xuICAgICAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2V0VmFsdWUgPSBmdW5jdGlvbiAodW5tYXBwZWRLZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gYWxpYXNNYXBbdW5tYXBwZWRLZXldIHx8IHVubWFwcGVkS2V5O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoc3RhdGVba2V5XSAhPT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRWYWx1ZXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkVmFsdWVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbkZyYW1lUmVuZGVyKHJlbmRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZW5kZXIoZm9yY2VSZW5kZXIpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZVJlbmRlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZVJlbmRlciB8fCBoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgb25SZW5kZXIoc3RhdGUsIHByb3BzLCBjaGFuZ2VkVmFsdWVzKTtcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hhbmdlZFZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKHVubWFwcGVkS2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGFsaWFzTWFwW3VubWFwcGVkS2V5XSB8fCB1bm1hcHBlZEtleTtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5ID8gdXNlQ2FjaGUgJiYgc3RhdGVba2V5XSAhPT0gdW5kZWZpbmVkID8gc3RhdGVba2V5XSA6IG9uUmVhZChrZXksIHByb3BzKSA6IHN0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlcywgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlKHZhbHVlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFZhbHVlKHZhbHVlcywgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUoa2V5LCB2YWx1ZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVuZGVyOiByZW5kZXJcbiAgICAgICAgfTtcbiAgICB9O1xufTtcblxudmFyIENBTUVMX0NBU0VfUEFUVEVSTiA9IC8oW2Etel0pKFtBLVpdKS9nO1xudmFyIFJFUExBQ0VfVEVNUExBVEUgPSAnJDEtJDInO1xudmFyIGNhbWVsVG9EYXNoID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShDQU1FTF9DQVNFX1BBVFRFUk4sIFJFUExBQ0VfVEVNUExBVEUpLnRvTG93ZXJDYXNlKCk7XG59O1xudmFyIHNldERvbUF0dHJzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGNhbWVsQ2FjaGUgPSAvKiNfX1BVUkVfXyovbmV3IE1hcCgpO1xudmFyIGRhc2hDYWNoZSA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKCk7XG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcycsICcnXTtcbnZhciBudW1QcmVmaXhlcyA9IHByZWZpeGVzLmxlbmd0aDtcbnZhciB0ZXN0RWxlbWVudDtcbnZhciB0ZXN0UHJlZml4ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgdGVzdEVsZW1lbnQgPSB0ZXN0RWxlbWVudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVByZWZpeGVzOyBpKyspIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgICAgICB2YXIgbm9QcmVmaXggPSBwcmVmaXggPT09ICcnO1xuICAgICAgICB2YXIgcHJlZml4ZWRQcm9wZXJ0eU5hbWUgPSBub1ByZWZpeCA/IGtleSA6IHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTtcbiAgICAgICAgaWYgKHByZWZpeGVkUHJvcGVydHlOYW1lIGluIHRlc3RFbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICBjYW1lbENhY2hlLnNldChrZXksIHByZWZpeGVkUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGRhc2hDYWNoZS5zZXQoa2V5LCBcIlwiICsgKG5vUHJlZml4ID8gJycgOiAnLScpICsgY2FtZWxUb0Rhc2gocHJlZml4ZWRQcm9wZXJ0eU5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgcHJlZml4ZXIgPSBmdW5jdGlvbiAoa2V5LCBhc0Rhc2hDYXNlKSB7XG4gICAgaWYgKGFzRGFzaENhc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBhc0Rhc2hDYXNlID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IGFzRGFzaENhc2UgPyBkYXNoQ2FjaGUgOiBjYW1lbENhY2hlO1xuICAgIGlmICghY2FjaGUuaGFzKGtleSkpIHRlc3RQcmVmaXgoa2V5KTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSkgfHwga2V5O1xufTtcblxudmFyIGF4ZXMgPSBbJycsICdYJywgJ1knLCAnWiddO1xudmFyIG9yZGVyID0gWyd0cmFuc2xhdGUnLCAnc2NhbGUnLCAncm90YXRlJywgJ3NrZXcnLCAndHJhbnNmb3JtUGVyc3BlY3RpdmUnXTtcbnZhciBUUkFOU0ZPUk1fT1JJR0lOX1ggPSAndHJhbnNmb3JtT3JpZ2luWCc7XG52YXIgVFJBTlNGT1JNX09SSUdJTl9ZID0gJ3RyYW5zZm9ybU9yaWdpblknO1xudmFyIHRyYW5zZm9ybVByb3BzID0gLyojX19QVVJFX18qL29yZGVyLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICByZXR1cm4gYXhlcy5yZWR1Y2UoZnVuY3Rpb24gKGF4ZXNBY2MsIGF4ZXNLZXkpIHtcbiAgICAgICAgYXhlc0FjYy5wdXNoKGtleSArIGF4ZXNLZXkpO1xuICAgICAgICByZXR1cm4gYXhlc0FjYztcbiAgICB9LCBhY2MpO1xufSwgWyd4JywgJ3knLCAneiddKTtcbnZhciB0cmFuc2Zvcm1Qcm9wRGljdGlvbmFyeSA9IC8qI19fUFVSRV9fKi90cmFuc2Zvcm1Qcm9wcy5yZWR1Y2UoZnVuY3Rpb24gKGRpY3QsIGtleSkge1xuICAgIGRpY3Rba2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIGRpY3Q7XG59LCB7fSk7XG52YXIgaXNUcmFuc2Zvcm1Qcm9wID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9wRGljdGlvbmFyeVtrZXldID09PSB0cnVlO1xufTtcbnZhciBzb3J0VHJhbnNmb3JtUHJvcHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9wcy5pbmRleE9mKGEpIC0gdHJhbnNmb3JtUHJvcHMuaW5kZXhPZihiKTtcbn07XG52YXIgaXNUcmFuc2Zvcm1PcmlnaW5Qcm9wID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkgPT09IFRSQU5TRk9STV9PUklHSU5fWCB8fCBrZXkgPT09IFRSQU5TRk9STV9PUklHSU5fWTtcbn07XG5cbnZhciB2YWx1ZVR5cGVzID0ge1xuICAgIGNvbG9yOiBjb2xvcixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgIG91dGxpbmVDb2xvcjogY29sb3IsXG4gICAgZmlsbDogY29sb3IsXG4gICAgc3Ryb2tlOiBjb2xvcixcbiAgICBib3JkZXJDb2xvcjogY29sb3IsXG4gICAgYm9yZGVyVG9wQ29sb3I6IGNvbG9yLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IGNvbG9yLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiBjb2xvcixcbiAgICBib3JkZXJMZWZ0Q29sb3I6IGNvbG9yLFxuICAgIGJvcmRlclJhZGl1czogcHgsXG4gICAgd2lkdGg6IHB4LFxuICAgIG1heFdpZHRoOiBweCxcbiAgICBoZWlnaHQ6IHB4LFxuICAgIG1heEhlaWdodDogcHgsXG4gICAgdG9wOiBweCxcbiAgICBsZWZ0OiBweCxcbiAgICBib3R0b206IHB4LFxuICAgIHJpZ2h0OiBweCxcbiAgICByb3RhdGU6IGRlZ3JlZXMsXG4gICAgcm90YXRlWDogZGVncmVlcyxcbiAgICByb3RhdGVZOiBkZWdyZWVzLFxuICAgIHJvdGF0ZVo6IGRlZ3JlZXMsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHNjYWxlWDogc2NhbGUsXG4gICAgc2NhbGVZOiBzY2FsZSxcbiAgICBzY2FsZVo6IHNjYWxlLFxuICAgIHNrZXdYOiBkZWdyZWVzLFxuICAgIHNrZXdZOiBkZWdyZWVzLFxuICAgIGRpc3RhbmNlOiBweCxcbiAgICB0cmFuc2xhdGVYOiBweCxcbiAgICB0cmFuc2xhdGVZOiBweCxcbiAgICB0cmFuc2xhdGVaOiBweCxcbiAgICBwZXJzcGVjdGl2ZTogcHgsXG4gICAgb3BhY2l0eTogYWxwaGEsXG4gICAgdHJhbnNmb3JtT3JpZ2luWDogcGVyY2VudCxcbiAgICB0cmFuc2Zvcm1PcmlnaW5ZOiBwZXJjZW50LFxuICAgIHRyYW5zZm9ybU9yaWdpblo6IHB4XG59O1xudmFyIGdldFZhbHVlVHlwZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdmFsdWVUeXBlc1trZXldO1xufTtcblxudmFyIGFsaWFzTWFwID0ge1xuICAgIHg6ICd0cmFuc2xhdGVYJyxcbiAgICB5OiAndHJhbnNsYXRlWScsXG4gICAgejogJ3RyYW5zbGF0ZVonLFxuICAgIG9yaWdpblg6ICd0cmFuc2Zvcm1PcmlnaW5YJyxcbiAgICBvcmlnaW5ZOiAndHJhbnNmb3JtT3JpZ2luWScsXG4gICAgb3JpZ2luWjogJ3RyYW5zZm9ybU9yaWdpblonXG59O1xudmFyIE5VTUJFUiA9ICdudW1iZXInO1xudmFyIE9CSkVDVCA9ICdvYmplY3QnO1xudmFyIENPTE9OID0gJzonO1xudmFyIFNFTUlfQ09MT04gPSAnOyc7XG52YXIgVFJBTlNGT1JNX09SSUdJTiA9ICd0cmFuc2Zvcm0tb3JpZ2luJztcbnZhciBUUkFOU0ZPUk0gPSAndHJhbnNmb3JtJztcbnZhciBUUkFOU0xBVEVfWiA9ICd0cmFuc2xhdGVaJztcbnZhciBUUkFOU0ZPUk1fTk9ORSA9ICc7dHJhbnNmb3JtOiBub25lJztcbnZhciBzdHlsZVJ1bGUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBcIlwiICsgU0VNSV9DT0xPTiArIGtleSArIENPTE9OICsgdmFsdWU7XG59O1xuZnVuY3Rpb24gYnVpbGRTdHlsZVByb3BlcnR5U3RyaW5nKHN0YXRlLCBjaGFuZ2VkVmFsdWVzLCBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKGNoYW5nZWRWYWx1ZXMgPT09IHZvaWQgMCkge1xuICAgICAgICBjaGFuZ2VkVmFsdWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgICAgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgdmFsdWVzVG9DaGFuZ2UgPSBjaGFuZ2VkVmFsdWVzID09PSB0cnVlID8gT2JqZWN0LmtleXMoc3RhdGUpIDogY2hhbmdlZFZhbHVlcztcbiAgICB2YXIgcHJvcGVydHlTdHJpbmcgPSAnJztcbiAgICB2YXIgdHJhbnNmb3JtU3RyaW5nID0gJyc7XG4gICAgdmFyIGhhc1RyYW5zZm9ybU9yaWdpbiA9IGZhbHNlO1xuICAgIHZhciB0cmFuc2Zvcm1Jc0RlZmF1bHQgPSB0cnVlO1xuICAgIHZhciBoYXNUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICB2YXIgdHJhbnNmb3JtSGFzWiA9IGZhbHNlO1xuICAgIHZhciBudW1DaGFuZ2VkVmFsdWVzID0gdmFsdWVzVG9DaGFuZ2UubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hhbmdlZFZhbHVlczsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZXNUb0NoYW5nZVtpXTtcbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUHJvcChrZXkpKSB7XG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgc3RhdGVLZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUcmFuc2Zvcm1Qcm9wKHN0YXRlS2V5KSAmJiB2YWx1ZXNUb0NoYW5nZS5pbmRleE9mKHN0YXRlS2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzVG9DaGFuZ2UucHVzaChzdGF0ZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzVG9DaGFuZ2Uuc29ydChzb3J0VHJhbnNmb3JtUHJvcHMpO1xuICAgIHZhciB0b3RhbE51bUNoYW5nZWRWYWx1ZXMgPSB2YWx1ZXNUb0NoYW5nZS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbE51bUNoYW5nZWRWYWx1ZXM7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gdmFsdWVzVG9DaGFuZ2VbaV07XG4gICAgICAgIGlmIChibGFja2xpc3QuaGFzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgaXNUcmFuc2Zvcm1LZXkgPSBpc1RyYW5zZm9ybVByb3Aoa2V5KTtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGVba2V5XTtcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IGdldFZhbHVlVHlwZShrZXkpO1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1LZXkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUuZGVmYXVsdCAmJiB2YWx1ZSAhPT0gdmFsdWVUeXBlLmRlZmF1bHQgfHwgIXZhbHVlVHlwZS5kZWZhdWx0ICYmIHZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSXNEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlVHlwZSAmJiAodHlwZW9mIHZhbHVlID09PSBOVU1CRVIgfHwgdHlwZW9mIHZhbHVlID09PSBPQkpFQ1QpICYmIHZhbHVlVHlwZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVUeXBlLnRyYW5zZm9ybSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtS2V5KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0ga2V5ICsgJygnICsgdmFsdWUgKyAnKSAnO1xuICAgICAgICAgICAgdHJhbnNmb3JtSGFzWiA9IGtleSA9PT0gVFJBTlNMQVRFX1ogPyB0cnVlIDogdHJhbnNmb3JtSGFzWjtcbiAgICAgICAgfSBlbHNlIGlmIChpc1RyYW5zZm9ybU9yaWdpblByb3Aoa2V5KSkge1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaGFzVHJhbnNmb3JtT3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3BlcnR5U3RyaW5nICs9IHN0eWxlUnVsZShwcmVmaXhlcihrZXksIHRydWUpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1RyYW5zZm9ybU9yaWdpbikge1xuICAgICAgICBwcm9wZXJ0eVN0cmluZyArPSBzdHlsZVJ1bGUoVFJBTlNGT1JNX09SSUdJTiwgKHN0YXRlLnRyYW5zZm9ybU9yaWdpblggfHwgMCkgKyBcIiBcIiArIChzdGF0ZS50cmFuc2Zvcm1PcmlnaW5ZIHx8IDApICsgXCIgXCIgKyAoc3RhdGUudHJhbnNmb3JtT3JpZ2luWiB8fCAwKSk7XG4gICAgfVxuICAgIGlmIChoYXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1IYXNaICYmIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gVFJBTlNMQVRFX1ogKyBcIigwKVwiO1xuICAgICAgICB9XG4gICAgICAgIHByb3BlcnR5U3RyaW5nICs9IHN0eWxlUnVsZShUUkFOU0ZPUk0sIHRyYW5zZm9ybUlzRGVmYXVsdCA/IFRSQU5TRk9STV9OT05FIDogdHJhbnNmb3JtU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnR5U3RyaW5nO1xufVxuXG52YXIgU0NST0xMX0xFRlQgPSAnc2Nyb2xsTGVmdCc7XG52YXIgU0NST0xMX1RPUCA9ICdzY3JvbGxUb3AnO1xudmFyIHNjcm9sbFZhbHVlcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFtTQ1JPTExfTEVGVCwgU0NST0xMX1RPUF0pO1xudmFyIGNzc1N0eWxlciA9IC8qI19fUFVSRV9fKi9jcmVhdGVTdHlsZXIoe1xuICAgIG9uUmVhZDogZnVuY3Rpb24gKGtleSwgX2EpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBfYS5lbGVtZW50LFxuICAgICAgICAgICAgcHJlcGFyc2VPdXRwdXQgPSBfYS5wcmVwYXJzZU91dHB1dDtcbiAgICAgICAgdmFyIHZhbHVlVHlwZSA9IGdldFZhbHVlVHlwZShrZXkpO1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVR5cGUgPyB2YWx1ZVR5cGUuZGVmYXVsdCB8fCAwIDogMDtcbiAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxWYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50W2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZG9tVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByZWZpeGVyKGtleSwgdHJ1ZSkpIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gcHJlcGFyc2VPdXRwdXQgJiYgdmFsdWVUeXBlICYmIHZhbHVlVHlwZS5wYXJzZSA/IHZhbHVlVHlwZS5wYXJzZShkb21WYWx1ZSkgOiBkb21WYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIGNoYW5nZWRWYWx1ZXMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBfYS5lbGVtZW50LFxuICAgICAgICAgICAgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24gPSBfYS5lbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ICs9IGJ1aWxkU3R5bGVQcm9wZXJ0eVN0cmluZyhzdGF0ZSwgY2hhbmdlZFZhbHVlcywgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24sIHNjcm9sbFZhbHVlcyk7XG4gICAgICAgIGlmIChjaGFuZ2VkVmFsdWVzLmluZGV4T2YoU0NST0xMX0xFRlQpICE9PSAtMSkgZWxlbWVudC5zY3JvbGxMZWZ0ID0gc3RhdGUuc2Nyb2xsTGVmdDtcbiAgICAgICAgaWYgKGNoYW5nZWRWYWx1ZXMuaW5kZXhPZihTQ1JPTExfVE9QKSAhPT0gLTEpIGVsZW1lbnQuc2Nyb2xsVG9wID0gc3RhdGUuc2Nyb2xsVG9wO1xuICAgIH0sXG4gICAgYWxpYXNNYXA6IGFsaWFzTWFwLFxuICAgIHVuY2FjaGVkVmFsdWVzOiBzY3JvbGxWYWx1ZXNcbn0pO1xudmFyIGNzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcykge1xuICAgIHJldHVybiBjc3NTdHlsZXIoX19hc3NpZ24oeyBlbGVtZW50OiBlbGVtZW50LCBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogdHJ1ZSwgcHJlcGFyc2VPdXRwdXQ6IHRydWUgfSwgcHJvcHMpKTtcbn07XG5cbnZhciBaRVJPX05PVF9aRVJPID0gMC4wMDAwMDAxO1xudmFyIHBlcmNlbnRUb1BpeGVscyA9IGZ1bmN0aW9uIChwZXJjZW50JCQxLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gcGVyY2VudCQkMSAvIDEwMCAqIGxlbmd0aCArICdweCc7XG59O1xudmFyIGJ1aWxkID0gZnVuY3Rpb24gKHN0YXRlLCBkaW1lbnNpb25zLCBpc1BhdGgsIHBhdGhMZW5ndGgpIHtcbiAgICB2YXIgaGFzVHJhbnNmb3JtID0gZmFsc2U7XG4gICAgdmFyIGhhc0Rhc2hBcnJheSA9IGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBkYXNoQXJyYXlTdHlsZXMgPSBpc1BhdGggPyB7XG4gICAgICAgIHBhdGhMZW5ndGg6ICcwJyxcbiAgICAgICAgcGF0aFNwYWNpbmc6IFwiXCIgKyBwYXRoTGVuZ3RoXG4gICAgfSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2NhbGUkJDEgPSBzdGF0ZS5zY2FsZSAhPT0gdW5kZWZpbmVkID8gc3RhdGUuc2NhbGUgfHwgWkVST19OT1RfWkVSTyA6IHN0YXRlLnNjYWxlWCB8fCAxO1xuICAgIHZhciBzY2FsZVkgPSBzdGF0ZS5zY2FsZVkgIT09IHVuZGVmaW5lZCA/IHN0YXRlLnNjYWxlWSB8fCBaRVJPX05PVF9aRVJPIDogc2NhbGUkJDEgfHwgMTtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luWCA9IGRpbWVuc2lvbnMud2lkdGggKiAoKHN0YXRlLm9yaWdpblggfHwgNTApIC8gMTAwKSArIGRpbWVuc2lvbnMueDtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luWSA9IGRpbWVuc2lvbnMuaGVpZ2h0ICogKChzdGF0ZS5vcmlnaW5ZIHx8IDUwKSAvIDEwMCkgKyBkaW1lbnNpb25zLnk7XG4gICAgdmFyIHNjYWxlVHJhbnNmb3JtWCA9IC10cmFuc2Zvcm1PcmlnaW5YICogKHNjYWxlJCQxICogMSk7XG4gICAgdmFyIHNjYWxlVHJhbnNmb3JtWSA9IC10cmFuc2Zvcm1PcmlnaW5ZICogKHNjYWxlWSAqIDEpO1xuICAgIHZhciBzY2FsZVJlcGxhY2VYID0gdHJhbnNmb3JtT3JpZ2luWCAvIHNjYWxlJCQxO1xuICAgIHZhciBzY2FsZVJlcGxhY2VZID0gdHJhbnNmb3JtT3JpZ2luWSAvIHNjYWxlWTtcbiAgICB2YXIgdHJhbnNmb3JtID0ge1xuICAgICAgICB0cmFuc2xhdGU6IFwidHJhbnNsYXRlKFwiICsgc3RhdGUudHJhbnNsYXRlWCArIFwiLCBcIiArIHN0YXRlLnRyYW5zbGF0ZVkgKyBcIikgXCIsXG4gICAgICAgIHNjYWxlOiBcInRyYW5zbGF0ZShcIiArIHNjYWxlVHJhbnNmb3JtWCArIFwiLCBcIiArIHNjYWxlVHJhbnNmb3JtWSArIFwiKSBzY2FsZShcIiArIHNjYWxlJCQxICsgXCIsIFwiICsgc2NhbGVZICsgXCIpIHRyYW5zbGF0ZShcIiArIHNjYWxlUmVwbGFjZVggKyBcIiwgXCIgKyBzY2FsZVJlcGxhY2VZICsgXCIpIFwiLFxuICAgICAgICByb3RhdGU6IFwicm90YXRlKFwiICsgc3RhdGUucm90YXRlICsgXCIsIFwiICsgdHJhbnNmb3JtT3JpZ2luWCArIFwiLCBcIiArIHRyYW5zZm9ybU9yaWdpblkgKyBcIikgXCIsXG4gICAgICAgIHNrZXdYOiBcInNrZXdYKFwiICsgc3RhdGUuc2tld1ggKyBcIikgXCIsXG4gICAgICAgIHNrZXdZOiBcInNrZXdZKFwiICsgc3RhdGUuc2tld1kgKyBcIikgXCJcbiAgICB9O1xuICAgIGZvciAodmFyIGtleSBpbiBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmIChpc1RyYW5zZm9ybVByb3Aoa2V5KSkge1xuICAgICAgICAgICAgICAgIGhhc1RyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUGF0aCAmJiAoa2V5ID09PSAncGF0aExlbmd0aCcgfHwga2V5ID09PSAncGF0aFNwYWNpbmcnKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaGFzRGFzaEFycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkYXNoQXJyYXlTdHlsZXNba2V5XSA9IHBlcmNlbnRUb1BpeGVscyh2YWx1ZSwgcGF0aExlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUGF0aCAmJiBrZXkgPT09ICdwYXRoT2Zmc2V0Jykge1xuICAgICAgICAgICAgICAgIHByb3BzWydzdHJva2UtZGFzaG9mZnNldCddID0gcGVyY2VudFRvUGl4ZWxzKC12YWx1ZSwgcGF0aExlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsVG9EYXNoKGtleSldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0Rhc2hBcnJheSkge1xuICAgICAgICBwcm9wc1snc3Ryb2tlLWRhc2hhcnJheSddID0gZGFzaEFycmF5U3R5bGVzLnBhdGhMZW5ndGggKyAnICcgKyBkYXNoQXJyYXlTdHlsZXMucGF0aFNwYWNpbmc7XG4gICAgfVxuICAgIGlmIChoYXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgcHJvcHMudHJhbnNmb3JtID0gJyc7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBrZXkgPT09ICdzY2FsZScgPyAnMScgOiAnMCc7XG4gICAgICAgICAgICAgICAgcHJvcHMudHJhbnNmb3JtICs9IHRyYW5zZm9ybVtrZXldLnJlcGxhY2UoL3VuZGVmaW5lZC9nLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbnZhciB2YWx1ZVR5cGVzJDEgPSB7XG4gICAgZmlsbDogY29sb3IsXG4gICAgc3Ryb2tlOiBjb2xvcixcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgc2NhbGVYOiBzY2FsZSxcbiAgICBzY2FsZVk6IHNjYWxlLFxuICAgIG9wYWNpdHk6IGFscGhhLFxuICAgIGZpbGxPcGFjaXR5OiBhbHBoYSxcbiAgICBzdHJva2VPcGFjaXR5OiBhbHBoYVxufTtcbnZhciBnZXRWYWx1ZVR5cGUkMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdmFsdWVUeXBlcyQxW2tleV07XG59O1xuXG52YXIgc3ZnU3R5bGVyID0gLyojX19QVVJFX18qL2NyZWF0ZVN0eWxlcih7XG4gICAgb25SZWFkOiBmdW5jdGlvbiAoa2V5LCBfYSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IF9hLmVsZW1lbnQ7XG4gICAgICAgIGlmICghaXNUcmFuc2Zvcm1Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlVHlwZSA9IGdldFZhbHVlVHlwZSQxKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVUeXBlID8gdmFsdWVUeXBlLmRlZmF1bHQgOiAwO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBvblJlbmRlcjogZnVuY3Rpb24gKHN0YXRlLCBfYSwgY2hhbmdlZFZhbHVlcykge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IF9hLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICBlbGVtZW50ID0gX2EuZWxlbWVudCxcbiAgICAgICAgICAgIGlzUGF0aCA9IF9hLmlzUGF0aCxcbiAgICAgICAgICAgIHBhdGhMZW5ndGggPSBfYS5wYXRoTGVuZ3RoO1xuICAgICAgICBzZXREb21BdHRycyhlbGVtZW50LCBidWlsZChzdGF0ZSwgZGltZW5zaW9ucywgaXNQYXRoLCBwYXRoTGVuZ3RoKSk7XG4gICAgfSxcbiAgICBhbGlhc01hcDoge1xuICAgICAgICB4OiAndHJhbnNsYXRlWCcsXG4gICAgICAgIHk6ICd0cmFuc2xhdGVZJyxcbiAgICAgICAgYmFja2dyb3VuZDogJ2ZpbGwnXG4gICAgfVxufSk7XG52YXIgc3ZnID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgX2EgPSBlbGVtZW50LmdldEJCb3goKSxcbiAgICAgICAgeCA9IF9hLngsXG4gICAgICAgIHkgPSBfYS55LFxuICAgICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgdmFyIHByb3BzID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBkaW1lbnNpb25zOiB7IHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSxcbiAgICAgICAgaXNQYXRoOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgIHByb3BzLmlzUGF0aCA9IHRydWU7XG4gICAgICAgIHByb3BzLnBhdGhMZW5ndGggPSBlbGVtZW50LmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgfVxuICAgIHJldHVybiBzdmdTdHlsZXIocHJvcHMpO1xufTtcblxudmFyIHZpZXdwb3J0ID0gLyojX19QVVJFX18qL2NyZWF0ZVN0eWxlcih7XG4gICAgdXNlQ2FjaGU6IGZhbHNlLFxuICAgIG9uUmVhZDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID09PSAnc2Nyb2xsVG9wJyA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICB9LFxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2Euc2Nyb2xsVG9wLFxuICAgICAgICAgICAgc2Nyb2xsVG9wID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYixcbiAgICAgICAgICAgIF9jID0gX2Euc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jO1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFRvKHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG4gICAgfVxufSk7XG5cbnZhciBjYWNoZSA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIGNyZWF0ZURPTVN0eWxlciA9IGZ1bmN0aW9uIChub2RlLCBwcm9wcykge1xuICAgIHZhciBzdHlsZXI7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICBzdHlsZXIgPSBjc3Mobm9kZSwgcHJvcHMpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICAgICAgc3R5bGVyID0gc3ZnKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgbm9kZSA9PT0gd2luZG93KSB7XG4gICAgICAgIHN0eWxlciA9IHZpZXdwb3J0KG5vZGUpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoc3R5bGVyICE9PSB1bmRlZmluZWQsICdObyB2YWxpZCBub2RlIHByb3ZpZGVkLiBOb2RlIG11c3QgYmUgSFRNTEVsZW1lbnQsIFNWR0VsZW1lbnQgb3Igd2luZG93LicpO1xuICAgIGNhY2hlLnNldChub2RlLCBzdHlsZXIpO1xuICAgIHJldHVybiBzdHlsZXI7XG59O1xudmFyIGdldFN0eWxlciA9IGZ1bmN0aW9uIChub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBjYWNoZS5oYXMobm9kZSkgPyBjYWNoZS5nZXQobm9kZSkgOiBjcmVhdGVET01TdHlsZXIobm9kZSwgcHJvcHMpO1xufTtcbmZ1bmN0aW9uIGluZGV4KG5vZGVPclNlbGVjdG9yLCBwcm9wcykge1xuICAgIHZhciBub2RlID0gdHlwZW9mIG5vZGVPclNlbGVjdG9yID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iobm9kZU9yU2VsZWN0b3IpIDogbm9kZU9yU2VsZWN0b3I7XG4gICAgcmV0dXJuIGdldFN0eWxlcihub2RlLCBwcm9wcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuZXhwb3J0IHsgY3JlYXRlU3R5bGVyIGFzIGNyZWF0ZVN0eWxlckZhY3RvcnksIGJ1aWxkU3R5bGVQcm9wZXJ0eVN0cmluZyBhcyBidWlsZFN0eWxlcyB9O1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNyZWF0ZVJlYWN0Q29udGV4dCBmcm9tICdjcmVhdGUtcmVhY3QtY29udGV4dCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU3RhdGVDb250ZXh0ID0gY3JlYXRlUmVhY3RDb250ZXh0KG51bGwpO1xuXG52YXIgQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250YWluZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250YWluZXIpO1xuXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG5cbiAgICBDT05UQUlORVJfREVCVUdfQ0FMTEJBQ0tTLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICByZXR1cm4gY2IoX3RoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgQ29udGFpbmVyLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKHVwZGF0ZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV4dFN0YXRlID0gdm9pZCAwO1xuXG4gICAgICBpZiAodHlwZW9mIHVwZGF0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbmV4dFN0YXRlID0gdXBkYXRlcihfdGhpczIuc3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFN0YXRlID0gdXBkYXRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpczIuc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBfdGhpczIuc3RhdGUsIG5leHRTdGF0ZSk7XG5cbiAgICAgIHZhciBwcm9taXNlcyA9IF90aGlzMi5fbGlzdGVuZXJzLm1hcChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIENvbnRhaW5lci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKGZuKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLnB1c2goZm4pO1xuICB9O1xuXG4gIENvbnRhaW5lci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZShmbikge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmICE9PSBmbjtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29udGFpbmVyO1xufSgpO1xuXG52YXIgRFVNTVlfU1RBVEUgPSB7fTtcblxudmFyIFN1YnNjcmliZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTdWJzY3JpYmUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN1YnNjcmliZSgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzMywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzY3JpYmUpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMzKSwgX3RoaXMzLnN0YXRlID0ge30sIF90aGlzMy5pbnN0YW5jZXMgPSBbXSwgX3RoaXMzLnVubW91bnRlZCA9IGZhbHNlLCBfdGhpczMub25VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgaWYgKCFfdGhpczMudW5tb3VudGVkKSB7XG4gICAgICAgICAgX3RoaXMzLnNldFN0YXRlKERVTU1ZX1NUQVRFLCByZXNvbHZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMzLCBfcmV0KTtcbiAgfVxuXG4gIFN1YnNjcmliZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVubW91bnRlZCA9IHRydWU7XG4gICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICBTdWJzY3JpYmUucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uIF91bnN1YnNjcmliZSgpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHRoaXMuaW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLnVuc3Vic2NyaWJlKF90aGlzNC5vblVwZGF0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgU3Vic2NyaWJlLnByb3RvdHlwZS5fY3JlYXRlSW5zdGFuY2VzID0gZnVuY3Rpb24gX2NyZWF0ZUluc3RhbmNlcyhtYXAsIGNvbnRhaW5lcnMpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG5cbiAgICBpZiAobWFwID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHdyYXAgeW91ciA8U3Vic2NyaWJlPiBjb21wb25lbnRzIHdpdGggYSA8UHJvdmlkZXI+Jyk7XG4gICAgfVxuXG4gICAgdmFyIHNhZmVNYXAgPSBtYXA7XG4gICAgdmFyIGluc3RhbmNlcyA9IGNvbnRhaW5lcnMubWFwKGZ1bmN0aW9uIChDb250YWluZXJJdGVtKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB2b2lkIDA7XG5cbiAgICAgIGlmICgodHlwZW9mIENvbnRhaW5lckl0ZW0gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKENvbnRhaW5lckl0ZW0pKSA9PT0gJ29iamVjdCcgJiYgQ29udGFpbmVySXRlbSBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgICBpbnN0YW5jZSA9IENvbnRhaW5lckl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZSA9IHNhZmVNYXAuZ2V0KENvbnRhaW5lckl0ZW0pO1xuXG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnN0YW5jZSA9IG5ldyBDb250YWluZXJJdGVtKCk7XG4gICAgICAgICAgc2FmZU1hcC5zZXQoQ29udGFpbmVySXRlbSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnVuc3Vic2NyaWJlKF90aGlzNS5vblVwZGF0ZSk7XG4gICAgICBpbnN0YW5jZS5zdWJzY3JpYmUoX3RoaXM1Lm9uVXBkYXRlKTtcblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5pbnN0YW5jZXMgPSBpbnN0YW5jZXM7XG4gICAgcmV0dXJuIGluc3RhbmNlcztcbiAgfTtcblxuICBTdWJzY3JpYmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgU3RhdGVDb250ZXh0LkNvbnN1bWVyLFxuICAgICAgbnVsbCxcbiAgICAgIGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5wcm9wcy5jaGlsZHJlbi5hcHBseShudWxsLCBfdGhpczYuX2NyZWF0ZUluc3RhbmNlcyhtYXAsIF90aGlzNi5wcm9wcy50bykpO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIFN1YnNjcmliZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUHJvdmlkZXIocHJvcHMpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgU3RhdGVDb250ZXh0LkNvbnN1bWVyLFxuICAgIG51bGwsXG4gICAgZnVuY3Rpb24gKHBhcmVudE1hcCkge1xuICAgICAgdmFyIGNoaWxkTWFwID0gbmV3IE1hcChwYXJlbnRNYXApO1xuXG4gICAgICBpZiAocHJvcHMuaW5qZWN0KSB7XG4gICAgICAgIHByb3BzLmluamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIGNoaWxkTWFwLnNldChpbnN0YW5jZS5jb25zdHJ1Y3RvciwgaW5zdGFuY2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFN0YXRlQ29udGV4dC5Qcm92aWRlcixcbiAgICAgICAgeyB2YWx1ZTogY2hpbGRNYXAgfSxcbiAgICAgICAgcHJvcHMuY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfVxuICApO1xufVxuXG52YXIgQ09OVEFJTkVSX0RFQlVHX0NBTExCQUNLUyA9IFtdO1xuXG4vLyBJZiB5b3VyIG5hbWUgaXNuJ3QgU2luZHJlLCB0aGlzIGlzIG5vdCBmb3IgeW91LlxuLy8gSSBtaWdodCBydWluIHlvdXIgZGF5IHN1ZGRlbmx5IGlmIHlvdSBkZXBlbmQgb24gdGhpcyB3aXRob3V0IHRhbGtpbmcgdG8gbWUuXG5mdW5jdGlvbiBfX1NVUEVSX1NFQ1JFVF9DT05UQUlORVJfREVCVUdfSE9PS19fKGNhbGxiYWNrKSB7XG4gIENPTlRBSU5FUl9ERUJVR19DQUxMQkFDS1MucHVzaChjYWxsYmFjayk7XG59XG5cbmV4cG9ydCB7IENvbnRhaW5lciwgU3Vic2NyaWJlLCBQcm92aWRlciwgX19TVVBFUl9TRUNSRVRfQ09OVEFJTkVSX0RFQlVHX0hPT0tfXyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW1pdHRlcih2YWx1ZSkge1xuICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBvbjogZnVuY3Rpb24gb24oaGFuZGxlcikge1xuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBoICE9PSBoYW5kbGVyO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcih2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xufVxuXG52YXIgdW5pcXVlSWQgPSAwO1xuXG5mdW5jdGlvbiBjcmVhdGVSZWFjdENvbnRleHQoZGVmYXVsdFZhbHVlKSB7XG4gIHZhciBfUHJvdmlkZXIkY2hpbGRDb250ZXgsIF9Db25zdW1lciRjb250ZXh0VHlwZTtcblxuICB2YXIgY29udGV4dFByb3AgPSAnX19jcmVhdGUtcmVhY3QtY29udGV4dC0nICsgdW5pcXVlSWQrKyArICdfXyc7XG5cbiAgdmFyIFByb3ZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gUHJvdmlkZXIoKSB7XG4gICAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvdmlkZXIpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbC5hcHBseShfQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuZW1pdHRlciA9IGNyZWF0ZUV2ZW50RW1pdHRlcihfdGhpcy5wcm9wcy52YWx1ZSksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgIH1cblxuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltjb250ZXh0UHJvcF0gPSB0aGlzLmVtaXR0ZXIsIF9yZWY7XG4gICAgfTtcblxuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnZhbHVlICE9PSBuZXh0UHJvcHMudmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldChuZXh0UHJvcHMudmFsdWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfTtcblxuICAgIHJldHVybiBQcm92aWRlcjtcbiAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICBQcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IChfUHJvdmlkZXIkY2hpbGRDb250ZXggPSB7fSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W2NvbnRleHRQcm9wXSA9IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWQsIF9Qcm92aWRlciRjaGlsZENvbnRleCk7XG5cbiAgdmFyIENvbnN1bWVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQyKSB7XG4gICAgX2luaGVyaXRzKENvbnN1bWVyLCBfQ29tcG9uZW50Mik7XG5cbiAgICBmdW5jdGlvbiBDb25zdW1lcigpIHtcbiAgICAgIHZhciBfdGVtcDIsIF90aGlzMiwgX3JldDI7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25zdW1lcik7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZXQyID0gKF90ZW1wMiA9IChfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50Mi5jYWxsLmFwcGx5KF9Db21wb25lbnQyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzMiksIF90aGlzMi5zdGF0ZSA9IHtcbiAgICAgICAgdmFsdWU6IF90aGlzMi5nZXRWYWx1ZSgpXG4gICAgICB9LCBfdGhpczIub25VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgdmFsdWU6IF90aGlzMi5nZXRWYWx1ZSgpXG4gICAgICAgIH0pO1xuICAgICAgfSwgX3RlbXAyKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMyLCBfcmV0Mik7XG4gICAgfVxuXG4gICAgQ29uc3VtZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLm9uKHRoaXMub25VcGRhdGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb25zdW1lci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0ub2ZmKHRoaXMub25VcGRhdGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDb25zdW1lci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLmdldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29uc3VtZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiBvbmx5Q2hpbGQodGhpcy5wcm9wcy5jaGlsZHJlbikodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb25zdW1lcjtcbiAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICBDb25zdW1lci5jb250ZXh0VHlwZXMgPSAoX0NvbnN1bWVyJGNvbnRleHRUeXBlID0ge30sIF9Db25zdW1lciRjb250ZXh0VHlwZVtjb250ZXh0UHJvcF0gPSBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCwgX0NvbnN1bWVyJGNvbnRleHRUeXBlKTtcblxuXG4gIHJldHVybiB7XG4gICAgUHJvdmlkZXI6IFByb3ZpZGVyLFxuICAgIENvbnN1bWVyOiBDb25zdW1lclxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVSZWFjdENvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLCBldmFsKShcInRoaXNcIik7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS0xIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi9tYWluLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tNS0xIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi9tYWluLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTUtMSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzIS4vbWFpbi5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBMaW5rIH0gZnJvbSAnQHJlYWNoL3JvdXRlcidcblxubGV0IEJhY2tMaW5rID0gKHsgdG8gfSkgPT4gKFxuICA8TGlua1xuICAgIHRvPXt0b31cbiAgICBjbGFzc05hbWU9XCJpbmxpbmUtZmxleCBpdGVtcy1jZW50ZXIgbm8tdW5kZXJsaW5lIHRleHQtcHVycGxlLWRhcmtcIlxuICAgIGRhdGEtYmFja1xuICA+XG4gICAgPHN2ZyB3aWR0aD17MjR9IGhlaWdodD17MjR9IGNsYXNzTmFtZT1cImZpbGwtY3VycmVudCBtci0yXCI+XG4gICAgICA8cGF0aCBkPVwiTTIxIDExSDYuODNsMy41OC0zLjU5TDkgNmwtNiA2IDYgNiAxLjQxLTEuNDFMNi44MyAxM0gyMXpcIiAvPlxuICAgIDwvc3ZnPlxuICAgIEJhY2tcbiAgPC9MaW5rPlxuKVxuXG5leHBvcnQgZGVmYXVsdCBCYWNrTGlua1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuLy8gaW1wb3J0IFNsaWRlciBmcm9tICcuL3NsaWRlci5qcyc7XG5pbXBvcnQgeyBTdWJzY3JpYmUgfSBmcm9tICd1bnN0YXRlZCdcbmltcG9ydCBCYWNrTGluayBmcm9tICcuL0JhY2tMaW5rLmpzJ1xuXG5jbGFzcyBFZGl0YWJsZVByb3AgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHNldCA9IHRoaXMucHJvcHMuc2V0XG5cbiAgICBzd2l0Y2ggKHRoaXMucHJvcHMudHlwZSkge1xuICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU9e3RoaXMucHJvcHMudmFsdWUgfHwgJyd9XG4gICAgICAgICAgICBvbklucHV0PXtlID0+IHNldChlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJhcHBlYXJhbmNlLW5vbmUgYmxvY2sgdy1mdWxsIGJnLXRyYW5zcGFyZW50IGZvY3VzOmJnLXdoaXRlIGJvcmRlciBib3JkZXItcHVycGxlLWRhcmsgcm91bmRlZCBoLTcgZm9jdXM6b3V0bGluZS1ub25lXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IHBhZGRpbmc6ICcwIDEycHgnIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgKVxuICAgICAgICBicmVha1xuICAgICAgLy8gY2FzZSAnbnVtYmVyJzpcbiAgICAgIC8vICAgcmV0dXJuIChcbiAgICAgIC8vICAgICA8U2xpZGVyXG4gICAgICAvLyAgICAgICBkZWZhdWx0VmFsdWU9e3RoaXMucHJvcHMudmFsdWUgfHwgMH1cbiAgICAgIC8vICAgICAgIG9uQ2hhbmdlPXt2YWwgPT4gc2V0KHZhbCl9XG4gICAgICAvLyAgICAgLz5cbiAgICAgIC8vICAgKTtcbiAgICAgIC8vICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxzZWxlY3QgaWQ9e3RoaXMucHJvcHMuaWR9IG9uQ2hhbmdlPXtlID0+IHNldChlLnRhcmdldC52YWx1ZSl9PlxuICAgICAgICAgICAge3RoaXMucHJvcHMub3B0aW9ucy5tYXAoKG9wdGlvbiwgaSkgPT4gKFxuICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtvcHRpb259IGtleT17aX0+XG4gICAgICAgICAgICAgICAge29wdGlvbn1cbiAgICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICBpZD17dGhpcy5wcm9wcy5pZH1cbiAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQ9e1xuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLnByb3BzLnZhbHVlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb3BzLnZhbHVlXG4gICAgICAgICAgICAgICAgICA6IHR5cGVvZiB0aGlzLnByb3BzLmRlZmF1bHQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wcm9wcy5kZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0KGUudGFyZ2V0LmNoZWNrZWQpXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInNyLW9ubHlcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2hlY2tib3ggYWJzb2x1dGUgcGluLXIgYm9yZGVyIGJvcmRlci1wdXJwbGUtZGFyayByb3VuZGVkLXNtXCJcbiAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IDIwLCBoZWlnaHQ6IDIwLCB0b3A6ICc1MCUnLCBtYXJnaW5Ub3A6IC0xMCB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDx1bFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibGlzdC1yZXNldCBmbGV4IGZsZXgtd3JhcFwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBtYXJnaW46ICctMTBweCAtNXB4IDAnXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLm9wdGlvbnMubWFwKG9wdGlvbiA9PiAoXG4gICAgICAgICAgICAgIDxsaSBzdHlsZT17eyBtYXJnaW46ICcxMHB4IDVweCAwJyB9fT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFwcGVhcmFuY2Utbm9uZSBibG9jayB3LTYgaC02IGJvcmRlci0wIHJvdW5kZWQgcmVsYXRpdmVcIlxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogb3B0aW9uXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXQob3B0aW9uKVxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7dGhpcy5wcm9wcy52YWx1ZSA9PT0gb3B0aW9uID8gKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYWJzb2x1dGUgcm91bmRlZC1mdWxsIGJnLXB1cnBsZS1kYXJrIGJvcmRlciBib3JkZXItd2hpdGVcIlxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IC00LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IC00LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDlcbiAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgICApXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVkaXRhYmxlT3B0aW9ucyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBsZXQgcHJvcHMgPSB0aGlzLnByb3BzLmVkaXRhYmxlc1t0aGlzLnByb3BzLmxvY11cbiAgICByZXR1cm4gKFxuICAgICAgPFN1YnNjcmliZSB0bz17W2NyZWF0ZUNvbnRhaW5lcihwcm9wcy5zdGF0ZUNvbnRhaW5lcildfT5cbiAgICAgICAge3MgPT4gKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZXhwb3NlLWVkaXRhYmxlLXByb3BzIHAtOFwiPlxuICAgICAgICAgICAgPEJhY2tMaW5rIHRvPVwiL1wiIC8+XG4gICAgICAgICAgICB7T2JqZWN0LmtleXMocHJvcHMub3B0aW9ucykubWFwKChwcm9wLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBwID0gcHJvcHMub3B0aW9uc1twcm9wXVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIDxkaXYga2V5PXtgJHtzLmxvY2F0aW9ufS4ke3Byb3B9YH0gY2xhc3NOYW1lPVwicmVsYXRpdmUgbXQtNVwiPlxuICAgICAgICAgICAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICAgICAgICAgIGh0bWxGb3I9e2Ake3MubG9jYXRpb259LiR7cHJvcH1gfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyZWxhdGl2ZSBibG9jayBtYi0zIHotMTBcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7cC5kaXNwbGF5TmFtZSB8fCBjYW1lbFRvU2VudGVuY2UocHJvcCl9XG4gICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgPEVkaXRhYmxlUHJvcFxuICAgICAgICAgICAgICAgICAgICBpZD17YCR7cy5sb2NhdGlvbn0uJHtwcm9wfWB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGU9e3AudHlwZX1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3Muc3RhdGUudmFsdWVbcHJvcF19XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ9e3AuZGVmYXVsdH1cbiAgICAgICAgICAgICAgICAgICAgc2V0PXt4ID0+IHMuc2V0KHByb3AsIHgpfVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zPXtwLm9wdGlvbnN9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvU3Vic2NyaWJlPlxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1lbFRvU2VudGVuY2Uoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICAucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgKG0sIHAxLCBwMikgPT4gcDEgKyAnICcgKyBwMi50b0xvd2VyQ2FzZSgpKVxuICAgIC5yZXBsYWNlKC9eKFthLXpdKS8sIG0gPT4gbS50b1VwcGVyQ2FzZSgpKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVyKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29udGFpbmVyXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIFJvdXRlciBhcyBSZWFjaFJvdXRlcixcbiAgTG9jYXRpb25Qcm92aWRlcixcbiAgTG9jYXRpb24sXG4gIGNyZWF0ZU1lbW9yeVNvdXJjZSxcbiAgY3JlYXRlSGlzdG9yeVxufSBmcm9tICdAcmVhY2gvcm91dGVyJ1xuaW1wb3J0IHBvc2VkLCB7IFBvc2VHcm91cCB9IGZyb20gJ3JlYWN0LXBvc2UnXG5cbmxldCBzb3VyY2UgPSBjcmVhdGVNZW1vcnlTb3VyY2UoJy8nKVxubGV0IGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KHNvdXJjZSlcbmxldCBuYXZpZ2F0ZVxuXG5sZXQgdHJhbnNpdGlvbiA9IHtcbiAgdHlwZTogJ3NwcmluZycsXG4gIHN0aWZmbmVzczogMjAwLFxuICBkYW1waW5nOiAyMFxufVxuXG5sZXQgUm91dGVDb250YWluZXIgPSBwb3NlZC5kaXYoe1xuICBlbnRlcjogeyB4OiAnMCUnLCB0cmFuc2l0aW9uIH0sXG4gIHByZUVudGVyOiB7IHg6ICcxMDAlJywgdHJhbnNpdGlvbiB9LFxuICBleGl0OiB7IHg6ICctMTAwJScsIHRyYW5zaXRpb24gfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7XG4gICAgcHJlRW50ZXJQb3NlOiAncHJlRW50ZXInLFxuICAgIGV4aXRQb3NlOiAnZXhpdCdcbiAgfVxuICAvLyBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHsgZGlyIH0pIHtcbiAgLy8gICBpZiAoZGlyID09PSAnYmFjaycpIHtcbiAgLy8gICAgIHJldHVybiB7XG4gIC8vICAgICAgIHByZUVudGVyUG9zZTogJ2V4aXQnLFxuICAvLyAgICAgICBleGl0UG9zZTogJ3ByZUVudGVyJ1xuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gICByZXR1cm4geyBwcmVFbnRlclBvc2U6ICdwcmVFbnRlcicsIGV4aXRQb3NlOiAnZXhpdCcgfVxuICAvLyB9XG4gIGhhbmRsZUNsaWNrID0gZSA9PiB7XG4gICAgbGV0IGEgPSBlLnRhcmdldC5jbG9zZXN0KCdhJylcbiAgICBpZiAoIWEpIHJldHVyblxuICAgIGlmIChhLmdldEF0dHJpYnV0ZSgnZGF0YS1iYWNrJykpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBwcmVFbnRlclBvc2U6ICdleGl0JywgZXhpdFBvc2U6ICdwcmVFbnRlcicgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHByZUVudGVyUG9zZTogJ3ByZUVudGVyJywgZXhpdFBvc2U6ICdleGl0JyB9KVxuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBuYXZpZ2F0ZSA9ICh0bywgYmFjayA9IGZhbHNlKSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBiYWNrXG4gICAgICAgID8geyBwcmVFbnRlclBvc2U6ICdleGl0JywgZXhpdFBvc2U6ICdwcmVFbnRlcicgfVxuICAgICAgICA6IHsgcHJlRW50ZXJQb3NlOiAncHJlRW50ZXInLCBleGl0UG9zZTogJ2V4aXQnIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSwgKCkgPT4ge1xuICAgICAgICBoaXN0b3J5Lm5hdmlnYXRlKHRvKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cImZsZXgtbm9uZSBiZy1ncmV5LWxpZ2h0ZXIgZmxleCBmbGV4LWNvbCByZWxhdGl2ZVwiXG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgd2lkdGg6IDMwNFxuICAgICAgICB9fVxuICAgICAgICBvbkNsaWNrQ2FwdHVyZT17dGhpcy5oYW5kbGVDbGlja31cbiAgICAgID5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsb2dvLWNvbnRhaW5lciBtdC05IGFic29sdXRlIHotMTAgcGluLXQgcGluLWwgdy1mdWxsIHBvaW50ZXItZXZlbnRzLW5vbmVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14LWF1dG8gbWItOVwiIHN0eWxlPXt7IHdpZHRoOiAxMTAgfX0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIGFzcGVjdC1yYXRpby1sb2dvXCI+XG4gICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDg2Ny4yMyAyMDguODRcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIHBpbiB3LWZ1bGwgaC1mdWxsXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxnIGZpbGw9XCIjMzMzXCI+XG4gICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTMxNi42IDEzOC4zMmMtNS4zMyAxOC4xMS0yMiAzMy4yNC00Ny43MyAzMy4yNC0yOC43NiAwLTU0LjEyLTIwLjY3LTU0LjEyLTU2IDAtMzMuNDUgMjQuNzItNTUuMTggNTEuNTYtNTUuMTggMzIuMzkgMCA1MS43OCAyMC42NyA1MS43OCA1NC4zMyAwIDQtLjQzIDguMzEtLjQzIDguNzRoLTc1Yy42NCAxMy44NSAxMi4zNiAyMy44NiAyNi40MiAyMy44NiAxMy4yMSAwIDIwLjQ2LTYuNiAyMy44Ny0xNnpNMjkwLjE4IDEwNGMtLjQzLTEwLjQ0LTcuMjUtMjAuNjctMjMuNDQtMjAuNjctMTQuNyAwLTIyLjggMTEuMDgtMjMuNDQgMjAuNjd6TTM1NS41IDExNS43NGwtMzcuMjktNTIuMmgzMy42NmMzLjYzIDUuNzUgMTcuMjYgMjUuMzUgMjAuODggMzEuMTFsMjAuNjctMzEuMTFoMzIuMTdMMzg5IDExNC44OWwzNy45MiA1My40N2gtMzMuMjlsLTIxLjk0LTMyLjE3Yy0zLjg0IDUuNzUtMTcuOSAyNi40Mi0yMS41MiAzMi4xN2gtMzJ6TTQzNyAyMDguODRWNjMuNTRoMjcuNDh2MTIuNzhjNC42OS04LjA5IDE2LjQxLTE1LjEzIDMyLjE3LTE1LjEzIDMwLjY4IDAgNDguMzcgMjMuNDQgNDguMzcgNTQuNTUgMCAzMS43NC0xOS44MiA1NS4xOC00OS40MyA1NS4xOC0xNC40OSAwLTI1LjE0LTUuNzUtMzAuMjYtMTIuNzh2NTAuN3ptNTQuMDYtMTIyLjI5Yy0xNC40OCAwLTI2LjIgMTAuODctMjYuMiAyOS40czExLjcyIDI5LjYyIDI2LjIgMjkuNjIgMjYtMTAuODcgMjYtMjkuNjJjMC0xOC41My0xMS41MS0yOS40LTI2LTI5LjR6TTY2My44NSAxMTZjMCAzMi4xNy0yMy42NSA1NS42MS01NSA1NS42MXMtNTUtMjMuNDQtNTUtNTUuNjFjMC0zMi4zOCAyMy42NS01NS42MSA1NS01NS42MXM1NSAyMy4xOCA1NSA1NS42MXptLTI4LjMzIDBjMC0xOS44MS0xMi43OS0yOS44My0yNi42NC0yOS44M3MtMjYuNjMgMTAtMjYuNjMgMjkuODNjMCAxOS42IDEyLjc4IDI5LjgzIDI2LjYzIDI5LjgzczI2LjY0LTEwLjA2IDI2LjY0LTI5Ljgzek02OTUuMzYgMTMzLjg1Yy42NCA4LjMxIDYuODIgMTYgMTkuMTggMTYgOS4zNyAwIDEzLjg1LTQuOSAxMy44NS0xMC40NCAwLTQuNjktMy4yLTguNTItMTEuMy0xMC4yM0w3MDMuMjQgMTI2Yy0yMC4yNC00LjQ3LTI5LjQtMTYuNjEtMjkuNC0zMS4zMSAwLTE4Ljc1IDE2LjYyLTM0LjMxIDM5LjIxLTM0LjMxIDI5LjgyIDAgMzkuODQgMTkgNDEuMTIgMzAuMjZsLTIzLjY1IDUuMzJjLS44Ni02LjE4LTUuMzMtMTQuMDYtMTcuMjYtMTQuMDYtNy40NiAwLTEzLjQyIDQuNDgtMTMuNDIgMTAuNDQgMCA1LjEyIDMuODMgOC4zMSA5LjU4IDkuMzhsMTQuOTIgMy4xOWMyMC42NiA0LjI2IDMxLjEgMTYuODMgMzEuMSAzMi4xNyAwIDE3LjA1LTEzLjIxIDM0LjUyLTQwLjY5IDM0LjUyLTMxLjUzIDAtNDIuNC0yMC40NS00My42OC0zMi4zOXpNODY1Ljc0IDEzOC4zMmMtNS4zMiAxOC4xMS0yMS45NCAzMy4yNC00Ny43MiAzMy4yNC0yOC43NyAwLTU0LjEyLTIwLjY3LTU0LjEyLTU2IDAtMzMuNDUgMjQuNzItNTUuMTggNTEuNTYtNTUuMTggMzIuMzkgMCA1MS43NyAyMC42NyA1MS43NyA1NC4zMyAwIDQtLjQyIDguMzEtLjQyIDguNzRoLTc1Yy42NCAxMy44NSAxMi4zNiAyMy44NiAyNi40MiAyMy44NiAxMy4yMSAwIDIwLjQ1LTYuNiAyMy44Ni0xNnpNODM5LjMyIDEwNGMtLjQyLTEwLjQ0LTcuMjQtMjAuNjctMjMuNDMtMjAuNjctMTQuNyAwLTIyLjggMTEuMDgtMjMuNDQgMjAuNjd6XCIgLz5cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgICAgICAgY3g9XCIxMTAuNjlcIlxuICAgICAgICAgICAgICAgICAgY3k9XCI3Mi41OVwiXG4gICAgICAgICAgICAgICAgICByPVwiNzIuNTlcIlxuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtPVwicm90YXRlKC02LjkgMTEwLjY1OSA3Mi41OTYpXCJcbiAgICAgICAgICAgICAgICAgIGZpbGw9XCIjY2ViZWVjXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxlbGxpcHNlXG4gICAgICAgICAgICAgICAgICBjeD1cIjY3LjE0XCJcbiAgICAgICAgICAgICAgICAgIGN5PVwiMTE5LjYxXCJcbiAgICAgICAgICAgICAgICAgIHJ4PVwiNjcuMTdcIlxuICAgICAgICAgICAgICAgICAgcnk9XCI2Ny4xMVwiXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm09XCJyb3RhdGUoLTQ1LjAzIDY3LjE0NCAxMTkuNjEpXCJcbiAgICAgICAgICAgICAgICAgIGZpbGw9XCIjODM2MGQ2XCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxjaXJjbGUgY3g9XCIxMzQuMjhcIiBjeT1cIjE1Mi40M1wiIHI9XCIzMi44MlwiIGZpbGw9XCIjM2MzNzRlXCIgLz5cbiAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJvdmVyZmxvdy1hdXRvIG92ZXJmbG93LXgtaGlkZGVuXCJcbiAgICAgICAgICBzdHlsZT17eyBwYWRkaW5nVG9wOiAxNjAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxMb2NhdGlvblByb3ZpZGVyIGhpc3Rvcnk9e2hpc3Rvcnl9PlxuICAgICAgICAgICAgPExvY2F0aW9uPlxuICAgICAgICAgICAgICB7KHsgbG9jYXRpb24gfSkgPT4gKFxuICAgICAgICAgICAgICAgIDxQb3NlR3JvdXBcbiAgICAgICAgICAgICAgICAgIHByZUVudGVyUG9zZT17dGhpcy5zdGF0ZS5wcmVFbnRlclBvc2V9XG4gICAgICAgICAgICAgICAgICBleGl0UG9zZT17dGhpcy5zdGF0ZS5leGl0UG9zZX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8Um91dGVDb250YWluZXIga2V5PXtsb2NhdGlvbi5wYXRobmFtZX0+XG4gICAgICAgICAgICAgICAgICAgIDxSZWFjaFJvdXRlciBsb2NhdGlvbj17bG9jYXRpb259PlxuICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICA8L1JlYWNoUm91dGVyPlxuICAgICAgICAgICAgICAgICAgPC9Sb3V0ZUNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L1Bvc2VHcm91cD5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvTG9jYXRpb24+XG4gICAgICAgICAgPC9Mb2NhdGlvblByb3ZpZGVyPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgeyBoaXN0b3J5LCBuYXZpZ2F0ZSB9XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IHsgTGluayB9IGZyb20gJ0ByZWFjaC9yb3V0ZXInXG5pbXBvcnQgUm91dGVyLCB7IG5hdmlnYXRlIH0gZnJvbSAnLi9jb21wb25lbnRzL1JvdXRlci5qcydcbmltcG9ydCBFZGl0YWJsZU9wdGlvbnMgZnJvbSAnLi9jb21wb25lbnRzL0VkaXRhYmxlT3B0aW9ucy5qcydcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAndW5zdGF0ZWQnXG5pbXBvcnQgQmFja0xpbmsgZnJvbSAnLi9jb21wb25lbnRzL0JhY2tMaW5rLmpzJ1xuaW1wb3J0ICcuLi9jc3MvbWFpbi5jc3MnXG5cbndpbmRvdy5FeHBvc2UgPSB7fVxuXG5sZXQgTWVudUxpbmsgPSAoeyB0bywgY2hpbGRyZW4gfSkgPT4gKFxuICA8TGlua1xuICAgIHRvPXt0b31cbiAgICBjbGFzc05hbWU9XCJtZW51LWxpbmsgbm8tdW5kZXJsaW5lIGZsZXggaXRlbXMtY2VudGVyIGgtOCByb3VuZGVkIHRleHQtcHVycGxlLWRhcmsgcHgtNiBtYi00XCJcbiAgICBzdHlsZT17e1xuICAgICAgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQgMC4zcydcbiAgICB9fVxuICA+XG4gICAge2NoaWxkcmVufVxuICA8L0xpbms+XG4pXG5cbmxldCBIb21lID0gKCkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT1cInAtNlwiPlxuICAgIDxNZW51TGluayB0bz1cIi9wYWdlLW9wdGlvbnNcIj5cbiAgICAgIDxzdmcgd2lkdGg9ezIwfSBoZWlnaHQ9ezIwfSBjbGFzc05hbWU9XCJmaWxsLWN1cnJlbnQgbXItNFwiPlxuICAgICAgICA8cGF0aCBkPVwiTTE1Ljk1IDEwLjc4Yy4wMy0uMjUuMDUtLjUxLjA1LS43OHMtLjAyLS41My0uMDYtLjc4bDEuNjktMS4zMmMuMTUtLjEyLjE5LS4zNC4xLS41MWwtMS42LTIuNzdjLS4xLS4xOC0uMzEtLjI0LS40OS0uMThsLTEuOTkuOGMtLjQyLS4zMi0uODYtLjU4LTEuMzUtLjc4TDEyIDIuMzRjLS4wMy0uMi0uMi0uMzQtLjQtLjM0SDguNGMtLjIgMC0uMzYuMTQtLjM5LjM0bC0uMyAyLjEyYy0uNDkuMi0uOTQuNDctMS4zNS43OGwtMS45OS0uOGMtLjE4LS4wNy0uMzkgMC0uNDkuMThsLTEuNiAyLjc3Yy0uMS4xOC0uMDYuMzkuMS41MWwxLjY5IDEuMzJjLS4wNC4yNS0uMDcuNTItLjA3Ljc4cy4wMi41My4wNi43OEwyLjM3IDEyLjFjLS4xNS4xMi0uMTkuMzQtLjEuNTFsMS42IDIuNzdjLjEuMTguMzEuMjQuNDkuMThsMS45OS0uOGMuNDIuMzIuODYuNTggMS4zNS43OGwuMyAyLjEyYy4wNC4yLjIuMzQuNC4zNGgzLjJjLjIgMCAuMzctLjE0LjM5LS4zNGwuMy0yLjEyYy40OS0uMi45NC0uNDcgMS4zNS0uNzhsMS45OS44Yy4xOC4wNy4zOSAwIC40OS0uMThsMS42LTIuNzdjLjEtLjE4LjA2LS4zOS0uMS0uNTFsLTEuNjctMS4zMnpNMTAgMTNjLTEuNjUgMC0zLTEuMzUtMy0zczEuMzUtMyAzLTMgMyAxLjM1IDMgMy0xLjM1IDMtMyAzelwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICAgIFBhZ2UgT3B0aW9uc1xuICAgIDwvTWVudUxpbms+XG4gICAgPE1lbnVMaW5rIHRvPVwiL2Jsb2ctcG9zdHNcIj5cbiAgICAgIDxzdmdcbiAgICAgICAgd2lkdGg9ezIwfVxuICAgICAgICBoZWlnaHQ9ezIwfVxuICAgICAgICBjbGFzc05hbWU9XCJmaWxsLWN1cnJlbnQgbXItNFwiXG4gICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgPlxuICAgICAgICA8cGF0aCBkPVwiTTMgMTcuMjVWMjFoMy43NUwxNy44MSA5Ljk0bC0zLjc1LTMuNzVMMyAxNy4yNXpNMjAuNzEgNy4wNGMuMzktLjM5LjM5LTEuMDIgMC0xLjQxbC0yLjM0LTIuMzRjLS4zOS0uMzktMS4wMi0uMzktMS40MSAwbC0xLjgzIDEuODMgMy43NSAzLjc1IDEuODMtMS44M3pcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgICBCbG9nIFBvc3RzXG4gICAgPC9NZW51TGluaz5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cImJ0bi1ncm91cCBmbGV4IGJvcmRlciBib3JkZXItcHVycGxlLWRhcmsgcm91bmRlZFwiPlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9XCItbWwtcHggZmxleFwiXG4gICAgICAgIHN0eWxlPXt7IGhlaWdodDogMzUsIHdpZHRoOiAnY2FsYygxMDAlICsgMnB4KScgfX1cbiAgICAgID5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cImFwcGVhcmFuY2Utbm9uZSByZWxhdGl2ZSB3LTEvNiBib3JkZXItMCByb3VuZGVkLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50XCJcbiAgICAgICAgLz5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cImFwcGVhcmFuY2Utbm9uZSByZWxhdGl2ZSB3LTEvNiBib3JkZXItMCByb3VuZGVkLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50XCJcbiAgICAgICAgLz5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cImFwcGVhcmFuY2Utbm9uZSByZWxhdGl2ZSB3LTEvNiBib3JkZXItMCByb3VuZGVkLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50XCJcbiAgICAgICAgLz5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cImFwcGVhcmFuY2Utbm9uZSByZWxhdGl2ZSB3LTEvNiBib3JkZXItMCByb3VuZGVkLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50XCJcbiAgICAgICAgLz5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cImFwcGVhcmFuY2Utbm9uZSByZWxhdGl2ZSB3LTEvNiBib3JkZXItMCByb3VuZGVkLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50XCJcbiAgICAgICAgLz5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT1cImFwcGVhcmFuY2Utbm9uZSByZWxhdGl2ZSB3LTEvNiBib3JkZXItMCByb3VuZGVkLW5vbmUgcC0wIGJnLXRyYW5zcGFyZW50XCJcbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbilcblxubGV0IFBhZ2VPcHRpb25zID0gKCkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT1cInAtNlwiPlxuICAgIDxCYWNrTGluayB0bz1cIi9cIiAvPlxuICAgIDxoMj5QYWdlIE9wdGlvbnM8L2gyPlxuICA8L2Rpdj5cbilcbmxldCBCbG9nUG9zdHMgPSAoKSA9PiAoXG4gIDxkaXYgY2xhc3NOYW1lPVwicC02XCI+XG4gICAgPEJhY2tMaW5rIHRvPVwiL1wiIC8+XG4gICAgPGgyPkJsb2cgUG9zdHM8L2gyPlxuICA8L2Rpdj5cbilcblxuY2xhc3MgQXBwIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgc3RhdGUgPSB7XG4gICAgZWRpdGFibGVzOiB7fSxcbiAgICBlZGl0YWJsZU9wdGlvbnM6IFtdLFxuICAgIGVkaXRhYmxlU3RhdGVDb250YWluZXI6IG51bGxcbiAgfVxuICBzaG93RWRpdGFibGVPcHRpb25zID0gKHsgbG9jYXRpb24sIG9wdGlvbnMsIHN0YXRlQ29udGFpbmVyIH0pID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgc3RhdGUgPT4gKHtcbiAgICAgICAgZWRpdGFibGVzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZWRpdGFibGVzLFxuICAgICAgICAgIFtsb2NhdGlvbl06IHsgb3B0aW9ucywgc3RhdGVDb250YWluZXIgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgbmF2aWdhdGUoJy9lZGl0YWJsZS1vcHRpb25zLycgKyBsb2NhdGlvbilcbiAgICAgIH1cbiAgICApXG4gICAgLy8gdGhpcy5zZXRTdGF0ZShcbiAgICAvLyAgIHsgZWRpdGFibGVPcHRpb25zOiBvcHRpb25zLCBlZGl0YWJsZVN0YXRlQ29udGFpbmVyOiBzdGF0ZUNvbnRhaW5lciB9LFxuICAgIC8vICAgKCkgPT4ge1xuICAgIC8vICAgICBuYXZpZ2F0ZSgnL2VkaXRhYmxlLW9wdGlvbnMnKVxuICAgIC8vICAgfVxuICAgIC8vIClcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB3aW5kb3cuRXhwb3NlLnNob3dFZGl0YWJsZU9wdGlvbnMgPSB0aGlzLnNob3dFZGl0YWJsZU9wdGlvbnNcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxQcm92aWRlcj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGgtc2NyZWVuXCI+XG4gICAgICAgICAgPFJvdXRlcj5cbiAgICAgICAgICAgIDxIb21lIHBhdGg9XCIvXCIgLz5cbiAgICAgICAgICAgIDxQYWdlT3B0aW9ucyBwYXRoPVwiL3BhZ2Utb3B0aW9uc1wiIC8+XG4gICAgICAgICAgICA8QmxvZ1Bvc3RzIHBhdGg9XCIvYmxvZy1wb3N0c1wiIC8+XG4gICAgICAgICAgICA8RWRpdGFibGVPcHRpb25zXG4gICAgICAgICAgICAgIHBhdGg9XCIvZWRpdGFibGUtb3B0aW9ucy86bG9jXCJcbiAgICAgICAgICAgICAgZWRpdGFibGVzPXt0aGlzLnN0YXRlLmVkaXRhYmxlc31cbiAgICAgICAgICAgICAgLy8gcHJvcHM9e3RoaXMuc3RhdGUuZWRpdGFibGVPcHRpb25zfVxuICAgICAgICAgICAgICAvLyBzdGF0ZUNvbnRhaW5lcj17dGhpcy5zdGF0ZS5lZGl0YWJsZVN0YXRlQ29udGFpbmVyfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L1JvdXRlcj5cbiAgICAgICAgICA8aWZyYW1lIHNyYz1cIi9ub2NhY2hlXCIgY2xhc3NOYW1lPVwicmVsYXRpdmUgYm9yZGVyLTAgdy1mdWxsXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L1Byb3ZpZGVyPlxuICAgIClcbiAgfVxufVxuXG5SZWFjdERPTS5yZW5kZXIoPEFwcCAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==